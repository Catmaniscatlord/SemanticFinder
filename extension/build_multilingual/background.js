/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/assert/build/assert.js":
/*!*********************************************!*\
  !*** ./node_modules/assert/build/assert.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = __webpack_require__(/*! ./internal/errors */ "./node_modules/assert/build/internal/errors.js"),
    _require$codes = _require.codes,
    ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
    ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;

var AssertionError = __webpack_require__(/*! ./internal/assert/assertion_error */ "./node_modules/assert/build/internal/assert/assertion_error.js");

var _require2 = __webpack_require__(/*! util/ */ "./node_modules/util/util.js"),
    inspect = _require2.inspect;

var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/util/util.js").types),
    isPromise = _require$types.isPromise,
    isRegExp = _require$types.isRegExp;

var objectAssign = Object.assign ? Object.assign : (__webpack_require__(/*! es6-object-assign */ "./node_modules/es6-object-assign/index.js").assign);
var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/object-is/index.js");
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;

function lazyLoadComparison() {
  var comparison = __webpack_require__(/*! ./internal/util/comparisons */ "./node_modules/assert/build/internal/util/comparisons.js");

  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
} // Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex


var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];

var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};

var warned = false; // The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}

function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;

  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }

    if (argsLen === 2) operator = '!=';
  }

  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };

  if (message !== undefined) {
    errArgs.message = message;
  }

  var err = new AssertionError(errArgs);

  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }

  throw err;
}

assert.fail = fail; // The AssertionError is defined in internal/error.

assert.AssertionError = AssertionError;

function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;

    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }

    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
} // Pure assertion tests whether a value is truthy, as determined
// by !!value.


function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  innerOk.apply(void 0, [ok, args.length].concat(args));
}

assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.

/* eslint-disable no-restricted-properties */

assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq


  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
}; // The non-equality assertion tests for whether two objects are not
// equal with !=.


assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq


  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
}; // The equivalence assertion tests a deep equality relation.


assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
}; // The non-equivalence assertion tests for any deep inequality.


assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */


assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (isDeepEqual === undefined) lazyLoadComparison();

  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }

  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};

var Comparison = function Comparison(obj, keys, actual) {
  var _this = this;

  _classCallCheck(this, Comparison);

  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
};

function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }

    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}

function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.

    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    } // Handle primitives properly.


    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }

    var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
    // as well.

    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }

    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
        return;
      }

      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  } // Guard instanceof against arrow functions as they don't have a prototype.


  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }

  try {
    fn();
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION_SENTINEL;
}

function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.
  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.
  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}

function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;

    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn(); // Fail in case no promise is returned.

      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }

    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}

function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }

    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }

    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }

  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';

    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }

    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }

  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}

function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;

  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }

  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }

  throw actual;
}

assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};

assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};

assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }

  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};

assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};

assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';

    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }

    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    }); // Make sure we actually have a stack trace!

    var origStack = err.stack;

    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift(); // Filter all frames existing in err.stack.

      var tmp1 = newErr.stack.split('\n');

      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);

        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }

      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }

    throw newErr;
  }
}; // Expose a strict only variant of assert


function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  innerOk.apply(void 0, [strict, args.length].concat(args));
}

assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

/***/ }),

/***/ "./node_modules/assert/build/internal/assert/assertion_error.js":
/*!**********************************************************************!*\
  !*** ./node_modules/assert/build/internal/assert/assertion_error.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c


function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = __webpack_require__(/*! util/ */ "./node_modules/util/util.js"),
    inspect = _require.inspect;

var _require2 = __webpack_require__(/*! ../errors */ "./node_modules/assert/build/internal/errors.js"),
    ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat


function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));

  while (count) {
    str += str;
    count--;
  }

  str += str.substring(0, maxCount - str.length);
  return str;
}

var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
}; // Comparing short primitives should just show === / !== instead of using the
// diff.

var kMaxShortLength = 10;

function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}

function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}

function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.

  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  } // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.


  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.

    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;

      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        } // Ignore the first characters.


        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  } // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).


  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];

  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }

    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }

  var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })

  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.


    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);

      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }

    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }

  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }

  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }

  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");

  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;

    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      lastPos = i; // Add the expected line to the cache.

      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++; // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }

        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.


      lastPos = i; // Add the actual line to the result.

      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++; // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.

      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //

      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }

      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }

          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        } // Mark the current line as the last diverging one.


        lastPos = i; // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.

        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2; // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = ''; // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.

        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    } // Inspected object to big (Show ~20 rows max)


    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }

  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}

var AssertionError =
/*#__PURE__*/
function (_Error) {
  _inherits(AssertionError, _Error);

  function AssertionError(options) {
    var _this;

    _classCallCheck(this, AssertionError);

    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }

    var message = options.message,
        operator = options.operator,
        stackStartFn = options.stackStartFn;
    var actual = options.actual,
        expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;

    if (message != null) {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      } // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.


      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }

      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.

        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        } // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.


        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);

          while (res.length > 27) {
            res.pop();
          }
        } // Only print a single input.


        if (res.length === 1) {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
        } else {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
        }
      } else {
        var _res = inspectValue(actual);

        var other = '';
        var knownOperators = kReadableOperator[operator];

        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);

          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));

          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }

          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }

          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }

        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
      }
    }

    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;

    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    } // Create error message including the error code in the name.


    _this.stack; // Reset the name.

    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }

  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: inspect.custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread({}, ctx, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);

  return AssertionError;
}(_wrapNativeSuper(Error));

module.exports = AssertionError;

/***/ }),

/***/ "./node_modules/assert/build/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/assert/build/internal/errors.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */

/* eslint node-core/alphabetize-errors: "error" */

/* eslint node-core/prefer-util-format-errors: "error" */
 // The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var codes = {}; // Lazy loaded

var assert;
var util;

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inherits(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      var _this;

      _classCallCheck(this, NodeError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
      _this.code = code;
      return _this;
    }

    return NodeError;
  }(Base);

  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/assert/build/assert.js");
  assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'

  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } // TODO(BridgeAR): Improve the output by showing `null` and similar.


  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__(/*! util/ */ "./node_modules/util/util.js");
  var inspected = util.inspect(value);

  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }

  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;

  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }

  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (assert === undefined) assert = __webpack_require__(/*! ../assert */ "./node_modules/assert/build/assert.js");
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });

  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;

    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;

    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }

  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

/***/ }),

/***/ "./node_modules/assert/build/internal/util/comparisons.js":
/*!****************************************************************!*\
  !*** ./node_modules/assert/build/internal/util/comparisons.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var regexFlagsSupported = /a/g.flags !== undefined;

var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};

var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};

var objectIs = Object.is ? Object.is : __webpack_require__(/*! object-is */ "./node_modules/object-is/index.js");
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(/*! is-nan */ "./node_modules/is-nan/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);

var _require$types = (__webpack_require__(/*! util/ */ "./node_modules/util/util.js").types),
    isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
    isArrayBufferView = _require$types.isArrayBufferView,
    isDate = _require$types.isDate,
    isMap = _require$types.isMap,
    isRegExp = _require$types.isRegExp,
    isSet = _require$types.isSet,
    isNativeError = _require$types.isNativeError,
    isBoxedPrimitive = _require$types.isBoxedPrimitive,
    isNumberObject = _require$types.isNumberObject,
    isStringObject = _require$types.isStringObject,
    isBooleanObject = _require$types.isBooleanObject,
    isBigIntObject = _require$types.isBigIntObject,
    isSymbolObject = _require$types.isSymbolObject,
    isFloat32Array = _require$types.isFloat32Array,
    isFloat64Array = _require$types.isFloat64Array;

function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;

  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  } // The maximum size for an array is 2 ** 32 -1.


  return key.length === 10 && key >= Math.pow(2, 32);
}

function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */


function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3; // Check if they have the same source and flags

function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}

function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }

  return true;
}

function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }

  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}

function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}

function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }

  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }

  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }

  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }

  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
} // Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.


function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  } // Check more closely if val1 and val2 are equal.


  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }

    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }

    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }

      return false;
    }

    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }

  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);

  if (val1Tag !== val2Tag) {
    return false;
  }

  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }

    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);

    if (keys1.length !== keys2.length) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.


  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }

  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    } // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.


    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);

    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);

    if (_keys.length !== _keys2.length) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }

    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }

  return keyCheck(val1, val2, strict, memos, kNoIterator);
}

function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}

function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.

    if (aKeys.length !== bKeys.length) {
      return false;
    }
  } // Cheap key test


  var i = 0;

  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }

  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);

    if (symbolKeysA.length !== 0) {
      var count = 0;

      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];

        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }

          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }

      var symbolKeysB = objectGetOwnPropertySymbols(val2);

      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);

      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }

  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  } // Use memos to handle cycles.


  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);

    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);

      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }

    memos.position++;
  }

  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}

function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];

    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }

  return false;
} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').


function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;

    case 'object':
      // Only pass in null as object!
      return undefined;

    case 'symbol':
      return false;

    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through

    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }

  }

  return true;
}

function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}

function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);

  if (altValue != null) {
    return altValue;
  }

  var curB = b.get(altValue);

  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }

  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}

function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);

  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.

    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      } // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.


      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.

      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }

      if (set === null) {
        set = new Set();
      }

      set.add(val);
    }
  }

  if (set !== null) {
    var bValues = arrayFromSet(b);

    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i]; // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.

      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);

  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];

    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }

  return false;
}

function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);

  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
        key = _aEntries$i[0],
        item1 = _aEntries$i[1];

    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }

      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);

      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
        // keys.

        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;

        if (set === null) {
          set = new Set();
        }

        set.add(key);
      }
    }
  }

  if (set !== null) {
    var bEntries = arrayFromMap(b);

    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
          key = _bEntries$_i[0],
          item = _bEntries$_i[1];

      if (_typeof(key) === 'object' && key !== null) {
        if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
        return false;
      }
    }

    return set.size === 0;
  }

  return true;
}

function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;

  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);

        for (; i < keysA.length; i++) {
          var key = keysA[i];

          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }

        if (keysA.length !== Object.keys(b).length) {
          return false;
        }

        return true;
      }
    }
  } // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:


  for (i = 0; i < keys.length; i++) {
    var _key = keys[i];

    if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
      return false;
    }
  }

  return true;
}

function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}

function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}

module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/console-browserify/index.js":
/*!**************************************************!*\
  !*** ./node_modules/console-browserify/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*global window, global*/
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js")
var assert = __webpack_require__(/*! assert */ "./node_modules/assert/build/assert.js")
function now() { return new Date().getTime() }

var slice = Array.prototype.slice
var console
var times = {}

if (typeof __webpack_require__.g !== "undefined" && __webpack_require__.g.console) {
    console = __webpack_require__.g.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = {}
}

var functions = [
    [log, "log"],
    [info, "info"],
    [warn, "warn"],
    [error, "error"],
    [time, "time"],
    [timeEnd, "timeEnd"],
    [trace, "trace"],
    [dir, "dir"],
    [consoleAssert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    delete times[label]
    var duration = now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function consoleAssert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}


/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(/*! object-keys */ "./node_modules/object-keys/index.js");
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var hasPropertyDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();

var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;

var defineProperty = function (object, name, value, predicate) {
	if (name in object) {
		if (predicate === true) {
			if (object[name] === value) {
				return;
			}
		} else if (!isFunction(predicate) || !predicate()) {
			return;
		}
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value; // eslint-disable-line no-param-reassign
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),

/***/ "./node_modules/es6-object-assign/index.js":
/*!*************************************************!*\
  !*** ./node_modules/es6-object-assign/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
/**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */



function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }

  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}

function polyfill() {
  if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: assign
    });
  }
}

module.exports = {
  assign: assign,
  polyfill: polyfill
};


/***/ }),

/***/ "./node_modules/for-each/index.js":
/*!****************************************!*\
  !*** ./node_modules/for-each/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(/*! is-callable */ "./node_modules/is-callable/index.js");

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};

var forEachString = function forEachString(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};

var forEach = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }

    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }

    if (toStr.call(list) === '[object Array]') {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};

module.exports = forEach;


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var hasProto = __webpack_require__(/*! has-proto */ "./node_modules/has-proto/index.js")();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/gopd/index.js":
/*!************************************!*\
  !*** ./node_modules/gopd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/has-property-descriptors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/has-property-descriptors/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
			return true;
		} catch (e) {
			// IE 8 has a broken defineProperty
			return false;
		}
	}
	return false;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!hasPropertyDescriptors()) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ "./node_modules/has-proto/index.js":
/*!*****************************************!*\
  !*** ./node_modules/has-proto/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


var test = {
	foo: {}
};

var $Object = Object;

module.exports = function hasProto() {
	return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;


/***/ }),

/***/ "./node_modules/is-callable/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-callable/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	try {
		badArrayLike = Object.defineProperty({}, 'length', {
			get: function () {
				throw isCallableMarker;
			}
		});
		isCallableMarker = {};
		// eslint-disable-next-line no-throw-literal
		reflectApply(function () { throw 42; }, null, badArrayLike);
	} catch (_) {
		if (_ !== isCallableMarker) {
			reflectApply = null;
		}
	}
} else {
	reflectApply = null;
}

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() { return false; };
if (typeof document === 'object') {
	// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	var all = document.all;
	if (toStr.call(all) === toStr.call(document.all)) {
		isDDA = function isDocumentDotAll(value) {
			/* globals document: false */
			// in IE 6-8, typeof document.all is "object" and it's truthy
			if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
				try {
					var str = toStr.call(value);
					return (
						str === ddaClass
						|| str === ddaClass2
						|| str === ddaClass3 // opera 12.16
						|| str === objectClass // IE 6-8
					) && value('') == null; // eslint-disable-line eqeqeq
				} catch (e) { /**/ }
			}
			return false;
		};
	}
}

module.exports = reflectApply
	? function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		try {
			reflectApply(value, null, badArrayLike);
		} catch (e) {
			if (e !== isCallableMarker) { return false; }
		}
		return !isES6ClassFn(value) && tryFunctionObject(value);
	}
	: function isCallable(value) {
		if (isDDA(value)) { return true; }
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
		return tryFunctionObject(value);
	};


/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};


/***/ }),

/***/ "./node_modules/is-nan/implementation.js":
/*!***********************************************!*\
  !*** ./node_modules/is-nan/implementation.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function isNaN(value) {
	return value !== value;
};


/***/ }),

/***/ "./node_modules/is-nan/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-nan/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/is-nan/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/is-nan/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/is-nan/shim.js");

var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/is-nan/polyfill.js":
/*!*****************************************!*\
  !*** ./node_modules/is-nan/polyfill.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/is-nan/implementation.js");

module.exports = function getPolyfill() {
	if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
		return Number.isNaN;
	}
	return implementation;
};


/***/ }),

/***/ "./node_modules/is-nan/shim.js":
/*!*************************************!*\
  !*** ./node_modules/is-nan/shim.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/is-nan/polyfill.js");

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
	var polyfill = getPolyfill();
	define(Number, { isNaN: polyfill }, {
		isNaN: function testIsNaN() {
			return Number.isNaN !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");

module.exports = function isTypedArray(value) {
	return !!whichTypedArray(value);
};


/***/ }),

/***/ "./node_modules/object-is/implementation.js":
/*!**************************************************!*\
  !*** ./node_modules/object-is/implementation.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};



/***/ }),

/***/ "./node_modules/object-is/index.js":
/*!*****************************************!*\
  !*** ./node_modules/object-is/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");

var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");
var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
var shim = __webpack_require__(/*! ./shim */ "./node_modules/object-is/shim.js");

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),

/***/ "./node_modules/object-is/polyfill.js":
/*!********************************************!*\
  !*** ./node_modules/object-is/polyfill.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/object-is/implementation.js");

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};


/***/ }),

/***/ "./node_modules/object-is/shim.js":
/*!****************************************!*\
  !*** ./node_modules/object-is/shim.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(/*! ./polyfill */ "./node_modules/object-is/polyfill.js");
var define = __webpack_require__(/*! define-properties */ "./node_modules/define-properties/index.js");

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js"); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(/*! ./isArguments */ "./node_modules/object-keys/isArguments.js");

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ "./node_modules/object-keys/implementation.js");

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),

/***/ "./node_modules/onnxruntime-common/dist/lib/backend-impl.js":
/*!******************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/backend-impl.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerBackend: () => (/* binding */ registerBackend),
/* harmony export */   resolveBackend: () => (/* binding */ resolveBackend)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const backends = {};
const backendsSortedByPriority = [];
/**
 * Register a backend.
 *
 * @param name - the name as a key to lookup as an execution provider.
 * @param backend - the backend object.
 * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority
 * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.
 *
 * @internal
 */
const registerBackend = (name, backend, priority) => {
    if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {
        const currentBackend = backends[name];
        if (currentBackend === undefined) {
            backends[name] = { backend, priority };
        }
        else if (currentBackend.priority > priority) {
            // same name is already registered with a higher priority. skip registeration.
            return;
        }
        else if (currentBackend.priority === priority) {
            if (currentBackend.backend !== backend) {
                throw new Error(`cannot register backend "${name}" using priority ${priority}`);
            }
        }
        if (priority >= 0) {
            const i = backendsSortedByPriority.indexOf(name);
            if (i !== -1) {
                backendsSortedByPriority.splice(i, 1);
            }
            for (let i = 0; i < backendsSortedByPriority.length; i++) {
                if (backends[backendsSortedByPriority[i]].priority <= priority) {
                    backendsSortedByPriority.splice(i, 0, name);
                    return;
                }
            }
            backendsSortedByPriority.push(name);
        }
        return;
    }
    throw new TypeError('not a valid backend');
};
/**
 * Resolve backend by specified hints.
 *
 * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.
 * @returns a promise that resolves to the backend.
 *
 * @internal
 */
const resolveBackend = async (backendHints) => {
    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
    const errors = [];
    for (const backendName of backendNames) {
        const backendInfo = backends[backendName];
        if (backendInfo) {
            if (backendInfo.initialized) {
                return backendInfo.backend;
            }
            else if (backendInfo.aborted) {
                continue; // current backend is unavailable; try next
            }
            const isInitializing = !!backendInfo.initPromise;
            try {
                if (!isInitializing) {
                    backendInfo.initPromise = backendInfo.backend.init();
                }
                await backendInfo.initPromise;
                backendInfo.initialized = true;
                return backendInfo.backend;
            }
            catch (e) {
                if (!isInitializing) {
                    errors.push({ name: backendName, err: e });
                }
                backendInfo.aborted = true;
            }
            finally {
                delete backendInfo.initPromise;
            }
        }
    }
    throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);
};
//# sourceMappingURL=backend-impl.js.map

/***/ }),

/***/ "./node_modules/onnxruntime-common/dist/lib/backend.js":
/*!*************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/backend.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registerBackend: () => (/* reexport safe */ _backend_impl__WEBPACK_IMPORTED_MODULE_0__.registerBackend)
/* harmony export */ });
/* harmony import */ var _backend_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend-impl */ "./node_modules/onnxruntime-common/dist/lib/backend-impl.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

//# sourceMappingURL=backend.js.map

/***/ }),

/***/ "./node_modules/onnxruntime-common/dist/lib/env-impl.js":
/*!**************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/env-impl.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EnvImpl: () => (/* binding */ EnvImpl)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
class EnvImpl {
    constructor() {
        this.wasm = {};
        this.webgl = {};
        this.logLevelInternal = 'warning';
    }
    // TODO standadize the getter and setter convention in env for other fields.
    set logLevel(value) {
        if (value === undefined) {
            return;
        }
        if (typeof value !== 'string' || ['verbose', 'info', 'warning', 'error', 'fatal'].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
        }
        this.logLevelInternal = value;
    }
    get logLevel() {
        return this.logLevelInternal;
    }
}
//# sourceMappingURL=env-impl.js.map

/***/ }),

/***/ "./node_modules/onnxruntime-common/dist/lib/env.js":
/*!*********************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/env.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   env: () => (/* binding */ env)
/* harmony export */ });
/* harmony import */ var _env_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env-impl */ "./node_modules/onnxruntime-common/dist/lib/env-impl.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

/**
 * Represent a set of flags as a global singleton.
 */
const env = new _env_impl__WEBPACK_IMPORTED_MODULE_0__.EnvImpl();
//# sourceMappingURL=env.js.map

/***/ }),

/***/ "./node_modules/onnxruntime-common/dist/lib/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InferenceSession: () => (/* reexport safe */ _inference_session__WEBPACK_IMPORTED_MODULE_2__.InferenceSession),
/* harmony export */   Tensor: () => (/* reexport safe */ _tensor__WEBPACK_IMPORTED_MODULE_3__.Tensor),
/* harmony export */   env: () => (/* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_1__.env),
/* harmony export */   registerBackend: () => (/* reexport safe */ _backend__WEBPACK_IMPORTED_MODULE_0__.registerBackend)
/* harmony export */ });
/* harmony import */ var _backend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend */ "./node_modules/onnxruntime-common/dist/lib/backend.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env */ "./node_modules/onnxruntime-common/dist/lib/env.js");
/* harmony import */ var _inference_session__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inference-session */ "./node_modules/onnxruntime-common/dist/lib/inference-session.js");
/* harmony import */ var _tensor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tensor */ "./node_modules/onnxruntime-common/dist/lib/tensor.js");
/* harmony import */ var _onnx_value__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./onnx-value */ "./node_modules/onnxruntime-common/dist/lib/onnx-value.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * # ONNX Runtime JavaScript API
 *
 * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:
 *
 * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)
 * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)
 * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)
 *
 * See also:
 * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript.html)
 * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)
 *
 * @packageDocumentation
 */





//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js":
/*!****************************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InferenceSession: () => (/* binding */ InferenceSession)
/* harmony export */ });
/* harmony import */ var _backend_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend-impl */ "./node_modules/onnxruntime-common/dist/lib/backend-impl.js");
/* harmony import */ var _tensor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tensor */ "./node_modules/onnxruntime-common/dist/lib/tensor.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.


class InferenceSession {
    constructor(handler) {
        this.handler = handler;
    }
    async run(feeds, arg1, arg2) {
        const fetches = {};
        let options = {};
        // check inputs
        if (typeof feeds !== 'object' || feeds === null || feeds instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor || Array.isArray(feeds)) {
            throw new TypeError('\'feeds\' must be an object that use input names as keys and OnnxValue as corresponding values.');
        }
        let isFetchesEmpty = true;
        // determine which override is being used
        if (typeof arg1 === 'object') {
            if (arg1 === null) {
                throw new TypeError('Unexpected argument[1]: cannot be null.');
            }
            if (arg1 instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor) {
                throw new TypeError('\'fetches\' cannot be a Tensor');
            }
            if (Array.isArray(arg1)) {
                if (arg1.length === 0) {
                    throw new TypeError('\'fetches\' cannot be an empty array.');
                }
                isFetchesEmpty = false;
                // output names
                for (const name of arg1) {
                    if (typeof name !== 'string') {
                        throw new TypeError('\'fetches\' must be a string array or an object.');
                    }
                    if (this.outputNames.indexOf(name) === -1) {
                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                    }
                    fetches[name] = null;
                }
                if (typeof arg2 === 'object' && arg2 !== null) {
                    options = arg2;
                }
                else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'options\' must be an object.');
                }
            }
            else {
                // decide whether arg1 is fetches or options
                // if any output name is present and its value is valid OnnxValue, we consider it fetches
                let isFetches = false;
                const arg1Keys = Object.getOwnPropertyNames(arg1);
                for (const name of this.outputNames) {
                    if (arg1Keys.indexOf(name) !== -1) {
                        const v = arg1[name];
                        if (v === null || v instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor) {
                            isFetches = true;
                            isFetchesEmpty = false;
                            fetches[name] = v;
                        }
                    }
                }
                if (isFetches) {
                    if (typeof arg2 === 'object' && arg2 !== null) {
                        options = arg2;
                    }
                    else if (typeof arg2 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                }
                else {
                    options = arg1;
                }
            }
        }
        else if (typeof arg1 !== 'undefined') {
            throw new TypeError('Unexpected argument[1]: must be \'fetches\' or \'options\'.');
        }
        // check if all inputs are in feed
        for (const name of this.inputNames) {
            if (typeof feeds[name] === 'undefined') {
                throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
        }
        // if no fetches is specified, we use the full output names list
        if (isFetchesEmpty) {
            for (const name of this.outputNames) {
                fetches[name] = null;
            }
        }
        // feeds, fetches and options are prepared
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
                returnValue[key] = new _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor(results[key].type, results[key].data, results[key].dims);
            }
        }
        return returnValue;
    }
    static async create(arg0, arg1, arg2, arg3) {
        // either load from a file or buffer
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === 'string') {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            }
            else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
        }
        else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            }
            else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
        }
        else if (arg0 instanceof ArrayBuffer ||
            (typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            }
            else if (typeof arg1 === 'number') {
                byteOffset = arg1;
                if (!Number.isSafeInteger(byteOffset)) {
                    throw new RangeError('\'byteOffset\' must be an integer.');
                }
                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
                }
                byteLength = arg0.byteLength - byteOffset;
                if (typeof arg2 === 'number') {
                    byteLength = arg2;
                    if (!Number.isSafeInteger(byteLength)) {
                        throw new RangeError('\'byteLength\' must be an integer.');
                    }
                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                    }
                    if (typeof arg3 === 'object' && arg3 !== null) {
                        options = arg3;
                    }
                    else if (typeof arg3 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                }
                else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'byteLength\' must be a number.');
                }
            }
            else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        }
        else {
            throw new TypeError('Unexpected argument[0]: must be \'path\' or \'buffer\'.');
        }
        // get backend hints
        const eps = options.executionProviders || [];
        const backendHints = eps.map(i => typeof i === 'string' ? i : i.name);
        const backend = await (0,_backend_impl__WEBPACK_IMPORTED_MODULE_0__.resolveBackend)(backendHints);
        const handler = await backend.createSessionHandler(filePathOrUint8Array, options);
        return new InferenceSession(handler);
    }
    startProfiling() {
        this.handler.startProfiling();
    }
    endProfiling() {
        this.handler.endProfiling();
    }
    get inputNames() {
        return this.handler.inputNames;
    }
    get outputNames() {
        return this.handler.outputNames;
    }
}
//# sourceMappingURL=inference-session-impl.js.map

/***/ }),

/***/ "./node_modules/onnxruntime-common/dist/lib/inference-session.js":
/*!***********************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/inference-session.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InferenceSession: () => (/* binding */ InferenceSession)
/* harmony export */ });
/* harmony import */ var _inference_session_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inference-session-impl */ "./node_modules/onnxruntime-common/dist/lib/inference-session-impl.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// eslint-disable-next-line @typescript-eslint/naming-convention
const InferenceSession = _inference_session_impl__WEBPACK_IMPORTED_MODULE_0__.InferenceSession;
//# sourceMappingURL=inference-session.js.map

/***/ }),

/***/ "./node_modules/onnxruntime-common/dist/lib/onnx-value.js":
/*!****************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/onnx-value.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

//# sourceMappingURL=onnx-value.js.map

/***/ }),

/***/ "./node_modules/onnxruntime-common/dist/lib/tensor-impl.js":
/*!*****************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/tensor-impl.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tensor: () => (/* binding */ Tensor)
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';
const isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([
    ['float32', Float32Array],
    ['uint8', Uint8Array],
    ['int8', Int8Array],
    ['uint16', Uint16Array],
    ['int16', Int16Array],
    ['int32', Int32Array],
    ['bool', Uint8Array],
    ['float64', Float64Array],
    ['uint32', Uint32Array],
]);
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([
    [Float32Array, 'float32'],
    [Uint8Array, 'uint8'],
    [Int8Array, 'int8'],
    [Uint16Array, 'uint16'],
    [Int16Array, 'int16'],
    [Int32Array, 'int32'],
    [Float64Array, 'float64'],
    [Uint32Array, 'uint32'],
]);
if (isBigInt64ArrayAvailable) {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');
}
if (isBigUint64ArrayAvailable) {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');
}
/**
 * calculate size from dims.
 *
 * @param dims the dims array. May be an illegal input.
 */
const calculateSize = (dims) => {
    let size = 1;
    for (let i = 0; i < dims.length; i++) {
        const dim = dims[i];
        if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
    }
    return size;
};
class Tensor {
    constructor(arg0, arg1, arg2) {
        let type;
        let data;
        let dims;
        // check whether arg0 is type or data
        if (typeof arg0 === 'string') {
            //
            // Override: constructor(type, data, ...)
            //
            type = arg0;
            dims = arg2;
            if (arg0 === 'string') {
                // string tensor
                if (!Array.isArray(arg1)) {
                    throw new TypeError('A string tensor\'s data must be a string array.');
                }
                // we don't check whether every element in the array is string; this is too slow. we assume it's correct and
                // error will be populated at inference
                data = arg1;
            }
            else {
                // numeric tensor
                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                if (typedArrayConstructor === undefined) {
                    throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                }
                if (Array.isArray(arg1)) {
                    // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces
                    // incorrect results.
                    // 'typedArrayConstructor' should be one of the typed array prototype objects.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data = typedArrayConstructor.from(arg1);
                }
                else if (arg1 instanceof typedArrayConstructor) {
                    data = arg1;
                }
                else {
                    throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                }
            }
        }
        else {
            //
            // Override: constructor(data, ...)
            //
            dims = arg1;
            if (Array.isArray(arg0)) {
                // only boolean[] and string[] is supported
                if (arg0.length === 0) {
                    throw new TypeError('Tensor type cannot be inferred from an empty array.');
                }
                const firstElementType = typeof arg0[0];
                if (firstElementType === 'string') {
                    type = 'string';
                    data = arg0;
                }
                else if (firstElementType === 'boolean') {
                    type = 'bool';
                    // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is
                    // wrong type. We use 'as any' to make it happy.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data = Uint8Array.from(arg0);
                }
                else {
                    throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                }
            }
            else {
                // get tensor type from TypedArray
                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                if (mappedType === undefined) {
                    throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                }
                type = mappedType;
                data = arg0;
            }
        }
        // type and data is processed, now processing dims
        if (dims === undefined) {
            // assume 1-D tensor if dims omitted
            dims = [data.length];
        }
        else if (!Array.isArray(dims)) {
            throw new TypeError('A tensor\'s dims must be a number array');
        }
        // perform check
        const size = calculateSize(dims);
        if (size !== data.length) {
            throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);
        }
        this.dims = dims;
        this.type = type;
        this.data = data;
        this.size = size;
    }
    // #endregion
    /**
     * Create a new tensor object from image object
     *
     * @param buffer - Extracted image buffer data - assuming RGBA format
     * @param imageFormat - input image configuration - required configurations height, width, format
     * @param tensorFormat - output tensor configuration - Default is RGB format
     */
    static bufferToTensor(buffer, options) {
        if (buffer === undefined) {
            throw new Error('Image buffer must be defined');
        }
        if (options.height === undefined || options.width === undefined) {
            throw new Error('Image height and width must be defined');
        }
        const { height, width } = options;
        const norm = options.norm;
        let normMean;
        let normBias;
        if (norm === undefined || norm.mean === undefined) {
            normMean = 255;
        }
        else {
            normMean = norm.mean;
        }
        if (norm === undefined || norm.bias === undefined) {
            normBias = 0;
        }
        else {
            normBias = norm.bias;
        }
        const inputformat = options.bitmapFormat !== undefined ? options.bitmapFormat : 'RGBA';
        // default value is RGBA since imagedata and HTMLImageElement uses it
        const outputformat = options.tensorFormat !== undefined ?
            (options.tensorFormat !== undefined ? options.tensorFormat : 'RGB') :
            'RGB';
        const offset = height * width;
        const float32Data = outputformat === 'RGBA' ? new Float32Array(offset * 4) : new Float32Array(offset * 3);
        // Default pointer assignments
        let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;
        // Updating the pointer assignments based on the input image format
        if (inputformat === 'RGB') {
            step = 3;
            rImagePointer = 0;
            gImagePointer = 1;
            bImagePointer = 2;
            aImagePointer = -1;
        }
        // Updating the pointer assignments based on the output tensor format
        if (outputformat === 'RGBA') {
            aTensorPointer = offset * 3;
        }
        else if (outputformat === 'RBG') {
            rTensorPointer = 0;
            bTensorPointer = offset;
            gTensorPointer = offset * 2;
        }
        else if (outputformat === 'BGR') {
            bTensorPointer = 0;
            gTensorPointer = offset;
            rTensorPointer = offset * 2;
        }
        for (let i = 0; i < offset; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
            float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias) / normMean;
            float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias) / normMean;
            float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias) / normMean;
            if (aTensorPointer !== -1 && aImagePointer !== -1) {
                float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias) / normMean;
            }
        }
        // Float32Array -> ort.Tensor
        const outputTensor = outputformat === 'RGBA' ? new Tensor('float32', float32Data, [1, 4, height, width]) :
            new Tensor('float32', float32Data, [1, 3, height, width]);
        return outputTensor;
    }
    static async fromImage(image, options) {
        // checking the type of image object
        const isHTMLImageEle = typeof (HTMLImageElement) !== 'undefined' && image instanceof HTMLImageElement;
        const isImageDataEle = typeof (ImageData) !== 'undefined' && image instanceof ImageData;
        const isImageBitmap = typeof (ImageBitmap) !== 'undefined' && image instanceof ImageBitmap;
        const isURL = typeof (String) !== 'undefined' && (image instanceof String || typeof image === 'string');
        let data;
        let tensorConfig = {};
        // filling and checking image configuration options
        if (isHTMLImageEle) {
            // HTMLImageElement - image object - format is RGBA by default
            const canvas = document.createElement('canvas');
            const pixels2DContext = canvas.getContext('2d');
            if (pixels2DContext != null) {
                let height = image.naturalHeight;
                let width = image.naturalWidth;
                if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {
                    height = options.resizedHeight;
                    width = options.resizedWidth;
                }
                if (options !== undefined) {
                    tensorConfig = options;
                    if (options.tensorFormat !== undefined) {
                        throw new Error('Image input config format must be RGBA for HTMLImageElement');
                    }
                    else {
                        tensorConfig.tensorFormat = 'RGBA';
                    }
                    if (options.height !== undefined && options.height !== height) {
                        throw new Error('Image input config height doesn\'t match HTMLImageElement height');
                    }
                    else {
                        tensorConfig.height = height;
                    }
                    if (options.width !== undefined && options.width !== width) {
                        throw new Error('Image input config width doesn\'t match HTMLImageElement width');
                    }
                    else {
                        tensorConfig.width = width;
                    }
                }
                else {
                    tensorConfig.tensorFormat = 'RGBA';
                    tensorConfig.height = height;
                    tensorConfig.width = width;
                }
                canvas.width = width;
                canvas.height = height;
                pixels2DContext.drawImage(image, 0, 0, width, height);
                data = pixels2DContext.getImageData(0, 0, width, height).data;
            }
            else {
                throw new Error('Can not access image data');
            }
        }
        else if (isImageDataEle) {
            // ImageData - image object - format is RGBA by default
            const format = 'RGBA';
            let height;
            let width;
            if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {
                height = options.resizedHeight;
                width = options.resizedWidth;
            }
            else {
                height = image.height;
                width = image.width;
            }
            if (options !== undefined) {
                tensorConfig = options;
                if (options.bitmapFormat !== undefined && options.bitmapFormat !== format) {
                    throw new Error('Image input config format must be RGBA for ImageData');
                }
                else {
                    tensorConfig.bitmapFormat = 'RGBA';
                }
            }
            else {
                tensorConfig.bitmapFormat = 'RGBA';
            }
            tensorConfig.height = height;
            tensorConfig.width = width;
            if (options !== undefined) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const pixels2DContext = tempCanvas.getContext('2d');
                if (pixels2DContext != null) {
                    pixels2DContext.putImageData(image, 0, 0);
                    data = pixels2DContext.getImageData(0, 0, width, height).data;
                }
                else {
                    throw new Error('Can not access image data');
                }
            }
            else {
                data = image.data;
            }
        }
        else if (isImageBitmap) {
            // ImageBitmap - image object - format must be provided by user
            if (options === undefined) {
                throw new Error('Please provide image config with format for Imagebitmap');
            }
            if (options.bitmapFormat !== undefined) {
                throw new Error('Image input config format must be defined for ImageBitmap');
            }
            const pixels2DContext = document.createElement('canvas').getContext('2d');
            if (pixels2DContext != null) {
                const height = image.height;
                const width = image.width;
                pixels2DContext.drawImage(image, 0, 0, width, height);
                data = pixels2DContext.getImageData(0, 0, width, height).data;
                if (options !== undefined) {
                    // using square brackets to avoid TS error - type 'never'
                    if (options.height !== undefined && options.height !== height) {
                        throw new Error('Image input config height doesn\'t match ImageBitmap height');
                    }
                    else {
                        tensorConfig.height = height;
                    }
                    // using square brackets to avoid TS error - type 'never'
                    if (options.width !== undefined && options.width !== width) {
                        throw new Error('Image input config width doesn\'t match ImageBitmap width');
                    }
                    else {
                        tensorConfig.width = width;
                    }
                }
                else {
                    tensorConfig.height = height;
                    tensorConfig.width = width;
                }
                return Tensor.bufferToTensor(data, tensorConfig);
            }
            else {
                throw new Error('Can not access image data');
            }
        }
        else if (isURL) {
            return new Promise((resolve, reject) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                if (!image || !context) {
                    return reject();
                }
                const newImage = new Image();
                newImage.crossOrigin = 'Anonymous';
                newImage.src = image;
                newImage.onload = () => {
                    canvas.width = newImage.width;
                    canvas.height = newImage.height;
                    context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
                    const img = context.getImageData(0, 0, canvas.width, canvas.height);
                    if (options !== undefined) {
                        // using square brackets to avoid TS error - type 'never'
                        if (options.height !== undefined && options.height !== canvas.height) {
                            throw new Error('Image input config height doesn\'t match ImageBitmap height');
                        }
                        else {
                            tensorConfig.height = canvas.height;
                        }
                        // using square brackets to avoid TS error - type 'never'
                        if (options.width !== undefined && options.width !== canvas.width) {
                            throw new Error('Image input config width doesn\'t match ImageBitmap width');
                        }
                        else {
                            tensorConfig.width = canvas.width;
                        }
                    }
                    else {
                        tensorConfig.height = canvas.height;
                        tensorConfig.width = canvas.width;
                    }
                    resolve(Tensor.bufferToTensor(img.data, tensorConfig));
                };
            });
        }
        else {
            throw new Error('Input data provided is not supported - aborted tensor creation');
        }
        if (data !== undefined) {
            return Tensor.bufferToTensor(data, tensorConfig);
        }
        else {
            throw new Error('Input data provided is not supported - aborted tensor creation');
        }
    }
    toImageData(options) {
        var _a, _b;
        const pixels2DContext = document.createElement('canvas').getContext('2d');
        let image;
        if (pixels2DContext != null) {
            // Default values for height and width & format
            const width = this.dims[3];
            const height = this.dims[2];
            const channels = this.dims[1];
            const inputformat = options !== undefined ? (options.format !== undefined ? options.format : 'RGB') : 'RGB';
            const normMean = options !== undefined ? (((_a = options.norm) === null || _a === void 0 ? void 0 : _a.mean) !== undefined ? options.norm.mean : 255) : 255;
            const normBias = options !== undefined ? (((_b = options.norm) === null || _b === void 0 ? void 0 : _b.bias) !== undefined ? options.norm.bias : 0) : 0;
            const offset = height * width;
            if (options !== undefined) {
                if (options.height !== undefined && options.height !== height) {
                    throw new Error('Image output config height doesn\'t match tensor height');
                }
                if (options.width !== undefined && options.width !== width) {
                    throw new Error('Image output config width doesn\'t match tensor width');
                }
                if (options.format !== undefined && (channels === 4 && options.format !== 'RGBA') ||
                    (channels === 3 && (options.format !== 'RGB' && options.format !== 'BGR'))) {
                    throw new Error('Tensor format doesn\'t match input tensor dims');
                }
            }
            // Default pointer assignments
            const step = 4;
            let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
            let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;
            // Updating the pointer assignments based on the input image format
            if (inputformat === 'RGBA') {
                rTensorPointer = 0;
                gTensorPointer = offset;
                bTensorPointer = offset * 2;
                aTensorPointer = offset * 3;
            }
            else if (inputformat === 'RGB') {
                rTensorPointer = 0;
                gTensorPointer = offset;
                bTensorPointer = offset * 2;
            }
            else if (inputformat === 'RBG') {
                rTensorPointer = 0;
                bTensorPointer = offset;
                gTensorPointer = offset * 2;
            }
            image = pixels2DContext.createImageData(width, height);
            for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
                image.data[rImagePointer] = (this.data[rTensorPointer++] - normBias) * normMean; // R value
                image.data[gImagePointer] = (this.data[gTensorPointer++] - normBias) * normMean; // G value
                image.data[bImagePointer] = (this.data[bTensorPointer++] - normBias) * normMean; // B value
                image.data[aImagePointer] =
                    aTensorPointer === -1 ? 255 : (this.data[aTensorPointer++] - normBias) * normMean; // A value
            }
        }
        else {
            throw new Error('Can not access image data');
        }
        return image;
    }
    // #endregion
    // #region tensor utilities
    reshape(dims) {
        return new Tensor(this.type, this.data, dims);
    }
}
//# sourceMappingURL=tensor-impl.js.map

/***/ }),

/***/ "./node_modules/onnxruntime-common/dist/lib/tensor.js":
/*!************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/lib/tensor.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tensor: () => (/* binding */ Tensor)
/* harmony export */ });
/* harmony import */ var _tensor_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tensor-impl */ "./node_modules/onnxruntime-common/dist/lib/tensor-impl.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// eslint-disable-next-line @typescript-eslint/naming-convention
const Tensor = _tensor_impl__WEBPACK_IMPORTED_MODULE_0__.Tensor;
//# sourceMappingURL=tensor.js.map

/***/ }),

/***/ "./node_modules/onnxruntime-web/dist/ort-web.min.js":
/*!**********************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort-web.min.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/
!function(t,e){if(true)module.exports=e(__webpack_require__(/*! onnxruntime-common */ "./node_modules/onnxruntime-common/dist/lib/index.js"));else { var r, n; }}(self,(__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return $.buffer!=C&&H($.buffer),F}function r(){return $.buffer!=C&&H($.buffer),N}function i(){return $.buffer!=C&&H($.buffer),L}function o(){return $.buffer!=C&&H($.buffer),R}function a(){return $.buffer!=C&&H($.buffer),j}var s,u,c;t=t||{},s||(s=void 0!==t?t:{}),s.ready=new Promise((function(t,e){u=t,c=e}));var l,p,f,d,h,g,b=Object.assign({},s),m="./this.program",y=(t,e)=>{throw e},_="object"==typeof window,v="function"==typeof importScripts,w="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x=s.ENVIRONMENT_IS_PTHREAD||!1,T="";function S(t){return s.locateFile?s.locateFile(t,T):T+t}if(w){let e;T=v?n(908).dirname(T)+"/":"//",g=()=>{h||(d=n(1384),h=n(908))},l=function(t,e){return g(),t=h.normalize(t),d.readFileSync(t,e?void 0:"utf8")},f=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),p=(t,e,n)=>{g(),t=h.normalize(t),d.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ut))throw t})),process.on("unhandledRejection",(function(t){throw t})),y=(t,e)=>{if(J())throw process.exitCode=t,e;e instanceof ut||P("exiting due to exception: "+e),process.exit(t)},s.inspect=function(){return"[Emscripten Module object]"};try{e=n(9925)}catch(t){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),t}n.g.Worker=e.Worker}else(_||v)&&(v?T=self.location.href:"undefined"!=typeof document&&document.currentScript&&(T=document.currentScript.src),_scriptDir&&(T=_scriptDir),T=0!==T.indexOf("blob:")?T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):"",w||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},v&&(f=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),p=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));w&&"undefined"==typeof performance&&(n.g.performance=n(6953).performance);var O=console.log.bind(console),A=console.warn.bind(console);w&&(g(),O=t=>d.writeSync(1,t+"\n"),A=t=>d.writeSync(2,t+"\n"));var E,I=s.print||O,P=s.printErr||A;Object.assign(s,b),b=null,s.thisProgram&&(m=s.thisProgram),s.quit&&(y=s.quit),s.wasmBinary&&(E=s.wasmBinary);var D=s.noExitRuntime||!1;"object"!=typeof WebAssembly&&it("no native wasm support detected");var $,k,C,F,N,L,R,j,M=!1,U="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function V(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&U)return U.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var i=t[e++];if(128&i){var o=63&t[e++];if(192==(224&i))r+=String.fromCharCode((31&i)<<6|o);else{var a=63&t[e++];65536>(i=224==(240&i)?(15&i)<<12|o<<6|a:(7&i)<<18|o<<12|a<<6|63&t[e++])?r+=String.fromCharCode(i):(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i))}}else r+=String.fromCharCode(i)}return r}function B(t,e){return(t>>>=0)?V(r(),t,e):""}function z(t,e,n,r){if(!(0<r))return 0;var i=n>>>=0;r=n+r-1;for(var o=0;o<t.length;++o){var a=t.charCodeAt(o);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&t.charCodeAt(++o)),127>=a){if(n>=r)break;e[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;e[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;e[n++>>>0]=224|a>>12}else{if(n+3>=r)break;e[n++>>>0]=240|a>>18,e[n++>>>0]=128|a>>12&63}e[n++>>>0]=128|a>>6&63}e[n++>>>0]=128|63&a}}return e[n>>>0]=0,n-i}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function H(t){C=t,s.HEAP8=F=new Int8Array(t),s.HEAP16=new Int16Array(t),s.HEAP32=L=new Int32Array(t),s.HEAPU8=N=new Uint8Array(t),s.HEAPU16=new Uint16Array(t),s.HEAPU32=R=new Uint32Array(t),s.HEAPF32=new Float32Array(t),s.HEAPF64=j=new Float64Array(t)}x&&(C=s.buffer);var W=s.INITIAL_MEMORY||16777216;if(x)$=s.wasmMemory,C=s.buffer;else if(s.wasmMemory)$=s.wasmMemory;else if(!(($=new WebAssembly.Memory({initial:W/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw P("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");$&&(C=$.buffer),W=C.byteLength,H(C);var q,X=[],Y=[],K=[],Z=[];function J(){return D||!1}function Q(){var t=s.preRun.shift();X.unshift(t)}var tt,et=0,nt=null,rt=null;function it(t){throw x?postMessage({cmd:"onAbort",arg:t}):s.onAbort&&s.onAbort(t),P(t="Aborted("+t+")"),M=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),c(t),t}function ot(){return tt.startsWith("data:application/octet-stream;base64,")}function at(){var t=tt;try{if(t==tt&&E)return new Uint8Array(E);if(f)return f(t);throw"both async and sync fetching of the wasm failed"}catch(t){it(t)}}tt="ort-wasm-threaded.wasm",ot()||(tt=S(tt));var st={};function ut(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function ct(t){(t=dt.Vb[t])||it(),dt.mc(t)}function lt(t){var e=dt.Cc();if(!e)return 6;dt.ac.push(e),dt.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function pt(t){if(x)return qt(1,1,t);J()||(dt.oc(),s.onExit&&s.onExit(t),M=!0),y(t,new ut(t))}function ft(t,e){if(!e&&x)throw bt(t),"unwind";J()||x||(me(),ht(K),be(0),re[1].length&&ie(1,10),re[2].length&&ie(2,10),dt.oc()),pt(t)}var dt={Yb:[],ac:[],qc:[],Vb:{},fc:function(){x&&dt.Ec()},Pc:function(){},Ec:function(){dt.receiveObjectTransfer=dt.Gc,dt.threadInitTLS=dt.pc,dt.setExitStatus=dt.nc,D=!1},nc:function(){},oc:function(){for(var t of Object.values(dt.Vb))dt.mc(t);for(t of dt.Yb)t.terminate();dt.Yb=[]},mc:function(t){var e=t.Ub;delete dt.Vb[e],dt.Yb.push(t),dt.ac.splice(dt.ac.indexOf(t),1),t.Ub=0,xe(e)},Gc:function(){},pc:function(){dt.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(dt.Bc=t.Ub),n.targetThread&&n.targetThread!=de()){var i=dt.Vb[n.Qc];i?i.postMessage(n,n.transferList):P('Internal error! Worker sent a message "'+r+'" to target pthread '+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?Vt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?ct(n.thread):"killThread"===r?(n=n.thread,r=dt.Vb[n],delete dt.Vb[n],r.terminate(),xe(n),dt.ac.splice(dt.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?dt.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?I("Thread "+n.threadId+": "+n.text):"printErr"===r?P("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&P("worker sent an unknown command "+r);dt.Bc=void 0},t.onerror=t=>{throw P("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},w&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:$,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");dt.Yb.push(new Worker(t))},Cc:function(){return 0==dt.Yb.length&&(dt.yc(),dt.Fc(dt.Yb[0])),dt.Yb.pop()}};function ht(t){for(;0<t.length;)t.shift()(s)}function gt(t){var e=Ae();return t=t(),Ee(e),t}function bt(t){if(x)return qt(2,0,t);try{ft(t)}catch(t){t instanceof ut||"unwind"==t||y(1,t)}}s.PThread=dt,s.establishStackSpace=function(){var t=de(),e=i()[t+44>>2>>>0];t=i()[t+48>>2>>>0],Oe(e,e-t),Ee(e)};var mt=[];function yt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=q.get(t)),e}s.invokeEntryPoint=function(t,e){t=yt(t)(e),J()?dt.nc(t):Te(t)};var _t,vt,wt=[],xt=0,Tt=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){o()[this.Sb+4>>2>>>0]=t},this.bc=function(){return o()[this.Sb+4>>2>>>0]},this.wc=function(t){o()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return o()[this.Sb+8>>2>>>0]},this.rc=function(){i()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(i(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(i(),this.Sb>>2,1)},this.cc=function(t){o()[this.Sb+16>>2>>>0]=t},this.tc=function(){return o()[this.Sb+16>>2>>>0]},this.vc=function(){if(De(this.bc()))return o()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Ot(t){return ge(new St(t).Sb)}function At(t,e,n,r){return x?qt(3,1,t,e,n,r):Et(t,e,n,r)}function Et(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return P("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var i=[];return x&&0===i.length?At(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:i},x?(t.Oc="spawnThread",postMessage(t,i),0):lt(t))}function It(t,e,n){return x?qt(4,1,t,e,n):0}function Pt(t,e){if(x)return qt(5,1,t,e)}function Dt(t,e){if(x)return qt(6,1,t,e)}function $t(t,e,n){if(x)return qt(7,1,t,e,n)}function kt(t,e,n){return x?qt(8,1,t,e,n):0}function Ct(t,e){if(x)return qt(9,1,t,e)}function Ft(t,e,n){if(x)return qt(10,1,t,e,n)}function Nt(t,e,n,r){if(x)return qt(11,1,t,e,n,r)}function Lt(t,e,n,r){if(x)return qt(12,1,t,e,n,r)}function Rt(t,e,n,r){if(x)return qt(13,1,t,e,n,r)}function jt(t){if(x)return qt(14,1,t)}function Mt(t,e){if(x)return qt(15,1,t,e)}function Ut(t,e,n){if(x)return qt(16,1,t,e,n)}function Vt(t){Atomics.store(i(),t>>2,1),de()&&we(t),Atomics.compareExchange(i(),t>>2,1,0)}function Bt(t){return o()[t>>>2]+4294967296*i()[t+4>>>2]}function zt(t,e,n,r,i,o){return x?qt(17,1,t,e,n,r,i,o):-52}function Gt(t,e,n,r,i,o){if(x)return qt(18,1,t,e,n,r,i,o)}function Ht(t){var n=G(t)+1,r=he(n);return r&&z(t,e(),r,n),r}function Wt(t,e,n){function r(t){return(t=t.toTimeString().match(/\(([A-Za-z ]+)\)$/))?t[1]:"GMT"}if(x)return qt(19,1,t,e,n);var a=(new Date).getFullYear(),s=new Date(a,0,1),u=new Date(a,6,1);a=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(a,c);i()[t>>2>>>0]=60*l,i()[e>>2>>>0]=Number(a!=c),t=r(s),e=r(u),t=Ht(t),e=Ht(e),c<a?(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e):(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t)}function qt(t,e){var n=arguments.length-2,r=arguments;return gt((()=>{for(var i=Ie(8*n),o=i>>3,s=0;s<n;s++){var u=r[2+s];a()[o+s>>>0]=u}return ve(t,n,i,e)}))}s.executeNotifiedProxyingQueue=Vt,vt=w?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:x?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Xt,Yt=[],Kt={};function Zt(){if(!Xt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Kt)void 0===Kt[t]?delete e[t]:e[t]=Kt[t];var n=[];for(t in e)n.push(t+"="+e[t]);Xt=n}return Xt}function Jt(t,n){if(x)return qt(20,1,t,n);var r=0;return Zt().forEach((function(i,a){var s=n+r;for(a=o()[t+4*a>>2>>>0]=s,s=0;s<i.length;++s)e()[a++>>0>>>0]=i.charCodeAt(s);e()[a>>0>>>0]=0,r+=i.length+1})),0}function Qt(t,e){if(x)return qt(21,1,t,e);var n=Zt();o()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),o()[e>>2>>>0]=r,0}function te(t){return x?qt(22,1,t):52}function ee(t,e,n,r){return x?qt(23,1,t,e,n,r):52}function ne(t,e,n,r,i){return x?qt(24,1,t,e,n,r,i):70}var re=[null,[],[]];function ie(t,e){var n=re[t];0===e||10===e?((1===t?I:P)(V(n,0)),n.length=0):n.push(e)}function oe(t,e,n,i){if(x)return qt(25,1,t,e,n,i);for(var a=0,s=0;s<n;s++){var u=o()[e>>2>>>0],c=o()[e+4>>2>>>0];e+=8;for(var l=0;l<c;l++)ie(t,r()[u+l>>>0]);a+=c}return o()[i>>2>>>0]=a,0}var ae=0;function se(t){return 0==t%4&&(0!=t%100||0==t%400)}var ue=[31,29,31,30,31,30,31,31,30,31,30,31],ce=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,o){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function s(t,e){return a(t,e,"0")}function u(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function c(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(se(t.getFullYear())?ue:ce)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=c(new Date(t.getFullYear(),0,4)),n=c(n),0>=u(e,t)?0>=u(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var p=i()[o+40>>2>>>0];for(var f in o={Lc:i()[o>>2>>>0],Kc:i()[o+4>>2>>>0],dc:i()[o+8>>2>>>0],jc:i()[o+12>>2>>>0],ec:i()[o+16>>2>>>0],Xb:i()[o+20>>2>>>0],Tb:i()[o+24>>2>>>0],Wb:i()[o+28>>2>>>0],Rc:i()[o+32>>2>>>0],Jc:i()[o+36>>2>>>0],Mc:p?B(p):""},r=B(r),p={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(f,"g"),p[f]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),h="January February March April May June July August September October November December".split(" ");for(f in p={"%a":function(t){return d[t.Tb].substring(0,3)},"%A":function(t){return d[t.Tb]},"%b":function(t){return h[t.ec].substring(0,3)},"%B":function(t){return h[t.ec]},"%C":function(t){return s((t.Xb+1900)/100|0,2)},"%d":function(t){return s(t.jc,2)},"%e":function(t){return a(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return s(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),s(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(se(t.Xb+1900)?ue:ce)[n++]);return s(t.jc+e,3)},"%m":function(t){return s(t.ec+1,2)},"%M":function(t){return s(t.Kc,2)},"%n":function(){return"\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return s(t.Lc,2)},"%t":function(){return"\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return s(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&se(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&se(t.Xb%400-1))&&e++}return s(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return s(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\0\0"),p)r.includes(f)&&(r=r.replace(new RegExp(f,"g"),p[f](o)));return f=function(t){var e=Array(G(t)+1);return z(t,e,0,e.length),e}(r=r.replace(/\0\0/g,"%")),f.length>n?0:(function(t,n){e().set(t,n>>>0)}(f,t),f.length-1)}dt.fc();var pe=[null,pt,bt,At,It,Pt,Dt,$t,kt,Ct,Ft,Nt,Lt,Rt,jt,Mt,Ut,zt,Gt,Wt,Jt,Qt,te,ee,ne,oe],fe={b:function(t){return he(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),xt--),t.ic(!1),wt.push(t),t.sc(),t.vc()},ma:function(t){throw P("Unexpected exception thrown, this is not properly supported - aborting"),M=!0,t},x:function(){Se(0);var t=wt.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&yt(e)(t.Zb),Ot(t.Zb)}Tt=0},e:function(){var t=Tt;if(!t)return ae=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return ae=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(Pe(o,n,e.Sb+16))return ae=o,t}return ae=n,t},l:function(){var t=Tt;if(!t)return ae=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return ae=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(Pe(o,n,e.Sb+16))return ae=o,t}return ae=n,t},h:function(){var t=Tt;if(!t)return ae=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return ae=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(Pe(o,n,e.Sb+16))return ae=o,t}return ae=n,t},t:Ot,M:function(){var t=wt.pop();t||it("no exception to throw");var e=t.Zb;throw t.kc()||(wt.push(t),t.ic(!0),t.hc(!1),xt++),Tt=e,e},c:function(t,e,n){throw new St(t).fc(e,n),Tt=t,xt++,t},pa:function(){return xt},Fa:function(t){ye(t,!v,1,!_),dt.pc()},T:function(t){x?postMessage({cmd:"cleanupThread",thread:t}):ct(t)},xa:Et,j:function(t){throw Tt||(Tt=t),t},H:It,Ma:Pt,ua:Dt,wa:$t,oa:kt,Ka:Ct,Ca:Ft,Ja:Nt,V:Lt,va:Rt,sa:jt,La:Mt,ta:Ut,Ta:function(){},X:function(){it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>Vt(r)));else if(x)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=dt.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Bt(t)),i()[e>>2>>>0]=t.getUTCSeconds(),i()[e+4>>2>>>0]=t.getUTCMinutes(),i()[e+8>>2>>>0]=t.getUTCHours(),i()[e+12>>2>>>0]=t.getUTCDate(),i()[e+16>>2>>>0]=t.getUTCMonth(),i()[e+20>>2>>>0]=t.getUTCFullYear()-1900,i()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,i()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Bt(t)),i()[e>>2>>>0]=t.getSeconds(),i()[e+4>>2>>>0]=t.getMinutes(),i()[e+8>>2>>>0]=t.getHours(),i()[e+12>>2>>>0]=t.getDate(),i()[e+16>>2>>>0]=t.getMonth(),i()[e+20>>2>>>0]=t.getFullYear()-1900,i()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;i()[e+28>>2>>>0]=r,i()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),i()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(i()[t+20>>2>>>0]+1900,i()[t+16>>2>>>0],i()[t+12>>2>>>0],i()[t+8>>2>>>0],i()[t+4>>2>>>0],i()[t>>2>>>0],0),n=i()[t+32>>2>>>0],r=e.getTimezoneOffset(),o=new Date(e.getFullYear(),0,1),a=new Date(e.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,a);return 0>n?i()[t+32>>2>>>0]=Number(a!=s&&u==r):0<n!=(u==r)&&(a=Math.max(s,a),e.setTime(e.getTime()+6e4*((0<n?u:a)-r))),i()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-o.getTime())/864e5|0,i()[t+28>>2>>>0]=n,i()[t>>2>>>0]=e.getSeconds(),i()[t+4>>2>>>0]=e.getMinutes(),i()[t+8>>2>>>0]=e.getHours(),i()[t+12>>2>>>0]=e.getDate(),i()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:zt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Wt(e,n,r))},y:function(){it("")},U:function(){if(!w&&!v){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";_t||(_t={}),_t[t]||(_t[t]=1,w&&(t="warning: "+t),P(t))}},ra:function(){return 4294901760},B:vt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return w?n(3993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Yt.length=e,n>>=3;for(var r=0;r<e;r++)Yt[r]=a()[n+r>>>0];return(0>t?st[-t-1]:pe[t]).apply(null,Yt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var i=e*(1+.2/n);i=Math.min(i,t+100663296);var o=Math;i=Math.max(t,i),o=o.min.call(o,4294901760,i+(65536-i%65536)%65536);t:{try{$.grow(o-C.byteLength+65535>>>16),H($.buffer);var a=1;break t}catch(t){}a=void 0}if(a)return!0}return!1},Na:function(){throw"unwind"},Ga:Jt,Ha:Qt,J:ft,I:te,S:ee,ga:ne,R:oe,d:function(){return ae},na:function t(r,i){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(w)try{var e=n(Object(function(){var t=new Error("Cannot find module 'crypto'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>it("randomDevice")}());for(var o=0;o<i;o++)e()[r+o>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ae();try{return yt(t)()}catch(t){if(Ee(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ae();try{return yt(t)(e)}catch(t){if(Ee(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ae();try{return yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var i=Ae();try{return yt(t)(e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,i){var o=Ae();try{return yt(t)(e,n,r,i)}catch(t){if(Ee(o),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,i,o){var a=Ae();try{return yt(t)(e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,i,o){var a=Ae();try{return yt(t)(e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,i,o,a){var s=Ae();try{return yt(t)(e,n,r,i,o,a)}catch(t){if(Ee(s),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,i,o,a,s){var u=Ae();try{return yt(t)(e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Ae();try{return yt(t)(e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(Ee(f),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,i,o,a,s){var u=Ae();try{return Me(t,e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,i,o,a){var s=Ae();try{return ke(t,e,n,r,i,o,a)}catch(t){if(Ee(s),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,i){var o=Ae();try{return Ue(t,e,n,r,i)}catch(t){if(Ee(o),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var i=Ae();try{return Re(t,e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ae();try{return $e(t)}catch(t){if(Ee(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ae();try{return je(t,e)}catch(t){if(Ee(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ae();try{return Ce(t,e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ae();try{yt(t)()}catch(t){if(Ee(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ae();try{yt(t)(e)}catch(t){if(Ee(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ae();try{yt(t)(e,n)}catch(t){if(Ee(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var i=Ae();try{yt(t)(e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var i=Ae();try{yt(t)(e,n,r)}catch(t){if(Ee(i),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,i){var o=Ae();try{yt(t)(e,n,r,i)}catch(t){if(Ee(o),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,i,o){var a=Ae();try{yt(t)(e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,i,o,a){var s=Ae();try{yt(t)(e,n,r,i,o,a)}catch(t){if(Ee(s),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,i,o,a,s){var u=Ae();try{yt(t)(e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,i,o,a,s,u){var c=Ae();try{yt(t)(e,n,r,i,o,a,s,u)}catch(t){if(Ee(c),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,i,o,a,s,u,c,l){var p=Ae();try{yt(t)(e,n,r,i,o,a,s,u,c,l)}catch(t){if(Ee(p),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,i,o,a,s,u,c,l,p,f,d,h,g){var b=Ae();try{yt(t)(e,n,r,i,o,a,s,u,c,l,p,f,d,h,g)}catch(t){if(Ee(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,i,o,a,s){var u=Ae();try{Fe(t,e,n,r,i,o,a,s)}catch(t){if(Ee(u),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Ae();try{Le(t,e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(Ee(f),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,i,o){var a=Ae();try{Ne(t,e,n,r,i,o)}catch(t){if(Ee(a),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:$||s.wasmMemory,G:function(t){ae=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){s.asm=t.exports,dt.qc.push(s.asm.sb),q=s.asm.ub,Y.unshift(s.asm.Va),k=e,x||(et--,s.monitorRunDependencies&&s.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!E&&(_||v)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at '"+tt+"'";return t.arrayBuffer()})).catch((function(){return at()}));if(p)return new Promise((function(t,e){p(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return at()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){P("failed to asynchronously prepare wasm: "+t),it(t)}))}var r={a:fe};if(x||(et++,s.monitorRunDependencies&&s.monitorRunDependencies(et)),s.instantiateWasm)try{return s.instantiateWasm(r,t)}catch(t){return P("Module.instantiateWasm callback failed with error: "+t),!1}(E||"function"!=typeof WebAssembly.instantiateStreaming||ot()||tt.startsWith("file://")||w||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return P("wasm streaming compile failed: "+t),P("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.Va).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.Wa).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.Xa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.Ya).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.Za).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm._a).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.$a).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.ab).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.bb).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.cb).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.db).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.eb).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.fb).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.gb).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.hb).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.ib).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.jb).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.kb).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.lb).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.mb).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.nb).apply(null,arguments)};var de=s._pthread_self=function(){return(de=s._pthread_self=s.asm.ob).apply(null,arguments)},he=s._malloc=function(){return(he=s._malloc=s.asm.pb).apply(null,arguments)},ge=s._free=function(){return(ge=s._free=s.asm.qb).apply(null,arguments)},be=s._fflush=function(){return(be=s._fflush=s.asm.rb).apply(null,arguments)};s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.sb).apply(null,arguments)};var me=s.___funcs_on_exit=function(){return(me=s.___funcs_on_exit=s.asm.tb).apply(null,arguments)},ye=s.__emscripten_thread_init=function(){return(ye=s.__emscripten_thread_init=s.asm.vb).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.wb).apply(null,arguments)};var _e,ve=s._emscripten_run_in_main_runtime_thread_js=function(){return(ve=s._emscripten_run_in_main_runtime_thread_js=s.asm.xb).apply(null,arguments)},we=s.__emscripten_proxy_execute_task_queue=function(){return(we=s.__emscripten_proxy_execute_task_queue=s.asm.yb).apply(null,arguments)},xe=s.__emscripten_thread_free_data=function(){return(xe=s.__emscripten_thread_free_data=s.asm.zb).apply(null,arguments)},Te=s.__emscripten_thread_exit=function(){return(Te=s.__emscripten_thread_exit=s.asm.Ab).apply(null,arguments)},Se=s._setThrew=function(){return(Se=s._setThrew=s.asm.Bb).apply(null,arguments)},Oe=s._emscripten_stack_set_limits=function(){return(Oe=s._emscripten_stack_set_limits=s.asm.Cb).apply(null,arguments)},Ae=s.stackSave=function(){return(Ae=s.stackSave=s.asm.Db).apply(null,arguments)},Ee=s.stackRestore=function(){return(Ee=s.stackRestore=s.asm.Eb).apply(null,arguments)},Ie=s.stackAlloc=function(){return(Ie=s.stackAlloc=s.asm.Fb).apply(null,arguments)},Pe=s.___cxa_can_catch=function(){return(Pe=s.___cxa_can_catch=s.asm.Gb).apply(null,arguments)},De=s.___cxa_is_pointer_type=function(){return(De=s.___cxa_is_pointer_type=s.asm.Hb).apply(null,arguments)},$e=s.dynCall_j=function(){return($e=s.dynCall_j=s.asm.Ib).apply(null,arguments)},ke=s.dynCall_iiiiij=function(){return(ke=s.dynCall_iiiiij=s.asm.Jb).apply(null,arguments)},Ce=s.dynCall_jii=function(){return(Ce=s.dynCall_jii=s.asm.Kb).apply(null,arguments)},Fe=s.dynCall_viiiiij=function(){return(Fe=s.dynCall_viiiiij=s.asm.Lb).apply(null,arguments)},Ne=s.dynCall_vjji=function(){return(Ne=s.dynCall_vjji=s.asm.Mb).apply(null,arguments)},Le=s.dynCall_viiijjjii=function(){return(Le=s.dynCall_viiijjjii=s.asm.Nb).apply(null,arguments)},Re=s.dynCall_iij=function(){return(Re=s.dynCall_iij=s.asm.Ob).apply(null,arguments)},je=s.dynCall_ji=function(){return(je=s.dynCall_ji=s.asm.Pb).apply(null,arguments)},Me=s.dynCall_iiiiiij=function(){return(Me=s.dynCall_iiiiiij=s.asm.Qb).apply(null,arguments)},Ue=s.dynCall_iiij=function(){return(Ue=s.dynCall_iiij=s.asm.Rb).apply(null,arguments)};function Ve(){function t(){if(!_e&&(_e=!0,s.calledRun=!0,!M)&&(x||ht(Y),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!x)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var t=s.postRun.shift();Z.unshift(t)}ht(Z)}}if(!(0<et))if(x)u(s),x||ht(Y),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)Q();ht(X),0<et||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),t()}),1)):t())}}if(s.UTF8ToString=B,s.stringToUTF8=function(t,e,n){return z(t,r(),e,n)},s.lengthBytesUTF8=G,s.keepRuntimeAlive=J,s.wasmMemory=$,s.stackSave=Ae,s.stackRestore=Ee,s.stackAlloc=Ie,s.ExitStatus=ut,s.PThread=dt,rt=function t(){_e||Ve(),_e||(rt=t)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return Ve(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,i;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,i=e}));var o,a,s,u,c,l,p=Object.assign({},e),f="./this.program",d=(t,e)=>{throw e},h="object"==typeof window,g="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=g?n(908).dirname(m)+"/":"//",l=()=>{c||(u=n(1384),c=n(908))},o=function(t,e){return l(),t=c.normalize(t),u.readFileSync(t,e?void 0:"utf8")},s=t=>((t=o(t,!0)).buffer||(t=new Uint8Array(t)),t),a=(t,e,n)=>{l(),t=c.normalize(t),u.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(f=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof K))throw t})),process.on("unhandledRejection",(function(t){throw t})),d=(t,e)=>{if(w||0<U)throw process.exitCode=t,e;e instanceof K||v("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(h||g)&&(g?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},g&&(s=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),a=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var y,_=e.print||console.log.bind(console),v=e.printErr||console.warn.bind(console);Object.assign(e,p),p=null,e.thisProgram&&(f=e.thisProgram),e.quit&&(d=e.quit),e.wasmBinary&&(y=e.wasmBinary);var w=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&W("no native wasm support detected");var x,T,S,O,A,E,I=!1,P="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function D(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&P)return P.decode(t.subarray(e,n));for(r="";e<n;){var i=t[e++];if(128&i){var o=63&t[e++];if(192==(224&i))r+=String.fromCharCode((31&i)<<6|o);else{var a=63&t[e++];65536>(i=224==(240&i)?(15&i)<<12|o<<6|a:(7&i)<<18|o<<12|a<<6|63&t[e++])?r+=String.fromCharCode(i):(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i))}}else r+=String.fromCharCode(i)}return r}function $(t,e){return(t>>>=0)?D(O,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var i=n>>>=0;r=n+r-1;for(var o=0;o<t.length;++o){var a=t.charCodeAt(o);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&t.charCodeAt(++o)),127>=a){if(n>=r)break;e[n++>>>0]=a}else{if(2047>=a){if(n+1>=r)break;e[n++>>>0]=192|a>>6}else{if(65535>=a){if(n+2>=r)break;e[n++>>>0]=224|a>>12}else{if(n+3>=r)break;e[n++>>>0]=240|a>>18,e[n++>>>0]=128|a>>12&63}e[n++>>>0]=128|a>>6&63}e[n++>>>0]=128|63&a}}return e[n>>>0]=0,n-i}function C(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function F(){var t=x.buffer;T=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=A=new Int32Array(t),e.HEAPU8=O=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=E=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var N,L=[],R=[],j=[],M=[],U=0;function V(){var t=e.preRun.shift();L.unshift(t)}var B,z=0,G=null,H=null;function W(t){throw e.onAbort&&e.onAbort(t),v(t="Aborted("+t+")"),I=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),i(t),t}function q(){return B.startsWith("data:application/octet-stream;base64,")}if(B="ort-wasm.wasm",!q()){var X=B;B=e.locateFile?e.locateFile(X,m):m+X}function Y(){var t=B;try{if(t==B&&y)return new Uint8Array(y);if(s)return s(t);throw"both async and sync fetching of the wasm failed"}catch(t){W(t)}}function K(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var J=[],Q=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){E[this.zb+4>>2>>>0]=t},this.Eb=function(){return E[this.zb+4>>2>>>0]},this.Sb=function(t){E[this.zb+8>>2>>>0]=t},this.Wb=function(){return E[this.zb+8>>2>>>0]},this.Tb=function(){A[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){A[this.zb>>2>>>0]+=1},this.Xb=function(){var t=A[this.zb>>2>>>0];return A[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){E[this.zb+16>>2>>>0]=t},this.Ob=function(){return E[this.zb+16>>2>>>0]},this.Qb=function(){if(Et(this.Eb()))return E[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return _t(new et(t).zb)}var rt=[];function it(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=N.get(t)),e}function ot(t){var e=C(t)+1,n=yt(e);return n&&k(t,S,n,e),n}var at={};function st(){if(!ut){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:f||"./this.program"};for(t in at)void 0===at[t]?delete e[t]:e[t]=at[t];var n=[];for(t in e)n.push(t+"="+e[t]);ut=n}return ut}var ut,ct=[null,[],[]];function lt(t,e){var n=ct[t];0===e||10===e?((1===t?_:v)(D(n,0)),n.length=0):n.push(e)}var pt=0;function ft(t){return 0==t%4&&(0!=t%100||0==t%400)}var dt=[31,29,31,30,31,30,31,31,30,31,30,31],ht=[31,28,31,30,31,30,31,31,30,31,30,31];function gt(t,e,n,r){function i(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function o(t,e){return i(t,e,"0")}function a(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function u(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ft(t.getFullYear())?dt:ht)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=a(e,t)?0>=a(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var c=A[r+40>>2>>>0];for(var l in r={$b:A[r>>2>>>0],Zb:A[r+4>>2>>>0],Gb:A[r+8>>2>>>0],Kb:A[r+12>>2>>>0],Hb:A[r+16>>2>>>0],Cb:A[r+20>>2>>>0],Ab:A[r+24>>2>>>0],Bb:A[r+28>>2>>>0],bc:A[r+32>>2>>>0],Yb:A[r+36>>2>>>0],ac:c?$(c):""},n=$(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var p="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),f="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(t){return p[t.Ab].substring(0,3)},"%A":function(t){return p[t.Ab]},"%b":function(t){return f[t.Hb].substring(0,3)},"%B":function(t){return f[t.Hb]},"%C":function(t){return o((t.Cb+1900)/100|0,2)},"%d":function(t){return o(t.Kb,2)},"%e":function(t){return i(t.Kb,2," ")},"%g":function(t){return u(t).toString().substring(2)},"%G":function(t){return u(t)},"%H":function(t){return o(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),o(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(ft(t.Cb+1900)?dt:ht)[n++]);return o(t.Kb+e,3)},"%m":function(t){return o(t.Hb+1,2)},"%M":function(t){return o(t.Zb,2)},"%n":function(){return"\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return o(t.$b,2)},"%t":function(){return"\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return o(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&ft(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&ft(t.Cb%400-1))&&e++}return o(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return o(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\0\0"),c)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(t){var e=Array(C(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\0\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return yt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),Q--),t.Jb(!1),J.push(t),t.Nb(),t.Qb()},ia:function(t){throw v("Unexpected exception thrown, this is not properly supported - aborting"),I=!0,t},w:function(){xt(0);var t=J.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&it(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return pt=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return pt=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(At(o,n,e.zb+16))return pt=o,t}return pt=n,t},k:function(){var t=tt;if(!t)return pt=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return pt=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(At(o,n,e.zb+16))return pt=o,t}return pt=n,t},g:function(){var t=tt;if(!t)return pt=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return pt=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var o=r[i];if(0===o||o===n)break;if(At(o,n,e.zb+16))return pt=o,t}return pt=n,t},s:nt,L:function(){var t=J.pop();t||W("no exception to throw");var e=t.Db;throw t.Lb()||(J.push(t),t.Jb(!0),t.Ib(!1),Q++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,Q++,t},la:function(){return Q},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){W("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){W("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(E[t>>>2]+4294967296*A[t+4>>>2])),A[e>>2>>>0]=t.getUTCSeconds(),A[e+4>>2>>>0]=t.getUTCMinutes(),A[e+8>>2>>>0]=t.getUTCHours(),A[e+12>>2>>>0]=t.getUTCDate(),A[e+16>>2>>>0]=t.getUTCMonth(),A[e+20>>2>>>0]=t.getUTCFullYear()-1900,A[e+24>>2>>>0]=t.getUTCDay(),A[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(E[t>>>2]+4294967296*A[t+4>>>2])),A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getFullYear()-1900,A[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);A[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,A[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),A[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(A[t+20>>2>>>0]+1900,A[t+16>>2>>>0],A[t+12>>2>>>0],A[t+8>>2>>>0],A[t+4>>2>>>0],A[t>>2>>>0],0),n=A[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),a=i.getTimezoneOffset(),s=Math.min(a,o);return 0>n?A[t+32>>2>>>0]=Number(o!=a&&s==r):0<n!=(s==r)&&(o=Math.max(a,o),e.setTime(e.getTime()+6e4*((0<n?s:o)-r))),A[t+24>>2>>>0]=e.getDay(),A[t+28>>2>>>0]=(e.getTime()-i.getTime())/864e5|0,A[t>>2>>>0]=e.getSeconds(),A[t+4>>2>>>0]=e.getMinutes(),A[t+8>>2>>>0]=e.getHours(),A[t+12>>2>>>0]=e.getDate(),A[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\(([A-Za-z ]+)\)$/))?t[1]:"GMT"}var i=(new Date).getFullYear(),o=new Date(i,0,1),a=new Date(i,6,1);i=o.getTimezoneOffset();var s=a.getTimezoneOffset();A[t>>2>>>0]=60*Math.max(i,s),A[e>>2>>>0]=Number(i!=s),t=r(o),e=r(a),t=ot(t),e=ot(e),s<i?(E[n>>2>>>0]=t,E[n+4>>2>>>0]=e):(E[n>>2>>>0]=e,E[n+4>>2>>>0]=t)}(e,n,r))},B:function(){W("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){O.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=O.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var i=Math;r=Math.max(t,r),i=i.min.call(i,4294901760,r+(65536-r%65536)%65536);t:{try{x.grow(i-T.byteLength+65535>>>16),F();var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},va:function(t,e){var n=0;return st().forEach((function(r,i){var o=e+n;for(i=E[t+4*i>>2>>>0]=o,o=0;o<r.length;++o)S[i++>>0>>>0]=r.charCodeAt(o);S[i>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=st();E[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),E[e>>2>>>0]=r,0},ba:function(t){w||0<U||(wt(),Z(j),vt(0),ct[1].length&&lt(1,10),ct[2].length&&lt(2,10)),w||0<U||(e.onExit&&e.onExit(t),I=!0),d(t,new K(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var i=0,o=0;o<n;o++){var a=E[e>>2>>>0],s=E[e+4>>2>>>0];e+=8;for(var u=0;u<s;u++)lt(t,O[a+u>>>0]);i+=s}return E[r>>2>>>0]=i,0},c:function(){return pt},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module 'crypto'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>W("randomDevice")}());for(var i=0;i<r;i++)S[e+i>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},fa:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},J:function(t){var e=Tt();try{return it(t)()}catch(t){if(St(e),t!==t+0)throw t;xt(1,0)}},e:function(t,e){var n=Tt();try{return it(t)(e)}catch(t){if(St(n),t!==t+0)throw t;xt(1,0)}},N:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},O:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},j:function(t,e,n){var r=Tt();try{return it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},o:function(t,e,n,r){var i=Tt();try{return it(t)(e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},p:function(t,e,n,r,i){var o=Tt();try{return it(t)(e,n,r,i)}catch(t){if(St(o),t!==t+0)throw t;xt(1,0)}},M:function(t,e,n,r,i,o){var a=Tt();try{return it(t)(e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},r:function(t,e,n,r,i,o){var a=Tt();try{return it(t)(e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},v:function(t,e,n,r,i,o,a){var s=Tt();try{return it(t)(e,n,r,i,o,a)}catch(t){if(St(s),t!==t+0)throw t;xt(1,0)}},K:function(t,e,n,r,i,o,a,s){var u=Tt();try{return it(t)(e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},D:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Tt();try{return it(t)(e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(St(f),t!==t+0)throw t;xt(1,0)}},X:function(t,e,n,r,i,o,a,s){var u=Tt();try{return Lt(t,e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},V:function(t,e,n,r,i,o,a){var s=Tt();try{return Pt(t,e,n,r,i,o,a)}catch(t){if(St(s),t!==t+0)throw t;xt(1,0)}},U:function(t,e,n,r,i){var o=Tt();try{return Rt(t,e,n,r,i)}catch(t){if(St(o),t!==t+0)throw t;xt(1,0)}},Z:function(t,e,n,r){var i=Tt();try{return Ft(t,e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},W:function(t){var e=Tt();try{return It(t)}catch(t){if(St(e),t!==t+0)throw t;xt(1,0)}},Y:function(t,e){var n=Tt();try{return Nt(t,e)}catch(t){if(St(n),t!==t+0)throw t;xt(1,0)}},T:function(t,e,n){var r=Tt();try{return Dt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},f:function(t){var e=Tt();try{it(t)()}catch(t){if(St(e),t!==t+0)throw t;xt(1,0)}},q:function(t,e){var n=Tt();try{it(t)(e)}catch(t){if(St(n),t!==t+0)throw t;xt(1,0)}},h:function(t,e,n){var r=Tt();try{it(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;xt(1,0)}},da:function(t,e,n,r){var i=Tt();try{it(t)(e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},l:function(t,e,n,r){var i=Tt();try{it(t)(e,n,r)}catch(t){if(St(i),t!==t+0)throw t;xt(1,0)}},t:function(t,e,n,r,i){var o=Tt();try{it(t)(e,n,r,i)}catch(t){if(St(o),t!==t+0)throw t;xt(1,0)}},u:function(t,e,n,r,i,o){var a=Tt();try{it(t)(e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},x:function(t,e,n,r,i,o,a){var s=Tt();try{it(t)(e,n,r,i,o,a)}catch(t){if(St(s),t!==t+0)throw t;xt(1,0)}},z:function(t,e,n,r,i,o,a,s){var u=Tt();try{it(t)(e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},ga:function(t,e,n,r,i,o,a,s,u){var c=Tt();try{it(t)(e,n,r,i,o,a,s,u)}catch(t){if(St(c),t!==t+0)throw t;xt(1,0)}},A:function(t,e,n,r,i,o,a,s,u,c,l){var p=Tt();try{it(t)(e,n,r,i,o,a,s,u,c,l)}catch(t){if(St(p),t!==t+0)throw t;xt(1,0)}},C:function(t,e,n,r,i,o,a,s,u,c,l,p,f,d,h,g){var b=Tt();try{it(t)(e,n,r,i,o,a,s,u,c,l,p,f,d,h,g)}catch(t){if(St(b),t!==t+0)throw t;xt(1,0)}},aa:function(t,e,n,r,i,o,a,s){var u=Tt();try{$t(t,e,n,r,i,o,a,s)}catch(t){if(St(u),t!==t+0)throw t;xt(1,0)}},_:function(t,e,n,r,i,o,a,s,u,c,l,p){var f=Tt();try{Ct(t,e,n,r,i,o,a,s,u,c,l,p)}catch(t){if(St(f),t!==t+0)throw t;xt(1,0)}},$:function(t,e,n,r,i,o){var a=Tt();try{kt(t,e,n,r,i,o)}catch(t){if(St(a),t!==t+0)throw t;xt(1,0)}},n:function(t){return t},F:function(t){pt=t},ha:gt,y:function(t,e,n,r){return gt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,x=e.asm.Ka,F(),N=e.asm.ib,R.unshift(e.asm.La),z--,e.monitorRunDependencies&&e.monitorRunDependencies(z),0==z&&(null!==G&&(clearInterval(G),G=null),H&&(t=H,H=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!y&&(h||g)){if("function"==typeof fetch&&!B.startsWith("file://"))return fetch(B,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at '"+B+"'";return t.arrayBuffer()})).catch((function(){return Y()}));if(a)return new Promise((function(t,e){a(B,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return Y()}))}().then((function(t){return WebAssembly.instantiate(t,o)})).then((function(t){return t})).then(t,(function(t){v("failed to asynchronously prepare wasm: "+t),W(t)}))}var o={a:bt};if(z++,e.monitorRunDependencies&&e.monitorRunDependencies(z),e.instantiateWasm)try{return e.instantiateWasm(o,t)}catch(t){return v("Module.instantiateWasm callback failed with error: "+t),!1}(y||"function"!=typeof WebAssembly.instantiateStreaming||q()||B.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(B,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,o).then(n,(function(t){return v("wasm streaming compile failed: "+t),v("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(i)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,yt=e._malloc=function(){return(yt=e._malloc=e.asm.eb).apply(null,arguments)},_t=e._free=function(){return(_t=e._free=e.asm.fb).apply(null,arguments)},vt=e._fflush=function(){return(vt=e._fflush=e.asm.gb).apply(null,arguments)},wt=e.___funcs_on_exit=function(){return(wt=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},xt=e._setThrew=function(){return(xt=e._setThrew=e.asm.jb).apply(null,arguments)},Tt=e.stackSave=function(){return(Tt=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Ot=e.stackAlloc=function(){return(Ot=e.stackAlloc=e.asm.mb).apply(null,arguments)},At=e.___cxa_can_catch=function(){return(At=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Et=e.___cxa_is_pointer_type=function(){return(Et=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},It=e.dynCall_j=function(){return(It=e.dynCall_j=e.asm.pb).apply(null,arguments)},Pt=e.dynCall_iiiiij=function(){return(Pt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Dt=e.dynCall_jii=function(){return(Dt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},$t=e.dynCall_viiiiij=function(){return($t=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Ct=e.dynCall_viiijjjii=function(){return(Ct=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Ft=e.dynCall_iij=function(){return(Ft=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Nt=e.dynCall_ji=function(){return(Nt=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Lt=e.dynCall_iiiiiij=function(){return(Lt=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},Rt=e.dynCall_iiij=function(){return(Rt=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function jt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!I)){if(Z(R),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();M.unshift(t)}Z(M)}}if(!(0<z)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)V();Z(L),0<z||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=$,e.stringToUTF8=function(t,e,n){return k(t,O,e,n)},e.lengthBytesUTF8=C,e.stackSave=Tt,e.stackRestore=St,e.stackAlloc=Ot,H=function t(){mt||jt(),mt||(H=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return jt(),t.ready});t.exports=r},4537:t=>{"use strict";t.exports=function(t,e){for(var n=new Array(arguments.length-1),r=0,i=2,o=!0;i<arguments.length;)n[r++]=arguments[i++];return new Promise((function(i,a){n[r]=function(t){if(o)if(o=!1,t)a(t);else{for(var e=new Array(arguments.length-1),n=0;n<e.length;)e[n++]=arguments[n];i.apply(null,e)}};try{t.apply(e||null,n)}catch(t){o&&(o=!1,a(t))}}))}},7419:(t,e)=>{"use strict";var n=e;n.length=function(t){var e=t.length;if(!e)return 0;for(var n=0;--e%4>1&&"="===t.charAt(e);)++n;return Math.ceil(3*t.length)/4-n};for(var r=new Array(64),i=new Array(123),o=0;o<64;)i[r[o]=o<26?o+65:o<52?o+71:o<62?o-4:o-59|43]=o++;n.encode=function(t,e,n){for(var i,o=null,a=[],s=0,u=0;e<n;){var c=t[e++];switch(u){case 0:a[s++]=r[c>>2],i=(3&c)<<4,u=1;break;case 1:a[s++]=r[i|c>>4],i=(15&c)<<2,u=2;break;case 2:a[s++]=r[i|c>>6],a[s++]=r[63&c],u=0}s>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,a)),s=0)}return u&&(a[s++]=r[i],a[s++]=61,1===u&&(a[s++]=61)),o?(s&&o.push(String.fromCharCode.apply(String,a.slice(0,s))),o.join("")):String.fromCharCode.apply(String,a.slice(0,s))};var a="invalid encoding";n.decode=function(t,e,n){for(var r,o=n,s=0,u=0;u<t.length;){var c=t.charCodeAt(u++);if(61===c&&s>1)break;if(void 0===(c=i[c]))throw Error(a);switch(s){case 0:r=c,s=1;break;case 1:e[n++]=r<<2|(48&c)>>4,r=c,s=2;break;case 2:e[n++]=(15&r)<<4|(60&c)>>2,r=c,s=3;break;case 3:e[n++]=(3&r)<<6|c,s=0}}if(1===s)throw Error(a);return n-o},n.test=function(t){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}},9211:t=>{"use strict";function e(){this._listeners={}}t.exports=e,e.prototype.on=function(t,e,n){return(this._listeners[t]||(this._listeners[t]=[])).push({fn:e,ctx:n||this}),this},e.prototype.off=function(t,e){if(void 0===t)this._listeners={};else if(void 0===e)this._listeners[t]=[];else for(var n=this._listeners[t],r=0;r<n.length;)n[r].fn===e?n.splice(r,1):++r;return this},e.prototype.emit=function(t){var e=this._listeners[t];if(e){for(var n=[],r=1;r<arguments.length;)n.push(arguments[r++]);for(r=0;r<e.length;)e[r].fn.apply(e[r++].ctx,n)}return this}},945:t=>{"use strict";function e(t){return"undefined"!=typeof Float32Array?function(){var e=new Float32Array([-0]),n=new Uint8Array(e.buffer),r=128===n[3];function i(t,r,i){e[0]=t,r[i]=n[0],r[i+1]=n[1],r[i+2]=n[2],r[i+3]=n[3]}function o(t,r,i){e[0]=t,r[i]=n[3],r[i+1]=n[2],r[i+2]=n[1],r[i+3]=n[0]}function a(t,r){return n[0]=t[r],n[1]=t[r+1],n[2]=t[r+2],n[3]=t[r+3],e[0]}function s(t,r){return n[3]=t[r],n[2]=t[r+1],n[1]=t[r+2],n[0]=t[r+3],e[0]}t.writeFloatLE=r?i:o,t.writeFloatBE=r?o:i,t.readFloatLE=r?a:s,t.readFloatBE=r?s:a}():function(){function e(t,e,n,r){var i=e<0?1:0;if(i&&(e=-e),0===e)t(1/e>0?0:2147483648,n,r);else if(isNaN(e))t(2143289344,n,r);else if(e>34028234663852886e22)t((i<<31|2139095040)>>>0,n,r);else if(e<11754943508222875e-54)t((i<<31|Math.round(e/1401298464324817e-60))>>>0,n,r);else{var o=Math.floor(Math.log(e)/Math.LN2);t((i<<31|o+127<<23|8388607&Math.round(e*Math.pow(2,-o)*8388608))>>>0,n,r)}}function a(t,e,n){var r=t(e,n),i=2*(r>>31)+1,o=r>>>23&255,a=8388607&r;return 255===o?a?NaN:i*(1/0):0===o?1401298464324817e-60*i*a:i*Math.pow(2,o-150)*(a+8388608)}t.writeFloatLE=e.bind(null,n),t.writeFloatBE=e.bind(null,r),t.readFloatLE=a.bind(null,i),t.readFloatBE=a.bind(null,o)}(),"undefined"!=typeof Float64Array?function(){var e=new Float64Array([-0]),n=new Uint8Array(e.buffer),r=128===n[7];function i(t,r,i){e[0]=t,r[i]=n[0],r[i+1]=n[1],r[i+2]=n[2],r[i+3]=n[3],r[i+4]=n[4],r[i+5]=n[5],r[i+6]=n[6],r[i+7]=n[7]}function o(t,r,i){e[0]=t,r[i]=n[7],r[i+1]=n[6],r[i+2]=n[5],r[i+3]=n[4],r[i+4]=n[3],r[i+5]=n[2],r[i+6]=n[1],r[i+7]=n[0]}function a(t,r){return n[0]=t[r],n[1]=t[r+1],n[2]=t[r+2],n[3]=t[r+3],n[4]=t[r+4],n[5]=t[r+5],n[6]=t[r+6],n[7]=t[r+7],e[0]}function s(t,r){return n[7]=t[r],n[6]=t[r+1],n[5]=t[r+2],n[4]=t[r+3],n[3]=t[r+4],n[2]=t[r+5],n[1]=t[r+6],n[0]=t[r+7],e[0]}t.writeDoubleLE=r?i:o,t.writeDoubleBE=r?o:i,t.readDoubleLE=r?a:s,t.readDoubleBE=r?s:a}():function(){function e(t,e,n,r,i,o){var a=r<0?1:0;if(a&&(r=-r),0===r)t(0,i,o+e),t(1/r>0?0:2147483648,i,o+n);else if(isNaN(r))t(0,i,o+e),t(2146959360,i,o+n);else if(r>17976931348623157e292)t(0,i,o+e),t((a<<31|2146435072)>>>0,i,o+n);else{var s;if(r<22250738585072014e-324)t((s=r/5e-324)>>>0,i,o+e),t((a<<31|s/4294967296)>>>0,i,o+n);else{var u=Math.floor(Math.log(r)/Math.LN2);1024===u&&(u=1023),t(4503599627370496*(s=r*Math.pow(2,-u))>>>0,i,o+e),t((a<<31|u+1023<<20|1048576*s&1048575)>>>0,i,o+n)}}}function a(t,e,n,r,i){var o=t(r,i+e),a=t(r,i+n),s=2*(a>>31)+1,u=a>>>20&2047,c=4294967296*(1048575&a)+o;return 2047===u?c?NaN:s*(1/0):0===u?5e-324*s*c:s*Math.pow(2,u-1075)*(c+4503599627370496)}t.writeDoubleLE=e.bind(null,n,0,4),t.writeDoubleBE=e.bind(null,r,4,0),t.readDoubleLE=a.bind(null,i,0,4),t.readDoubleBE=a.bind(null,o,4,0)}(),t}function n(t,e,n){e[n]=255&t,e[n+1]=t>>>8&255,e[n+2]=t>>>16&255,e[n+3]=t>>>24}function r(t,e,n){e[n]=t>>>24,e[n+1]=t>>>16&255,e[n+2]=t>>>8&255,e[n+3]=255&t}function i(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0}function o(t,e){return(t[e]<<24|t[e+1]<<16|t[e+2]<<8|t[e+3])>>>0}t.exports=e(e)},7199:module=>{"use strict";function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(t){}return null}module.exports=inquire},6662:t=>{"use strict";t.exports=function(t,e,n){var r=n||8192,i=r>>>1,o=null,a=r;return function(n){if(n<1||n>i)return t(n);a+n>r&&(o=t(r),a=0);var s=e.call(o,a,a+=n);return 7&a&&(a=1+(7|a)),s}}},4997:(t,e)=>{"use strict";var n=e;n.length=function(t){for(var e=0,n=0,r=0;r<t.length;++r)(n=t.charCodeAt(r))<128?e+=1:n<2048?e+=2:55296==(64512&n)&&56320==(64512&t.charCodeAt(r+1))?(++r,e+=4):e+=3;return e},n.read=function(t,e,n){if(n-e<1)return"";for(var r,i=null,o=[],a=0;e<n;)(r=t[e++])<128?o[a++]=r:r>191&&r<224?o[a++]=(31&r)<<6|63&t[e++]:r>239&&r<365?(r=((7&r)<<18|(63&t[e++])<<12|(63&t[e++])<<6|63&t[e++])-65536,o[a++]=55296+(r>>10),o[a++]=56320+(1023&r)):o[a++]=(15&r)<<12|(63&t[e++])<<6|63&t[e++],a>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,o)),a=0);return i?(a&&i.push(String.fromCharCode.apply(String,o.slice(0,a))),i.join("")):String.fromCharCode.apply(String,o.slice(0,a))},n.write=function(t,e,n){for(var r,i,o=n,a=0;a<t.length;++a)(r=t.charCodeAt(a))<128?e[n++]=r:r<2048?(e[n++]=r>>6|192,e[n++]=63&r|128):55296==(64512&r)&&56320==(64512&(i=t.charCodeAt(a+1)))?(r=65536+((1023&r)<<10)+(1023&i),++a,e[n++]=r>>18|240,e[n++]=r>>12&63|128,e[n++]=r>>6&63|128,e[n++]=63&r|128):(e[n++]=r>>12|224,e[n++]=r>>6&63|128,e[n++]=63&r|128);return n-o}},3442:(t,e)=>{"use strict";e.__esModule=!0;var n=function(){function t(e){if(!e)throw new TypeError("Invalid argument; `value` has no value.");this.value=t.EMPTY,e&&t.isGuid(e)&&(this.value=e)}return t.isGuid=function(e){var n=e.toString();return e&&(e instanceof t||t.validator.test(n))},t.create=function(){return new t([t.gen(2),t.gen(1),t.gen(1),t.gen(1),t.gen(3)].join("-"))},t.createEmpty=function(){return new t("emptyguid")},t.parse=function(e){return new t(e)},t.raw=function(){return[t.gen(2),t.gen(1),t.gen(1),t.gen(1),t.gen(3)].join("-")},t.gen=function(t){for(var e="",n=0;n<t;n++)e+=(65536*(1+Math.random())|0).toString(16).substring(1);return e},t.prototype.equals=function(e){return t.isGuid(e)&&this.value===e.toString()},t.prototype.isEmpty=function(){return this.value===t.EMPTY},t.prototype.toString=function(){return this.value},t.prototype.toJSON=function(){return{value:this.value}},t.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),t.EMPTY="00000000-0000-0000-0000-000000000000",t}();e.Guid=n},3720:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function r(t){return!0===(t&&t.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var i={},o={};function a(t,e){var n,r,a;return e?(a=0<=(t>>>=0)&&t<256)&&(r=o[t])?r:(n=u(t,(0|t)<0?-1:0,!0),a&&(o[t]=n),n):(a=-128<=(t|=0)&&t<128)&&(r=i[t])?r:(n=u(t,t<0?-1:0,!1),a&&(i[t]=n),n)}function s(t,e){if(isNaN(t))return e?m:b;if(e){if(t<0)return m;if(t>=d)return x}else{if(t<=-h)return T;if(t+1>=h)return w}return t<0?s(-t,e).neg():u(t%f|0,t/f|0,e)}function u(t,e,r){return new n(t,e,r)}n.fromInt=a,n.fromNumber=s,n.fromBits=u;var c=Math.pow;function l(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return b;if("number"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return l(t.substring(1),e,n).neg();for(var i=s(c(n,8)),o=b,a=0;a<t.length;a+=8){var u=Math.min(8,t.length-a),p=parseInt(t.substring(a,a+u),n);if(u<8){var f=s(c(n,u));o=o.mul(f).add(s(p))}else o=(o=o.mul(i)).add(s(p))}return o.unsigned=e,o}function p(t,e){return"number"==typeof t?s(t,e):"string"==typeof t?l(t,e):u(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}n.fromString=l,n.fromValue=p;var f=4294967296,d=f*f,h=d/2,g=a(1<<24),b=a(0);n.ZERO=b;var m=a(0,!0);n.UZERO=m;var y=a(1);n.ONE=y;var _=a(1,!0);n.UONE=_;var v=a(-1);n.NEG_ONE=v;var w=u(-1,2147483647,!1);n.MAX_VALUE=w;var x=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=x;var T=u(0,-2147483648,!1);n.MIN_VALUE=T;var S=n.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},S.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(T)){var e=s(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var i=s(c(t,6),this.unsigned),o=this,a="";;){var u=o.div(i),l=(o.sub(u.mul(i)).toInt()>>>0).toString(t);if((o=u).isZero())return l+a;for(;l.length<6;)l="0"+l;a=""+l+a}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},S.isZero=function(){return 0===this.high&&0===this.low},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return 1==(1&this.low)},S.isEven=function(){return 0==(1&this.low)},S.equals=function(t){return r(t)||(t=p(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low},S.eq=S.equals,S.notEquals=function(t){return!this.eq(t)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(t){return this.comp(t)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(t){return this.comp(t)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(t){return this.comp(t)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(t){return this.comp(t)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(t){if(r(t)||(t=p(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(y)},S.neg=S.negate,S.add=function(t){r(t)||(t=p(t));var e=this.high>>>16,n=65535&this.high,i=this.low>>>16,o=65535&this.low,a=t.high>>>16,s=65535&t.high,c=t.low>>>16,l=0,f=0,d=0,h=0;return d+=(h+=o+(65535&t.low))>>>16,f+=(d+=i+c)>>>16,l+=(f+=n+s)>>>16,l+=e+a,u((d&=65535)<<16|(h&=65535),(l&=65535)<<16|(f&=65535),this.unsigned)},S.subtract=function(t){return r(t)||(t=p(t)),this.add(t.neg())},S.sub=S.subtract,S.multiply=function(t){if(this.isZero())return b;if(r(t)||(t=p(t)),e)return u(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return b;if(this.eq(T))return t.isOdd()?T:b;if(t.eq(T))return this.isOdd()?T:b;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(g)&&t.lt(g))return s(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,i=65535&this.high,o=this.low>>>16,a=65535&this.low,c=t.high>>>16,l=65535&t.high,f=t.low>>>16,d=65535&t.low,h=0,m=0,y=0,_=0;return y+=(_+=a*d)>>>16,m+=(y+=o*d)>>>16,y&=65535,m+=(y+=a*f)>>>16,h+=(m+=i*d)>>>16,m&=65535,h+=(m+=o*f)>>>16,m&=65535,h+=(m+=a*l)>>>16,h+=n*d+i*f+o*l+a*c,u((y&=65535)<<16|(_&=65535),(h&=65535)<<16|(m&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(t){if(r(t)||(t=p(t)),t.isZero())throw Error("division by zero");var n,i,o;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?u((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?m:b;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return m;if(t.gt(this.shru(1)))return _;o=m}else{if(this.eq(T))return t.eq(y)||t.eq(v)?T:t.eq(T)?y:(n=this.shr(1).div(t).shl(1)).eq(b)?t.isNegative()?y:v:(i=this.sub(t.mul(n)),o=n.add(i.div(t)));if(t.eq(T))return this.unsigned?m:b;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();o=b}for(i=this;i.gte(t);){n=Math.max(1,Math.floor(i.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),l=a<=48?1:c(2,a-48),f=s(n),d=f.mul(t);d.isNegative()||d.gt(i);)d=(f=s(n-=l,this.unsigned)).mul(t);f.isZero()&&(f=y),o=o.add(f),i=i.sub(d)}return o},S.div=S.divide,S.modulo=function(t){return r(t)||(t=p(t)),e?u((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return u(~this.low,~this.high,this.unsigned)},S.and=function(t){return r(t)||(t=p(t)),u(this.low&t.low,this.high&t.high,this.unsigned)},S.or=function(t){return r(t)||(t=p(t)),u(this.low|t.low,this.high|t.high,this.unsigned)},S.xor=function(t){return r(t)||(t=p(t)),u(this.low^t.low,this.high^t.high,this.unsigned)},S.shiftLeft=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?u(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):u(0,this.low<<t-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?u(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):u(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(t){if(r(t)&&(t=t.toInt()),0==(t&=63))return this;var e=this.high;return t<32?u(this.low>>>t|e<<32-t,e>>>t,this.unsigned):u(32===t?e:e>>>t-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},S.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},S.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,r){return r?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},1446:(t,e,n)=>{"use strict";var r,i,o,a=n(2100),s=a.Reader,u=a.Writer,c=a.util,l=a.roots.default||(a.roots.default={});l.onnx=((o={}).Version=(r={},(i=Object.create(r))[r[0]="_START_VERSION"]=0,i[r[1]="IR_VERSION_2017_10_10"]=1,i[r[2]="IR_VERSION_2017_10_30"]=2,i[r[3]="IR_VERSION_2017_11_3"]=3,i[r[4]="IR_VERSION_2019_1_22"]=4,i[r[5]="IR_VERSION"]=5,i),o.AttributeProto=function(){function t(t){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.name="",t.prototype.refAttrName="",t.prototype.docString="",t.prototype.type=0,t.prototype.f=0,t.prototype.i=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.s=c.newBuffer([]),t.prototype.t=null,t.prototype.g=null,t.prototype.floats=c.emptyArray,t.prototype.ints=c.emptyArray,t.prototype.strings=c.emptyArray,t.prototype.tensors=c.emptyArray,t.prototype.graphs=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.name&&t.hasOwnProperty("name")&&e.uint32(10).string(t.name),null!=t.f&&t.hasOwnProperty("f")&&e.uint32(21).float(t.f),null!=t.i&&t.hasOwnProperty("i")&&e.uint32(24).int64(t.i),null!=t.s&&t.hasOwnProperty("s")&&e.uint32(34).bytes(t.s),null!=t.t&&t.hasOwnProperty("t")&&l.onnx.TensorProto.encode(t.t,e.uint32(42).fork()).ldelim(),null!=t.g&&t.hasOwnProperty("g")&&l.onnx.GraphProto.encode(t.g,e.uint32(50).fork()).ldelim(),null!=t.floats&&t.floats.length){e.uint32(58).fork();for(var n=0;n<t.floats.length;++n)e.float(t.floats[n]);e.ldelim()}if(null!=t.ints&&t.ints.length){for(e.uint32(66).fork(),n=0;n<t.ints.length;++n)e.int64(t.ints[n]);e.ldelim()}if(null!=t.strings&&t.strings.length)for(n=0;n<t.strings.length;++n)e.uint32(74).bytes(t.strings[n]);if(null!=t.tensors&&t.tensors.length)for(n=0;n<t.tensors.length;++n)l.onnx.TensorProto.encode(t.tensors[n],e.uint32(82).fork()).ldelim();if(null!=t.graphs&&t.graphs.length)for(n=0;n<t.graphs.length;++n)l.onnx.GraphProto.encode(t.graphs[n],e.uint32(90).fork()).ldelim();return null!=t.docString&&t.hasOwnProperty("docString")&&e.uint32(106).string(t.docString),null!=t.type&&t.hasOwnProperty("type")&&e.uint32(160).int32(t.type),null!=t.refAttrName&&t.hasOwnProperty("refAttrName")&&e.uint32(170).string(t.refAttrName),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.AttributeProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.name=t.string();break;case 21:r.refAttrName=t.string();break;case 13:r.docString=t.string();break;case 20:r.type=t.int32();break;case 2:r.f=t.float();break;case 3:r.i=t.int64();break;case 4:r.s=t.bytes();break;case 5:r.t=l.onnx.TensorProto.decode(t,t.uint32());break;case 6:r.g=l.onnx.GraphProto.decode(t,t.uint32());break;case 7:if(r.floats&&r.floats.length||(r.floats=[]),2==(7&i))for(var o=t.uint32()+t.pos;t.pos<o;)r.floats.push(t.float());else r.floats.push(t.float());break;case 8:if(r.ints&&r.ints.length||(r.ints=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.ints.push(t.int64());else r.ints.push(t.int64());break;case 9:r.strings&&r.strings.length||(r.strings=[]),r.strings.push(t.bytes());break;case 10:r.tensors&&r.tensors.length||(r.tensors=[]),r.tensors.push(l.onnx.TensorProto.decode(t,t.uint32()));break;case 11:r.graphs&&r.graphs.length||(r.graphs=[]),r.graphs.push(l.onnx.GraphProto.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.name&&t.hasOwnProperty("name")&&!c.isString(t.name))return"name: string expected";if(null!=t.refAttrName&&t.hasOwnProperty("refAttrName")&&!c.isString(t.refAttrName))return"refAttrName: string expected";if(null!=t.docString&&t.hasOwnProperty("docString")&&!c.isString(t.docString))return"docString: string expected";if(null!=t.type&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(null!=t.f&&t.hasOwnProperty("f")&&"number"!=typeof t.f)return"f: number expected";if(null!=t.i&&t.hasOwnProperty("i")&&!(c.isInteger(t.i)||t.i&&c.isInteger(t.i.low)&&c.isInteger(t.i.high)))return"i: integer|Long expected";if(null!=t.s&&t.hasOwnProperty("s")&&!(t.s&&"number"==typeof t.s.length||c.isString(t.s)))return"s: buffer expected";if(null!=t.t&&t.hasOwnProperty("t")&&(n=l.onnx.TensorProto.verify(t.t)))return"t."+n;if(null!=t.g&&t.hasOwnProperty("g")&&(n=l.onnx.GraphProto.verify(t.g)))return"g."+n;if(null!=t.floats&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var e=0;e<t.floats.length;++e)if("number"!=typeof t.floats[e])return"floats: number[] expected"}if(null!=t.ints&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(e=0;e<t.ints.length;++e)if(!(c.isInteger(t.ints[e])||t.ints[e]&&c.isInteger(t.ints[e].low)&&c.isInteger(t.ints[e].high)))return"ints: integer|Long[] expected"}if(null!=t.strings&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(e=0;e<t.strings.length;++e)if(!(t.strings[e]&&"number"==typeof t.strings[e].length||c.isString(t.strings[e])))return"strings: buffer[] expected"}if(null!=t.tensors&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(e=0;e<t.tensors.length;++e)if(n=l.onnx.TensorProto.verify(t.tensors[e]))return"tensors."+n}if(null!=t.graphs&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(e=0;e<t.graphs.length;++e){var n;if(n=l.onnx.GraphProto.verify(t.graphs[e]))return"graphs."+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.AttributeProto)return t;var e=new l.onnx.AttributeProto;switch(null!=t.name&&(e.name=String(t.name)),null!=t.refAttrName&&(e.refAttrName=String(t.refAttrName)),null!=t.docString&&(e.docString=String(t.docString)),t.type){case"UNDEFINED":case 0:e.type=0;break;case"FLOAT":case 1:e.type=1;break;case"INT":case 2:e.type=2;break;case"STRING":case 3:e.type=3;break;case"TENSOR":case 4:e.type=4;break;case"GRAPH":case 5:e.type=5;break;case"FLOATS":case 6:e.type=6;break;case"INTS":case 7:e.type=7;break;case"STRINGS":case 8:e.type=8;break;case"TENSORS":case 9:e.type=9;break;case"GRAPHS":case 10:e.type=10}if(null!=t.f&&(e.f=Number(t.f)),null!=t.i&&(c.Long?(e.i=c.Long.fromValue(t.i)).unsigned=!1:"string"==typeof t.i?e.i=parseInt(t.i,10):"number"==typeof t.i?e.i=t.i:"object"==typeof t.i&&(e.i=new c.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),null!=t.s&&("string"==typeof t.s?c.base64.decode(t.s,e.s=c.newBuffer(c.base64.length(t.s)),0):t.s.length&&(e.s=t.s)),null!=t.t){if("object"!=typeof t.t)throw TypeError(".onnx.AttributeProto.t: object expected");e.t=l.onnx.TensorProto.fromObject(t.t)}if(null!=t.g){if("object"!=typeof t.g)throw TypeError(".onnx.AttributeProto.g: object expected");e.g=l.onnx.GraphProto.fromObject(t.g)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");e.floats=[];for(var n=0;n<t.floats.length;++n)e.floats[n]=Number(t.floats[n])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(e.ints=[],n=0;n<t.ints.length;++n)c.Long?(e.ints[n]=c.Long.fromValue(t.ints[n])).unsigned=!1:"string"==typeof t.ints[n]?e.ints[n]=parseInt(t.ints[n],10):"number"==typeof t.ints[n]?e.ints[n]=t.ints[n]:"object"==typeof t.ints[n]&&(e.ints[n]=new c.LongBits(t.ints[n].low>>>0,t.ints[n].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(e.strings=[],n=0;n<t.strings.length;++n)"string"==typeof t.strings[n]?c.base64.decode(t.strings[n],e.strings[n]=c.newBuffer(c.base64.length(t.strings[n])),0):t.strings[n].length&&(e.strings[n]=t.strings[n])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(e.tensors=[],n=0;n<t.tensors.length;++n){if("object"!=typeof t.tensors[n])throw TypeError(".onnx.AttributeProto.tensors: object expected");e.tensors[n]=l.onnx.TensorProto.fromObject(t.tensors[n])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(e.graphs=[],n=0;n<t.graphs.length;++n){if("object"!=typeof t.graphs[n])throw TypeError(".onnx.AttributeProto.graphs: object expected");e.graphs[n]=l.onnx.GraphProto.fromObject(t.graphs[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.floats=[],n.ints=[],n.strings=[],n.tensors=[],n.graphs=[]),e.defaults){if(n.name="",n.f=0,c.Long){var r=new c.Long(0,0,!1);n.i=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.i=e.longs===String?"0":0;e.bytes===String?n.s="":(n.s=[],e.bytes!==Array&&(n.s=c.newBuffer(n.s))),n.t=null,n.g=null,n.docString="",n.type=e.enums===String?"UNDEFINED":0,n.refAttrName=""}if(null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),null!=t.f&&t.hasOwnProperty("f")&&(n.f=e.json&&!isFinite(t.f)?String(t.f):t.f),null!=t.i&&t.hasOwnProperty("i")&&("number"==typeof t.i?n.i=e.longs===String?String(t.i):t.i:n.i=e.longs===String?c.Long.prototype.toString.call(t.i):e.longs===Number?new c.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),null!=t.s&&t.hasOwnProperty("s")&&(n.s=e.bytes===String?c.base64.encode(t.s,0,t.s.length):e.bytes===Array?Array.prototype.slice.call(t.s):t.s),null!=t.t&&t.hasOwnProperty("t")&&(n.t=l.onnx.TensorProto.toObject(t.t,e)),null!=t.g&&t.hasOwnProperty("g")&&(n.g=l.onnx.GraphProto.toObject(t.g,e)),t.floats&&t.floats.length){n.floats=[];for(var i=0;i<t.floats.length;++i)n.floats[i]=e.json&&!isFinite(t.floats[i])?String(t.floats[i]):t.floats[i]}if(t.ints&&t.ints.length)for(n.ints=[],i=0;i<t.ints.length;++i)"number"==typeof t.ints[i]?n.ints[i]=e.longs===String?String(t.ints[i]):t.ints[i]:n.ints[i]=e.longs===String?c.Long.prototype.toString.call(t.ints[i]):e.longs===Number?new c.LongBits(t.ints[i].low>>>0,t.ints[i].high>>>0).toNumber():t.ints[i];if(t.strings&&t.strings.length)for(n.strings=[],i=0;i<t.strings.length;++i)n.strings[i]=e.bytes===String?c.base64.encode(t.strings[i],0,t.strings[i].length):e.bytes===Array?Array.prototype.slice.call(t.strings[i]):t.strings[i];if(t.tensors&&t.tensors.length)for(n.tensors=[],i=0;i<t.tensors.length;++i)n.tensors[i]=l.onnx.TensorProto.toObject(t.tensors[i],e);if(t.graphs&&t.graphs.length)for(n.graphs=[],i=0;i<t.graphs.length;++i)n.graphs[i]=l.onnx.GraphProto.toObject(t.graphs[i],e);return null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),null!=t.type&&t.hasOwnProperty("type")&&(n.type=e.enums===String?l.onnx.AttributeProto.AttributeType[t.type]:t.type),null!=t.refAttrName&&t.hasOwnProperty("refAttrName")&&(n.refAttrName=t.refAttrName),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.AttributeType=function(){var t={},e=Object.create(t);return e[t[0]="UNDEFINED"]=0,e[t[1]="FLOAT"]=1,e[t[2]="INT"]=2,e[t[3]="STRING"]=3,e[t[4]="TENSOR"]=4,e[t[5]="GRAPH"]=5,e[t[6]="FLOATS"]=6,e[t[7]="INTS"]=7,e[t[8]="STRINGS"]=8,e[t[9]="TENSORS"]=9,e[t[10]="GRAPHS"]=10,e}(),t}(),o.ValueInfoProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.name="",t.prototype.type=null,t.prototype.docString="",t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.name&&t.hasOwnProperty("name")&&e.uint32(10).string(t.name),null!=t.type&&t.hasOwnProperty("type")&&l.onnx.TypeProto.encode(t.type,e.uint32(18).fork()).ldelim(),null!=t.docString&&t.hasOwnProperty("docString")&&e.uint32(26).string(t.docString),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.ValueInfoProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.name=t.string();break;case 2:r.type=l.onnx.TypeProto.decode(t,t.uint32());break;case 3:r.docString=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.name&&t.hasOwnProperty("name")&&!c.isString(t.name))return"name: string expected";if(null!=t.type&&t.hasOwnProperty("type")){var e=l.onnx.TypeProto.verify(t.type);if(e)return"type."+e}return null!=t.docString&&t.hasOwnProperty("docString")&&!c.isString(t.docString)?"docString: string expected":null},t.fromObject=function(t){if(t instanceof l.onnx.ValueInfoProto)return t;var e=new l.onnx.ValueInfoProto;if(null!=t.name&&(e.name=String(t.name)),null!=t.type){if("object"!=typeof t.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");e.type=l.onnx.TypeProto.fromObject(t.type)}return null!=t.docString&&(e.docString=String(t.docString)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.name="",n.type=null,n.docString=""),null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),null!=t.type&&t.hasOwnProperty("type")&&(n.type=l.onnx.TypeProto.toObject(t.type,e)),null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.NodeProto=function(){function t(t){if(this.input=[],this.output=[],this.attribute=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.input=c.emptyArray,t.prototype.output=c.emptyArray,t.prototype.name="",t.prototype.opType="",t.prototype.domain="",t.prototype.attribute=c.emptyArray,t.prototype.docString="",t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.input&&t.input.length)for(var n=0;n<t.input.length;++n)e.uint32(10).string(t.input[n]);if(null!=t.output&&t.output.length)for(n=0;n<t.output.length;++n)e.uint32(18).string(t.output[n]);if(null!=t.name&&t.hasOwnProperty("name")&&e.uint32(26).string(t.name),null!=t.opType&&t.hasOwnProperty("opType")&&e.uint32(34).string(t.opType),null!=t.attribute&&t.attribute.length)for(n=0;n<t.attribute.length;++n)l.onnx.AttributeProto.encode(t.attribute[n],e.uint32(42).fork()).ldelim();return null!=t.docString&&t.hasOwnProperty("docString")&&e.uint32(50).string(t.docString),null!=t.domain&&t.hasOwnProperty("domain")&&e.uint32(58).string(t.domain),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.NodeProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.input&&r.input.length||(r.input=[]),r.input.push(t.string());break;case 2:r.output&&r.output.length||(r.output=[]),r.output.push(t.string());break;case 3:r.name=t.string();break;case 4:r.opType=t.string();break;case 7:r.domain=t.string();break;case 5:r.attribute&&r.attribute.length||(r.attribute=[]),r.attribute.push(l.onnx.AttributeProto.decode(t,t.uint32()));break;case 6:r.docString=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.input&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var e=0;e<t.input.length;++e)if(!c.isString(t.input[e]))return"input: string[] expected"}if(null!=t.output&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(e=0;e<t.output.length;++e)if(!c.isString(t.output[e]))return"output: string[] expected"}if(null!=t.name&&t.hasOwnProperty("name")&&!c.isString(t.name))return"name: string expected";if(null!=t.opType&&t.hasOwnProperty("opType")&&!c.isString(t.opType))return"opType: string expected";if(null!=t.domain&&t.hasOwnProperty("domain")&&!c.isString(t.domain))return"domain: string expected";if(null!=t.attribute&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(e=0;e<t.attribute.length;++e){var n=l.onnx.AttributeProto.verify(t.attribute[e]);if(n)return"attribute."+n}}return null!=t.docString&&t.hasOwnProperty("docString")&&!c.isString(t.docString)?"docString: string expected":null},t.fromObject=function(t){if(t instanceof l.onnx.NodeProto)return t;var e=new l.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");e.input=[];for(var n=0;n<t.input.length;++n)e.input[n]=String(t.input[n])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");for(e.output=[],n=0;n<t.output.length;++n)e.output[n]=String(t.output[n])}if(null!=t.name&&(e.name=String(t.name)),null!=t.opType&&(e.opType=String(t.opType)),null!=t.domain&&(e.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(e.attribute=[],n=0;n<t.attribute.length;++n){if("object"!=typeof t.attribute[n])throw TypeError(".onnx.NodeProto.attribute: object expected");e.attribute[n]=l.onnx.AttributeProto.fromObject(t.attribute[n])}}return null!=t.docString&&(e.docString=String(t.docString)),e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.input=[],n.output=[],n.attribute=[]),e.defaults&&(n.name="",n.opType="",n.docString="",n.domain=""),t.input&&t.input.length){n.input=[];for(var r=0;r<t.input.length;++r)n.input[r]=t.input[r]}if(t.output&&t.output.length)for(n.output=[],r=0;r<t.output.length;++r)n.output[r]=t.output[r];if(null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),null!=t.opType&&t.hasOwnProperty("opType")&&(n.opType=t.opType),t.attribute&&t.attribute.length)for(n.attribute=[],r=0;r<t.attribute.length;++r)n.attribute[r]=l.onnx.AttributeProto.toObject(t.attribute[r],e);return null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),null!=t.domain&&t.hasOwnProperty("domain")&&(n.domain=t.domain),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.ModelProto=function(){function t(t){if(this.opsetImport=[],this.metadataProps=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.irVersion=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.opsetImport=c.emptyArray,t.prototype.producerName="",t.prototype.producerVersion="",t.prototype.domain="",t.prototype.modelVersion=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.docString="",t.prototype.graph=null,t.prototype.metadataProps=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.irVersion&&t.hasOwnProperty("irVersion")&&e.uint32(8).int64(t.irVersion),null!=t.producerName&&t.hasOwnProperty("producerName")&&e.uint32(18).string(t.producerName),null!=t.producerVersion&&t.hasOwnProperty("producerVersion")&&e.uint32(26).string(t.producerVersion),null!=t.domain&&t.hasOwnProperty("domain")&&e.uint32(34).string(t.domain),null!=t.modelVersion&&t.hasOwnProperty("modelVersion")&&e.uint32(40).int64(t.modelVersion),null!=t.docString&&t.hasOwnProperty("docString")&&e.uint32(50).string(t.docString),null!=t.graph&&t.hasOwnProperty("graph")&&l.onnx.GraphProto.encode(t.graph,e.uint32(58).fork()).ldelim(),null!=t.opsetImport&&t.opsetImport.length)for(var n=0;n<t.opsetImport.length;++n)l.onnx.OperatorSetIdProto.encode(t.opsetImport[n],e.uint32(66).fork()).ldelim();if(null!=t.metadataProps&&t.metadataProps.length)for(n=0;n<t.metadataProps.length;++n)l.onnx.StringStringEntryProto.encode(t.metadataProps[n],e.uint32(114).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.ModelProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.irVersion=t.int64();break;case 8:r.opsetImport&&r.opsetImport.length||(r.opsetImport=[]),r.opsetImport.push(l.onnx.OperatorSetIdProto.decode(t,t.uint32()));break;case 2:r.producerName=t.string();break;case 3:r.producerVersion=t.string();break;case 4:r.domain=t.string();break;case 5:r.modelVersion=t.int64();break;case 6:r.docString=t.string();break;case 7:r.graph=l.onnx.GraphProto.decode(t,t.uint32());break;case 14:r.metadataProps&&r.metadataProps.length||(r.metadataProps=[]),r.metadataProps.push(l.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.irVersion&&t.hasOwnProperty("irVersion")&&!(c.isInteger(t.irVersion)||t.irVersion&&c.isInteger(t.irVersion.low)&&c.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(null!=t.opsetImport&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var e=0;e<t.opsetImport.length;++e)if(n=l.onnx.OperatorSetIdProto.verify(t.opsetImport[e]))return"opsetImport."+n}if(null!=t.producerName&&t.hasOwnProperty("producerName")&&!c.isString(t.producerName))return"producerName: string expected";if(null!=t.producerVersion&&t.hasOwnProperty("producerVersion")&&!c.isString(t.producerVersion))return"producerVersion: string expected";if(null!=t.domain&&t.hasOwnProperty("domain")&&!c.isString(t.domain))return"domain: string expected";if(null!=t.modelVersion&&t.hasOwnProperty("modelVersion")&&!(c.isInteger(t.modelVersion)||t.modelVersion&&c.isInteger(t.modelVersion.low)&&c.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=t.docString&&t.hasOwnProperty("docString")&&!c.isString(t.docString))return"docString: string expected";if(null!=t.graph&&t.hasOwnProperty("graph")&&(n=l.onnx.GraphProto.verify(t.graph)))return"graph."+n;if(null!=t.metadataProps&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(e=0;e<t.metadataProps.length;++e){var n;if(n=l.onnx.StringStringEntryProto.verify(t.metadataProps[e]))return"metadataProps."+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.ModelProto)return t;var e=new l.onnx.ModelProto;if(null!=t.irVersion&&(c.Long?(e.irVersion=c.Long.fromValue(t.irVersion)).unsigned=!1:"string"==typeof t.irVersion?e.irVersion=parseInt(t.irVersion,10):"number"==typeof t.irVersion?e.irVersion=t.irVersion:"object"==typeof t.irVersion&&(e.irVersion=new c.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");e.opsetImport=[];for(var n=0;n<t.opsetImport.length;++n){if("object"!=typeof t.opsetImport[n])throw TypeError(".onnx.ModelProto.opsetImport: object expected");e.opsetImport[n]=l.onnx.OperatorSetIdProto.fromObject(t.opsetImport[n])}}if(null!=t.producerName&&(e.producerName=String(t.producerName)),null!=t.producerVersion&&(e.producerVersion=String(t.producerVersion)),null!=t.domain&&(e.domain=String(t.domain)),null!=t.modelVersion&&(c.Long?(e.modelVersion=c.Long.fromValue(t.modelVersion)).unsigned=!1:"string"==typeof t.modelVersion?e.modelVersion=parseInt(t.modelVersion,10):"number"==typeof t.modelVersion?e.modelVersion=t.modelVersion:"object"==typeof t.modelVersion&&(e.modelVersion=new c.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),null!=t.docString&&(e.docString=String(t.docString)),null!=t.graph){if("object"!=typeof t.graph)throw TypeError(".onnx.ModelProto.graph: object expected");e.graph=l.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(e.metadataProps=[],n=0;n<t.metadataProps.length;++n){if("object"!=typeof t.metadataProps[n])throw TypeError(".onnx.ModelProto.metadataProps: object expected");e.metadataProps[n]=l.onnx.StringStringEntryProto.fromObject(t.metadataProps[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.opsetImport=[],n.metadataProps=[]),e.defaults){if(c.Long){var r=new c.Long(0,0,!1);n.irVersion=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.irVersion=e.longs===String?"0":0;n.producerName="",n.producerVersion="",n.domain="",c.Long?(r=new c.Long(0,0,!1),n.modelVersion=e.longs===String?r.toString():e.longs===Number?r.toNumber():r):n.modelVersion=e.longs===String?"0":0,n.docString="",n.graph=null}if(null!=t.irVersion&&t.hasOwnProperty("irVersion")&&("number"==typeof t.irVersion?n.irVersion=e.longs===String?String(t.irVersion):t.irVersion:n.irVersion=e.longs===String?c.Long.prototype.toString.call(t.irVersion):e.longs===Number?new c.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),null!=t.producerName&&t.hasOwnProperty("producerName")&&(n.producerName=t.producerName),null!=t.producerVersion&&t.hasOwnProperty("producerVersion")&&(n.producerVersion=t.producerVersion),null!=t.domain&&t.hasOwnProperty("domain")&&(n.domain=t.domain),null!=t.modelVersion&&t.hasOwnProperty("modelVersion")&&("number"==typeof t.modelVersion?n.modelVersion=e.longs===String?String(t.modelVersion):t.modelVersion:n.modelVersion=e.longs===String?c.Long.prototype.toString.call(t.modelVersion):e.longs===Number?new c.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),null!=t.graph&&t.hasOwnProperty("graph")&&(n.graph=l.onnx.GraphProto.toObject(t.graph,e)),t.opsetImport&&t.opsetImport.length){n.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i)n.opsetImport[i]=l.onnx.OperatorSetIdProto.toObject(t.opsetImport[i],e)}if(t.metadataProps&&t.metadataProps.length)for(n.metadataProps=[],i=0;i<t.metadataProps.length;++i)n.metadataProps[i]=l.onnx.StringStringEntryProto.toObject(t.metadataProps[i],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.StringStringEntryProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.key="",t.prototype.value="",t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.key&&t.hasOwnProperty("key")&&e.uint32(10).string(t.key),null!=t.value&&t.hasOwnProperty("value")&&e.uint32(18).string(t.value),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.StringStringEntryProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.key=t.string();break;case 2:r.value=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){return"object"!=typeof t||null===t?"object expected":null!=t.key&&t.hasOwnProperty("key")&&!c.isString(t.key)?"key: string expected":null!=t.value&&t.hasOwnProperty("value")&&!c.isString(t.value)?"value: string expected":null},t.fromObject=function(t){if(t instanceof l.onnx.StringStringEntryProto)return t;var e=new l.onnx.StringStringEntryProto;return null!=t.key&&(e.key=String(t.key)),null!=t.value&&(e.value=String(t.value)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.key="",n.value=""),null!=t.key&&t.hasOwnProperty("key")&&(n.key=t.key),null!=t.value&&t.hasOwnProperty("value")&&(n.value=t.value),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.TensorAnnotation=function(){function t(t){if(this.quantParameterTensorNames=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.tensorName="",t.prototype.quantParameterTensorNames=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.tensorName&&t.hasOwnProperty("tensorName")&&e.uint32(10).string(t.tensorName),null!=t.quantParameterTensorNames&&t.quantParameterTensorNames.length)for(var n=0;n<t.quantParameterTensorNames.length;++n)l.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[n],e.uint32(18).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorAnnotation;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.tensorName=t.string();break;case 2:r.quantParameterTensorNames&&r.quantParameterTensorNames.length||(r.quantParameterTensorNames=[]),r.quantParameterTensorNames.push(l.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.tensorName&&t.hasOwnProperty("tensorName")&&!c.isString(t.tensorName))return"tensorName: string expected";if(null!=t.quantParameterTensorNames&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var e=0;e<t.quantParameterTensorNames.length;++e){var n=l.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[e]);if(n)return"quantParameterTensorNames."+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.TensorAnnotation)return t;var e=new l.onnx.TensorAnnotation;if(null!=t.tensorName&&(e.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");e.quantParameterTensorNames=[];for(var n=0;n<t.quantParameterTensorNames.length;++n){if("object"!=typeof t.quantParameterTensorNames[n])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");e.quantParameterTensorNames[n]=l.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.quantParameterTensorNames=[]),e.defaults&&(n.tensorName=""),null!=t.tensorName&&t.hasOwnProperty("tensorName")&&(n.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){n.quantParameterTensorNames=[];for(var r=0;r<t.quantParameterTensorNames.length;++r)n.quantParameterTensorNames[r]=l.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[r],e)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.GraphProto=function(){function t(t){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.node=c.emptyArray,t.prototype.name="",t.prototype.initializer=c.emptyArray,t.prototype.docString="",t.prototype.input=c.emptyArray,t.prototype.output=c.emptyArray,t.prototype.valueInfo=c.emptyArray,t.prototype.quantizationAnnotation=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.node&&t.node.length)for(var n=0;n<t.node.length;++n)l.onnx.NodeProto.encode(t.node[n],e.uint32(10).fork()).ldelim();if(null!=t.name&&t.hasOwnProperty("name")&&e.uint32(18).string(t.name),null!=t.initializer&&t.initializer.length)for(n=0;n<t.initializer.length;++n)l.onnx.TensorProto.encode(t.initializer[n],e.uint32(42).fork()).ldelim();if(null!=t.docString&&t.hasOwnProperty("docString")&&e.uint32(82).string(t.docString),null!=t.input&&t.input.length)for(n=0;n<t.input.length;++n)l.onnx.ValueInfoProto.encode(t.input[n],e.uint32(90).fork()).ldelim();if(null!=t.output&&t.output.length)for(n=0;n<t.output.length;++n)l.onnx.ValueInfoProto.encode(t.output[n],e.uint32(98).fork()).ldelim();if(null!=t.valueInfo&&t.valueInfo.length)for(n=0;n<t.valueInfo.length;++n)l.onnx.ValueInfoProto.encode(t.valueInfo[n],e.uint32(106).fork()).ldelim();if(null!=t.quantizationAnnotation&&t.quantizationAnnotation.length)for(n=0;n<t.quantizationAnnotation.length;++n)l.onnx.TensorAnnotation.encode(t.quantizationAnnotation[n],e.uint32(114).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.GraphProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.node&&r.node.length||(r.node=[]),r.node.push(l.onnx.NodeProto.decode(t,t.uint32()));break;case 2:r.name=t.string();break;case 5:r.initializer&&r.initializer.length||(r.initializer=[]),r.initializer.push(l.onnx.TensorProto.decode(t,t.uint32()));break;case 10:r.docString=t.string();break;case 11:r.input&&r.input.length||(r.input=[]),r.input.push(l.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 12:r.output&&r.output.length||(r.output=[]),r.output.push(l.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 13:r.valueInfo&&r.valueInfo.length||(r.valueInfo=[]),r.valueInfo.push(l.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 14:r.quantizationAnnotation&&r.quantizationAnnotation.length||(r.quantizationAnnotation=[]),r.quantizationAnnotation.push(l.onnx.TensorAnnotation.decode(t,t.uint32()));break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.node&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var e=0;e<t.node.length;++e)if(n=l.onnx.NodeProto.verify(t.node[e]))return"node."+n}if(null!=t.name&&t.hasOwnProperty("name")&&!c.isString(t.name))return"name: string expected";if(null!=t.initializer&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(e=0;e<t.initializer.length;++e)if(n=l.onnx.TensorProto.verify(t.initializer[e]))return"initializer."+n}if(null!=t.docString&&t.hasOwnProperty("docString")&&!c.isString(t.docString))return"docString: string expected";if(null!=t.input&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(e=0;e<t.input.length;++e)if(n=l.onnx.ValueInfoProto.verify(t.input[e]))return"input."+n}if(null!=t.output&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(e=0;e<t.output.length;++e)if(n=l.onnx.ValueInfoProto.verify(t.output[e]))return"output."+n}if(null!=t.valueInfo&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(e=0;e<t.valueInfo.length;++e)if(n=l.onnx.ValueInfoProto.verify(t.valueInfo[e]))return"valueInfo."+n}if(null!=t.quantizationAnnotation&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(e=0;e<t.quantizationAnnotation.length;++e){var n;if(n=l.onnx.TensorAnnotation.verify(t.quantizationAnnotation[e]))return"quantizationAnnotation."+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.GraphProto)return t;var e=new l.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");e.node=[];for(var n=0;n<t.node.length;++n){if("object"!=typeof t.node[n])throw TypeError(".onnx.GraphProto.node: object expected");e.node[n]=l.onnx.NodeProto.fromObject(t.node[n])}}if(null!=t.name&&(e.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(e.initializer=[],n=0;n<t.initializer.length;++n){if("object"!=typeof t.initializer[n])throw TypeError(".onnx.GraphProto.initializer: object expected");e.initializer[n]=l.onnx.TensorProto.fromObject(t.initializer[n])}}if(null!=t.docString&&(e.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");for(e.input=[],n=0;n<t.input.length;++n){if("object"!=typeof t.input[n])throw TypeError(".onnx.GraphProto.input: object expected");e.input[n]=l.onnx.ValueInfoProto.fromObject(t.input[n])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");for(e.output=[],n=0;n<t.output.length;++n){if("object"!=typeof t.output[n])throw TypeError(".onnx.GraphProto.output: object expected");e.output[n]=l.onnx.ValueInfoProto.fromObject(t.output[n])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(e.valueInfo=[],n=0;n<t.valueInfo.length;++n){if("object"!=typeof t.valueInfo[n])throw TypeError(".onnx.GraphProto.valueInfo: object expected");e.valueInfo[n]=l.onnx.ValueInfoProto.fromObject(t.valueInfo[n])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(e.quantizationAnnotation=[],n=0;n<t.quantizationAnnotation.length;++n){if("object"!=typeof t.quantizationAnnotation[n])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");e.quantizationAnnotation[n]=l.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.node=[],n.initializer=[],n.input=[],n.output=[],n.valueInfo=[],n.quantizationAnnotation=[]),e.defaults&&(n.name="",n.docString=""),t.node&&t.node.length){n.node=[];for(var r=0;r<t.node.length;++r)n.node[r]=l.onnx.NodeProto.toObject(t.node[r],e)}if(null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),t.initializer&&t.initializer.length)for(n.initializer=[],r=0;r<t.initializer.length;++r)n.initializer[r]=l.onnx.TensorProto.toObject(t.initializer[r],e);if(null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),t.input&&t.input.length)for(n.input=[],r=0;r<t.input.length;++r)n.input[r]=l.onnx.ValueInfoProto.toObject(t.input[r],e);if(t.output&&t.output.length)for(n.output=[],r=0;r<t.output.length;++r)n.output[r]=l.onnx.ValueInfoProto.toObject(t.output[r],e);if(t.valueInfo&&t.valueInfo.length)for(n.valueInfo=[],r=0;r<t.valueInfo.length;++r)n.valueInfo[r]=l.onnx.ValueInfoProto.toObject(t.valueInfo[r],e);if(t.quantizationAnnotation&&t.quantizationAnnotation.length)for(n.quantizationAnnotation=[],r=0;r<t.quantizationAnnotation.length;++r)n.quantizationAnnotation[r]=l.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[r],e);return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o.TensorProto=function(){function t(t){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.dims=c.emptyArray,t.prototype.dataType=0,t.prototype.segment=null,t.prototype.floatData=c.emptyArray,t.prototype.int32Data=c.emptyArray,t.prototype.stringData=c.emptyArray,t.prototype.int64Data=c.emptyArray,t.prototype.name="",t.prototype.docString="",t.prototype.rawData=c.newBuffer([]),t.prototype.externalData=c.emptyArray,t.prototype.dataLocation=0,t.prototype.doubleData=c.emptyArray,t.prototype.uint64Data=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.dims&&t.dims.length){e.uint32(10).fork();for(var n=0;n<t.dims.length;++n)e.int64(t.dims[n]);e.ldelim()}if(null!=t.dataType&&t.hasOwnProperty("dataType")&&e.uint32(16).int32(t.dataType),null!=t.segment&&t.hasOwnProperty("segment")&&l.onnx.TensorProto.Segment.encode(t.segment,e.uint32(26).fork()).ldelim(),null!=t.floatData&&t.floatData.length){for(e.uint32(34).fork(),n=0;n<t.floatData.length;++n)e.float(t.floatData[n]);e.ldelim()}if(null!=t.int32Data&&t.int32Data.length){for(e.uint32(42).fork(),n=0;n<t.int32Data.length;++n)e.int32(t.int32Data[n]);e.ldelim()}if(null!=t.stringData&&t.stringData.length)for(n=0;n<t.stringData.length;++n)e.uint32(50).bytes(t.stringData[n]);if(null!=t.int64Data&&t.int64Data.length){for(e.uint32(58).fork(),n=0;n<t.int64Data.length;++n)e.int64(t.int64Data[n]);e.ldelim()}if(null!=t.name&&t.hasOwnProperty("name")&&e.uint32(66).string(t.name),null!=t.rawData&&t.hasOwnProperty("rawData")&&e.uint32(74).bytes(t.rawData),null!=t.doubleData&&t.doubleData.length){for(e.uint32(82).fork(),n=0;n<t.doubleData.length;++n)e.double(t.doubleData[n]);e.ldelim()}if(null!=t.uint64Data&&t.uint64Data.length){for(e.uint32(90).fork(),n=0;n<t.uint64Data.length;++n)e.uint64(t.uint64Data[n]);e.ldelim()}if(null!=t.docString&&t.hasOwnProperty("docString")&&e.uint32(98).string(t.docString),null!=t.externalData&&t.externalData.length)for(n=0;n<t.externalData.length;++n)l.onnx.StringStringEntryProto.encode(t.externalData[n],e.uint32(106).fork()).ldelim();return null!=t.dataLocation&&t.hasOwnProperty("dataLocation")&&e.uint32(112).int32(t.dataLocation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:if(r.dims&&r.dims.length||(r.dims=[]),2==(7&i))for(var o=t.uint32()+t.pos;t.pos<o;)r.dims.push(t.int64());else r.dims.push(t.int64());break;case 2:r.dataType=t.int32();break;case 3:r.segment=l.onnx.TensorProto.Segment.decode(t,t.uint32());break;case 4:if(r.floatData&&r.floatData.length||(r.floatData=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.floatData.push(t.float());else r.floatData.push(t.float());break;case 5:if(r.int32Data&&r.int32Data.length||(r.int32Data=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.int32Data.push(t.int32());else r.int32Data.push(t.int32());break;case 6:r.stringData&&r.stringData.length||(r.stringData=[]),r.stringData.push(t.bytes());break;case 7:if(r.int64Data&&r.int64Data.length||(r.int64Data=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.int64Data.push(t.int64());else r.int64Data.push(t.int64());break;case 8:r.name=t.string();break;case 12:r.docString=t.string();break;case 9:r.rawData=t.bytes();break;case 13:r.externalData&&r.externalData.length||(r.externalData=[]),r.externalData.push(l.onnx.StringStringEntryProto.decode(t,t.uint32()));break;case 14:r.dataLocation=t.int32();break;case 10:if(r.doubleData&&r.doubleData.length||(r.doubleData=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.doubleData.push(t.double());else r.doubleData.push(t.double());break;case 11:if(r.uint64Data&&r.uint64Data.length||(r.uint64Data=[]),2==(7&i))for(o=t.uint32()+t.pos;t.pos<o;)r.uint64Data.push(t.uint64());else r.uint64Data.push(t.uint64());break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.dims&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var e=0;e<t.dims.length;++e)if(!(c.isInteger(t.dims[e])||t.dims[e]&&c.isInteger(t.dims[e].low)&&c.isInteger(t.dims[e].high)))return"dims: integer|Long[] expected"}if(null!=t.dataType&&t.hasOwnProperty("dataType")&&!c.isInteger(t.dataType))return"dataType: integer expected";if(null!=t.segment&&t.hasOwnProperty("segment")&&(n=l.onnx.TensorProto.Segment.verify(t.segment)))return"segment."+n;if(null!=t.floatData&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(e=0;e<t.floatData.length;++e)if("number"!=typeof t.floatData[e])return"floatData: number[] expected"}if(null!=t.int32Data&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(e=0;e<t.int32Data.length;++e)if(!c.isInteger(t.int32Data[e]))return"int32Data: integer[] expected"}if(null!=t.stringData&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(e=0;e<t.stringData.length;++e)if(!(t.stringData[e]&&"number"==typeof t.stringData[e].length||c.isString(t.stringData[e])))return"stringData: buffer[] expected"}if(null!=t.int64Data&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(e=0;e<t.int64Data.length;++e)if(!(c.isInteger(t.int64Data[e])||t.int64Data[e]&&c.isInteger(t.int64Data[e].low)&&c.isInteger(t.int64Data[e].high)))return"int64Data: integer|Long[] expected"}if(null!=t.name&&t.hasOwnProperty("name")&&!c.isString(t.name))return"name: string expected";if(null!=t.docString&&t.hasOwnProperty("docString")&&!c.isString(t.docString))return"docString: string expected";if(null!=t.rawData&&t.hasOwnProperty("rawData")&&!(t.rawData&&"number"==typeof t.rawData.length||c.isString(t.rawData)))return"rawData: buffer expected";if(null!=t.externalData&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(e=0;e<t.externalData.length;++e){var n;if(n=l.onnx.StringStringEntryProto.verify(t.externalData[e]))return"externalData."+n}}if(null!=t.dataLocation&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=t.doubleData&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(e=0;e<t.doubleData.length;++e)if("number"!=typeof t.doubleData[e])return"doubleData: number[] expected"}if(null!=t.uint64Data&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(e=0;e<t.uint64Data.length;++e)if(!(c.isInteger(t.uint64Data[e])||t.uint64Data[e]&&c.isInteger(t.uint64Data[e].low)&&c.isInteger(t.uint64Data[e].high)))return"uint64Data: integer|Long[] expected"}return null},t.fromObject=function(t){if(t instanceof l.onnx.TensorProto)return t;var e=new l.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");e.dims=[];for(var n=0;n<t.dims.length;++n)c.Long?(e.dims[n]=c.Long.fromValue(t.dims[n])).unsigned=!1:"string"==typeof t.dims[n]?e.dims[n]=parseInt(t.dims[n],10):"number"==typeof t.dims[n]?e.dims[n]=t.dims[n]:"object"==typeof t.dims[n]&&(e.dims[n]=new c.LongBits(t.dims[n].low>>>0,t.dims[n].high>>>0).toNumber())}if(null!=t.dataType&&(e.dataType=0|t.dataType),null!=t.segment){if("object"!=typeof t.segment)throw TypeError(".onnx.TensorProto.segment: object expected");e.segment=l.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(e.floatData=[],n=0;n<t.floatData.length;++n)e.floatData[n]=Number(t.floatData[n])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(e.int32Data=[],n=0;n<t.int32Data.length;++n)e.int32Data[n]=0|t.int32Data[n]}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(e.stringData=[],n=0;n<t.stringData.length;++n)"string"==typeof t.stringData[n]?c.base64.decode(t.stringData[n],e.stringData[n]=c.newBuffer(c.base64.length(t.stringData[n])),0):t.stringData[n].length&&(e.stringData[n]=t.stringData[n])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(e.int64Data=[],n=0;n<t.int64Data.length;++n)c.Long?(e.int64Data[n]=c.Long.fromValue(t.int64Data[n])).unsigned=!1:"string"==typeof t.int64Data[n]?e.int64Data[n]=parseInt(t.int64Data[n],10):"number"==typeof t.int64Data[n]?e.int64Data[n]=t.int64Data[n]:"object"==typeof t.int64Data[n]&&(e.int64Data[n]=new c.LongBits(t.int64Data[n].low>>>0,t.int64Data[n].high>>>0).toNumber())}if(null!=t.name&&(e.name=String(t.name)),null!=t.docString&&(e.docString=String(t.docString)),null!=t.rawData&&("string"==typeof t.rawData?c.base64.decode(t.rawData,e.rawData=c.newBuffer(c.base64.length(t.rawData)),0):t.rawData.length&&(e.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(e.externalData=[],n=0;n<t.externalData.length;++n){if("object"!=typeof t.externalData[n])throw TypeError(".onnx.TensorProto.externalData: object expected");e.externalData[n]=l.onnx.StringStringEntryProto.fromObject(t.externalData[n])}}switch(t.dataLocation){case"DEFAULT":case 0:e.dataLocation=0;break;case"EXTERNAL":case 1:e.dataLocation=1}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(e.doubleData=[],n=0;n<t.doubleData.length;++n)e.doubleData[n]=Number(t.doubleData[n])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(e.uint64Data=[],n=0;n<t.uint64Data.length;++n)c.Long?(e.uint64Data[n]=c.Long.fromValue(t.uint64Data[n])).unsigned=!0:"string"==typeof t.uint64Data[n]?e.uint64Data[n]=parseInt(t.uint64Data[n],10):"number"==typeof t.uint64Data[n]?e.uint64Data[n]=t.uint64Data[n]:"object"==typeof t.uint64Data[n]&&(e.uint64Data[n]=new c.LongBits(t.uint64Data[n].low>>>0,t.uint64Data[n].high>>>0).toNumber(!0))}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.dims=[],n.floatData=[],n.int32Data=[],n.stringData=[],n.int64Data=[],n.doubleData=[],n.uint64Data=[],n.externalData=[]),e.defaults&&(n.dataType=0,n.segment=null,n.name="",e.bytes===String?n.rawData="":(n.rawData=[],e.bytes!==Array&&(n.rawData=c.newBuffer(n.rawData))),n.docString="",n.dataLocation=e.enums===String?"DEFAULT":0),t.dims&&t.dims.length){n.dims=[];for(var r=0;r<t.dims.length;++r)"number"==typeof t.dims[r]?n.dims[r]=e.longs===String?String(t.dims[r]):t.dims[r]:n.dims[r]=e.longs===String?c.Long.prototype.toString.call(t.dims[r]):e.longs===Number?new c.LongBits(t.dims[r].low>>>0,t.dims[r].high>>>0).toNumber():t.dims[r]}if(null!=t.dataType&&t.hasOwnProperty("dataType")&&(n.dataType=t.dataType),null!=t.segment&&t.hasOwnProperty("segment")&&(n.segment=l.onnx.TensorProto.Segment.toObject(t.segment,e)),t.floatData&&t.floatData.length)for(n.floatData=[],r=0;r<t.floatData.length;++r)n.floatData[r]=e.json&&!isFinite(t.floatData[r])?String(t.floatData[r]):t.floatData[r];if(t.int32Data&&t.int32Data.length)for(n.int32Data=[],r=0;r<t.int32Data.length;++r)n.int32Data[r]=t.int32Data[r];if(t.stringData&&t.stringData.length)for(n.stringData=[],r=0;r<t.stringData.length;++r)n.stringData[r]=e.bytes===String?c.base64.encode(t.stringData[r],0,t.stringData[r].length):e.bytes===Array?Array.prototype.slice.call(t.stringData[r]):t.stringData[r];if(t.int64Data&&t.int64Data.length)for(n.int64Data=[],r=0;r<t.int64Data.length;++r)"number"==typeof t.int64Data[r]?n.int64Data[r]=e.longs===String?String(t.int64Data[r]):t.int64Data[r]:n.int64Data[r]=e.longs===String?c.Long.prototype.toString.call(t.int64Data[r]):e.longs===Number?new c.LongBits(t.int64Data[r].low>>>0,t.int64Data[r].high>>>0).toNumber():t.int64Data[r];if(null!=t.name&&t.hasOwnProperty("name")&&(n.name=t.name),null!=t.rawData&&t.hasOwnProperty("rawData")&&(n.rawData=e.bytes===String?c.base64.encode(t.rawData,0,t.rawData.length):e.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length)for(n.doubleData=[],r=0;r<t.doubleData.length;++r)n.doubleData[r]=e.json&&!isFinite(t.doubleData[r])?String(t.doubleData[r]):t.doubleData[r];if(t.uint64Data&&t.uint64Data.length)for(n.uint64Data=[],r=0;r<t.uint64Data.length;++r)"number"==typeof t.uint64Data[r]?n.uint64Data[r]=e.longs===String?String(t.uint64Data[r]):t.uint64Data[r]:n.uint64Data[r]=e.longs===String?c.Long.prototype.toString.call(t.uint64Data[r]):e.longs===Number?new c.LongBits(t.uint64Data[r].low>>>0,t.uint64Data[r].high>>>0).toNumber(!0):t.uint64Data[r];if(null!=t.docString&&t.hasOwnProperty("docString")&&(n.docString=t.docString),t.externalData&&t.externalData.length)for(n.externalData=[],r=0;r<t.externalData.length;++r)n.externalData[r]=l.onnx.StringStringEntryProto.toObject(t.externalData[r],e);return null!=t.dataLocation&&t.hasOwnProperty("dataLocation")&&(n.dataLocation=e.enums===String?l.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.DataType=function(){var t={},e=Object.create(t);return e[t[0]="UNDEFINED"]=0,e[t[1]="FLOAT"]=1,e[t[2]="UINT8"]=2,e[t[3]="INT8"]=3,e[t[4]="UINT16"]=4,e[t[5]="INT16"]=5,e[t[6]="INT32"]=6,e[t[7]="INT64"]=7,e[t[8]="STRING"]=8,e[t[9]="BOOL"]=9,e[t[10]="FLOAT16"]=10,e[t[11]="DOUBLE"]=11,e[t[12]="UINT32"]=12,e[t[13]="UINT64"]=13,e[t[14]="COMPLEX64"]=14,e[t[15]="COMPLEX128"]=15,e[t[16]="BFLOAT16"]=16,e}(),t.Segment=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.begin=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.end=c.Long?c.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.begin&&t.hasOwnProperty("begin")&&e.uint32(8).int64(t.begin),null!=t.end&&t.hasOwnProperty("end")&&e.uint32(16).int64(t.end),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorProto.Segment;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.begin=t.int64();break;case 2:r.end=t.int64();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){return"object"!=typeof t||null===t?"object expected":null!=t.begin&&t.hasOwnProperty("begin")&&!(c.isInteger(t.begin)||t.begin&&c.isInteger(t.begin.low)&&c.isInteger(t.begin.high))?"begin: integer|Long expected":null!=t.end&&t.hasOwnProperty("end")&&!(c.isInteger(t.end)||t.end&&c.isInteger(t.end.low)&&c.isInteger(t.end.high))?"end: integer|Long expected":null},t.fromObject=function(t){if(t instanceof l.onnx.TensorProto.Segment)return t;var e=new l.onnx.TensorProto.Segment;return null!=t.begin&&(c.Long?(e.begin=c.Long.fromValue(t.begin)).unsigned=!1:"string"==typeof t.begin?e.begin=parseInt(t.begin,10):"number"==typeof t.begin?e.begin=t.begin:"object"==typeof t.begin&&(e.begin=new c.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber())),null!=t.end&&(c.Long?(e.end=c.Long.fromValue(t.end)).unsigned=!1:"string"==typeof t.end?e.end=parseInt(t.end,10):"number"==typeof t.end?e.end=t.end:"object"==typeof t.end&&(e.end=new c.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber())),e},t.toObject=function(t,e){e||(e={});var n={};if(e.defaults){if(c.Long){var r=new c.Long(0,0,!1);n.begin=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.begin=e.longs===String?"0":0;c.Long?(r=new c.Long(0,0,!1),n.end=e.longs===String?r.toString():e.longs===Number?r.toNumber():r):n.end=e.longs===String?"0":0}return null!=t.begin&&t.hasOwnProperty("begin")&&("number"==typeof t.begin?n.begin=e.longs===String?String(t.begin):t.begin:n.begin=e.longs===String?c.Long.prototype.toString.call(t.begin):e.longs===Number?new c.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber():t.begin),null!=t.end&&t.hasOwnProperty("end")&&("number"==typeof t.end?n.end=e.longs===String?String(t.end):t.end:n.end=e.longs===String?c.Long.prototype.toString.call(t.end):e.longs===Number?new c.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber():t.end),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),t.DataLocation=function(){var t={},e=Object.create(t);return e[t[0]="DEFAULT"]=0,e[t[1]="EXTERNAL"]=1,e}(),t}(),o.TensorShapeProto=function(){function t(t){if(this.dim=[],t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.dim=c.emptyArray,t.create=function(e){return new t(e)},t.encode=function(t,e){if(e||(e=u.create()),null!=t.dim&&t.dim.length)for(var n=0;n<t.dim.length;++n)l.onnx.TensorShapeProto.Dimension.encode(t.dim[n],e.uint32(10).fork()).ldelim();return e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorShapeProto;t.pos<n;){var i=t.uint32();i>>>3==1?(r.dim&&r.dim.length||(r.dim=[]),r.dim.push(l.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()))):t.skipType(7&i)}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.dim&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var e=0;e<t.dim.length;++e){var n=l.onnx.TensorShapeProto.Dimension.verify(t.dim[e]);if(n)return"dim."+n}}return null},t.fromObject=function(t){if(t instanceof l.onnx.TensorShapeProto)return t;var e=new l.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");e.dim=[];for(var n=0;n<t.dim.length;++n){if("object"!=typeof t.dim[n])throw TypeError(".onnx.TensorShapeProto.dim: object expected");e.dim[n]=l.onnx.TensorShapeProto.Dimension.fromObject(t.dim[n])}}return e},t.toObject=function(t,e){e||(e={});var n={};if((e.arrays||e.defaults)&&(n.dim=[]),t.dim&&t.dim.length){n.dim=[];for(var r=0;r<t.dim.length;++r)n.dim[r]=l.onnx.TensorShapeProto.Dimension.toObject(t.dim[r],e)}return n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.Dimension=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}var e;return t.prototype.dimValue=c.Long?c.Long.fromBits(0,0,!1):0,t.prototype.dimParam="",t.prototype.denotation="",Object.defineProperty(t.prototype,"value",{get:c.oneOfGetter(e=["dimValue","dimParam"]),set:c.oneOfSetter(e)}),t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.dimValue&&t.hasOwnProperty("dimValue")&&e.uint32(8).int64(t.dimValue),null!=t.dimParam&&t.hasOwnProperty("dimParam")&&e.uint32(18).string(t.dimParam),null!=t.denotation&&t.hasOwnProperty("denotation")&&e.uint32(26).string(t.denotation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TensorShapeProto.Dimension;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.dimValue=t.int64();break;case 2:r.dimParam=t.string();break;case 3:r.denotation=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";var e={};if(null!=t.dimValue&&t.hasOwnProperty("dimValue")&&(e.value=1,!(c.isInteger(t.dimValue)||t.dimValue&&c.isInteger(t.dimValue.low)&&c.isInteger(t.dimValue.high))))return"dimValue: integer|Long expected";if(null!=t.dimParam&&t.hasOwnProperty("dimParam")){if(1===e.value)return"value: multiple values";if(e.value=1,!c.isString(t.dimParam))return"dimParam: string expected"}return null!=t.denotation&&t.hasOwnProperty("denotation")&&!c.isString(t.denotation)?"denotation: string expected":null},t.fromObject=function(t){if(t instanceof l.onnx.TensorShapeProto.Dimension)return t;var e=new l.onnx.TensorShapeProto.Dimension;return null!=t.dimValue&&(c.Long?(e.dimValue=c.Long.fromValue(t.dimValue)).unsigned=!1:"string"==typeof t.dimValue?e.dimValue=parseInt(t.dimValue,10):"number"==typeof t.dimValue?e.dimValue=t.dimValue:"object"==typeof t.dimValue&&(e.dimValue=new c.LongBits(t.dimValue.low>>>0,t.dimValue.high>>>0).toNumber())),null!=t.dimParam&&(e.dimParam=String(t.dimParam)),null!=t.denotation&&(e.denotation=String(t.denotation)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.denotation=""),null!=t.dimValue&&t.hasOwnProperty("dimValue")&&("number"==typeof t.dimValue?n.dimValue=e.longs===String?String(t.dimValue):t.dimValue:n.dimValue=e.longs===String?c.Long.prototype.toString.call(t.dimValue):e.longs===Number?new c.LongBits(t.dimValue.low>>>0,t.dimValue.high>>>0).toNumber():t.dimValue,e.oneofs&&(n.value="dimValue")),null!=t.dimParam&&t.hasOwnProperty("dimParam")&&(n.dimParam=t.dimParam,e.oneofs&&(n.value="dimParam")),null!=t.denotation&&t.hasOwnProperty("denotation")&&(n.denotation=t.denotation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),t}(),o.TypeProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}var e;return t.prototype.tensorType=null,t.prototype.denotation="",Object.defineProperty(t.prototype,"value",{get:c.oneOfGetter(e=["tensorType"]),set:c.oneOfSetter(e)}),t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.tensorType&&t.hasOwnProperty("tensorType")&&l.onnx.TypeProto.Tensor.encode(t.tensorType,e.uint32(10).fork()).ldelim(),null!=t.denotation&&t.hasOwnProperty("denotation")&&e.uint32(50).string(t.denotation),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TypeProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.tensorType=l.onnx.TypeProto.Tensor.decode(t,t.uint32());break;case 6:r.denotation=t.string();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.tensorType&&t.hasOwnProperty("tensorType")){var e=l.onnx.TypeProto.Tensor.verify(t.tensorType);if(e)return"tensorType."+e}return null!=t.denotation&&t.hasOwnProperty("denotation")&&!c.isString(t.denotation)?"denotation: string expected":null},t.fromObject=function(t){if(t instanceof l.onnx.TypeProto)return t;var e=new l.onnx.TypeProto;if(null!=t.tensorType){if("object"!=typeof t.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");e.tensorType=l.onnx.TypeProto.Tensor.fromObject(t.tensorType)}return null!=t.denotation&&(e.denotation=String(t.denotation)),e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.denotation=""),null!=t.tensorType&&t.hasOwnProperty("tensorType")&&(n.tensorType=l.onnx.TypeProto.Tensor.toObject(t.tensorType,e),e.oneofs&&(n.value="tensorType")),null!=t.denotation&&t.hasOwnProperty("denotation")&&(n.denotation=t.denotation),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t.Tensor=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.elemType&&t.hasOwnProperty("elemType")&&e.uint32(8).int32(t.elemType),null!=t.shape&&t.hasOwnProperty("shape")&&l.onnx.TensorShapeProto.encode(t.shape,e.uint32(18).fork()).ldelim(),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.TypeProto.Tensor;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.elemType=t.int32();break;case 2:r.shape=l.onnx.TensorShapeProto.decode(t,t.uint32());break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){if("object"!=typeof t||null===t)return"object expected";if(null!=t.elemType&&t.hasOwnProperty("elemType")&&!c.isInteger(t.elemType))return"elemType: integer expected";if(null!=t.shape&&t.hasOwnProperty("shape")){var e=l.onnx.TensorShapeProto.verify(t.shape);if(e)return"shape."+e}return null},t.fromObject=function(t){if(t instanceof l.onnx.TypeProto.Tensor)return t;var e=new l.onnx.TypeProto.Tensor;if(null!=t.elemType&&(e.elemType=0|t.elemType),null!=t.shape){if("object"!=typeof t.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");e.shape=l.onnx.TensorShapeProto.fromObject(t.shape)}return e},t.toObject=function(t,e){e||(e={});var n={};return e.defaults&&(n.elemType=0,n.shape=null),null!=t.elemType&&t.hasOwnProperty("elemType")&&(n.elemType=t.elemType),null!=t.shape&&t.hasOwnProperty("shape")&&(n.shape=l.onnx.TensorShapeProto.toObject(t.shape,e)),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),t}(),o.OperatorSetIdProto=function(){function t(t){if(t)for(var e=Object.keys(t),n=0;n<e.length;++n)null!=t[e[n]]&&(this[e[n]]=t[e[n]])}return t.prototype.domain="",t.prototype.version=c.Long?c.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(t,e){return e||(e=u.create()),null!=t.domain&&t.hasOwnProperty("domain")&&e.uint32(10).string(t.domain),null!=t.version&&t.hasOwnProperty("version")&&e.uint32(16).int64(t.version),e},t.encodeDelimited=function(t,e){return this.encode(t,e).ldelim()},t.decode=function(t,e){t instanceof s||(t=s.create(t));for(var n=void 0===e?t.len:t.pos+e,r=new l.onnx.OperatorSetIdProto;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:r.domain=t.string();break;case 2:r.version=t.int64();break;default:t.skipType(7&i)}}return r},t.decodeDelimited=function(t){return t instanceof s||(t=new s(t)),this.decode(t,t.uint32())},t.verify=function(t){return"object"!=typeof t||null===t?"object expected":null!=t.domain&&t.hasOwnProperty("domain")&&!c.isString(t.domain)?"domain: string expected":null!=t.version&&t.hasOwnProperty("version")&&!(c.isInteger(t.version)||t.version&&c.isInteger(t.version.low)&&c.isInteger(t.version.high))?"version: integer|Long expected":null},t.fromObject=function(t){if(t instanceof l.onnx.OperatorSetIdProto)return t;var e=new l.onnx.OperatorSetIdProto;return null!=t.domain&&(e.domain=String(t.domain)),null!=t.version&&(c.Long?(e.version=c.Long.fromValue(t.version)).unsigned=!1:"string"==typeof t.version?e.version=parseInt(t.version,10):"number"==typeof t.version?e.version=t.version:"object"==typeof t.version&&(e.version=new c.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),e},t.toObject=function(t,e){e||(e={});var n={};if(e.defaults)if(n.domain="",c.Long){var r=new c.Long(0,0,!1);n.version=e.longs===String?r.toString():e.longs===Number?r.toNumber():r}else n.version=e.longs===String?"0":0;return null!=t.domain&&t.hasOwnProperty("domain")&&(n.domain=t.domain),null!=t.version&&t.hasOwnProperty("version")&&("number"==typeof t.version?n.version=e.longs===String?String(t.version):t.version:n.version=e.longs===String?c.Long.prototype.toString.call(t.version):e.longs===Number?new c.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),n},t.prototype.toJSON=function(){return this.constructor.toObject(this,a.util.toJSONOptions)},t}(),o),t.exports=l},2100:(t,e,n)=>{"use strict";t.exports=n(9482)},9482:(t,e,n)=>{"use strict";var r=e;function i(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}r.build="minimal",r.Writer=n(1173),r.BufferWriter=n(3155),r.Reader=n(1408),r.BufferReader=n(593),r.util=n(9693),r.rpc=n(5994),r.roots=n(5054),r.configure=i,i()},1408:(t,e,n)=>{"use strict";t.exports=u;var r,i=n(9693),o=i.LongBits,a=i.utf8;function s(t,e){return RangeError("index out of range: "+t.pos+" + "+(e||1)+" > "+t.len)}function u(t){this.buf=t,this.pos=0,this.len=t.length}var c,l="undefined"!=typeof Uint8Array?function(t){if(t instanceof Uint8Array||Array.isArray(t))return new u(t);throw Error("illegal buffer")}:function(t){if(Array.isArray(t))return new u(t);throw Error("illegal buffer")},p=function(){return i.Buffer?function(t){return(u.create=function(t){return i.Buffer.isBuffer(t)?new r(t):l(t)})(t)}:l};function f(){var t=new o(0,0),e=0;if(!(this.len-this.pos>4)){for(;e<3;++e){if(this.pos>=this.len)throw s(this);if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*e)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(127&this.buf[this.pos++])<<7*e)>>>0,t}for(;e<4;++e)if(t.lo=(t.lo|(127&this.buf[this.pos])<<7*e)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(127&this.buf[this.pos])<<28)>>>0,t.hi=(t.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return t;if(e=0,this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw s(this);if(t.hi=(t.hi|(127&this.buf[this.pos])<<7*e+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}function d(t,e){return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0}function h(){if(this.pos+8>this.len)throw s(this,8);return new o(d(this.buf,this.pos+=4),d(this.buf,this.pos+=4))}u.create=p(),u.prototype._slice=i.Array.prototype.subarray||i.Array.prototype.slice,u.prototype.uint32=(c=4294967295,function(){if(c=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return c;if(c=(c|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return c;if((this.pos+=5)>this.len)throw this.pos=this.len,s(this,10);return c}),u.prototype.int32=function(){return 0|this.uint32()},u.prototype.sint32=function(){var t=this.uint32();return t>>>1^-(1&t)|0},u.prototype.bool=function(){return 0!==this.uint32()},u.prototype.fixed32=function(){if(this.pos+4>this.len)throw s(this,4);return d(this.buf,this.pos+=4)},u.prototype.sfixed32=function(){if(this.pos+4>this.len)throw s(this,4);return 0|d(this.buf,this.pos+=4)},u.prototype.float=function(){if(this.pos+4>this.len)throw s(this,4);var t=i.float.readFloatLE(this.buf,this.pos);return this.pos+=4,t},u.prototype.double=function(){if(this.pos+8>this.len)throw s(this,4);var t=i.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,t},u.prototype.bytes=function(){var t=this.uint32(),e=this.pos,n=this.pos+t;if(n>this.len)throw s(this,t);return this.pos+=t,Array.isArray(this.buf)?this.buf.slice(e,n):e===n?new this.buf.constructor(0):this._slice.call(this.buf,e,n)},u.prototype.string=function(){var t=this.bytes();return a.read(t,0,t.length)},u.prototype.skip=function(t){if("number"==typeof t){if(this.pos+t>this.len)throw s(this,t);this.pos+=t}else do{if(this.pos>=this.len)throw s(this)}while(128&this.buf[this.pos++]);return this},u.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(t=7&this.uint32());)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+t+" at offset "+this.pos)}return this},u._configure=function(t){r=t,u.create=p(),r._configure();var e=i.Long?"toLong":"toNumber";i.merge(u.prototype,{int64:function(){return f.call(this)[e](!1)},uint64:function(){return f.call(this)[e](!0)},sint64:function(){return f.call(this).zzDecode()[e](!1)},fixed64:function(){return h.call(this)[e](!0)},sfixed64:function(){return h.call(this)[e](!1)}})}},593:(t,e,n)=>{"use strict";t.exports=o;var r=n(1408);(o.prototype=Object.create(r.prototype)).constructor=o;var i=n(9693);function o(t){r.call(this,t)}o._configure=function(){i.Buffer&&(o.prototype._slice=i.Buffer.prototype.slice)},o.prototype.string=function(){var t=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+t,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+t,this.len))},o._configure()},5054:t=>{"use strict";t.exports={}},5994:(t,e,n)=>{"use strict";e.Service=n(7948)},7948:(t,e,n)=>{"use strict";t.exports=i;var r=n(9693);function i(t,e,n){if("function"!=typeof t)throw TypeError("rpcImpl must be a function");r.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=Boolean(e),this.responseDelimited=Boolean(n)}(i.prototype=Object.create(r.EventEmitter.prototype)).constructor=i,i.prototype.rpcCall=function t(e,n,i,o,a){if(!o)throw TypeError("request must be specified");var s=this;if(!a)return r.asPromise(t,s,e,n,i,o);if(s.rpcImpl)try{return s.rpcImpl(e,n[s.requestDelimited?"encodeDelimited":"encode"](o).finish(),(function(t,n){if(t)return s.emit("error",t,e),a(t);if(null!==n){if(!(n instanceof i))try{n=i[s.responseDelimited?"decodeDelimited":"decode"](n)}catch(t){return s.emit("error",t,e),a(t)}return s.emit("data",n,e),a(null,n)}s.end(!0)}))}catch(t){return s.emit("error",t,e),void setTimeout((function(){a(t)}),0)}else setTimeout((function(){a(Error("already ended"))}),0)},i.prototype.end=function(t){return this.rpcImpl&&(t||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(t,e,n)=>{"use strict";t.exports=i;var r=n(9693);function i(t,e){this.lo=t>>>0,this.hi=e>>>0}var o=i.zero=new i(0,0);o.toNumber=function(){return 0},o.zzEncode=o.zzDecode=function(){return this},o.length=function(){return 1};var a=i.zeroHash="\0\0\0\0\0\0\0\0";i.fromNumber=function(t){if(0===t)return o;var e=t<0;e&&(t=-t);var n=t>>>0,r=(t-n)/4294967296>>>0;return e&&(r=~r>>>0,n=~n>>>0,++n>4294967295&&(n=0,++r>4294967295&&(r=0))),new i(n,r)},i.from=function(t){if("number"==typeof t)return i.fromNumber(t);if(r.isString(t)){if(!r.Long)return i.fromNumber(parseInt(t,10));t=r.Long.fromString(t)}return t.low||t.high?new i(t.low>>>0,t.high>>>0):o},i.prototype.toNumber=function(t){if(!t&&this.hi>>>31){var e=1+~this.lo>>>0,n=~this.hi>>>0;return e||(n=n+1>>>0),-(e+4294967296*n)}return this.lo+4294967296*this.hi},i.prototype.toLong=function(t){return r.Long?new r.Long(0|this.lo,0|this.hi,Boolean(t)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(t)}};var s=String.prototype.charCodeAt;i.fromHash=function(t){return t===a?o:new i((s.call(t,0)|s.call(t,1)<<8|s.call(t,2)<<16|s.call(t,3)<<24)>>>0,(s.call(t,4)|s.call(t,5)<<8|s.call(t,6)<<16|s.call(t,7)<<24)>>>0)},i.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},i.prototype.zzEncode=function(){var t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this},i.prototype.zzDecode=function(){var t=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this},i.prototype.length=function(){var t=this.lo,e=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0===n?0===e?t<16384?t<128?1:2:t<2097152?3:4:e<16384?e<128?5:6:e<2097152?7:8:n<128?9:10}},9693:function(t,e,n){"use strict";var r=e;function i(t,e,n){for(var r=Object.keys(e),i=0;i<r.length;++i)void 0!==t[r[i]]&&n||(t[r[i]]=e[r[i]]);return t}function o(t){function e(t,n){if(!(this instanceof e))return new e(t,n);Object.defineProperty(this,"message",{get:function(){return t}}),Error.captureStackTrace?Error.captureStackTrace(this,e):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),n&&i(this,n)}return(e.prototype=Object.create(Error.prototype)).constructor=e,Object.defineProperty(e.prototype,"name",{get:function(){return t}}),e.prototype.toString=function(){return this.name+": "+this.message},e}r.asPromise=n(4537),r.base64=n(7419),r.EventEmitter=n(9211),r.float=n(945),r.inquire=n(7199),r.utf8=n(4997),r.pool=n(6662),r.LongBits=n(1945),r.isNode=Boolean(void 0!==n.g&&n.g&&n.g.process&&n.g.process.versions&&n.g.process.versions.node),r.global=r.isNode&&n.g||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},r.isString=function(t){return"string"==typeof t||t instanceof String},r.isObject=function(t){return t&&"object"==typeof t},r.isset=r.isSet=function(t,e){var n=t[e];return!(null==n||!t.hasOwnProperty(e))&&("object"!=typeof n||(Array.isArray(n)?n.length:Object.keys(n).length)>0)},r.Buffer=function(){try{var t=r.inquire("buffer").Buffer;return t.prototype.utf8Write?t:null}catch(t){return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(t){return"number"==typeof t?r.Buffer?r._Buffer_allocUnsafe(t):new r.Array(t):r.Buffer?r._Buffer_from(t):"undefined"==typeof Uint8Array?t:new Uint8Array(t)},r.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(t){return t?r.LongBits.from(t).toHash():r.LongBits.zeroHash},r.longFromHash=function(t,e){var n=r.LongBits.fromHash(t);return r.Long?r.Long.fromBits(n.lo,n.hi,e):n.toNumber(Boolean(e))},r.merge=i,r.lcFirst=function(t){return t.charAt(0).toLowerCase()+t.substring(1)},r.newError=o,r.ProtocolError=o("ProtocolError"),r.oneOfGetter=function(t){for(var e={},n=0;n<t.length;++n)e[t[n]]=1;return function(){for(var t=Object.keys(this),n=t.length-1;n>-1;--n)if(1===e[t[n]]&&void 0!==this[t[n]]&&null!==this[t[n]])return t[n]}},r.oneOfSetter=function(t){return function(e){for(var n=0;n<t.length;++n)t[n]!==e&&delete this[t[n]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var t=r.Buffer;t?(r._Buffer_from=t.from!==Uint8Array.from&&t.from||function(e,n){return new t(e,n)},r._Buffer_allocUnsafe=t.allocUnsafe||function(e){return new t(e)}):r._Buffer_from=r._Buffer_allocUnsafe=null}},1173:(t,e,n)=>{"use strict";t.exports=p;var r,i=n(9693),o=i.LongBits,a=i.base64,s=i.utf8;function u(t,e,n){this.fn=t,this.len=e,this.next=void 0,this.val=n}function c(){}function l(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function p(){this.len=0,this.head=new u(c,0,0),this.tail=this.head,this.states=null}var f=function(){return i.Buffer?function(){return(p.create=function(){return new r})()}:function(){return new p}};function d(t,e,n){e[n]=255&t}function h(t,e){this.len=t,this.next=void 0,this.val=e}function g(t,e,n){for(;t.hi;)e[n++]=127&t.lo|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;t.lo>127;)e[n++]=127&t.lo|128,t.lo=t.lo>>>7;e[n++]=t.lo}function b(t,e,n){e[n]=255&t,e[n+1]=t>>>8&255,e[n+2]=t>>>16&255,e[n+3]=t>>>24}p.create=f(),p.alloc=function(t){return new i.Array(t)},i.Array!==Array&&(p.alloc=i.pool(p.alloc,i.Array.prototype.subarray)),p.prototype._push=function(t,e,n){return this.tail=this.tail.next=new u(t,e,n),this.len+=e,this},h.prototype=Object.create(u.prototype),h.prototype.fn=function(t,e,n){for(;t>127;)e[n++]=127&t|128,t>>>=7;e[n]=t},p.prototype.uint32=function(t){return this.len+=(this.tail=this.tail.next=new h((t>>>=0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this},p.prototype.int32=function(t){return t<0?this._push(g,10,o.fromNumber(t)):this.uint32(t)},p.prototype.sint32=function(t){return this.uint32((t<<1^t>>31)>>>0)},p.prototype.uint64=function(t){var e=o.from(t);return this._push(g,e.length(),e)},p.prototype.int64=p.prototype.uint64,p.prototype.sint64=function(t){var e=o.from(t).zzEncode();return this._push(g,e.length(),e)},p.prototype.bool=function(t){return this._push(d,1,t?1:0)},p.prototype.fixed32=function(t){return this._push(b,4,t>>>0)},p.prototype.sfixed32=p.prototype.fixed32,p.prototype.fixed64=function(t){var e=o.from(t);return this._push(b,4,e.lo)._push(b,4,e.hi)},p.prototype.sfixed64=p.prototype.fixed64,p.prototype.float=function(t){return this._push(i.float.writeFloatLE,4,t)},p.prototype.double=function(t){return this._push(i.float.writeDoubleLE,8,t)};var m=i.Array.prototype.set?function(t,e,n){e.set(t,n)}:function(t,e,n){for(var r=0;r<t.length;++r)e[n+r]=t[r]};p.prototype.bytes=function(t){var e=t.length>>>0;if(!e)return this._push(d,1,0);if(i.isString(t)){var n=p.alloc(e=a.length(t));a.decode(t,n,0),t=n}return this.uint32(e)._push(m,e,t)},p.prototype.string=function(t){var e=s.length(t);return e?this.uint32(e)._push(s.write,e,t):this._push(d,1,0)},p.prototype.fork=function(){return this.states=new l(this),this.head=this.tail=new u(c,0,0),this.len=0,this},p.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new u(c,0,0),this.len=0),this},p.prototype.ldelim=function(){var t=this.head,e=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=t.next,this.tail=e,this.len+=n),this},p.prototype.finish=function(){for(var t=this.head.next,e=this.constructor.alloc(this.len),n=0;t;)t.fn(t.val,e,n),n+=t.len,t=t.next;return e},p._configure=function(t){r=t,p.create=f(),r._configure()}},3155:(t,e,n)=>{"use strict";t.exports=o;var r=n(1173);(o.prototype=Object.create(r.prototype)).constructor=o;var i=n(9693);function o(){r.call(this)}function a(t,e,n){t.length<40?i.utf8.write(t,e,n):e.utf8Write?e.utf8Write(t,n):e.write(t,n)}o._configure=function(){o.alloc=i._Buffer_allocUnsafe,o.writeBytesBuffer=i.Buffer&&i.Buffer.prototype instanceof Uint8Array&&"set"===i.Buffer.prototype.set.name?function(t,e,n){e.set(t,n)}:function(t,e,n){if(t.copy)t.copy(e,n,0,t.length);else for(var r=0;r<t.length;)e[n++]=t[r++]}},o.prototype.bytes=function(t){i.isString(t)&&(t=i._Buffer_from(t,"base64"));var e=t.length>>>0;return this.uint32(e),e&&this._push(o.writeBytesBuffer,e,t),this},o.prototype.string=function(t){var e=i.Buffer.byteLength(t);return this.uint32(e),e&&this._push(a,e,t),this},o._configure()},7714:(t,e,n)=>{"use strict";e.R=void 0;const r=n(6919),i=n(7448);e.R=new class{async init(){}async createSessionHandler(t,e){const n=new r.Session(e);return await n.loadModel(t),new i.OnnxjsSessionHandler(n)}}},4200:(t,e,n)=>{"use strict";e.c8=e.rX=void 0;const r=n(1670),i=n(5381),o=n(2157),a=n(2306);e.rX=()=>{if(("number"!=typeof r.env.wasm.initTimeout||r.env.wasm.initTimeout<0)&&(r.env.wasm.initTimeout=0),"boolean"!=typeof r.env.wasm.simd&&(r.env.wasm.simd=!0),"boolean"!=typeof r.env.wasm.proxy&&(r.env.wasm.proxy=!1),"number"!=typeof r.env.wasm.numThreads||!Number.isInteger(r.env.wasm.numThreads)||r.env.wasm.numThreads<=0){const t="undefined"==typeof navigator?(0,i.cpus)().length:navigator.hardwareConcurrency;r.env.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},e.c8=new class{async init(){(0,e.rX)(),await(0,o.initWasm)()}async createSessionHandler(t,e){const n=new a.OnnxruntimeWebAssemblySessionHandler;return await n.loadModel(t,e),Promise.resolve(n)}}},6018:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__exportStar||function(t,e){for(var n in t)"default"===n||Object.prototype.hasOwnProperty.call(e,n)||r(e,t,n)};Object.defineProperty(e,"__esModule",{value:!0}),i(n(1670),e);const o=n(1670);{const t=n(7714).R;(0,o.registerBackend)("webgl",t,-10)}{const t=n(4200).c8;(0,o.registerBackend)("cpu",t,10),(0,o.registerBackend)("wasm",t,10),(0,o.registerBackend)("xnnpack",t,9)}},246:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createAttributeWithCacheKey=void 0;class n{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((t=>`${this[t]}`)).join(";")),this._cacheKey}}e.createAttributeWithCacheKey=t=>new n(t)},7778:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Attribute=void 0;const r=n(1446),i=n(9395),o=n(9162),a=n(2517);var s=i.onnxruntime.experimental.fbs;class u{constructor(t){if(this._attributes=new Map,null!=t){for(const e of t)e instanceof r.onnx.AttributeProto?this._attributes.set(e.name,[u.getValue(e),u.getType(e)]):e instanceof s.Attribute&&this._attributes.set(e.name(),[u.getValue(e),u.getType(e)]);if(this._attributes.size<t.length)throw new Error("duplicated attribute names")}}set(t,e,n){this._attributes.set(t,[n,e])}delete(t){this._attributes.delete(t)}getFloat(t,e){return this.get(t,"float",e)}getInt(t,e){return this.get(t,"int",e)}getString(t,e){return this.get(t,"string",e)}getTensor(t,e){return this.get(t,"tensor",e)}getFloats(t,e){return this.get(t,"floats",e)}getInts(t,e){return this.get(t,"ints",e)}getStrings(t,e){return this.get(t,"strings",e)}getTensors(t,e){return this.get(t,"tensors",e)}get(t,e,n){const r=this._attributes.get(t);if(void 0===r){if(void 0!==n)return n;throw new Error(`required attribute not found: ${t}`)}if(r[1]!==e)throw new Error(`type mismatch: expected ${e} but got ${r[1]}`);return r[0]}static getType(t){const e=t instanceof r.onnx.AttributeProto?t.type:t.type();switch(e){case r.onnx.AttributeProto.AttributeType.FLOAT:return"float";case r.onnx.AttributeProto.AttributeType.INT:return"int";case r.onnx.AttributeProto.AttributeType.STRING:return"string";case r.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case r.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case r.onnx.AttributeProto.AttributeType.INTS:return"ints";case r.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case r.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[e]}`)}}static getValue(t){const e=t instanceof r.onnx.AttributeProto?t.type:t.type();if(e===r.onnx.AttributeProto.AttributeType.GRAPH||e===r.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const n=this.getValueNoCheck(t);if(e===r.onnx.AttributeProto.AttributeType.INT&&a.LongUtil.isLong(n))return a.LongUtil.longToNumber(n);if(e===r.onnx.AttributeProto.AttributeType.INTS){const t=n,e=new Array(t.length);for(let n=0;n<t.length;n++){const r=t[n];e[n]=a.LongUtil.longToNumber(r)}return e}if(e===r.onnx.AttributeProto.AttributeType.TENSOR)return t instanceof r.onnx.AttributeProto?o.Tensor.fromProto(n):o.Tensor.fromOrtTensor(n);if(e===r.onnx.AttributeProto.AttributeType.TENSORS){if(t instanceof r.onnx.AttributeProto)return n.map((t=>o.Tensor.fromProto(t)));if(t instanceof s.Attribute)return n.map((t=>o.Tensor.fromOrtTensor(t)))}if(e===r.onnx.AttributeProto.AttributeType.STRING&&t instanceof r.onnx.AttributeProto){const t=n;return(0,a.decodeUtf8String)(t)}return e===r.onnx.AttributeProto.AttributeType.STRINGS&&t instanceof r.onnx.AttributeProto?n.map(a.decodeUtf8String):n}static getValueNoCheck(t){return t instanceof r.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(t):this.getValueNoCheckFromOrtFormat(t)}static getValueNoCheckFromOnnxFormat(t){switch(t.type){case r.onnx.AttributeProto.AttributeType.FLOAT:return t.f;case r.onnx.AttributeProto.AttributeType.INT:return t.i;case r.onnx.AttributeProto.AttributeType.STRING:return t.s;case r.onnx.AttributeProto.AttributeType.TENSOR:return t.t;case r.onnx.AttributeProto.AttributeType.GRAPH:return t.g;case r.onnx.AttributeProto.AttributeType.FLOATS:return t.floats;case r.onnx.AttributeProto.AttributeType.INTS:return t.ints;case r.onnx.AttributeProto.AttributeType.STRINGS:return t.strings;case r.onnx.AttributeProto.AttributeType.TENSORS:return t.tensors;case r.onnx.AttributeProto.AttributeType.GRAPHS:return t.graphs;default:throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[t.type]}`)}}static getValueNoCheckFromOrtFormat(t){switch(t.type()){case s.AttributeType.FLOAT:return t.f();case s.AttributeType.INT:return t.i();case s.AttributeType.STRING:return t.s();case s.AttributeType.TENSOR:return t.t();case s.AttributeType.GRAPH:return t.g();case s.AttributeType.FLOATS:return t.floatsArray();case s.AttributeType.INTS:{const e=[];for(let n=0;n<t.intsLength();n++)e.push(t.ints(n));return e}case s.AttributeType.STRINGS:{const e=[];for(let n=0;n<t.stringsLength();n++)e.push(t.strings(n));return e}case s.AttributeType.TENSORS:{const e=[];for(let n=0;n<t.tensorsLength();n++)e.push(t.tensors(n));return e}default:throw new Error(`unsupported attribute type: ${s.AttributeType[t.type()]}`)}}}e.Attribute=u},7091:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.resolveBackend=e.backend=void 0;const r=n(5038),i=new Map;async function o(t){const n=e.backend;if(void 0!==n[t]&&function(t){const e=t;return"initialize"in e&&"function"==typeof e.initialize&&"createSessionHandler"in e&&"function"==typeof e.createSessionHandler&&"dispose"in e&&"function"==typeof e.dispose}(n[t])){const e=n[t];let r=e.initialize();if("object"==typeof r&&"then"in r&&(r=await r),r)return i.set(t,e),e}}e.backend={webgl:new r.WebGLBackend},e.resolveBackend=async function t(e){if(!e)return t(["webgl"]);{const t="string"==typeof e?[e]:e;for(const e of t){const t=i.get(e);if(t)return t;const n=await o(e);if(n)return n}}throw new Error("no available backend to use")}},5038:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLBackend=void 0;const r=n(1670),i=n(6231),o=n(6416),a=n(7305);e.WebGLBackend=class{get contextId(){return r.env.webgl.contextId}set contextId(t){r.env.webgl.contextId=t}get matmulMaxBatchSize(){return r.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(t){r.env.webgl.matmulMaxBatchSize=t}get textureCacheMode(){return r.env.webgl.textureCacheMode}set textureCacheMode(t){r.env.webgl.textureCacheMode=t}get pack(){return r.env.webgl.pack}set pack(t){r.env.webgl.pack=t}get async(){return r.env.webgl.async}set async(t){r.env.webgl.async=t}initialize(){try{return this.glContext=(0,a.createWebGLContext)(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),i.Logger.setWithEnv(r.env),i.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(t){return i.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${t}`),!1}}createSessionHandler(t){return new o.WebGLSessionHandler(this,t)}dispose(){this.glContext.dispose()}}},5107:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.CoordsGlslLib=void 0;const r=n(2517),i=n(8520),o=n(5060),a=n(7859),s=n(9390);class u extends i.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new i.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new i.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){const t=this.context.outputTextureLayout;return t.isPacked?this.getPackedOutputSamplingSnippet(t):this.getUnpackedOutputSamplingSnippet(t)}getPackedOutputSamplingSnippet(t){const e=t.unpackedShape,n=[t.width,t.height],r={},a="getOutputCoords";switch(e.length){case 0:r[a]=this.getOutputScalarCoords();break;case 1:r[a]=this.getOutputPacked1DCoords(e,n);break;case 2:r[a]=this.getOutputPacked2DCoords(e,n);break;case 3:r[a]=this.getOutputPacked3DCoords(e,n);break;default:r[a]=this.getOutputPackedNDCoords(e,n)}const s=`\n      void setOutput(vec4 val) {\n        ${(0,o.getGlsl)(this.context.glContext.version).output} = val;\n      }\n    `;return r.floatTextureSetRGBA=new i.GlslLibRoutine(s),r}getUnpackedOutputSamplingSnippet(t){const e=t.unpackedShape,n=[t.width,t.height],r={},a="getOutputCoords";switch(e.length){case 0:r[a]=this.getOutputScalarCoords();break;case 1:r[a]=this.getOutputUnpacked1DCoords(e,n);break;case 2:r[a]=this.getOutputUnpacked2DCoords(e,n);break;case 3:r[a]=this.getOutputUnpacked3DCoords(e,n);break;case 4:r[a]=this.getOutputUnpacked4DCoords(e,n);break;case 5:r[a]=this.getOutputUnpacked5DCoords(e,n);break;case 6:r[a]=this.getOutputUnpacked6DCoords(e,n);break;default:throw new Error(`Unsupported output dimensionality: ${e.length}`)}const s=`\n        void setOutput(float val) {\n          ${(0,o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `;return r.floatTextureSetR=new i.GlslLibRoutine(s),r}getOutputScalarCoords(){return new i.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(t,e){const n=e;let r="";return 1===n[0]?(r=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${n[1]}.0);\n          }\n        `,new i.GlslLibRoutine(r)):1===n[1]?(r=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${n[0]}.0);\n          }\n        `,new i.GlslLibRoutine(r)):(r=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${n[0]}, ${n[1]}));\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\n        }\n      `,new i.GlslLibRoutine(r))}getOutputPacked2DCoords(t,e){let n="";if(r.ArrayUtil.arraysEqual(t,e))return n=`\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${e[0]}, ${e[1]}));\n        }\n      `,new i.GlslLibRoutine(n);const o=e,a=Math.ceil(t[1]/2);return n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${o[0]}, ${o[1]}));\n\n          int index = resTexRC.y * ${o[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${a}) * 2;\n          int c = 2 * (index / ${a});\n\n          return ivec2(r, c);\n        }\n      `,new i.GlslLibRoutine(n)}getOutputPacked3DCoords(t,e){const n=[e[0],e[1]],r=Math.ceil(t[2]/2),o=r*Math.ceil(t[1]/2),a=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${n[0]}, ${n[1]}));\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n          int b = index / ${o};\n          index -= b * ${o};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${r}) * 2;\n          int c = 2 * (index / ${r});\n\n          return ivec3(b, r, c);\n        }\n      `;return new i.GlslLibRoutine(a)}getOutputPackedNDCoords(t,e){const n=[e[0],e[1]],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2);let a=o,s="",u="b, r, c";for(let e=2;e<t.length-1;e++)a*=t[t.length-e-1],s=`\n      int b${e} = index / ${a};\n      index -= b${e} * ${a};\n    `+s,u=`b${e}, `+u;const c=`\n      ivec${t.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n        ${s}\n\n        int b = index / ${o};\n        index -= b * ${o};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${r}) * 2;\n        int c = 2 * (index / ${r});\n\n        return ivec${t.length}(${u});\n      }\n    `;return new i.GlslLibRoutine(c)}getOutputUnpacked1DCoords(t,e){const n=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          return resTexRC.y * ${e[0]} + resTexRC.x;\n        }\n      `;return new i.GlslLibRoutine(n)}getOutputUnpacked2DCoords(t,e){const n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          int r = index / ${t[1]};\n          int c = index - r * ${t[1]};\n          return ivec2(r, c);\n        }\n      `;return new i.GlslLibRoutine(n)}getOutputUnpacked3DCoords(t,e){let n="";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=["r","c","d"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join("");return n=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          ${s}\n          return ivec3(r, c, d);\n        }\n      `,new i.GlslLibRoutine(n)}getOutputUnpacked4DCoords(t,e){let n="";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=["r","c","d","d2"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join("");return n=`\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          ${s}\n          return ivec4(r, c, d, d2);\n        }\n      `,new i.GlslLibRoutine(n)}getOutputUnpacked5DCoords(t,e){let n="";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=["r","c","d","d2","d3"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join("");return n=`\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${e[0]}, ${e[1]}));\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\n          ${s}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `,new i.GlslLibRoutine(n)}getOutputUnpacked6DCoords(t,e){let n="";const r=t.length;let o=null;r<2&&(o=[]),o=new Array(r-1),o[r-2]=t[r-1];for(let e=r-3;e>=0;--e)o[e]=o[e+1]*t[e+1];const a=["r","c","d","d2","d3","d4"],s=o.map(((t,e)=>`int ${a[e]} = index / ${t}; ${e===o.length-1?`int ${a[e+1]} = index - ${a[e]} * ${t}`:`index -= ${a[e]} * ${t}`};`)).join("");return n=`\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${e[0]}, ${e[1]}));\n         int index = resTexRC.y * ${e[0]} + resTexRC.x;\n         ${s}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `,new i.GlslLibRoutine(n)}getCommonUtilFuncs(){const t={};let e="uvFromFlat";t[e]=new i.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),e="packedUVfrom1D",t[e]=new i.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),e="packedUVfrom2D",t[e]=new i.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),e="packedUVfrom3D",t[e]=new i.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),e="sampleTexture";const n=(0,o.getGlsl)(this.context.glContext.version);return t[e]=new i.GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${n.texture2D}(textureSampler, uv).r;\n        }`),t}getInputsSamplingSnippets(){const t={},e=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach(((n,r)=>{const i=this.context.inputTextureLayouts[r],o=(0,s.generateShaderFuncNameFromInputSamplerName)(n);i.isPacked?t[o]=this.getPackedSamplerFromInput(o,n,i):t[o]=this.getUnpackedSamplerFromInput(o,n,i);const a=(0,s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n);i.unpackedShape.length<=e.unpackedShape.length&&(i.isPacked?t[a]=this.getPackedSamplerAtOutputCoords(a,i,e,n):t[a]=this.getUnpackedSamplerAtOutputCoords(a,i,e,n))})),t}getPackedSamplerAtOutputCoords(t,e,n,o){const a=e.unpackedShape,u=n.unpackedShape,c=o,l=(0,s.generateShaderFuncNameFromInputSamplerName)(c),p=a.length,f=u.length,d=r.BroadcastUtil.getBroadcastDims(a,u),h=(0,s.getCoordsDataType)(f),g=f-p;let b;const m=(0,s.getGlChannels)();b=0===p?"":f<2&&d.length>=1?"coords = 0;":d.map((t=>`coords.${m[t+g]} = 0;`)).join("\n");let y="";y=f<2&&p>0?"coords":a.map(((t,e)=>`coords.${m[e+g]}`)).join(", ");let _="return outputValue;";const v=1===r.ShapeUtil.size(a),w=1===r.ShapeUtil.size(u);if(1!==p||v||w){if(v&&!w)_=1===f?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(d.length){const t=p-2,e=p-1;d.indexOf(t)>-1&&d.indexOf(e)>-1?_="return vec4(outputValue.x);":d.indexOf(t)>-1?_="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":d.indexOf(e)>-1&&(_="return vec4(outputValue.xx, outputValue.zz);")}}else _="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";const x=`\n      vec4 ${t}() {\n        ${h} coords = getOutputCoords();\n        \n        int lastDim = coords.${m[f-1]};\n        coords.${m[f-1]} = coords.${m[f-2]};\n        coords.${m[f-2]} = lastDim;\n      \n        ${b}\n        vec4 outputValue = ${l}(${y});\n        ${_}\n      }\n    `;return new i.GlslLibRoutine(x,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(t,e,n,o){const a=[n.width,n.height],u=[e.width,e.height],c=e.unpackedShape.length,l=n.unpackedShape.length,p=e.unpackedShape,f=n.unpackedShape,d=(0,s.generateShaderFuncNameFromInputSamplerName)(o);if(c===l&&r.ArrayUtil.arraysEqual(u,a)){const e=`\n          float ${t}() {\n            return sampleTexture(${o}, TexCoords);\n          }\n        `;return new i.GlslLibRoutine(e,["coordinates.sampleTexture"])}const h=(0,s.getCoordsDataType)(l),g=r.BroadcastUtil.getBroadcastDims(p,f),b=l-c;let m;const y=(0,s.getGlChannels)();m=0===c?"":l<2&&g.length>=1?"coords = 0;":g.map((t=>`coords.${y[t+b]} = 0;`)).join("\n");let _="";_=l<2&&c>0?"coords":e.unpackedShape.map(((t,e)=>`coords.${y[e+b]}`)).join(", ");const v=`\n        float ${t}() {\n          ${h} coords = getOutputCoords();\n          ${m}\n          return ${d}(${_});\n        }\n      `;return new i.GlslLibRoutine(v,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(t,e,n){switch(n.unpackedShape.length){case 0:return this.getPackedSamplerScalar(t,e);case 1:return this.getPackedSampler1D(t,e,n);case 2:return this.getPackedSampler2D(t,e,n);case 3:return this.getPackedSampler3D(t,e,n);default:return this.getPackedSamplerND(t,e,n)}}getUnpackedSamplerFromInput(t,e,n){const r=n.unpackedShape;switch(r.length){case 0:return this.getUnpackedSamplerScalar(t,e,n);case 1:return this.getUnpackedSampler1D(t,e,n);case 2:return this.getUnpackedSampler2D(t,e,n);case 3:return this.getUnpackedSampler3D(t,e,n);case 4:return this.getUnpackedSampler4D(t,e,n);case 5:return this.getUnpackedSampler5D(t,e,n);case 6:return this.getUnpackedSampler6D(t,e,n);default:throw new Error(`Unsupported dimension ${r.length}-D`)}}getPackedSamplerScalar(t,e){const n=`\n          vec4 ${t}() {\n            return ${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${e}, halfCR);\n          }\n        `;return new i.GlslLibRoutine(n)}getPackedSampler1D(t,e,n){const r=[n.width,n.height],a=[r[1],r[0]],s=(0,o.getGlsl)(this.context.glContext.version),u=`vec4 ${t}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${a[0]}, ${a[1]}, index);\n      return ${s.texture2D}(${e}, uv);\n    }`;return new i.GlslLibRoutine(u,["coordinates.packedUVfrom1D"])}getPackedSampler2D(t,e,n){const a=n.unpackedShape,s=[n.width,n.height],u=(0,o.getGlsl)(this.context.glContext.version),c=s[0],l=s[1];if(null!=s&&r.ArrayUtil.arraysEqual(a,s)){const n=`vec4 ${t}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${c}.0);\n        return ${u.texture2D}(${e}, uv);\n      }`;return new i.GlslLibRoutine(n)}const p=s,f=Math.ceil(a[1]/2),d=`vec4 ${t}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${f}, row, col);\n      return ${u.texture2D}(${e}, uv);\n    }`;return new i.GlslLibRoutine(d,["coordinates.packedUVfrom2D"])}getPackedSampler3D(t,e,n){const r=n.unpackedShape,a=[n.width,n.height],u=[a[0],a[1]],c=(0,o.getGlsl)(this.context.glContext.version);if(1===r[0]){const o=r.slice(1),a=[1,2],u=(0,s.squeezeInputShape)(r,o),c=["b","row","col"],l=JSON.parse(JSON.stringify(n));l.unpackedShape=u;const p=this.getPackedSamplerFromInput(t,e,l),f=`${p.routineBody}\n      vec4 ${t}(int b, int row, int col) {\n        return ${t}(${(0,s.getSqueezedParams)(c,a)});\n      } `;return new i.GlslLibRoutine(f,p.dependencies)}const l=u[0],p=u[1],f=Math.ceil(r[2]/2),d=`vec4 ${t}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${p}, ${l}, ${f*Math.ceil(r[1]/2)}, ${f}, b, row, col);\n      return ${c.texture2D}(${e}, uv);}`;return new i.GlslLibRoutine(d,["coordinates.packedUVfrom3D"])}getPackedSamplerND(t,e,n){const r=n.unpackedShape,a=r.length,s=[n.width,n.height],u=(0,o.getGlsl)(this.context.glContext.version),c=[s[0],s[1]],l=c[1],p=c[0],f=Math.ceil(r[a-1]/2);let d=f*Math.ceil(r[a-2]/2),h="int b, int row, int col",g=`b * ${d} + (row / 2) * ${f} + (col / 2)`;for(let t=2;t<a-1;t++)h=`int b${t}, `+h,d*=r[a-t-1],g=`b${t} * ${d} + `+g;const b=`vec4 ${t}(${h}) {\n      int index = ${g};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});\n      return ${u.texture2D}(${e}, uv);\n    }`;return new i.GlslLibRoutine(b)}getUnpackedSamplerScalar(t,e,n){const[r,o]=[n.width,n.height];if(1===r&&1===o){const n=`\n          float ${t}() {\n            return sampleTexture(${e}, halfCR);\n          }\n        `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture"])}const a=`\n        float ${t}() {\n          int offset_${e} = coordsToOffset(TexCoords, ${r}, ${o});\n          vec2 uv = uvFromFlat(${r}, ${o}, offset_${e});\n          return sampleTexture(${e}, uv);\n        }\n      `;return new i.GlslLibRoutine(a,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(t,e,n){const r=n.width,o=n.height;if(1===o&&1===r){const n=`\n        float ${t}(int index) {\n          return sampleTexture(${e}, halfCR);\n        }\n      `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture"])}if(1===o){const n=`\n          float ${t}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture"])}if(1===r){const n=`\n          float ${t}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o}.0);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture"])}const a=`\n        float ${t}(int index) {\n          vec2 uv = uvFromFlat(${r}, ${o}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new i.GlslLibRoutine(a,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(t,e,n){const o=n.unpackedShape,u=[n.height,n.width];if(null!=u&&r.ArrayUtil.arraysEqual(o,u)){const n=`\n          float ${t}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u[1]}.0, ${u[0]}.0);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture"])}const{newShape:c,keptDims:l}=(0,a.squeezeShape)(o),p=c;if(p.length<o.length){const r=(0,s.squeezeInputShape)(o,p),a=JSON.parse(JSON.stringify(n));a.unpackedShape=r;const u=["col","row"],c=`\n          ${this.getUnpackedSamplerFromInput(t,e,a).routineBody}\n          float ${t}(int row, int col) {\n            return ${t}(${(0,s.getSqueezedParams)(u,l)});\n          }\n        `;return new i.GlslLibRoutine(c,["coordinates.sampleTexture"])}const f=u[1],d=u[0];if(1===d){const n=`\n          float ${t}(int row, int col) {\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${d});\n            float index = dot(vec3(row, col, offset_${e}), vec3(${o[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(1===f){const n=`\n          float ${t}(int row, int col) {\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${d});\n            float index = dot(vec3(row, col, offset_${e}), vec3(${o[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new i.GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const h=`\n        float ${t}(int row, int col) {\n          int index = col * ${o[1]} + row;\n          vec2 uv = uvFromFlat(${f}, ${d}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new i.GlslLibRoutine(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(t,e,n){const r=n.unpackedShape,o=r[1]*r[2],u=r[2],{newShape:c,keptDims:l}=(0,a.squeezeShape)(r),p=c;if(p.length<r.length){const o=(0,s.squeezeInputShape)(r,p),a=["batch","col","row"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=o;const c=this.getUnpackedSamplerFromInput(t,e,u),f=l.reverse(),d=`\n          ${c.routineBody}\n          float ${t}(int batch, int row, int col) {\n            return ${t}(${(0,s.getSqueezedParams)(a,f)});\n          }\n        `;return new i.GlslLibRoutine(d,c.dependencies)}const f=`\n          float ${t}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${o} + col * ${u} + row;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${e}, uv);\n          }\n      `;return new i.GlslLibRoutine(f,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(t,e,n){const r=n.unpackedShape,o=r[3],a=r[2]*o,s=`\n        float ${t}(int row, int col, int depth, int depth2) {\n          int index = row * ${r[1]*a} + col * ${a} +\n              depth2 * ${o} + depth;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new i.GlslLibRoutine(s,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(t,e,n){const r=n.unpackedShape,o=r[4],u=r[3]*o,c=r[2]*u,l=r[1]*c,{newShape:p,keptDims:f}=(0,a.squeezeShape)(r);if(p.length<r.length){const o=(0,s.squeezeInputShape)(r,p),a=["row","col","depth","depth2","depth3"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=o;const c=`\n          ${this.getUnpackedSamplerFromInput(t,e,u).routineBody}\n          float ${t}(int row, int col, int depth, int depth2, int depth3) {\n            return ${t}(${(0,s.getSqueezedParams)(a,f)});\n          }\n        `;return new i.GlslLibRoutine(c,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const d=`\n        float ${t}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${l} + col * ${c} + depth * ${u} +\n          depth3 * ${o} + depth2;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${e}, uv);\n        }\n      `;return new i.GlslLibRoutine(d,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(t,e,n){const r=n.unpackedShape,o=r[5],u=r[4]*o,c=r[3]*u,l=r[2]*c,p=r[1]*l,{newShape:f,keptDims:d}=(0,a.squeezeShape)(r);if(f.length<r.length){const o=(0,s.squeezeInputShape)(r,f),a=["row","col","depth","depth2","depth3","depth4"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=o;const c=`\n            ${this.getUnpackedSamplerFromInput(t,e,u).routineBody}\n            float ${t}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${t}(${(0,s.getSqueezedParams)(a,d)});\n            }\n          `;return new i.GlslLibRoutine(c,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const h=`\n          float ${t}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${p} + col * ${l} + depth * ${c} +\n            depth2 * ${u} + depth3 * ${o} + depth4;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${e}, uv);\n          }\n        `;return new i.GlslLibRoutine(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const t=this.context.outputTextureLayout,e=t.shape.length,n=t.strides,r=t.width,o=t.height,a=[];for(let t=0;t<e-1;++t)a.push(`\n        c[${t}] = offset / ${n[t]};`),a.push(`\n        offset -= c[${t}] * ${n[t]};`);a.push(`\n        c[${e-1}] = offset;`);const s=`\n      void toVec(vec2 texCoords, out int c[${e}]) {\n        int offset = coordsToOffset(texCoords, ${r}, ${o});\n        ${a.join("")}\n      }\n      void toVec(int offset, out int c[${e}]) {\n        ${a.join("")}\n      }\n    `;return{toVec:new i.GlslLibRoutine(s,["coordinates.coordsToOffset"])}}valueFrom(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const r=this.context.inputTextureLayouts[n],o=(r.unpackedShape.length>0?r.unpackedShape:r.shape).length;let a=`_${e}`;t[a]=new i.GlslLibRoutine(this.getValueFromSingle(e,o,r.width,r.height,!1),[`shapeUtils.indicesToOffset${a}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),a+="_T",t[a]=new i.GlslLibRoutine(this.getValueFromSingle(e,o,r.width,r.height,!0),[`shapeUtils.indicesToOffset${a}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])})),t}getValueFromSingle(t,e,n,r,i){let a=`_${t}`;return i&&(a+="_T"),`\n        float ${a}(int m[${e}]) {\n          int offset = indicesToOffset${a}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          float value = getColorAsFloat(${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${t}, coords));\n          return value;\n        }\n        `}getPackedValueFrom(t,e,n,r,i){let a=`_${t}_Pack`;return i&&(a+="_T"),`\n        vec4 ${a}(int m[${e}]) {\n          int offset = indicesToOffset_${t}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          return ${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${t}, coords);\n        }\n        `}}e.CoordsGlslLib=u},8520:(t,e)=>{"use strict";var n;Object.defineProperty(e,"__esModule",{value:!0}),e.TopologicalSortGlslRoutines=e.GlslLibRoutineNode=e.GlslLibRoutine=e.GlslLib=e.GlslContext=e.FunctionType=void 0,(n=e.FunctionType||(e.FunctionType={}))[n.ValueBased=0]="ValueBased",n[n.Positional=1]="Positional",e.GlslContext=class{constructor(t,e,n,r){this.glContext=t,this.programInfo=e,this.inputTextureLayouts=n,this.outputTextureLayout=r}},e.GlslLib=class{constructor(t){this.context=t}},e.GlslLibRoutine=class{constructor(t,e){this.routineBody=t,this.dependencies=e}},e.GlslLibRoutineNode=class{constructor(t,e,n){this.name=t,this.dependencies=n||[],e&&(this.routineBody=e)}addDependency(t){t&&this.dependencies.push(t)}},e.TopologicalSortGlslRoutines=class{static returnOrderedNodes(t){if(!t||0===t.length)return[];if(1===t.length)return t;const e=new Set,n=new Set,r=new Array;return this.createOrderedNodes(t,e,n,r),r}static createOrderedNodes(t,e,n,r){for(let i=0;i<t.length;++i)this.dfsTraverse(t[i],e,n,r)}static dfsTraverse(t,e,n,r){if(!t||n.has(t.name))return;if(e.has(t.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");e.add(t.name);const i=t.dependencies;if(i&&i.length>0)for(let t=0;t<i.length;++t)this.dfsTraverse(i[t],e,n,r);r.push(t),n.add(t.name),e.delete(t.name)}}},7341:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.EncodingGlslLib=void 0;const r=n(8520);class i extends r.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){const t=i.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new r.GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${t}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)}}decodeUint8(){const t=i.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new r.GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${t}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)}}static isLittleEndian(){const t=new ArrayBuffer(4),e=new Uint32Array(t),n=new Uint8Array(t);if(e[0]=3735928559,239===n[0])return!0;if(222===n[0])return!1;throw new Error("unknown endianness")}}e.EncodingGlslLib=i},9894:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.FragColorGlslLib=void 0;const r=n(8520),i=n(5060);class o extends r.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const t=(0,i.getGlsl)(this.context.glContext.version);return{setFragColor:new r.GlslLibRoutine(`\n        void setFragColor(float value) {\n            ${t.output} = encode(value);\n        }\n        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}e.FragColorGlslLib=o},2848:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.replaceInlines=void 0;const n=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;e.replaceInlines=function(t){const e={};let r;for(;null!==(r=n.exec(t));){const t=r[3].split(",").map((t=>{const e=t.trim().split(" ");return e&&2===e.length?{type:e[0],name:e[1]}:null})).filter((t=>null!==t));e[r[2]]={params:t,body:r[4]}}for(const n in e){const i="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",n),o=new RegExp(i,"gm");for(;null!==(r=o.exec(t));){const i=r[1],o=r[2],a=r[3].split(","),s=i?`${i} ${o};`:"";let u=e[n].body,c="";e[n].params.forEach(((t,e)=>{t&&(c+=`${t.type} ${t.name} = ${a[e]};\n`)})),u=`${c}\n ${u}`,u=u.replace("return",`${o} = `);const l=`\n      ${s}\n      {\n        ${u}\n      }\n      `;t=t.replace(r[0],l)}}return t.replace(n,"")}},8879:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.GlslPreprocessor=void 0;const r=n(8520),i=n(2848),o=n(5483),a=n(5060);e.GlslPreprocessor=class{constructor(t,e,n,i){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new r.GlslContext(t,e,n,i),Object.keys(o.glslRegistry).forEach((t=>{const e=new o.glslRegistry[t](this.context);this.libs[t]=e}));const a=this.glslLibRoutineDependencyGraph;for(const t in this.libs){const e=this.libs[t].getFunctions();for(const n in e){const i=t+"."+n;let o;a[i]?(o=a[i],o.routineBody=e[n].routineBody):(o=new r.GlslLibRoutineNode(i,e[n].routineBody),a[i]=o);const s=e[n].dependencies;if(s)for(let t=0;t<s.length;++t)if(a[s[t]])o.addDependency(a[s[t]]);else{const e=new r.GlslLibRoutineNode(s[t]);a[s[t]]=e,o.addDependency(e)}}}}preprocess(){const t=this.context.programInfo;let e=t.shaderSource;return this.context.programInfo.hasMain||(e=`${e}\n      ${(0,a.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),e=(0,i.replaceInlines)(e),`${(0,a.getFragShaderPreamble)(this.context.glContext.version)}\n    ${this.getUniforms(t.inputNames,t.variables)}\n    ${this.getImports(e)}\n    ${e}`}getImports(t){const e=this.selectGlslLibRoutinesToBeIncluded(t);if(0===e.length)return"";let n="";for(let t=0;t<e.length;++t){if(!e[t].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${e[t].name}`);n+=e[t].routineBody+"\n"}return n}selectGlslLibRoutinesToBeIncluded(t){const e=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n=>{const r=n.split(".")[1];-1!==t.indexOf(r)&&e.push(this.glslLibRoutineDependencyGraph[n])})),r.TopologicalSortGlslRoutines.returnOrderedNodes(e)}getUniforms(t,e){const n=[];if(t)for(const e of t)n.push(`uniform sampler2D ${e};`);if(e)for(const t of e)n.push(`uniform ${t.type} ${t.name}${t.arrayLength?`[${t.arrayLength}]`:""};`);return n.join("\n")}}},5483:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.glslRegistry=void 0;const r=n(5107),i=n(7341),o=n(9894),a=n(2655),s=n(3891);e.glslRegistry={encoding:i.EncodingGlslLib,fragcolor:o.FragColorGlslLib,vec:s.VecGlslLib,shapeUtils:a.ShapeUtilsGlslLib,coordinates:r.CoordsGlslLib}},2655:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ShapeUtilsGlslLib=void 0;const r=n(8520);class i extends r.GlslLib{constructor(t){super(t)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const t=this.context.outputTextureLayout.shape.length,e={};return this.context.programInfo.inputNames.forEach(((n,i)=>{const o=this.context.inputTextureLayouts[i].unpackedShape;if(o.length<=t){const i=o.length,a=t-i,s=`bcastIndices_${n}`;let u="";for(let t=0;t<i;++t)u+=`\n          realIndices[${t}] = int( mod(float(bcastedIndices[${a+t}]), ${o[t]}.0) );\n          `;const c=`\n        void ${s} (int bcastedIndices[${t}], out int realIndices[${i}]) {\n          ${u}\n        }\n        `;e[s]=new r.GlslLibRoutine(c)}})),e}bcastMatmulIndex(){const t=this.context.outputTextureLayout.shape.length,e={};return this.context.programInfo.inputNames.forEach(((n,i)=>{const o=this.context.inputTextureLayouts[i].shape;if(!(o.length<2||o.length>t)){const i=o.length,a=t-i,s=`bcastMatmulIndices_${n}`;let u="";for(let t=0;t<i-2;++t)u+=`\n          realIndices[${t}] = int( mod(float(bcastedIndices[${a+t}]), ${o[t]}.0) );\n          `;const c=`\n        void ${s}(int bcastedIndices[${t}], out int realIndices[${i}]) {\n          ${u}\n          realIndices[${i-1}] = bcastedIndices[${t-1}];\n          realIndices[${i-2}] = bcastedIndices[${t-2}];\n        }\n        `;e[s]=new r.GlslLibRoutine(c)}})),e}indicesToOffset(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const o=this.context.inputTextureLayouts[n].shape,a=this.context.inputTextureLayouts[n].strides,s=o.length;let u=`indicesToOffset_${e}`;t[u]=new r.GlslLibRoutine(i.indexToOffsetSingle(u,s,a)),u=`indicesToOffset_${e}_T`,t[u]=new r.GlslLibRoutine(i.indexToOffsetSingle(u,s,a.slice().reverse()))})),t}static indexToOffsetSingle(t,e,n){let r="";for(let t=e-1;t>=0;--t)r+=`\n        offset += indices[${t}] * ${n[t]};\n        `;return`\n      int ${t}(int indices[${e}]) {\n        int offset = 0;\n        ${r}\n        return offset;\n      }\n      `}offsetToIndices(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const o=this.context.inputTextureLayouts[n].shape,a=this.context.inputTextureLayouts[n].strides,s=o.length;let u=`offsetToIndices_${e}`;t[u]=new r.GlslLibRoutine(i.offsetToIndicesSingle(u,s,a)),u=`offsetToIndices_${e}_T`,t[u]=new r.GlslLibRoutine(i.offsetToIndicesSingle(u,s,a.slice().reverse()))})),t}static offsetToIndicesSingle(t,e,n){const r=[];for(let t=0;t<e-1;++t)r.push(`\n      indices[${t}] = offset / ${n[t]};`),r.push(`\n        offset -= indices[${t}] * ${n[t]};`);return r.push(`\n      indices[${e-1}] = offset;`),`\n      void ${t}(int offset, out int indices[${e}]) {\n        ${r.join("")}\n      }\n      `}incrementIndices(){const t={};return this.context.programInfo.inputNames.forEach(((e,n)=>{const i=this.context.inputTextureLayouts[n].shape,o=i.length,a=`incrementIndices_${e}`;let s="";for(let t=0;t<o;++t)s+=`\n        shape[${t}] = ${i[t]};`;const u=`\n        void ${a}(int axis, out int indices[${o}]) {\n          int shape[${o}];\n          ${s};\n          for(int i = ${o} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;t[a]=new r.GlslLibRoutine(u)})),t}}e.ShapeUtilsGlslLib=i},5060:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getDefaultFragShaderMain=e.getFragShaderPreamble=e.getVertexShaderSource=e.getGlsl=void 0;const n={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},r={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function i(t){return 1===t?n:r}e.getGlsl=i,e.getVertexShaderSource=function(t){const e=i(t);return`${e.version}\n      precision highp float;\n      ${e.attribute} vec3 position;\n      ${e.attribute} vec2 textureCoord;\n\n      ${e.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`},e.getFragShaderPreamble=function(t){const e=i(t);return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFrag} vec2 TexCoords;\n    ${e.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `},e.getDefaultFragShaderMain=function(t,e){return`\n  void main() {\n    int indices[${e}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${i(t).output} = result;\n  }\n  `}},3891:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.VecGlslLib=void 0;const r=n(8520);class i extends r.GlslLib{constructor(t){super(t)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const t=this.context.outputTextureLayout.shape.length,e={add:"+=",sub:"-=",mul:"*=",div:"/="},n={};for(const i in e){const o=`${i}Vec`;let a="";for(let n=0;n<t;++n)a+=`\n          dest[${n}] ${e[i]} src[${n}];\n          `;const s=`\n        void ${o}(int src[${t}], out int dest[${t}]) {\n          ${a}\n        }\n        `;n[o]=new r.GlslLibRoutine(s)}return n}copyVec(){const t=this.context.outputTextureLayout.shape.length;let e="";for(let n=0;n<t;++n)e+=`\n        dest[${n}] = src[${n}];\n        `;const n=`\n      void copyVec(int src[${t}], out int dest[${t}]) {\n        ${e}\n      }\n      `;return{copyVec:new r.GlslLibRoutine(n)}}setVecItem(){const t=this.context.outputTextureLayout.shape.length;let e=`\n        if(index < 0)\n            index =${t} + index;\n        if (index == 0)\n            m[0] = value;\n        `;for(let n=1;n<t-1;++n)e+=`\n        else if (index == ${n})\n            m[${n}] = value;\n            `;e+=`\n        else\n            m[${t-1}] = value;\n        `;const n=`\n      void setVecItem(out int m[${t}], int index, int value) {\n        ${e}\n      }\n        `;return{setVecItem:new r.GlslLibRoutine(n)}}getVecItem(){const t=this.context.outputTextureLayout.shape.length;let e=`\n        if(index < 0)\n            index = ${t} + index;\n        if (index == 0)\n            return m[0];\n      `;for(let n=1;n<t-1;++n)e+=`\n        else if (index == ${n})\n            return m[${n}];\n      `;e+=`\n        else\n            return m[${t-1}];\n        `;const n=`\n      int getVecItem(int m[${t}], int index) {\n        ${e}\n      }\n    `;return{getVecItem:new r.GlslLibRoutine(n)}}}e.VecGlslLib=i},8316:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLInferenceHandler=void 0;const r=n(6231),i=n(9162),o=n(2517),a=n(2403),s=n(7019),u=n(8710),c=n(5611),l=n(4057),p=n(2039);e.WebGLInferenceHandler=class{constructor(t){this.session=t,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(t,e){return(0,l.calculateTextureWidthAndHeight)(this.session.layoutStrategy,t,e)}executeProgram(t,e){if(e.length<t.inputNames.length)throw new Error(`Input size mustn't be less than ${t.inputNames.length}.`);if(t.inputNames.length!==t.inputTypes.length)throw new Error("input names size does not match input types");const n=[];for(let r=0;r<t.inputNames.length;++r)n[r]=this.getOrCreateTextureData(e[r],t.inputTypes[r]);const r=((t,e)=>{const n=e.map((t=>`${t.unpackedShape.join(",")};${t.width}x${t.height}`)).join("_");let r=t.name;return t.cacheHint&&(r+="["+t.cacheHint+"]"),r+=":"+n,r})(t,n);let i=this.session.programManager.getArtifact(r);const o=i?i.programInfo:"function"==typeof t.get?t.get():t,a=(0,l.createTextureLayoutFromTextureType)(this.session.layoutStrategy,o.output.dims,o.output.textureType),s=this.createTextureData(a,o.output.type);return i||(i=this.session.programManager.build(o,n,s),this.session.programManager.setArtifact(r,i)),this.runProgram(i,n,s),s}run(t,e){return this.executeProgram(t,e).tensor}runProgram(t,e,n){for(let n=0;n<e.length;++n)if(!!e[n].isPacked!=(t.programInfo.inputTypes[n]===p.TextureType.packed))throw new Error(`input[${n}] property packed inconsistent`);if(!!n.isPacked!=(t.programInfo.output.textureType===p.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(t,e,n)}getOrCreateTextureData(t,e){let n=this.getTextureData(t.dataId,e===p.TextureType.packed);if(!n&&(n=this.getTextureData(t.dataId,e!==p.TextureType.packed),n))return e===p.TextureType.packed?this.pack(n):this.unpack(n);if(!n){const r=(0,l.createTextureLayoutFromTextureType)(this.session.layoutStrategy,t.dims,e);if(e===p.TextureType.packedLastDimension){const n=1,r=4,i=t.dims;if(4===i.length){const o=[i[0],Math.ceil(i[1]*i[2]*i[3]/r)],a=(0,l.createTextureLayoutFromTextureType)(this.session.layoutStrategy,o,e);let s=t.numberData;if(i[1]*i[2]*i[3]%r!=0){const e=i[0],o=i[1]*i[2]*i[3],a=Math.ceil(o*n/r)*r;s=new Float32Array(e*a);for(let r=0;r<e;++r){const e=r*o,i=r*a+r%n*o;s.set(t.numberData.subarray(e,e+o),i)}}return this.createTextureData(a,t.type,s,t,1)}}if(e===p.TextureType.packed){const e=(0,l.createTextureLayoutFromShape)(this.session.layoutStrategy,t.dims,1,[],{reverseWH:!0}),r=this.createTextureData(e,t.type,t.numberData,t,1);n=this.pack(r)}else n=this.createTextureData(r,t.type,t.numberData,t,1)}return n}createTextureDataFromLayoutBindTensor(t,e,n,r){return this.createTextureData(t,e,n,r,1)}createTextureData(t,e,n,i,o){r.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(t)}]`);const a=this.session.textureManager.createTextureFromLayout(e,t,n,o);return this.createTextureDataFromTexture(t,e,a,i)}reshapeUnpacked(t,e){const n=this.getOrCreateTextureData(t,p.TextureType.unpacked),r={channels:n.channels,height:n.height,width:n.width,shape:0!==e.length?e:[1],strides:o.ShapeUtil.computeStrides(e),unpackedShape:e};return this.createTextureDataFromTexture(r,t.type,n.texture).tensor}reshapePacked(t,e){const n=this.getOrCreateTextureData(t,p.TextureType.packed);if((0,s.isReshapeCheap)(t.dims,e)){const r={channels:n.channels,height:n.height,width:n.width,shape:0!==e.length?e:[1],strides:o.ShapeUtil.computeStrides(e),unpackedShape:e,isPacked:!0};return this.createTextureDataFromTexture(r,t.type,n.texture).tensor}const r=(0,s.processDims3D)(t.dims),i=(0,s.processDims3D)(e),a=this.reshapePacked(t,r),u=this.run((0,s.createPackedReshape3DProgramInfoLoader)(this,a,i),[a]);return this.reshapePacked(u,e)}cast(t,e){const n=this.getOrCreateTextureData(t,p.TextureType.unpacked);return this.createTextureDataFromTexture(n,e,n.texture).tensor}createTextureDataFromTexture(t,e,n,r,o){const a=Object.assign(Object.assign({},t),{tensor:r||new i.Tensor(t.unpackedShape,e,(t=>this.readTexture(a)),(async t=>this.readTextureAsync(a)),void 0,o),texture:n});return this.setTextureData(a.tensor.dataId,a,t.isPacked),a}getTextureData(t,e=!1){return this.session.isInitializer(t)?this.session.getTextureData(t,e):e?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,e,n=!1){this.session.isInitializer(t)?this.session.setTextureData(t,e,n):(n?this.packedTextureDataCache:this.unpackedTextureDataCache).set(t,e)}isTextureLayoutCached(t,e=!1){return!!this.getTextureData(t.dataId,e)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((t=>this.session.textureManager.releaseTexture(t))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((t=>this.session.textureManager.releaseTexture(t))),this.unpackedTextureDataCache=new Map}readTexture(t){return t.isPacked?this.readTexture(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,t))}async readTextureAsync(t){return t.isPacked?this.readTextureAsync(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,t))}pack(t){return this.executeProgram((0,a.createPackProgramInfoLoader)(this,t.tensor),[t.tensor])}unpack(t){return this.executeProgram((0,c.createUnpackProgramInfoLoader)(this,t.tensor),[t.tensor])}}},1640:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return i(e,t),e};Object.defineProperty(e,"__esModule",{value:!0}),e.WEBGL_OP_RESOLVE_RULES=void 0;const a=n(2898),s=o(n(7839)),u=n(4196),c=n(2069),l=n(8138),p=n(9663),f=n(5193),d=n(7992),h=n(1253),g=n(4776),b=n(6572),m=n(3346),y=n(5623),_=n(2870),v=n(2143),w=n(4939),x=n(718),T=n(2268),S=n(8117),O=n(2278),A=n(5524),E=n(5975),I=n(3933),P=n(6558),D=n(5723),$=n(3738),k=o(n(4909)),C=n(8428),F=n(9793);e.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",k.abs],["Acos","","7+",k.acos],["Add","","7+",s.add],["And","","7+",s.and],["Asin","","7+",k.asin],["Atan","","7+",k.atan],["AveragePool","","7+",v.averagePool,v.parseAveragePoolAttributes],["BatchNormalization","","7+",a.batchNormalization,a.parseBatchNormalizationAttributes],["Cast","","6+",u.cast,u.parseCastAttributes],["Ceil","","6+",k.ceil],["Clip","","6-10",k.clip,k.parseClipAttributes],["Clip","","11+",k.clipV11],["Concat","","4+",c.concat,c.parseConcatAttributes],["Conv","","1+",l.conv,l.parseConvAttributes],["ConvTranspose","","1+",p.convTranspose,p.parseConvTransposeAttributes],["Cos","","7+",k.cos],["Div","","7+",s.div],["Dropout","","7+",k.identity],["DepthToSpace","","1+",f.depthToSpace,f.parseDepthToSpaceAttributes],["Equal","","7+",s.equal],["Elu","","6+",k.elu,k.parseEluAttributes],["Exp","","6+",k.exp],["Flatten","","1+",d.flatten,d.parseFlattenAttributes],["Floor","","6+",k.floor],["FusedConv","com.microsoft","1+",l.conv,l.parseConvAttributes],["Gather","","1+",h.gather,h.parseGatherAttributes],["Gemm","","7-10",g.gemm,g.parseGemmAttributesV7],["Gemm","","11+",g.gemm,g.parseGemmAttributesV11],["GlobalAveragePool","","1+",v.globalAveragePool,v.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",v.globalMaxPool],["Greater","","7+",s.greater],["Identity","","1+",k.identity],["ImageScaler","","1+",b.imageScaler,b.parseImageScalerAttributes],["InstanceNormalization","","6+",m.instanceNormalization,m.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",k.leakyRelu,k.parseLeakyReluAttributes],["Less","","7+",s.less],["Log","","6+",k.log],["MatMul","","1+",y.matMul,y.parseMatMulAttributes],["MaxPool","","1+",v.maxPool,v.parseMaxPoolAttributes],["Mul","","7+",s.mul],["Neg","","6+",k.neg],["Not","","1+",k.not],["Or","","7+",s.or],["Pad","","2-10",_.padV2,_.parsePadAttributesV2],["Pad","","11+",_.padV11,_.parsePadAttributesV11],["Pow","","7+",s.pow],["PRelu","","7+",s.pRelu],["ReduceLogSum","","1+",w.reduceLogSum,w.parseReduceAttributes],["ReduceMax","","1+",w.reduceMax,w.parseReduceAttributes],["ReduceMean","","1+",w.reduceMean,w.parseReduceAttributes],["ReduceMin","","1+",w.reduceMin,w.parseReduceAttributes],["ReduceProd","","1+",w.reduceProd,w.parseReduceAttributes],["ReduceSum","","1-12",w.reduceSum,w.parseReduceAttributes],["ReduceSumSquare","","1+",w.reduceLogSumSquare,w.parseReduceAttributes],["Relu","","6+",k.relu],["Reshape","","5+",x.reshape],["Resize","","10",T.resize,T.parseResizeAttributesV10],["Resize","","11+",T.resize,T.parseResizeAttributesV11],["Shape","","1+",S.shape],["Sigmoid","","6+",k.sigmoid],["Sin","","7+",k.sin],["Slice","","10+",O.sliceV10],["Slice","","1-9",O.slice,O.parseSliceAttributes],["Softmax","","1-12",A.softmax,A.parseSoftmaxAttributes],["Softmax","","13+",A.softmaxV13,A.parseSoftmaxAttributesV13],["Split","","2-12",E.split,E.parseSplitAttributes],["Sqrt","","6+",k.sqrt],["Squeeze","","1-12",I.squeeze,I.parseSqueezeAttributes],["Squeeze","","13+",I.squeezeV13],["Sub","","7+",s.sub],["Sum","","6+",P.sum],["Tan","","7+",k.tan],["Tanh","","6+",k.tanh],["Tile","","6+",D.tile],["Transpose","","1+",$.transpose,$.parseTransposeAttributes],["Upsample","","7-8",F.upsample,F.parseUpsampleAttributesV7],["Upsample","","9",F.upsample,F.parseUpsampleAttributesV9],["Unsqueeze","","1-12",C.unsqueeze,C.parseUnsqueezeAttributes],["Unsqueeze","","13+",C.unsqueezeV13],["Xor","","7+",s.xor]]},2898:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseBatchNormalizationAttributes=e.batchNormalization=void 0;const r=n(246),i=n(5060),o=n(2039),a={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]};e.batchNormalization=(t,e,n)=>(u(e),[t.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>s(t,e,n)}),e)]),e.parseBatchNormalizationAttributes=t=>{const e=t.attributes.getFloat("epsilon",1e-5),n=t.attributes.getFloat("momentum",.9),i=t.attributes.getInt("spatial",1);return(0,r.createAttributeWithCacheKey)({epsilon:e,momentum:n,spatial:i})};const s=(t,e,n)=>{const r=(0,i.getGlsl)(t.session.backend.glContext.version),s=e[0].dims.length,[u,c]=t.calculateTextureWidthAndHeight(e[1].dims,o.TextureType.unpacked),l=`\n  float process(int[${s}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${u}, ${c});\n    float scale = getColorAsFloat(${r.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${r.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${r.texture2D}(Variance, position));\n    float b = getColorAsFloat(${r.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\n  }`;return Object.assign(Object.assign({},a),{output:{dims:e[0].dims,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:l})},u=t=>{if(!t||5!==t.length)throw new Error("BatchNormalization requires 5 inputs.");const e=t[0],n=t[1],r=t[2],i=t[3],o=t[4];if(e.dims.length<3||1!==n.dims.length||1!==r.dims.length||1!==i.dims.length||1!==o.dims.length)throw new Error("invalid input shape.");if(n.dims[0]!==e.dims[1]||r.dims[0]!==e.dims[1]||i.dims[0]!==e.dims[1]||o.dims[0]!==e.dims[1])throw new Error("invalid input shape.");if("float32"!==e.type&&"float64"!==e.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==r.type&&"float64"!==r.type||"float32"!==i.type&&"float64"!==i.type||"float32"!==o.type&&"float64"!==o.type)throw new Error("invalid input tensor types.")}},7839:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.xor=e.sub=e.pRelu=e.pow=e.or=e.mul=e.less=e.greater=e.equal=e.div=e.and=e.add=e.glslPRelu=e.glslPow=e.glslXor=e.glslOr=e.glslAnd=e.glslLess=e.glslGreater=e.glslEqual=e.glslSub=e.glslMul=e.glslDiv=e.glslAdd=void 0;const r=n(2517),i=n(8520),o=n(5060),a=n(2039);function s(){const t="add_";return{body:`\n  float ${t}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function u(){const t="div_";return{body:`\n  float ${t}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function c(){const t="mul_";return{body:`\n  float ${t}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function l(){const t="sub_";return{body:`\n  float ${t}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function p(){const t="equal_";return{body:`\n  float ${t}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function f(){const t="greater_";return{body:`\n  float ${t}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function d(){const t="less_";return{body:`\n  float ${t}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function h(){const t="and_";return{body:`\n  float ${t}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function g(){const t="or_";return{body:`\n  float ${t}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function b(){const t="xor_";return{body:`\n  float ${t}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}function m(){return function(t){const e=`${t}_`;return{body:`\n  float ${e}(float a, float b) {\n    return ${t}(a, b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return ${t}(v1, v2);\n  }\n  `,name:e,type:i.FunctionType.ValueBased}}("pow")}function y(){const t="prelu_";return{body:`\n  float ${t}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,name:t,type:i.FunctionType.ValueBased}}e.glslAdd=s,e.glslDiv=u,e.glslMul=c,e.glslSub=l,e.glslEqual=p,e.glslGreater=f,e.glslLess=d,e.glslAnd=h,e.glslOr=g,e.glslXor=b,e.glslPow=m,e.glslPRelu=y;const _=(t,e,n,r=e[0].type,i)=>{const o=t.session.pack?a.TextureType.packed:a.TextureType.unpacked;return{name:n.name,inputNames:["A","B"],inputTypes:[o,o],cacheHint:i,get:()=>v(t,e,n,r)}},v=(t,e,n,i=e[0].type)=>{const s=t.session.pack?a.TextureType.packed:a.TextureType.unpacked,u=!r.ShapeUtil.areEqual(e[0].dims,e[1].dims);let c=e[0].dims;const l=t.session.pack;if(u){const a=r.BroadcastUtil.calcShape(e[0].dims,e[1].dims,!1);if(!a)throw new Error("Can't perform binary op on the given tensors");c=a;const u=c.length,p=0!==e[0].dims.length?e[0].dims.length:1,f=0!==e[1].dims.length?e[1].dims.length:1,d=0!==e[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",h=0!==e[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",g=(0,o.getGlsl)(t.session.backend.glContext.version),b=l?`\n      ${n.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${n.name}(a, b);\n        ${g.output} = result;\n      }`:`\n      ${n.body}\n      float process(int indices[${u}]) {\n        int aindices[${p}];\n        int bindices[${f}];\n        ${d}\n        ${h}\n        return ${n.name}(_A(aindices), _B(bindices));\n      }`;return{name:n.name,inputNames:["A","B"],inputTypes:[s,s],output:{dims:c,type:i,textureType:s},shaderSource:b,hasMain:l}}const p=(0,o.getGlsl)(t.session.backend.glContext.version),f=`\n    ${n.body}\n    void main() {\n      vec4 v1 = ${p.texture2D}(A, TexCoords);\n      vec4 v2 = ${p.texture2D}(B, TexCoords);\n      vec4 result = ${n.name}(v1, v2);\n      ${p.output} = result;\n    }\n    `;return{name:n.name,inputNames:["A","B"],inputTypes:[s,s],output:{dims:e[0].dims,type:i,textureType:s},shaderSource:f,hasMain:!0}};e.add=(t,e)=>[t.run(_(t,e,s()),e)],e.and=(t,e)=>[t.run(_(t,e,h(),"bool"),e)],e.div=(t,e)=>[t.run(_(t,e,u()),e)],e.equal=(t,e)=>[t.run(_(t,e,p(),"bool"),e)],e.greater=(t,e)=>[t.run(_(t,e,f(),"bool"),e)],e.less=(t,e)=>[t.run(_(t,e,d(),"bool"),e)],e.mul=(t,e)=>[t.run(_(t,e,c()),e)],e.or=(t,e)=>[t.run(_(t,e,g(),"bool"),e)],e.pow=(t,e)=>[t.run(_(t,e,m()),e)],e.pRelu=(t,e)=>[t.run(_(t,e,y()),e)],e.sub=(t,e)=>[t.run(_(t,e,l()),e)],e.xor=(t,e)=>[t.run(_(t,e,b(),"bool"),e)]},4196:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseCastAttributes=e.cast=void 0;const r=n(2517);e.cast=(t,e,n)=>(i(e),[t.cast(e[0],n)]),e.parseCastAttributes=t=>r.ProtoUtil.tensorDataTypeFromProto(t.attributes.getInt("to"));const i=t=>{if(!t||1!==t.length)throw new Error("Cast requires 1 input.");if("string"===t[0].type)throw new Error("Invalid input type.")}},1163:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedConcatProgramInfoLoader=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827);e.createPackedConcatProgramInfoLoader=(t,e,n)=>{const u=(c=e.length,l=n.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:c},((t,e)=>`X${e}`)),inputTypes:Array(c).fill(i.TextureType.packed),cacheHint:l});var c,l;return Object.assign(Object.assign({},u),{get:()=>((t,e,n,u)=>{const c=n[0].dims.slice();if(u>=c.length||u<-1*c.length)throw new Error("axis specified for concat doesn't match input dimensionality");u<0&&(u=c.length+u);const l=c.slice(0);for(let t=1;t<n.length;t++){const e=n[t].dims.slice();for(let t=0;t<c.length;t++)if(t===u)l[u]+=e[t];else if(c[t]!==e[t])throw new Error("non concat dimensions must match")}const p=l.length,f=(0,a.getChannels)("coords",p),d=(0,o.getCoordsDataType)(p),h=(0,a.unpackFromChannel)(),g=n.map((t=>t.dims)),b=(0,o.getGlChannels)(p),m=new Array(g.length-1);m[0]=g[0][u];for(let t=1;t<m.length;t++)m[t]=m[t-1]+g[t][u];const y=b[u],_=b.slice(-2),v=b.join();let w=`if (${y} < ${m[0]}) {\n        return getChannel(\n            getX0(${v}), vec2(${_.join()}));\n        }`;for(let t=1;t<m.length;t++){const e=m[t-1];w+=`\n            if (${y} < ${m[t]}  && ${y} >= ${m[t-1]}) {\n              return getChannel(\n                getX${t}(${s(b,y,e)}),\n                vec2(${s(_,y,e)}));\n            }`}const x=m.length,T=m[m.length-1];w+=`\n            return getChannel(\n              getX${x}(${s(b,y,T)}),\n              vec2(${s(_,y,T)}));`;const S=(0,r.getGlsl)(t.session.backend.glContext.version),O=`\n          ${h}\n          float getValue(${b.map((t=>"int "+t))}) {\n            ${w}\n          }\n\n          void main() {\n            ${d} coords = getOutputCoords();\n            int lastDim = coords.${b[p-1]};\n            coords.${b[p-1]} = coords.${b[p-2]};\n            coords.${b[p-2]} = lastDim;\n\n            vec4 result = vec4(getValue(${f}), 0., 0., 0.);\n\n            ${f[p-1]} = ${f[p-1]} + 1;\n            if (${f[p-1]} < ${l[p-1]}) {\n              result.g = getValue(${f});\n            }\n\n            ${f[p-2]} = ${f[p-2]} + 1;\n            if (${f[p-2]} < ${l[p-2]}) {\n              result.a = getValue(${f});\n            }\n\n            ${f[p-1]} = ${f[p-1]} - 1;\n            if (${f[p-2]} < ${l[p-2]} &&\n                ${f[p-1]} < ${l[p-1]}) {\n              result.b = getValue(${f});\n            }\n            ${S.output} = result;\n          }\n        `;return Object.assign(Object.assign({},e),{output:{dims:l,type:n[0].type,textureType:i.TextureType.packed},shaderSource:O,hasMain:!0})})(t,u,e,n.axis)})};const s=(t,e,n)=>{const r=t.indexOf(e);return t.map(((t,e)=>e===r?`${t} - ${n}`:t)).join()}},2069:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseConcatAttributes=e.concat=void 0;const r=n(246),i=n(2039),o=n(1163);e.concat=(t,e,n)=>(p(e),t.session.pack&&e[0].dims.length>1?[t.run((0,o.createPackedConcatProgramInfoLoader)(t,e,n),e)]:[t.run(a(t,e,n),e)]);const a=(t,e,n)=>{const r=(o=e.length,a=n.cacheKey,{name:"Concat",inputNames:Array.from({length:o},((t,e)=>`X${e}`)),inputTypes:Array(o).fill(i.TextureType.unpacked),cacheHint:a});var o,a;return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const o=n[0].dims.slice();if(r>=o.length||r<-1*o.length)throw new Error("axis specified for concat doesn't match input dimensionality");r<0&&(r=o.length+r);const a=o.slice(0);for(let t=1;t<n.length;t++){const e=n[t].dims.slice();for(let t=0;t<o.length;t++)if(t===r)a[r]+=e[t];else if(o[t]!==e[t])throw new Error("non concat dimensions must match")}const p=a.length,f=new Array(n.length);let d=0;for(let t=0;t<f.length;++t)d+=n[t].dims[r],f[t]=d;let h="";h=n.length<5?s(f):u(f);const g=`\n        ${c(n.length,p)}\n        ${l(f)}\n        ${h}\n        float process(int indices[${p}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${r}]);\n\n          if(textureIndex != 0) {\n            indices[${r}] = indices[${r}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;return Object.assign(Object.assign({},e),{output:{dims:a,type:n[0].type,textureType:i.TextureType.unpacked},shaderSource:g})})(0,r,e,n.axis)})},s=t=>`int getTextureWhereDataResides(int index) {\n      ${t.map(((t,e)=>`if(index<${t}) {return ${e};}\n`)).join("")}\n    }`,u=t=>s(t),c=(t,e)=>{const n=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];for(let e=0;e<t;++e)0===e?n.push(`\tif (textureIndex == ${e}) { return _X${e}(indices); }`):e===t-1?n.push(`\telse { return _X${e}(indices); }`):n.push(`\telse if (textureIndex == ${e}) { return _X${e}(indices); }`);return n.push("\t}"),n.join("\n")},l=t=>{const e=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let n=0;n<t.length;++n)0===n?e.push(`\tif (index == ${n}) { return ${t[n]}; }`):n===t.length-1?e.push(`\telse { return ${t[n]}; }`):e.push(`\telse if (index == ${n}) { return ${t[n]}; }`);return e.push("\t}"),e.join("\n")};e.parseConcatAttributes=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt("axis")});const p=t=>{if(!t||t.length<1)throw new Error("too few inputs");const e=t[0].type,n=t[0].dims.length;if("string"===e)throw new Error("string tensor is not supported yet");for(const r of t){if(r.type!==e)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}}},4770:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createUnpackedGroupedConvProgramInfoLoader=void 0;const r=n(6231),i=n(5060),o=n(2039),a=n(8138),s=n(2823);e.createUnpackedGroupedConvProgramInfoLoader=(t,e,n)=>{const u=(c=e.length>2,l=n.cacheKey,{name:"GroupedConv",inputNames:c?["X","W","Bias"]:["X","W"],inputTypes:c?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:l});var c,l;return Object.assign(Object.assign({},u),{get:()=>((t,e,n,u)=>{const c=e.length>2?"value += getBias(output_channel);":"",l=e[0].dims.slice(),p=e[1].dims.slice(),f=p[0]/u.group;r.Logger.verbose("GroupedConv",`autpPad:${u.autoPad}, dilations:${u.dilations}, group:${u.group}, kernelShape:${u.kernelShape}, pads:${u.pads}, strides:${u.strides}`);const d=(0,a.calculateOutputShape)(l,p,u.dilations,u.pads,u.strides),h=(0,i.getGlsl)(t.session.backend.glContext.version),{activationFunction:g,applyActivation:b}=(0,s.getActivationSnippet)(u),m=`\n  const ivec2 strides = ivec2(${u.strides[0]}, ${u.strides[1]});\n  const ivec2 pads = ivec2(${u.pads[0]}, ${u.pads[1]});\n  ${g}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${f};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {\n      int input_channel = group_id * ${p[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${u.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${l[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${u.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${l[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${c}\n    ${b}\n    ${h.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},n),{output:{dims:d,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:m,hasMain:!0})})(t,e,u,n)})}},1386:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.conv2DPacked=e.conv2DPackedPointwise=void 0;const r=n(8138),i=n(8555),o=n(708);e.conv2DPackedPointwise=(t,e,n)=>{const i=e[0].dims,a=e[1].dims,s=(0,r.calculateOutputShape)(i,a,n.dilations,n.pads,n.strides),u=t.reshapePacked(e[0],[i[1],i[2]*i[3]]),c=t.reshapePacked(e[1],[a[0],a[1]]),l=e.length>2?[c,u,e[2]]:[c,u],p=t.run((0,o.createPackedMatmulProgramInfoLoader)(t,l,n),l);return t.reshapePacked(p,s)},e.conv2DPacked=(t,e,n)=>{const a=e[0].dims,s=e[1].dims,u=(0,r.calculateOutputShape)(a,s,n.dilations,n.pads,n.strides),c=t.run((0,i.createPackedIm2ColProgramInfoLoader)(t,e[0],e[1],u,n),[e[0]]),l=t.reshapePacked(e[1],[s[0],s[1]*s[2]*s[3]]),p=3===e.length?[l,c,e[2]]:[l,c],f=t.run((0,o.createPackedMatmulProgramInfoLoader)(t,p,n),p);return t.reshapePacked(f,u)}},9663:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseConvTransposeAttributes=e.convTranspose=void 0;const r=n(246),i=n(5060),o=n(2039),a=n(2823),s=(t,e,n,r,i,o)=>(t-1)*e+n+(r-1)*i+1-o,u=(t,e,n,r,i)=>{const o=Math.floor(t/2);"SAME_UPPER"===e?(n[r]=o,n[i]=t-o):"SAME_LOWER"===e&&(n[r]=t-o,n[i]=o)};e.convTranspose=(t,e,n)=>(f(e,n),c(t,e,n));const c=(t,e,n)=>{const r=p(n,e);return[l(t,e,r)]},l=(t,e,n)=>t.run(((t,e,n)=>{const r=(s=e.length>2,u=n.cacheKey,{name:"ConvTranspose",inputNames:s?["X","W","B"]:["X","W"],inputTypes:s?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:u});var s,u;return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const s=e.length>2?"getB(output_channel)":"0.0",u=e[0].dims,c=e[1].dims,l=c[1],p=c[0]/r.group,f=[e[0].dims[0],e[1].dims[1]*r.group,...r.outputShape],d=(0,i.getGlsl)(t.session.backend.glContext.version),{activationFunction:h,applyActivation:g}=(0,a.getActivationSnippet)(r),b=`\n  const ivec2 strides = ivec2(${r.strides[0]}, ${r.strides[1]});\n  const ivec2 pads = ivec2(${r.pads[0]}, ${r.pads[1]});\n  ${h}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${l};\n    int wOutChannel = output_channel - group_id * ${l};\n\n    float value = ${s};\n    for (int inChannelOffset = 0; inChannelOffset < ${p}; inChannelOffset++) {\n      int input_channel = group_id * ${p} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${c[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${c[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${r.dilations[0]}, wHOff * ${r.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${u[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${u[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${g}\n    ${d.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},n),{output:{dims:f,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:b,hasMain:!0})})(t,e,r,n)})})(t,e,n),e),p=(t,e)=>{const n=t.kernelShape.slice();if(0===t.kernelShape.length)for(let t=2;t<e[1].dims.length;++t)n.push(e[1].dims[t]);const r=t.pads.slice(),i=t.outputShape.slice();((t,e,n,r,i,o,a,c)=>{const l=t.length-2,p=0===c.length;for(let f=0;f<l;++f){const d=p?t[f+2]*o[f]:c[f],h=s(t[f+2],o[f],i[f],e[f],n[f],d);u(h,r,i,f,f+l),p&&c.push(o[f]*(t[f+2]-1)+a[f]+(e[f]-1)*n[f]+1-i[f]-i[f+l])}})(e[0].dims,n,t.dilations,t.autoPad,r,t.strides,t.outputPadding,i);const o=Object.assign({},t);return Object.assign(o,{kernelShape:n,pads:r,outputShape:i,cacheKey:t.cacheKey}),o};e.parseConvTransposeAttributes=t=>{const e=t.attributes,n=(0,a.parseInternalActivationAttributes)(e),i=e.getString("auto_pad","NOTSET"),o=e.getInts("dilations",[1,1]),s=e.getInt("group",1),u=e.getInts("kernel_shape",[]),c=e.getInts("output_padding",[0,0]),l=e.getInts("output_shape",[]),p=e.getInts("pads",[0,0,0,0]),f=e.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:i,dilations:o,group:s,kernelShape:u,outputPadding:c,outputShape:l,pads:p,strides:f},n))};const f=(t,e)=>{if(!t||2!==t.length&&3!==t.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==t[0].dims.length||4!==t[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(t[0].dims[1]!==t[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const n=t[1].dims[1]*e.group;if(3===t.length&&(1!==t[2].dims.length||t[2].dims[0]!==n))throw new Error("invalid bias");const r=t[0].dims.length-2;if(e.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(e.strides.length!==r)throw new Error(`strides should be ${r}D`);if(e.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(e.outputPadding.length!==r)throw new Error(`output_padding should be ${r}D`);if(0!==e.kernelShape.length&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==e.outputShape.length&&e.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape");if("float32"!==t[0].type||"float32"!==t[1].type)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===t.length&&"float32"!==t[2].type)throw new Error("ConvTranspose input(bias) should be float tensor")}},8138:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseConvAttributes=e.conv=e.calculateOutputShape=void 0;const r=n(246),i=n(2517),o=n(4770),a=n(1386),s=n(9828),u=n(2823),c=n(3248),l=n(5623);e.calculateOutputShape=(t,e,n,r,i)=>{const o=t[0],a=t.slice(2),s=a.length,u=e[0],c=e.slice(2).map(((t,e)=>t+(t-1)*(n[e]-1))),l=a.map(((t,e)=>t+r[e]+r[e+s])).map(((t,e)=>Math.floor((t-c[e]+i[e])/i[e])));return[o,u].concat(...l)},e.conv=(t,e,n)=>(g(e,n),p(t,e,n));const p=(t,e,n)=>{const r=h(n,e),i=t.session.pack,s=1===r.kernelShape[0]&&1===r.kernelShape[1];return r.group>1?[t.run((0,o.createUnpackedGroupedConvProgramInfoLoader)(t,e,r),e)]:s&&i?[f(t,e,r)]:i&&4===e[0].dims.length&&1===e[0].dims[0]&&!s?[(0,a.conv2DPacked)(t,e,r)]:[d(t,e,r)]},f=(t,n,r)=>{const i=n[0].dims,o=n[1].dims,a=(0,e.calculateOutputShape)(i,o,r.dilations,r.pads,r.strides),s=t.reshapeUnpacked(n[0],[i[1],i[2]*i[3]]),u=t.reshapeUnpacked(n[1],[o[0],o[1]]),c=n.length>2?[u,s,n[2]]:[u,s],p=t.run((0,l.createMatmulProgramInfoLoader)(c,r),c);return t.reshapeUnpacked(p,a)},d=(t,n,r)=>{const i=n[0].dims,o=n[1].dims,a=(0,e.calculateOutputShape)(i,o,r.dilations,r.pads,r.strides),u=t.run((0,c.createIm2ColProgramInfoLoader)(t,n[0],n[1],a,r),[n[0]]),l=3===n.length?[u,n[1],n[2]]:[u,n[1]];return t.run((0,s.createDotProductProgramInfoLoader)(t,n,a,r),l)},h=(t,e)=>{const n=t.kernelShape.slice();if(0===t.kernelShape.length)for(let t=2;t<e[1].dims.length;++t)n.push(e[1].dims[t]);const r=t.pads.slice();i.PoolConvUtil.adjustPadsBasedOnAutoPad(e[0].dims,t.strides,t.dilations,n,r,t.autoPad);const o=Object.assign({},t);return Object.assign(o,{kernelShape:n,pads:r,cacheKey:t.cacheKey}),o};e.parseConvAttributes=t=>{const e=t.attributes,n=(0,u.parseInternalActivationAttributes)(e),i=e.getString("auto_pad","NOTSET"),o=e.getInts("dilations",[1,1]),a=e.getInt("group",1),s=e.getInts("kernel_shape",[]),c=e.getInts("pads",[0,0,0,0]),l=e.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:i,dilations:o,group:a,kernelShape:s,pads:c,strides:l},n))};const g=(t,e)=>{if(!t||2!==t.length&&3!==t.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==t[0].dims.length||4!==t[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(t[0].dims[1]!==t[1].dims[1]*e.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===t.length&&(1!==t[2].dims.length||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");const n=t[0].dims.length-2;if(e.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(e.strides.length!==n)throw new Error(`strides should be ${n}D`);if(e.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==e.kernelShape.length&&e.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if("float32"!==t[0].type||"float32"!==t[1].type)throw new Error("Conv input(X,W) should be float tensor");if(3===t.length&&"float32"!==t[2].type)throw new Error("Conv input(bias) should be float tensor")}},5193:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseDepthToSpaceAttributes=e.depthToSpace=void 0;const r=n(3738);e.depthToSpace=(t,e,n)=>{i(e);const o=n.blocksize,a=o*o,s="DCR"===n.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],u="DCR"===n.mode?[e[0].dims[0],o,o,e[0].dims[1]/a,e[0].dims[2],e[0].dims[3]]:[e[0].dims[0],e[0].dims[1]/a,o,o,e[0].dims[2],e[0].dims[3]],c=t.reshapeUnpacked(e[0],u),l={perm:s,cacheKey:`${s}`},[p]=(0,r.transpose)(t,[c],l),f=[e[0].dims[0],e[0].dims[1]/a,e[0].dims[2]*o,e[0].dims[3]*o];return[t.reshapeUnpacked(p,f)]},e.parseDepthToSpaceAttributes=t=>{const e=t.attributes.getInt("blocksize");if(e<1)throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);const n=t.attributes.getString("mode","DCR");if("DCR"!==n&&"CRD"!==n)throw new Error(`unrecognized mode: ${n} for DepthToSpace`);return{mode:n,blocksize:e}};const i=t=>{if(1!==t.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${t.length}`);if("string"===t[0].type||4!==t[0].dims.length)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},9828:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createDotProductProgramInfoLoader=void 0;const r=n(2517),i=n(5060),o=n(2039),a=n(2823),s=n(3248);e.createDotProductProgramInfoLoader=(t,e,n,u)=>{const c=((t,e)=>({name:"ConvDotProduct",inputNames:t?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:t?[o.TextureType.unpacked,o.TextureType.packedLastDimension,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.packedLastDimension],cacheKey:e.activationCacheKey}))(e.length>2,u);return Object.assign(Object.assign({},c),{get:()=>((t,e,n,u,c)=>{const l=n[0].dims,p=n[1].dims,f=[p[0],Math.ceil(l[1]*p[2]*p[3]/4)],d=(0,s.calculateIm2ColDims)(l,p,u),[h,g]=t.calculateTextureWidthAndHeight(f,o.TextureType.packedLastDimension),b=r.ShapeUtil.computeStrides(d),[m,y]=t.calculateTextureWidthAndHeight(d,o.TextureType.packedLastDimension),_=u.length,v=n.length<3?"0.0":"_B(b)",w=Math.ceil(l[1]*p[2]*p[3]/4),{activationFunction:x,applyActivation:T}=(0,a.getActivationSnippet)(c),S=(0,i.getGlsl)(t.session.backend.glContext.version),O=`\n${x}\nfloat process(int indices[${_}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};\n  int kernelOffset = indices[1] * ${f[1]};\n  float value = ${v};\n  for (int i = 0; i < ${w}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${y});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});\n    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${T}\n  return value;\n}`;return Object.assign(Object.assign({},e),{output:{dims:u,type:n[0].type,textureType:o.TextureType.unpacked},shaderSource:O})})(t,c,e,n,u)})}},7992:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseFlattenAttributes=e.flatten=void 0;const r=n(2517);e.flatten=(t,e,n)=>{i(e,n);const o=r.ShapeUtil.flattenShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],o)]},e.parseFlattenAttributes=t=>t.attributes.getInt("axis",1);const i=(t,e)=>{if(!t||1!==t.length)throw new Error("Flatten requires 1 input.");const n=t[0].dims.length;if(0===n)throw new Error("scalar tensor is not supported.");if(e<-n||e>n)throw new Error("Invalid axis");if("string"===t[0].type)throw new Error("string tensor is not supported.")}},2823:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseInternalActivationAttributes=e.getActivationSnippet=void 0;const r=n(2517),i=n(4909);e.getActivationSnippet=function(t){let e;switch(t.activation){case"Relu":e=(0,i.glslRelu)();break;case"Sigmoid":e=(0,i.glslSigmoid)();break;case"Clip":e=(0,i.glslClip)(t.clipMin,t.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const n=e.name;return{activationFunction:e.body,applyActivation:`value = ${n}_(value);`}},e.parseInternalActivationAttributes=t=>{const e=t.getString("activation","");if("Clip"===e){const[n,i]=t.getFloats("activation_params",[r.MIN_CLIP,r.MAX_CLIP]);return{activation:e,clipMax:i,clipMin:n,activationCacheKey:`${e}:${n},${i}`}}return{activation:e,activationCacheKey:e}}},1253:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseGatherAttributes=e.gather=void 0;const r=n(246),i=n(782),o=n(2517),a=n(2039);e.gather=(t,e,n)=>(c(e,n.axis),[t.run(u(t,e,n),e)]),e.parseGatherAttributes=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt("axis",0)});const s={name:"Gather",inputNames:["A","B"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},u=(t,e,n)=>{const r=Object.assign(Object.assign({},s),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const i=n[0].dims.slice(),s=n[1].dims.slice(),u=new Array(i.length+s.length-1);r=o.ShapeUtil.normalizeAxis(r,i.length);const c=[];for(let t=0;t<u.length;t++)t<r?(u[t]=i[t],c.push(`inputIdx[${t}] = outputIdx[${t}];`)):t<r+s.length?(u[t]=s[t-r],c.push(`indexDataIdx[${t-r}] = outputIdx[${t}];`)):(u[t]=i[t-s.length+1],c.push(`inputIdx[${t-s.length+1}] = outputIdx[${t}];`));const l=`\n      float process(int outputIdx[${u.length||1}]) {\n        int inputIdx[${i.length}];\n        int indexDataIdx[${s.length||1}];\n        indexDataIdx[0] = 0;\n        ${c.join("\n        ")}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${r}] = idx < 0 ? idx + ${i[r]} : idx;\n        return _A(inputIdx);\n      }`;return Object.assign(Object.assign({},e),{output:{dims:u,type:n[0].type,textureType:a.TextureType.unpacked},shaderSource:l})})(0,r,e,n.axis)})},c=(t,e)=>{if(!t||2!==t.length)throw new Error("Gather requires 2 inputs.");const n=t[0].dims.length;if(n<1)throw new Error("Invalid input shape.");if(e<-n||e>n-1)throw new Error("Invalid axis.");if(-1===i.NUMBER_TYPES.indexOf(t[0].type))throw new Error("Invaid input type.");if("int32"!==t[1].type&&"int16"!==t[1].type)throw new Error("Invaid input type.")}},4776:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseGemmAttributesV11=e.parseGemmAttributesV7=e.gemm=void 0;const r=n(246),i=n(2517),o=n(2039);e.gemm=(t,e,n)=>(c(e,n),[t.run(s(e,n),e)]);const a=(t,e)=>{const n=0!==t.attributes.getInt("transA",0),i=0!==t.attributes.getInt("transB",0),o=t.attributes.getFloat("alpha",1),a=t.attributes.getFloat("beta",1);return(0,r.createAttributeWithCacheKey)({transA:n,transB:i,alpha:o,beta:a,isOptionalC:e})};e.parseGemmAttributesV7=t=>a(t,!1),e.parseGemmAttributesV11=t=>a(t,!0);const s=(t,e)=>{const n={name:"Gemm",inputNames:3===t.length?["A","B","C"]:["A","B"],inputTypes:3===t.length?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],key:e.cacheKey};return Object.assign(Object.assign({},n),{get:()=>u(n,t,e)})},u=(t,e,n)=>{const r=e[0].dims.slice(),a=e[1].dims.slice(),[s,u]=i.GemmUtil.getShapeOfGemmResult(r,n.transA,a,n.transB,3===e.length?e[2].dims:void 0),c=[s,u];if(!c)throw new Error("Can't use gemm on the given tensors");let l=r[r.length-1],p="";n.transA&&(l=r[0]),n.transA&&n.transB?p="value += _A_T(a) * _B_T(b);":n.transA&&!n.transB?p="value += _A_T(a) * _B(b);":!n.transA&&n.transB?p="value += _A(a) * _B_T(b);":n.transA||n.transB||(p="value += _A(a) * _B(b);");const f=c.length,d=`\n      float process(int indices[${f}]) {\n          int a[${f}];\n          int b[${f}];\n          ${3===e.length?`int c[${e[2].dims.length}];`:""}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${3===e.length?"bcastIndices_C(indices, c);":""}\n\n          float value = 0.0;\n          for (int k=0; k<${l}; ++k) {\n              a[${f-1}] = k;\n              b[${f-2}] = k;\n              ${p}\n          }\n\n          value = value * alpha;\n          ${3===e.length?"value += beta * _C(c);":""}\n          return value;\n      }`;return Object.assign(Object.assign({},t),{output:{dims:c,type:e[0].type,textureType:o.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:n.alpha},{name:"beta",type:"float",data:n.beta}],shaderSource:d})},c=(t,e)=>{if(!t)throw new Error("Input is missing");if(e.isOptionalC&&(t.length<2||t.length>3))throw new Error("Invaid input shape.");if(!e.isOptionalC&&3!==t.length)throw new Error("Gemm requires 3 inputs");if(3===t.length&&1!==t[2].dims.length&&2!==t[2].dims.length)throw new Error("Invalid input shape of C");if("float32"!==t[0].type&&"float64"!==t[0].type||"float32"!==t[1].type&&"float64"!==t[1].type||3===t.length&&"float32"!==t[2].type&&"float64"!==t[2].type)throw new Error("Invalid input type.");if(t[0].type!==t[1].type||3===t.length&&t[0].type!==t[2].type)throw new Error("Input types are mismatched")}},8555:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedIm2ColProgramInfoLoader=void 0;const r=n(5060),i=n(2039),o=n(2827);e.createPackedIm2ColProgramInfoLoader=(t,e,n,a,s)=>{const u=(c=s.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[i.TextureType.packed],cacheHint:c});var c;return Object.assign(Object.assign({},u),{get:()=>((t,e,n,a,s,u)=>{const c=n.dims,l=a.dims,p=s.length,f=[l[1]*l[2]*l[3],s[2]*s[3]],d=l[2]*l[3],h=(0,o.unpackFromChannel)(),g=(0,r.getGlsl)(t.session.backend.glContext.version);let b="";for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)b+=`\n            blockIndex = rc.x + ${e};\n            pos = rc.y + ${t};\n\n            if(blockIndex < ${f[1]} && pos < ${f[0]}) {\n              offsetY = int(blockIndex / (${s[p-1]})) * ${u.strides[0]} -\n                ${u.pads[0]};\n              d0 = offsetY + ${u.dilations[0]} * (imod(pos, ${d}) / ${l[2]});\n\n              if(d0 < ${c[2]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${s[p-1]}) * ${u.strides[1]} -\n                  ${u.pads[1]};\n                d1 = offsetX + ${u.dilations[1]} * imod(imod(pos, ${d}), ${l[2]});\n\n                if(d1 < ${c[3]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${d}.);\n                    innerDims = vec2(d0, d1);\n                    result[${2*t+e}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;const m=`\n      ${h}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${b}\n          ${g.output} = result;\n      }\n            `;return Object.assign(Object.assign({},e),{output:{dims:f,type:n.type,textureType:i.TextureType.packed},shaderSource:m,hasMain:!0})})(t,u,e,n,a,s)})}},3248:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.calculateIm2ColDims=e.createIm2ColProgramInfoLoader=void 0;const r=n(2039);e.createIm2ColProgramInfoLoader=(t,n,i,o,a)=>{const s=(u=a.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[r.TextureType.unpacked],cacheHint:u});var u;return Object.assign(Object.assign({},s),{get:()=>((t,n,i,o,a,s)=>{const u=i.dims,c=o.dims,l=a.length,p=(0,e.calculateIm2ColDims)(u,c,a,4),f=`\n        const int XC = ${u[1]};\n        const int XH = ${u[2]};\n        const int XW = ${u[3]};\n        const int KH = ${s.kernelShape[0]};\n        const int KW = ${s.kernelShape[1]};\n        const int dilationH = ${s.dilations[0]};\n        const int dilationW = ${s.dilations[1]};\n        const int strideH = ${s.strides[0]};\n        const int strideW = ${s.strides[1]};\n        const int padH = ${s.pads[0]};\n        const int padW = ${s.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${l}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${u.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;return Object.assign(Object.assign({},n),{output:{dims:p,type:i.type,textureType:r.TextureType.packedLastDimension},shaderSource:f})})(0,s,n,i,o,a)})},e.calculateIm2ColDims=(t,e,n,r=4)=>[n[0],n[2],n[3],Math.ceil(t[1]*e[2]*e[3]/r)]},6572:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseImageScalerAttributes=e.imageScaler=void 0;const r=n(246),i=n(2039);e.imageScaler=(t,e,n)=>(u(e),[t.run(a(t,e,n),e)]),e.parseImageScalerAttributes=t=>{const e=t.attributes.getFloat("scale"),n=t.attributes.getFloats("bias");return(0,r.createAttributeWithCacheKey)({scale:e,bias:n})};const o={name:"ImageScaler",inputNames:["X"],inputTypes:[i.TextureType.unpacked]},a=(t,e,n)=>{const r=Object.assign(Object.assign({},o),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((t,e,n,r)=>{const o=n[0].dims.slice(),a=o.length,u=`\n      ${s(r.bias.length)}\n      float process(int indices[${a}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;return Object.assign(Object.assign({},e),{output:{dims:o,type:n[0].type,textureType:i.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:r.bias.length,data:r.bias},{name:"scale",type:"float",data:r.scale}],shaderSource:u})})(0,r,e,n)})},s=t=>{const e=[`float getBias(float bias[${t}], int channel) {`];for(let n=0;n<t;++n)0===n?e.push(`\tif (channel == ${n}) { return bias[${n}]; }`):n===t-1?e.push(`\telse { return bias[${n}]; }`):e.push(`\telse if (channel == ${n}) { return bias[${n}]; }`);return e.push("\t}"),e.join("\n")},u=t=>{if(!t||1!==t.length)throw new Error("ImageScaler requires 1 input.");if(4!==t[0].dims.length)throw new Error("Invalid input shape.");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type.")}},3346:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseInstanceNormalizationAttributes=e.instanceNormalization=void 0;const r=n(5060),i=n(2039);e.instanceNormalization=(t,e,n)=>{c(e);const r=t.run(a(e[0]),e);return[t.run(u(t,e[0],n,r.dims),[e[0],r,e[1],e[2]])]},e.parseInstanceNormalizationAttributes=t=>t.attributes.getFloat("epsilon",1e-5);const o={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[i.TextureType.unpacked]},a=t=>Object.assign(Object.assign({},o),{get:()=>((t,e)=>{const n=e.dims.slice(),r=n[1],o=n[2]*n[3],a=[n[0],r],s=`\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${o});\n        temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${o});\n\n        return v;\n      }`;return Object.assign(Object.assign({},t),{output:{dims:a,type:e.type,textureType:i.TextureType.packedLastDimension},shaderSource:s})})(o,t)}),s={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[i.TextureType.unpacked,i.TextureType.packedLastDimension,i.TextureType.unpacked,i.TextureType.unpacked]},u=(t,e,n,o)=>{const a=Object.assign(Object.assign({},s),{cacheHint:`${n}`});return Object.assign(Object.assign({},a),{get:()=>((t,e,n,o,a)=>{const s=(0,r.getGlsl)(t.session.backend.glContext.version),[u,c]=t.calculateTextureWidthAndHeight(a,i.TextureType.packedLastDimension),[l,p]=[u/4,c],f=`\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${l}, ${p});\n        return ${s.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;return Object.assign(Object.assign({},e),{output:{dims:n.dims,type:n.type,textureType:i.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:o}],shaderSource:f})})(t,a,e,n,o)})},c=t=>{if(!t||3!==t.length)throw new Error("InstanceNormalization requires 3 inputs.");const e=t[0],n=t[1],r=t[2];if(e.dims.length<3||1!==n.dims.length||1!==r.dims.length)throw new Error("Invalid input shape.");if(n.dims[0]!==e.dims[1]||r.dims[0]!==e.dims[1])throw new Error("Input shapes are mismatched.");if("float32"!==e.type&&"float64"!==e.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==r.type&&"float64"!==r.type)throw new Error("Invalid input type.");if(4!==t[0].dims.length)throw new Error("Only support 4-D input shape.")}},708:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createPackedMatmulProgramInfoLoader=void 0;const r=n(2517),i=n(5060),o=n(2039),a=n(9390),s=n(2823),u=n(5623);e.createPackedMatmulProgramInfoLoader=(t,e,n)=>{const c=(l=e.length>2,p=n.activationCacheKey,{name:"MatMul (packed)",inputNames:l?["A","B","Bias"]:["A","B"],inputTypes:l?[o.TextureType.packed,o.TextureType.packed,o.TextureType.packed]:[o.TextureType.packed,o.TextureType.packed],cacheHint:p});var l,p;return Object.assign(Object.assign({},c),{get:()=>((t,e,n,c)=>{const l=n.length>2,p=l?"value += getBiasForMatmul();":"",f=n[0].dims,d=n[1].dims,h=r.BroadcastUtil.calcShape(f,d,!0),g=!r.ShapeUtil.areEqual(n[0].dims,n[1].dims);if(!h)throw new Error("Can't use matmul on the given tensors");const b=f[f.length-1],m=Math.ceil(b/2),y=f.length,_=d.length,v=(0,i.getGlsl)(t.session.backend.glContext.version),w=(0,a.getCoordsDataType)(h.length),x=h.length,T=(0,a.getGlChannels)(),{activationFunction:S,applyActivation:O}=(0,s.getActivationSnippet)(c),A=l?`${(0,u.getBiasForMatmul)(w,T,n[2].dims,h,!0)}`:"",E=g?`${function(t,e,n,i){let o=[],a=[];const s=n[0].dims,u=n[1].dims,c=s.length,l=u.length,p=i.length,f=p-c,d=p-l;o=s.map(((t,n)=>`coords.${e[n+f]}`)),o[c-1]="i*2",o.join(", "),a=u.map(((t,n)=>`coords.${e[n+d]}`)),a[l-2]="i*2",a.join(", ");const h=r.BroadcastUtil.getBroadcastDims(s,i),g=r.BroadcastUtil.getBroadcastDims(u,i),b=h.map((t=>`coords.${e[t+f]} = 0;`)).join("\n"),m=g.map((t=>`coords.${e[t+d]} = 0;`)).join("\n"),y=`int lastDim = coords.${e[p-1]};\n  coords.${e[p-1]} = coords.${e[p-2]};\n  coords.${e[p-2]} = lastDim;`;return`\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${t} coords = getOutputCoords();\n  ${y}\n  ${b}\n  vec4 outputValue = getA(${o});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${t} coords = getOutputCoords();\n  ${y}\n  ${m}\n  vec4 outputValue = getB(${a});\n  return outputValue;\n}`}(w,T,n,h)}`:"",I=g?"getAAtOutCoordsMatmul(i)":`getA(${function(t,e){let n="";for(let r=0;r<e-2;r++)n+=`rc.${t[r]}, `;return n+=`rc.${t[e-2]}, i*2`,n}(T,y)})`,P=g?"getBAtOutCoordsMatmul(i)":`getB(${function(t,e){let n="";for(let r=0;r<e-2;r++)n+=`rc.${t[r]}, `;return n+=`i*2, rc.${t[e-1]}`,n}(T,_)})`,D=`\n            ${E}\n            ${A}\n            ${S}\n            void main() {\n              ${g?"":`${w} rc =\n          getOutputCoords(); int lastDim = rc.${T[x-1]}; rc.${T[x-1]} =\n          rc.${T[x-2]}; rc.${T[x-2]} = lastDim;\n      `}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${m}; i++) {\n                vec4 a = ${I};\n                vec4 b = ${P};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${p}\n              ${O}\n              ${v.output} = value;\n            }`;return Object.assign(Object.assign({},e),{output:{dims:h,type:n[0].type,textureType:o.TextureType.packed},shaderSource:D,hasMain:!0})})(t,c,e,n)})}},5623:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getBiasForMatmul=e.createMatmulProgramInfoLoader=e.parseMatMulAttributes=e.matMul=void 0;const r=n(2517),i=n(2039),o=n(9390),a=n(2823),s=n(708);function u(t,e){const n=(s=t.length>2,u=e.activationCacheKey,{name:"MatMul",inputNames:s?["A","B","Bias"]:["A","B"],inputTypes:s?[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]:[i.TextureType.unpacked,i.TextureType.unpacked],cacheHint:u});var s,u;return Object.assign(Object.assign({},n),{get:()=>function(t,e,n){const s=e[0].dims,u=e[1].dims,c=r.BroadcastUtil.calcShape(s,u,!0);if(!c)throw new Error("Can't use matmul on the given tensors");const p=(0,o.getCoordsDataType)(c.length),f=(0,o.getGlChannels)(),{activationFunction:d,applyActivation:h}=(0,a.getActivationSnippet)(n),g=e.length>2,b=g?"value += getBiasForMatmul();":"",m=g?`${l(p,f,e[2].dims,c,!1)}`:"",y=c.length,_=s.length,v=u.length,w=`\n    ${d}\n    ${m}\n    float process(int indices[${y}]) {\n        int a[${_}];\n        int b[${v}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${s[s.length-1]}; ++k) {\n            a[${_-1}] = k;\n            b[${v-2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${b}\n        ${h}\n        return value;\n    }`;return Object.assign(Object.assign({},t),{output:{dims:c,type:e[0].type,textureType:i.TextureType.unpacked},shaderSource:w})}(n,t,e)})}e.matMul=(t,e,n)=>(c(e),t.session.pack?[t.run((0,s.createPackedMatmulProgramInfoLoader)(t,e,n),e)]:[t.run(u(e,n),e)]),e.parseMatMulAttributes=t=>(0,a.parseInternalActivationAttributes)(t.attributes),e.createMatmulProgramInfoLoader=u;const c=t=>{if(!t||2!==t.length)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.");if("float32"!==t[0].type&&"float64"!==t[0].type||"float32"!==t[1].type&&"float64"!==t[1].type)throw new Error("inputs should be float type");if(t[0].type!==t[1].type)throw new Error("inputs types should match")};function l(t,e,n,i,o){let a="";const s=n.length,u=i.length,c=u-s;a=u<2&&s>0?"coords":n.map(((t,n)=>`coords.${e[n+c]}`)).join(", ");const l=r.BroadcastUtil.getBroadcastDims(n,i).map((t=>`coords.${e[t+c]} = 0;`)).join("\n");let p="vec4(outputValue.xx, outputValue.yy)";return 1===r.ShapeUtil.size(n)&&(p="vec4(outputValue.x)"),o?`\nvec4 getBiasForMatmul() {\n  ${t} coords = getOutputCoords();\n  ${l}\n  vec4 outputValue = getBias(${a});\n  return ${p};\n}`:`\nfloat getBiasForMatmul() {\n  ${t} coords = getOutputCoords();\n  ${l}\n  return getBias(coords.x);\n}`}e.getBiasForMatmul=l},2403:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createPackProgramInfoLoader=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827),s={name:"pack",inputNames:["A"],inputTypes:[i.TextureType.unpackedReversed]};e.createPackProgramInfoLoader=(t,e)=>Object.assign(Object.assign({},s),{get:()=>((t,e)=>{const n=(0,r.getGlsl)(t.session.backend.glContext.version),u=e.dims,c=u.length,l=e.dims.length,p=(0,o.getCoordsDataType)(l),f=(0,a.getChannels)("rc",l),d=(h=l,g=f,b=u[u.length-2],m=u[u.length-1],0===h||1===h?"":`\n    int r = ${g[h-2]};\n    int c = ${g[h-1]};\n    int rp1 = ${g[h-2]} + 1;\n    int cp1 = ${g[h-1]} + 1;\n    bool rEdge = rp1 >= ${m};\n    bool cEdge = cp1 >= ${b};\n    `);var h,g,b,m;let y;y=0===c?[1,1]:1===c?[u[0],1]:[u[l-1],u[l-2]];const _=function(t,e,n){if(0===t)return"false";if(1===t)return`rc > ${e[0]}`;let r="";for(let i=t-2;i<t;i++)r+=`${n[i]} >= ${e[i-t+2]}`,i<t-1&&(r+="||");return r}(l,y,f),v=function(t,e){const n=t.length;if(0===n)return"getA(), 0, 0, 0";if(1===n)return`getA(rc),\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\n            0, 0`;let r="";if(n>2)for(let t=0;t<n-2;++t)r+=`${e[t]},`;return`getA(${r}r, c),\n          rEdge ? 0. : getA(${r}rp1, c),\n          cEdge ? 0. : getA(${r}r, cp1),\n          rEdge || cEdge ? 0. : getA(${r}rp1, cp1)`}(u,f),w=`\n        void main() {\n          ${p} rc = getOutputCoords();\n\n          if(${_}) {\n            ${n.output} = vec4(0);\n          } else {\n            ${d}\n\n            ${n.output} = vec4(${v});\n          }\n        }\n      `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:e.dims,type:e.type,textureType:i.TextureType.packed},shaderSource:w})})(t,e)})},2827:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.unpackFromChannel=e.getChannels=e.getVecChannels=void 0;const r=n(9390);function i(t,e){return(0,r.getGlChannels)(e).map((e=>`${t}.${e}`))}e.getVecChannels=i,e.getChannels=function(t,e){return 1===e?[t]:i(t,e)},e.unpackFromChannel=function(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}},2870:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parsePadAttributesV11=e.padV11=e.parsePadAttributesV2=e.padV2=void 0;const r=n(246),i=n(2517),o=n(5060),a=n(2039),s={name:"Pad",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};e.padV2=(t,e,n)=>(l(e),[t.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>c(t,e[0],n)}),e)]),e.parsePadAttributesV2=t=>{const e=t.attributes.getString("mode","constant"),n=t.attributes.getFloat("value",0),i=t.attributes.getInts("pads");return(0,r.createAttributeWithCacheKey)({mode:e,value:n,pads:i})},e.padV11=(t,n,r)=>{p(n);const i=u(t,n,r);return(0,e.padV2)(t,[n[0]],i)},e.parsePadAttributesV11=t=>t.attributes.getString("mode","constant");const u=(t,e,n)=>{if(!t.session.isInitializer(e[1].dataId)||e.length>=3&&!t.session.isInitializer(e[2].dataId))throw new Error("dynamic pad attributes are not allowed");const i=Array.from(e[1].integerData),o=e.length>=3?e[2].floatData[0]:0;return(0,r.createAttributeWithCacheKey)({mode:n,pads:i,value:o})},c=(t,e,n)=>{const r=i.ShapeUtil.padShape(e.dims.slice(),n.pads),o=r.length,s=`\n      ${f(t,e,n)}\n      float process(int[${o}] indices) {\n          return padA(indices);\n      }`;return{name:"Pad",inputNames:["A"],inputTypes:[a.TextureType.unpacked],output:{dims:r,type:e.type,textureType:a.TextureType.unpacked},shaderSource:s}},l=t=>{if(!t||1!==t.length)throw new Error("Pad requires 1 input");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type.")},p=t=>{if(!t||2!==t.length&&3!==t.length)throw new Error("Pad requires 2 or 3 inputs");if("int32"!==t[1].type)throw new Error("Invalid input type.");if(t.length>=3&&"string"===t[2].type)throw new Error("Invalid input type.")},f=(t,e,n)=>{const r=(0,o.getGlsl)(t.session.backend.glContext.version),[s,u]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),c=i.ShapeUtil.computeStrides(e.dims);switch(n.mode){case"constant":return d(r,e.dims,c,s,u,n.pads,n.value);case"reflect":return h(r,e.dims,c,s,u,n.pads);case"edge":return g(r,e.dims,c,s,u,n.pads);default:throw new Error("Invalid mode")}},d=(t,e,n,r,i,o,a)=>{const s=e.length;let u="";for(let t=s-1;t>=0;--t)u+=`\n        k = m[${t}] - ${o[t]};\n        if (k < 0)  return constant;\n        if (k >= ${e[t]}) return constant;\n        offset += k * ${n[t]};\n        `;return`\n      float padA(int m[${s}]) {\n        const float constant = float(${a});\n        int offset = 0;\n        int k = 0;\n        ${u}\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\n        return value;\n      }\n      `},h=(t,e,n,r,i,o)=>{const a=e.length;let s="";for(let t=a-1;t>=0;--t)s+=`\n        k = m[${t}] - ${o[t]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2*(e[t]-1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${e[t]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${n[t]};\n        `;return`\n      float padA(int m[${a}]) {\n        int offset = 0;\n        int k = 0;\n        ${s}\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\n        return value;\n      }\n      `},g=(t,e,n,r,i,o)=>{const a=e.length;let s="";for(let t=a-1;t>=0;--t)s+=`\n        k = m[${t}] - ${o[t]};\n        if (k < 0)  k = 0;\n        if (k >= ${e[t]}) k = ${e[t]-1};\n        offset += k * ${n[t]};\n      `;return`\n      float padA(int m[${a}]) {\n        int offset = 0;\n        int k = 0;\n        ${s}\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\n        return value;\n      }\n      `}},2143:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.globalMaxPool=e.parseMaxPoolAttributes=e.maxPool=e.parseGlobalAveragePoolAttributes=e.globalAveragePool=e.parseAveragePoolAttributes=e.averagePool=void 0;const r=n(246),i=n(2517),o=n(2039);e.averagePool=(t,e,n)=>{p(e);const r={name:"AveragePool",inputNames:["X"],inputTypes:[o.TextureType.unpacked],cacheHint:n.cacheKey};return[t.run(Object.assign(Object.assign({},r),{get:()=>a(e,r,!1,n)}),e)]},e.parseAveragePoolAttributes=t=>{const e=t.attributes.getString("auto_pad","NOTSET"),n=t.attributes.getInt("ceil_mode",0),i=0!==t.attributes.getInt("count_include_pad",0),o=t.attributes.getInts("kernel_shape"),a=t.attributes.getInts("strides",[]),s=t.attributes.getInts("pads",[]);if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,r.createAttributeWithCacheKey)({autoPad:e,ceilMode:n,countIncludePad:i,kernelShape:o,strides:a,pads:s})};const a=(t,e,n,r)=>{const[a,s]=u(t,r,n),c=i.ShapeUtil.size(a.kernelShape);let l="";a.countIncludePad?l+=`value /= float(${c});`:l+=`value /= float(${c} - pad);`;const p=`\n        ${f(t[0].dims,a,"value += _X(x);",l,"0.0")}\n      `;return Object.assign(Object.assign({},e),{output:{dims:s,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:p})};e.globalAveragePool=(t,e,n)=>{p(e);const r={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[o.TextureType.unpacked],cacheHint:`${n.countIncludePad}`};return[t.run(Object.assign(Object.assign({},r),{get:()=>a(e,r,!0,n)}),e)]},e.parseGlobalAveragePoolAttributes=t=>{const e=0!==t.attributes.getInt("count_include_pad",0);return(0,r.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:e,kernelShape:[],strides:[],pads:[]})},e.maxPool=(t,e,n)=>{p(e);const r={name:"MaxPool",inputNames:["X"],inputTypes:[o.TextureType.unpacked],cacheHint:n.cacheKey};return[t.run(Object.assign(Object.assign({},r),{get:()=>s(e,r,!1,n)}),e)]},e.parseMaxPoolAttributes=t=>{const e=t.attributes.getString("auto_pad","NOTSET"),n=t.attributes.getInt("ceil_mode",0),i=t.attributes.getInts("kernel_shape"),o=t.attributes.getInts("strides",[]),a=t.attributes.getInts("pads",[]),s=t.attributes.getInt("storage_order",0),u=t.attributes.getInts("dilations",[]);if(0!==s)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,r.createAttributeWithCacheKey)({autoPad:e,ceilMode:n,countIncludePad:!1,kernelShape:i,strides:o,pads:a,storageOrder:s,dilations:u})};const s=(t,e,n,r)=>{const[i,a]=u(t,r,n),s=`\n      ${f(t[0].dims,i,"\n      value = max(_X(x), value);\n    ","","-1e5")}\n    `;return Object.assign(Object.assign({},e),{output:{dims:a,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:s})},u=(t,e,n)=>{const r=t[0].dims.slice(),o=Object.hasOwnProperty.call(e,"dilations"),a=e.kernelShape.slice(),s=e.strides.slice(),u=o?e.dilations.slice():[],c=e.pads.slice();i.PoolConvUtil.adjustPoolAttributes(n,r,a,s,u,c);const l=i.PoolConvUtil.computePoolOutputShape(n,r,s,u,a,c,e.autoPad),p=Object.assign({},e);return o?Object.assign(p,{kernelShape:a,strides:s,pads:c,dilations:u,cacheKey:e.cacheKey}):Object.assign(p,{kernelShape:a,strides:s,pads:c,cacheKey:e.cacheKey}),[p,l]},c={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},l={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[o.TextureType.unpacked]};e.globalMaxPool=(t,e)=>(p(e),[t.run(Object.assign(Object.assign({},l),{get:()=>s(e,l,!0,c)}),e)]);const p=t=>{if(!t||1!==t.length)throw new Error("Pool ops requires 1 input.");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type.")},f=(t,e,n,r,o)=>{const a=t.length;if(e.kernelShape.length<=2){const i=e.kernelShape[e.kernelShape.length-1],s=e.strides[e.strides.length-1],u=e.pads[e.pads.length/2-1],c=e.pads[e.pads.length-1],l=t[a-1];let p="",f="",d="";if(p=u+c!==0?`\n          for (int i = 0; i < ${i}; i++) {\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\n            if (x[${a} - 1] < 0 || x[${a} - 1] >= ${l}) {\n              pad++;\n              continue;\n            }\n            ${n}\n          }`:`\n          for (int i = 0; i < ${i}; i++) {\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\n            ${n}\n          }`,2===e.kernelShape.length){const n=e.kernelShape[e.kernelShape.length-2],r=e.strides[e.strides.length-2],o=e.pads[e.pads.length/2-2],s=e.pads[e.pads.length-2],u=t[a-2];f=o+s!==0?`\n            for (int j = 0; j < ${n}; j++) {\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${o} + j;\n              if (x[${a} - 2] < 0 || x[${a} - 2] >= ${u}) {\n                pad+= ${i};\n                continue;\n              }\n          `:`\n            for (int j = 0; j < ${n}; j++) {\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${o} + j;\n            `,d="\n          }\n        "}return`\n        float process(int indices[${a}]) {\n          int x[${a}];\n          copyVec(indices, x);\n\n          float value = ${o};\n          int pad = 0;\n          ${f}\n          ${p}\n          ${d}\n          ${r}\n          return value;\n        }\n      `}{const s=i.ShapeUtil.size(e.kernelShape),u=i.ShapeUtil.computeStrides(e.kernelShape),c=u.length,l=e.pads.length,p=h(c),f=d(t,"inputDims"),g=d(e.pads,"pads"),b=d(u,"kernelStrides"),m=d(e.strides,"strides");let y="";return y=e.pads.reduce(((t,e)=>t+e))?`\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${n}\n          }`:`\n          }\n          ${n}\n        `,`\n        ${p}\n        float process(int indices[${a}]) {\n          int x[${a}];\n          copyVec(indices, x);\n          int offset[${c}];\n          int pads[${l}];\n          int inputDims[${a}];\n          int kernelStrides[${c}];\n          int strides[${c}];\n          ${g}\n          ${f}\n          ${m}\n          ${b}\n\n          float value = ${o};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${s}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${a} - ${c}; j < ${a}; j++) {\n              x[j] = indices[j] * strides[j - ${a} + ${c}]\n                + offset[j - ${a} + ${c}] - pads[j - 2];\n              ${y}\n          }\n          ${r}\n\n          return value;\n        }\n      `}},d=(t,e)=>{let n="";for(let r=0;r<t.length;r++)n+=`\n      ${e}[${r}] = ${t[r]};\n    `;return n},h=t=>`\n  void offsetToIndices(int offset, int[${t}] strides, out int[${t}] indices) {\n    if (${t} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${t} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${t} - 1] = offset;\n  }`},4939:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.reduceLogSumSquare=e.reduceLogSum=e.reduceProd=e.reduceMin=e.reduceMax=e.reduceMean=e.reduceSum=e.parseReduceAttributes=void 0;const r=n(246),i=n(782),o=n(2517),a=n(2039),s=(t,e,n,r,i)=>{c(e);const o={name:r,inputNames:["A"],inputTypes:[a.TextureType.unpacked]};return[t.run(Object.assign(Object.assign({},o),{cacheHint:n.cacheKey,get:()=>u(t,e,n,r,i,o)}),e)]};e.parseReduceAttributes=t=>{const e=t.attributes.getInts("axes",[]),n=1===t.attributes.getInt("keepdims",1);return(0,r.createAttributeWithCacheKey)({axes:e,keepDims:n})};const u=(t,e,n,r,i,s)=>{const u=[],c=e[0].dims.length||1,l=[],p=o.ShapeUtil.normalizeAxes(n.axes,e[0].dims.length),f=i(e,p);let d=f[1];for(let t=0;t<e[0].dims.length;t++)p.indexOf(t)>=0||0===p.length?(n.keepDims&&u.push(1),d=`\n          for(int j${t} = 0; j${t} < ${e[0].dims[t]}; j${t}++) {\n            inputIdx[${t}] = j${t};\n            ${d}\n          }`):(l.push(`inputIdx[${t}] = outputIdx[${u.length}];`),u.push(e[0].dims[t]));const h=`\n      float process(int outputIdx[${u.length||1}]) {\n        float value;                 // final result\n        int inputIdx[${c}];      // addressing input data\n        ${l.join("\n")}\n        ${f[0]}       // init ops for reduce max/min\n        ${d}\n        ${f[2]}       // final computation for reduce mean\n        return value;\n      }`;return Object.assign(Object.assign({},s),{output:{dims:u,type:e[0].type,textureType:a.TextureType.unpacked},shaderSource:h})},c=t=>{if(!t||1!==t.length)throw new Error("Reduce op requires 1 input.");if(-1===i.NUMBER_TYPES.indexOf(t[0].type))throw new Error("Invalid input type.")};e.reduceSum=(t,e,n)=>s(t,e,n,"ReduceSum",(()=>["value = 0.0;","value += _A(inputIdx);",""])),e.reduceMean=(t,e,n)=>s(t,e,n,"ReduceMean",((t,e)=>{let n=1;for(let r=0;r<t[0].dims.length;r++)(e.indexOf(r)>=0||0===e.length)&&(n*=t[0].dims[r]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${n}.;`]})),e.reduceMax=(t,e,n)=>s(t,e,n,"ReduceMax",((t,e)=>{const n=[];for(let r=0;r<t[0].dims.length;r++)(e.indexOf(r)>=0||0===e.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]})),e.reduceMin=(t,e,n)=>s(t,e,n,"ReduceMin",((t,e)=>{const n=[];for(let r=0;r<t[0].dims.length;r++)(e.indexOf(r)>=0||0===e.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]})),e.reduceProd=(t,e,n)=>s(t,e,n,"ReduceProd",(()=>["value = 1.0;","value *= _A(inputIdx);",""])),e.reduceLogSum=(t,e,n)=>s(t,e,n,"ReduceLogSum",(()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"])),e.reduceLogSumSquare=(t,e,n)=>s(t,e,n,"ReduceLogSumSquare",(()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""]))},7019:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.isReshapeCheap=e.processDims3D=e.createPackedReshape3DProgramInfoLoader=void 0;const r=n(2517),i=n(5060),o=n(2039),a=n(2827);e.createPackedReshape3DProgramInfoLoader=(t,e,n)=>{const s=(t=>({name:"Reshape (packed)",inputTypes:[o.TextureType.packed],inputNames:["A"],cacheHint:`${t}`}))(n);return Object.assign(Object.assign({},s),{get:()=>((t,e,n,s)=>{const u=e.dims,c=s;let l="";for(let t=0;t<4;t++){let e="";switch(t){case 0:e="outputCoords = rc;";break;case 1:e="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:e="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:e="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}l+=`\n        ${e}\n        ${t>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${t}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${t>0?"}":""}\n      `}const p=(0,i.getGlsl)(t.session.backend.glContext.version),f=`\n      ${function(t){const e=r.ShapeUtil.computeStrides(t),n=["b","r","c"],i="index";return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${e.map(((t,r)=>`int ${n[r]} = ${i} / ${t}; ${r===e.length-1?`int ${n[r+1]} = ${i} - ${n[r]} * ${t}`:`index -= ${n[r]} * ${t}`};`)).join("")}\n      return ivec3(b, r, c);\n    }\n  `}(u)}\n      ${function(t){const e=r.ShapeUtil.computeStrides(t);return`\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;\n  }\n`}(c)}\n      ${(0,a.unpackFromChannel)()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${c[2]};\n        int cols = ${c[1]};\n\n        ${l}\n        ${p.output} = result;\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:c,type:e.type,textureType:o.TextureType.packed},shaderSource:f,hasMain:!0})})(t,e,s,n)})},e.processDims3D=function(t){if(0===t.length)return[1,1,1];let e=1;for(let n=0;n<t.length-2;++n)e*=t[n];return[e,t.length>1?t[t.length-2]:1,t[t.length-1]]},e.isReshapeCheap=function(t,e){let n=!1;return n=0===t.length||0===e.length||(t.length<2||e.length<2?t[t.length-1]===e[e.length-1]:t[t.length-1]===e[e.length-1]&&t[t.length-2]===e[e.length-2]),n}},718:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.reshape=void 0;const r=n(2517);e.reshape=(t,e)=>{const n=r.ShapeUtil.calculateReshapedDims(e[0].dims,e[1].integerData);return t.session.pack?[t.reshapePacked(e[0],n)]:[t.reshapeUnpacked(e[0],n)]}},2268:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseResizeAttributesV11=e.parseResizeAttributesV10=e.resize=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827),s=n(9793),u={name:"Resize",inputNames:["A"],inputTypes:[i.TextureType.packed]};e.resize=(t,e,n)=>((0,s.validateInputs)(e,n),[t.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>c(t,e,n)}),e)]),e.parseResizeAttributesV10=t=>(0,s.parseUpsampleAttributes)(t,10),e.parseResizeAttributesV11=t=>(0,s.parseUpsampleAttributes)(t,11);const c=(t,e,n)=>{const s=(0,r.getGlsl)(t.session.backend.glContext.version),[c,p]=l(e,n);if(c.every((t=>1===t))&&"tf_crop_and_resize"!==n.coordinateTransformMode)return Object.assign(Object.assign({},u),{output:{dims:p,type:e[0].type,textureType:i.TextureType.packed},hasMain:!0,shaderSource:`void main() {\n                    vec4 v = ${s.texture2D}(X, TexCoords);\n                    ${s.output} = v;\n                }`});const f=p.length;if(f<2)throw new Error(`output dimension should be at least 2, but got ${f}`);const d=p[f-2],h=p[f-1],g=e[0].dims;if(f!==g.length)throw new Error(`output dimension should match input ${g.length}, but got ${f}`);const b=g[f-2],m=g[f-1],y=c[f-2],_=c[f-1];let v="";if("linear"!==n.mode)throw new Error(`resize (packed) does not support mode: '${n.mode}'`);switch(n.coordinateTransformMode){case"asymmetric":v="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":v="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":v=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${d}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${d}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;break;case"align_corners":v=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${h}.0 - 1.0, ${d}.0 - 1.0, ${h}.0 - 1.0,\n                            ${d}.0 - 1.0);\n                        vec4 original = vec4(${m}.0 - 1.0, ${b}.0 - 1.0, ${m}.0 - 1.0,\n                            ${b}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`)}const w=(0,o.getCoordsDataType)(f),x=`\n            const vec2 inputWH = vec2(${b}.0, ${m}.0);\n            const vec4 scaleWHWH = vec4(float(${y}), float(${_}), float(${y}), float(${_}));\n            ${(0,a.unpackFromChannel)()}\n            ${v}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${w} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${d-1};\n                bool hasNextCol = rc.z < ${h-1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${s.output} = vec4(newValue);\n            }\n        `;return Object.assign(Object.assign({},u),{output:{dims:p,type:e[0].type,textureType:i.TextureType.packed},hasMain:!0,shaderSource:x})},l=(t,e)=>{const n=t[0].dims;let r,i=e.scales;if(0===i.length){const o=t[e.scalesInputIdx];if(o&&0!==o.size){if(t[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");i=p(o,e.mode,e.isResize)}else{const o=t[e.sizesInputIdx];if(!o||0===o.size)throw new Error("Either scales or sizes MUST be provided as input.");r=Array.from(o.integerData),i=f(r,n,e.mode,e.isResize)}}else if(t[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const o=r||n.map(((t,e)=>Math.floor(t*i[e])));return[i,o]},p=(t,e,n)=>{const r=Array.from(t.floatData);return(0,s.scalesValidation)(r,e,n),r},f=(t,e,n,r)=>{const i=e.length,o=new Array(i);for(let n=0,r=i;n<r;n++)if(0===e[n]){if(0!==t[n])throw new Error("Input dim is zero but required output dim is non-zero.");o[n]=1}else o[n]=t[n]/e[n];return(0,s.scalesValidation)(o,n,r),o}},8117:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.shape=void 0;const r=n(9162);e.shape=(t,e)=>(i(e),[new r.Tensor([e[0].dims.length],"int32",void 0,void 0,new Int32Array(e[0].dims))]);const i=t=>{if(!t||1!==t.length)throw new Error("Shape requires 1 input.")}},2278:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sliceV10=e.parseSliceAttributes=e.slice=void 0;const r=n(246),i=n(782),o=n(2517),a=n(2039),s={name:"Slice",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};e.slice=(t,e,n)=>(c(e),[t.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>u(t,e[0],n)}),e)]),e.parseSliceAttributes=t=>{const e=t.attributes.getInts("starts"),n=t.attributes.getInts("ends"),i=t.attributes.getInts("axes",[]);return(0,r.createAttributeWithCacheKey)({starts:e,ends:n,axes:i})};const u=(t,e,n)=>{const r=0===n.axes.length?e.dims.slice(0).map(((t,e)=>e)):n.axes,i=o.ShapeUtil.normalizeAxes(r,e.dims.length),u=n.starts.map(((t,n)=>t>e.dims[i[n]]-1?e.dims[i[n]]:o.ShapeUtil.normalizeAxis(t,e.dims[i[n]]))),c=n.ends.map(((t,n)=>t>e.dims[i[n]]-1?e.dims[i[n]]:o.ShapeUtil.normalizeAxis(t,e.dims[i[n]]))),l=e.dims.slice(),p=[];for(let t=0;t<i.length;t++)l[i[t]]=c[t]-u[t],u[t]>0&&p.push(`outputIdx[${i[t]}] += ${u[t]};`);const f=`\n      float process(int outputIdx[${l.length}]) {\n        ${p.join("\n      ")}\n        return _A(outputIdx);\n      }`;return Object.assign(Object.assign({},s),{output:{dims:l,type:e.type,textureType:a.TextureType.unpacked},shaderSource:f})},c=t=>{if(!t||1!==t.length)throw new Error("Slice requires 1 input.");if(-1===i.NUMBER_TYPES.indexOf(t[0].type))throw new Error("Invalid input type.")};e.sliceV10=(t,e)=>{p(e);const n=l(t,e);return[t.run(Object.assign(Object.assign({},s),{cacheHint:n.cacheKey,get:()=>u(t,e[0],n)}),[e[0]])]};const l=(t,e)=>{if(!t.session.isInitializer(e[1].dataId)||!t.session.isInitializer(e[2].dataId)||e.length>=4&&!t.session.isInitializer(e[3].dataId)||e.length>=5&&!t.session.isInitializer(e[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(e.length>=5&&e[4].integerData.some((t=>1!==t)))throw new Error("currently non-1 steps is not supported for Slice");const n=Array.from(e[1].integerData),r=Array.from(e[2].integerData),i=e.length>=4?Array.from(e[3].integerData):[];return{starts:n,ends:r,axes:i,cacheKey:`${i};${n};${r}`}},p=t=>{if(!t||t.length<3||t.length>5)throw new Error("Invalid input number.");if("int32"!==t[1].type||1!==t[1].dims.length)throw new Error("Invalid input type.");if("int32"!==t[2].type||1!==t[2].dims.length)throw new Error("Invalid input type.");if(t.length>=4&&("int32"!==t[3].type||1!==t[3].dims.length))throw new Error("Invalid input type.");if(t.length>=5&&("int32"!==t[4].type||1!==t[4].dims.length))throw new Error("Invalid input type.")}},5524:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.softmaxV13=e.parseSoftmaxAttributesV13=e.parseSoftmaxAttributes=e.softmax=void 0;const r=n(246),i=n(2517),o=n(5060),a=n(2039),s=n(3738),u={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[a.TextureType.unpacked]},c={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked]},l={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]};e.softmax=(t,e,n)=>{g(e);const r=e[0].dims.slice(),o=i.ShapeUtil.normalizeAxis(n.axis,r.length),a=i.ShapeUtil.sizeToDimension(r,o),s=i.ShapeUtil.sizeFromDimension(r,o);return p(t,e,n,a,s)},e.parseSoftmaxAttributes=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt("axis",1)}),e.parseSoftmaxAttributesV13=t=>(0,r.createAttributeWithCacheKey)({axis:t.attributes.getInt("axis",-1)}),e.softmaxV13=(t,e,n)=>{g(e);const o=e[0].dims.slice(),a=i.ShapeUtil.normalizeAxis(n.axis,o.length),u=o.length,c=a!==u-1,l=[];let f,d=[],h=[];c&&(d=Array.from({length:u}).map(((t,e)=>e)),d[a]=u-1,d[u-1]=a,d.map((t=>l.push(o[t]))),f=(0,r.createAttributeWithCacheKey)({perm:d}),h=(0,s.transpose)(t,e,f));const b=c?i.ShapeUtil.sizeToDimension(l,u-1):i.ShapeUtil.sizeToDimension(o,u-1),m=c?i.ShapeUtil.sizeFromDimension(l,u-1):i.ShapeUtil.sizeFromDimension(o,u-1),y=p(t,c?h:e,n,b,m);return c?(0,s.transpose)(t,y,f):y};const p=(t,e,n,r,i)=>{const o=f(t,e[0],r,i,[r]),a=t.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>o}),e),s=d(t,e[0],r,i,o.output.dims,[r]),p=t.run(Object.assign(Object.assign({},c),{cacheHint:n.cacheKey,get:()=>s}),[e[0],a]),g=h(t,e[0],r,i,o.output.dims,s.output.dims);return[t.run(Object.assign(Object.assign({},l),{cacheHint:n.cacheKey,get:()=>g}),[e[0],a,p])]},f=(t,e,n,r,i)=>{const[s,c]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),l=i.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==i.length)throw new Error("Dimensionality of the output should be 1");if(i[0]!==n)throw new Error("Shape of the output should be equal to logical row count");const p=(0,o.getGlsl)(t.session.backend.glContext.version),f=`\n      float process(int[${l}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s},\n        ${c} )));\n        for(int i=1; i<${r}; ++i)\n        {\n          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${s}, ${c})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;return Object.assign(Object.assign({},u),{output:{dims:i,type:e.type,textureType:a.TextureType.unpacked},shaderSource:f})},d=(t,e,n,r,i,s)=>{const[u,l]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),p=s.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length)throw new Error("Dimensionality of the output should be 1");if(s[0]!==n)throw new Error("Shape of the output should be equal to logical row count");if(1!==i.length)throw new Error("Dimensionality of the intermediate results should be 1");if(i[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const f=`\n      float process(int[${p}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${r}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${(0,o.getGlsl)(t.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${u}, ${l}))) - max);\n        }\n\n        return norm_factor;\n      }`;return Object.assign(Object.assign({},c),{output:{dims:s,type:e.type,textureType:a.TextureType.unpacked},shaderSource:f})},h=(t,e,n,r,i,o)=>{const[s,u]=t.calculateTextureWidthAndHeight(e.dims,a.TextureType.unpacked),c=e.dims.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==i.length||1!==o.length)throw new Error("Dimensionality of the intermediate results should be 1");if(i[0]!==n||o[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const p=`\n      float process(int[${c}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${s}, ${u});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${r};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;return Object.assign(Object.assign({},l),{output:{dims:e.dims,type:e.type,textureType:a.TextureType.unpacked},shaderSource:p})},g=t=>{if(!t||1!==t.length)throw new Error("Softmax requires 1 input.");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type")}},5975:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseSplitAttributes=e.split=void 0;const r=n(246),i=n(2517),o=n(2039),a={name:"Split",inputNames:["A"],inputTypes:[o.TextureType.unpacked]};e.split=(t,e,n)=>{c(e);const r=i.ShapeUtil.normalizeAxis(n.axis,e[0].dims.length),o=s(t,e,r,n),l=[];for(let i=0;i<o;++i)l.push(t.run(Object.assign(Object.assign({},a),{cacheHint:`${n.cacheKey};${i}`,get:()=>u(t,e[0],n,r,i)}),e));return l},e.parseSplitAttributes=t=>{const e=t.attributes.getInt("axis",0),n=t.attributes.getInts("split",[]),i=t.outputs.length;return(0,r.createAttributeWithCacheKey)({axis:e,split:n,numOutputs:i})};const s=(t,e,n,r)=>{const[,o]=i.SplitUtil.splitShape(e[0].dims,n,r.split,r.numOutputs);return o.length},u=(t,e,n,r,s)=>{const[u,c]=i.SplitUtil.splitShape(e.dims,r,n.split,n.numOutputs),l=c[s],p=u[s],f=`\n      float process(int indices[${p.length}]) {\n        indices[${r}] += ${l};\n        return _A(indices);\n      }\n    `;return Object.assign(Object.assign({},a),{cacheHint:`${n.cacheKey}:${s}`,output:{dims:p,type:e.type,textureType:o.TextureType.unpacked},shaderSource:f})},c=t=>{if(!t||1!==t.length)throw new Error("Split requires one input.");if("int8"!==t[0].type&&"uint8"!==t[0].type&&"int16"!==t[0].type&&"uint16"!==t[0].type&&"int32"!==t[0].type&&"uint32"!==t[0].type&&"float32"!==t[0].type&&"float64"!==t[0].type&&"bool"!==t[0].type)throw new Error("Invalid input type.")}},3933:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseSqueezeAttributes=e.squeezeV13=e.squeeze=void 0;const r=n(2517);e.squeeze=(t,e,n)=>{i(e);const o=r.ShapeUtil.squeezeShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],o)]},e.squeezeV13=(t,n)=>(o(n),(0,e.squeeze)(t,[n[0]],Array.from(n[1].integerData))),e.parseSqueezeAttributes=t=>t.attributes.getInts("axes");const i=t=>{if(!t||1!==t.length)throw new Error("Squeeze requires 1 input.");if("string"===t[0].type)throw new Error("invalid input tensor types.")},o=t=>{if(!t||2!==t.length)throw new Error("Squeeze requires 2 inputs.");if("int32"!==t[1].type)throw new Error("Invalid input type.")}},6558:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sum=void 0;const r=n(5060),i=n(2039);e.sum=(t,e)=>{a(e);const n={name:"Sum",inputNames:e.map(((t,e)=>`X${e}`)),inputTypes:new Array(e.length).fill(i.TextureType.unpacked)};return[t.run(Object.assign(Object.assign({},n),{get:()=>o(t,e,n)}),e)]};const o=(t,e,n)=>{const o=(0,r.getGlsl)(t.session.backend.glContext.version),a=e[0].dims.slice(),s=`\n      void main() {\n        vec4 result = ${e.map(((t,e)=>`${o.texture2D}(X${e},TexCoords)`)).join(" + ")};\n        ${o.output} = result;\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:a,type:e[0].type,textureType:i.TextureType.unpacked},hasMain:!0,shaderSource:s})},a=t=>{if(!t||0===t.length)throw new Error("Sum requires inputs.");const e=t[0].dims.length;for(let n=1;n<t.length;n++){if(e!==t[n].dims.length)throw new Error("Input shapes are mismatched.");for(let r=0;r<e;r++)if(t[0].dims[r]!==t[n].dims[r])throw new Error("Input shapes are not matched.")}if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("Invalid input type.");for(let e=1;e<t.length;e++)if(t[0].type!==t[e].type)throw new Error("Input types are not matched.")}},5723:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.tile=void 0;const r=n(782),i=n(2039);e.tile=(t,e)=>{a(e);const n={name:"Tile",inputNames:["A"],inputTypes:[i.TextureType.unpacked]};return[t.run(Object.assign(Object.assign({},n),{get:()=>o(t,e,n)}),e)]};const o=(t,e,n)=>{const r=e[0].dims.slice(),o=new Array(r.length),a=[];for(let t=0;t<r.length;t++)o[t]=r[t]*e[1].numberData[t],a.push(`inputIdx[${t}] = int(mod(float(outputIdx[${t}]), ${r[t]}.));`);const s=o.length,u=`\n      float process(int outputIdx[${s}]) {\n        int inputIdx[${s}];\n        ${a.join("\n")}\n        return _A(inputIdx);\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:o,type:e[0].type,textureType:i.TextureType.unpacked},shaderSource:u})},a=t=>{if(!t||2!==t.length)throw new Error("Tile requires 2 input.");if(1!==t[1].dims.length)throw new Error("The second input shape must 1 dimension.");if(t[1].dims[0]!==t[0].dims.length)throw new Error("Invalid input shape.");if(-1===r.NUMBER_TYPES.indexOf(t[0].type))throw new Error("Invalid input type.");if("int32"!==t[1].type&&"int16"!==t[1].type)throw new Error("Invalid repeat type.")}},3738:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseTransposeAttributes=e.transpose=void 0;const r=n(246),i=n(2517),o=n(2039),a={name:"Transpose",inputNames:["A"],inputTypes:[o.TextureType.unpacked]};e.transpose=(t,e,n)=>(p(e),[t.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>s(t,e[0],n.perm)}),e)]),e.parseTransposeAttributes=t=>(0,r.createAttributeWithCacheKey)({perm:t.attributes.getInts("perm",[])});const s=(t,e,n)=>{const r=e.dims;n=u(r,n);const i=c(r,n),s=r.length,p=`\n      ${l("perm",n,s)}\n      float process(int indices[${s}]) {\n        int a[${s}];\n        perm(a, indices);\n        return _A(a);\n      }`;return Object.assign(Object.assign({},a),{output:{dims:i,type:e.type,textureType:o.TextureType.unpacked},shaderSource:p})},u=(t,e)=>(e&&e.length!==t.length&&(e=[...t.keys()].reverse()),e),c=(t,e)=>(e=u(t,e),i.ShapeUtil.sortBasedOnPerm(t,e)),l=(t,e,n)=>{const r=[];r.push(`void ${t}(out int a[${n}], int src[${n}]) {`);for(let t=0;t<n;++t)r.push(`\ta[${e[t]}]=src[${t}];`);return r.push("\t}"),r.join("\n")},p=t=>{if(!t||1!==t.length)throw new Error("Transpose requires 1 input.");if("float32"!==t[0].type&&"float64"!==t[0].type)throw new Error("input should be float tensor")}},8710:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.encodeAsUint8=void 0;const r=n(5060),i=n(2039);e.encodeAsUint8=(t,e)=>{const n=e.shape,o=(0,r.getGlsl)(t.session.backend.glContext.version),a=`\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${o.texture2D}(X,TexCoords).r;\n      ${o.output} = encodeAsUint8(value);\n    }`,s={name:"Uint8Encode",inputTypes:[i.TextureType.unpacked],inputNames:["X"],output:{dims:n,type:e.tensor.type,textureType:i.TextureType.downloadUint8AsFloat},shaderSource:a,hasMain:!0};return t.executeProgram(s,[e.tensor])}},4909:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.tanh=e.tan=e.sqrt=e.sin=e.sigmoid=e.relu=e.not=e.neg=e.log=e.parseLeakyReluAttributes=e.leakyRelu=e.identity=e.floor=e.exp=e.parseEluAttributes=e.elu=e.cos=e.ceil=e.clipV11=e.parseClipAttributes=e.clip=e.atan=e.asin=e.acos=e.abs=e.glslTanh=e.glslTan=e.glslSqrt=e.glslSigmoid=e.glslRelu=e.glslSin=e.glslNot=e.glslNeg=e.glslLog=e.glslLeakyRelu=e.glslIdentity=e.glslClip=e.glslFloor=e.glslExp=e.glslElu=e.glslCos=e.glslCeil=e.glslAtan=e.glslAsin=e.glslAcos=e.glslAbs=void 0;const r=n(246),i=n(2517),o=n(8520),a=n(5060),s=n(2039);function u(){return P("abs")}function c(){return P("acos")}function l(){return P("asin")}function p(){return P("atan")}function f(){return P("ceil")}function d(){return P("cos")}function h(t){const e="elu";return{body:`\n  const float alpha = float(${t});\n\n  float ${e}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function g(){return P("exp")}function b(){return P("floor")}function m(t,e){const n="clip";return{body:`\n  const float min = float(${t});\n  const float max = float(${e});\n\n  float ${n}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${n}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,name:n,type:o.FunctionType.ValueBased}}function y(){const t="indentity";return{body:`\n  float ${t}_(float a) {\n    return a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return v;\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function _(t){const e="leakyRelu";return{body:`\n  const float alpha = float(${t});\n\n  float ${e}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function v(){return P("log")}function w(){const t="neg";return{body:`\n  float ${t}_(float a) {\n    return -a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return -v;\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function x(){const t="not";return{body:`\n  float ${t}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${t}_(bool a) {\n    return !a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${t}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function T(){return P("sin")}function S(){const t="relu";return{body:`\n  float ${t}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${t}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function O(){const t="sigmoid";return{body:`\n  float ${t}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${t}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function A(){return P("sqrt")}function E(){return P("tan")}function I(){const t="tanh";return{body:`\n  float ${t}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${t}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function P(t){return{body:`\n  float ${t}_(float a) {\n    return ${t}(a);\n  }\n  vec4 ${t}_(vec4 v) {\n    return ${t}(v);\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}e.glslAbs=u,e.glslAcos=c,e.glslAsin=l,e.glslAtan=p,e.glslCeil=f,e.glslCos=d,e.glslElu=h,e.glslExp=g,e.glslFloor=b,e.glslClip=m,e.glslIdentity=y,e.glslLeakyRelu=_,e.glslLog=v,e.glslNeg=w,e.glslNot=x,e.glslSin=T,e.glslRelu=S,e.glslSigmoid=O,e.glslSqrt=A,e.glslTan=E,e.glslTanh=I;const D=(t,e,n,r)=>{const i=t.session.pack?s.TextureType.packed:s.TextureType.unpacked,o={name:n.name,inputTypes:[i],inputNames:["A"],cacheHint:r};return Object.assign(Object.assign({},o),{get:()=>((t,e,n,r)=>{const i=t.session.pack?s.TextureType.packed:s.TextureType.unpacked,o=(0,a.getGlsl)(t.session.backend.glContext.version);return Object.assign(Object.assign({},e),{output:{dims:n.dims,type:n.type,textureType:i},shaderSource:`\n     ${r.body}\n     void main() {\n       vec4 v = ${o.texture2D}(A, TexCoords);\n       v = ${r.name}_(v);\n       ${o.output} = v;\n     }\n     `,hasMain:!0})})(t,o,e,n)})};e.abs=(t,e)=>[t.run(D(t,e[0],u()),e)],e.acos=(t,e)=>[t.run(D(t,e[0],c()),e)],e.asin=(t,e)=>[t.run(D(t,e[0],l()),e)],e.atan=(t,e)=>[t.run(D(t,e[0],p()),e)],e.clip=(t,e,n)=>[t.run(D(t,e[0],m(n.min,n.max),n.cacheKey),e)],e.parseClipAttributes=t=>(0,r.createAttributeWithCacheKey)({min:t.attributes.getFloat("min",i.MIN_CLIP),max:t.attributes.getFloat("max",i.MAX_CLIP)}),e.clipV11=(t,n)=>{const r=$(t,n);return(0,e.clip)(t,[n[0]],r)};const $=(t,e)=>{if(e.length>=3&&(!t.session.isInitializer(e[1].dataId)||!t.session.isInitializer(e[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const n=e.length>=3?e[1].numberData[0]:i.MIN_CLIP,o=e.length>=3?e[2].numberData[0]:i.MAX_CLIP;return(0,r.createAttributeWithCacheKey)({min:n,max:o})};e.ceil=(t,e)=>[t.run(D(t,e[0],f()),e)],e.cos=(t,e)=>[t.run(D(t,e[0],d()),e)],e.elu=(t,e,n)=>[t.run(D(t,e[0],h(n.alpha),n.cacheKey),e)],e.parseEluAttributes=t=>(0,r.createAttributeWithCacheKey)({alpha:t.attributes.getFloat("alpha",1)}),e.exp=(t,e)=>[t.run(D(t,e[0],g()),e)],e.floor=(t,e)=>[t.run(D(t,e[0],b()),e)],e.identity=(t,e)=>[t.run(D(t,e[0],y()),e)],e.leakyRelu=(t,e,n)=>[t.run(D(t,e[0],_(n.alpha),n.cacheKey),e)],e.parseLeakyReluAttributes=t=>(0,r.createAttributeWithCacheKey)({alpha:t.attributes.getFloat("alpha",.01)}),e.log=(t,e)=>[t.run(D(t,e[0],v()),e)],e.neg=(t,e)=>[t.run(D(t,e[0],w()),e)],e.not=(t,e)=>[t.run(D(t,e[0],x()),e)],e.relu=(t,e)=>[t.run(D(t,e[0],S()),e)],e.sigmoid=(t,e)=>[t.run(D(t,e[0],O()),e)],e.sin=(t,e)=>[t.run(D(t,e[0],T()),e)],e.sqrt=(t,e)=>[t.run(D(t,e[0],A()),e)],e.tan=(t,e)=>[t.run(D(t,e[0],E()),e)],e.tanh=(t,e)=>[t.run(D(t,e[0],I()),e)]},5611:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createUnpackProgramInfoLoader=e.createUnpackProgramInfo=void 0;const r=n(5060),i=n(2039),o=n(9390),a=n(2827),s={name:"unpack",inputNames:["A"],inputTypes:[i.TextureType.packed]};e.createUnpackProgramInfo=(t,e)=>{const n=e.dims.length,u=(0,a.getChannels)("rc",n),c=u.slice(-2),l=(0,o.getCoordsDataType)(n),p=(0,a.unpackFromChannel)(),f=0===e.dims.length?"":function(t,e){if(1===t)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(n,u),d=n<=1?"rc":`vec2(${c.join(",")})`,h=`\n    ${p}\n    void main() {\n      ${l} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${f});\n\n       ${(0,r.getGlsl)(t.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${d}), 0, 0, 0);\n     }\n   `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:e.dims,type:e.type,textureType:i.TextureType.unpacked},shaderSource:h})},e.createUnpackProgramInfoLoader=(t,n)=>Object.assign(Object.assign({},s),{get:()=>(0,e.createUnpackProgramInfo)(t,n)})},8428:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.parseUnsqueezeAttributes=e.unsqueezeV13=e.unsqueeze=void 0;const r=n(2517);e.unsqueeze=(t,e,n)=>{i(e);const o=r.ShapeUtil.unsqueezeShape(e[0].dims,n);return[t.reshapeUnpacked(e[0],o)]},e.unsqueezeV13=(t,n)=>(o(n),(0,e.unsqueeze)(t,[n[0]],Array.from(n[1].integerData))),e.parseUnsqueezeAttributes=t=>t.attributes.getInts("axes");const i=t=>{if(!t||1!==t.length)throw new Error("Unsqueeze requires 1 input.");if("string"===t[0].type)throw new Error("invalid input tensor types.")},o=t=>{if(!t||2!==t.length)throw new Error("Unsqueeze requires 2 inputs.");if("int32"!==t[1].type)throw new Error("Invalid input type.")}},9793:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.scalesValidation=e.validateInputs=e.parseUpsampleAttributes=e.parseUpsampleAttributesV9=e.parseUpsampleAttributesV7=e.upsample=void 0;const r=n(246),i=n(5060),o=n(2039),a={name:"Upsample",inputNames:["X"],inputTypes:[o.TextureType.unpacked]};e.upsample=(t,n,r)=>((0,e.validateInputs)(n,r),[t.run(Object.assign(Object.assign({},a),{cacheHint:r.cacheKey,get:()=>s(t,n,r)}),n)]),e.parseUpsampleAttributesV7=t=>(0,e.parseUpsampleAttributes)(t,7),e.parseUpsampleAttributesV9=t=>(0,e.parseUpsampleAttributes)(t,9),e.parseUpsampleAttributes=(t,n)=>{const i=n>=10,o=t.attributes.getString("mode","nearest");if("nearest"!==o&&"linear"!==o&&(n<11||"cubic"!==o))throw new Error(`unrecognized mode: ${o}`);let a=[];n<9&&(a=t.attributes.getFloats("scales"),(0,e.scalesValidation)(a,o,i));const s=t.attributes.getFloat("extrapolation_value",0),u=n>10?t.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(u))throw new Error(`coordinate_transform_mode '${u}' is not supported`);const c="tf_crop_and_resize"===u,l=c,p="nearest"===o&&n>=11?t.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(p))throw new Error(`nearest_mode '${p}' is not supported`);const f=t.attributes.getFloat("cubic_coeff_a",-.75),d=0!==t.attributes.getInt("exclude_outside",0);if(d&&"cubic"!==o)throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const h=n<11||"nearest"===o&&"asymmetric"===u&&"floor"===p;let g=0,b=0,m=0;return n>10?t.inputs.length>2?(g=1,b=2,m=3):(b=1,m=2):9===n&&(b=1),(0,r.createAttributeWithCacheKey)({opset:n,isResize:i,mode:o,scales:a,extrapolationValue:s,coordinateTransformMode:u,useExtrapolation:l,needRoiInput:c,nearestMode:p,cubicCoefficientA:f,excludeOutside:d,useNearest2xOptimization:h,roiInputIdx:g,scalesInputIdx:b,sizesInputIdx:m})};const s=(t,e,n)=>{const r=(0,i.getGlsl)(t.session.backend.glContext.version),[s,u]=t.calculateTextureWidthAndHeight(e[0].dims,o.TextureType.unpacked),c=e[0].dims.map(((t,e)=>Math.floor(t*n.scales[e]))),[l,p]=t.calculateTextureWidthAndHeight(c,o.TextureType.unpacked),f=c.length,d=new Array(f),h=new Array(f);let g=`\n      int output_pitches[${f}];\n      int input_pitches[${f}];\n      `;for(let t=f-1;t>=0;t--)d[t]=t===f-1?1:d[t+1]*c[t+1],h[t]=t===f-1?1:h[t+1]*e[0].dims[t+1],g+=`\n        output_pitches[${t}] = ${d[t]};\n        input_pitches[${t}] = ${h[t]};\n        `;const b=`\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${s}, ${u});\n        float value = getColorAsFloat(${r.texture2D}(X, coords));\n        return value;\n      }\n      `,m="nearest"===n.mode?`\n    ${b}\n    float process(int indices[${f}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\n\n      ${g}\n\n      int d, m;\n      for (int dim = 0; dim < ${f}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`:4===f?`\n    ${b}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\n\n      ${g}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`:`\n    ${b}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\n\n      ${g}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;return Object.assign(Object.assign({},a),{output:{dims:c,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:m,variables:[{name:"scales",type:"int",arrayLength:n.scales.length,data:n.scales.map((t=>Math.ceil(t)))}]})};e.validateInputs=(t,e)=>{if(!t||e.opset<9&&1!==t.length||e.opset>=9&&e.opset<11&&2!==t.length||e.opset>=11&&t.length<2)throw new Error("invalid inputs.");if(e.scales.length>0&&t[0].dims.length!==e.scales.length)throw new Error("Invalid input shape.");if("string"===t[0].type)throw new Error("Invalid input tensor types.")},e.scalesValidation=(t,e,n)=>{if(n){for(const e of t)if(e<=0)throw new Error("Scale value should be greater than 0.")}else for(const e of t)if(e<1)throw new Error("Scale value should be greater than or equal to 1.");if(!("linear"!==e&&"cubic"!==e||2===t.length||4===t.length&&1===t[0]&&1===t[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n?"Resize":"Upsample"} opeartor.`)}},1958:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ProgramManager=void 0;const r=n(1670),i=n(6231),o=n(8879),a=n(5060);e.ProgramManager=class{constructor(t,e,n){this.profiler=t,this.glContext=e,this.textureLayoutStrategy=n,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,e){this.repo.set(t,e)}run(t,e,n){var r;this.profiler.event("op",`ProgramManager.run ${null!==(r=t.programInfo.name)&&void 0!==r?r:"unknown kernel"}`,(()=>{var r;const o=this.glContext.gl,a=t.program;o.useProgram(a);try{this.bindOutput(n),this.attributesBound||this.bindAttributes(t.attribLocations),this.bindUniforms(t.uniformLocations,null!==(r=t.programInfo.variables)&&void 0!==r?r:[],e)}catch(e){throw i.Logger.error("ProgramManager",t.programInfo.shaderSource),e}this.profiler.event("backend","GlContext.draw()",(()=>{this.glContext.draw()}))}),this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((t=>this.glContext.deleteProgram(t.program)))}build(t,e,n){return this.profiler.event("backend","ProgramManager.build",(()=>{const r=new o.GlslPreprocessor(this.glContext,t,e,n),i=r.preprocess(),a=this.compile(i);return{programInfo:t,program:a,uniformLocations:this.getUniformLocations(a,r.context.programInfo.inputNames,r.context.programInfo.variables),attribLocations:this.getAttribLocations(a)}}))}compile(t){if(!this.vertexShader){i.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const t=(0,a.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(t,this.glContext.gl.VERTEX_SHADER)}r.env.debug&&i.Logger.verbose("ProrgramManager",`FragShader:\n${t}\n`);const e=this.glContext.compileShader(t,this.glContext.gl.FRAGMENT_SHADER),n=this.glContext.createProgram(this.vertexShader,e);return this.glContext.deleteShader(e),n}bindOutput(t){const e=t.width,n=t.height;i.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${e}/${n}, shape=${t.shape}, type=${t.tensor.type}`),this.glContext.attachFramebuffer(t.texture,e,n)}bindAttributes(t){const e=t.position,n=t.textureCoord;this.glContext.setVertexAttributes(e,n),this.attributesBound=!0}bindUniforms(t,e,n){var r;const i=this.glContext.gl;let o=0;for(const{name:a,type:s,location:u,arrayLength:c}of t){const t=null===(r=e.find((t=>t.name===a)))||void 0===r?void 0:r.data;if("sampler2D"!==s&&!t)throw new Error(`variable '${a}' does not have data defined in program info`);switch(s){case"sampler2D":this.bindTexture(n[o],u,o),o++;break;case"float":c?i.uniform1fv(u,t):i.uniform1f(u,t);break;case"int":c?i.uniform1iv(u,t):i.uniform1i(u,t);break;default:throw new Error(`Uniform not implemented: ${s}`)}}}bindTexture(t,e,n){this.glContext.bindTextureToUniform(t.texture,n,e)}getAttribLocations(t){return{position:this.getAttribLocation(t,"position"),textureCoord:this.getAttribLocation(t,"textureCoord")}}getUniformLocations(t,e,n){const r=[];if(e)for(const n of e)r.push({name:n,type:"sampler2D",location:this.getUniformLocation(t,n)});if(n)for(const e of n)r.push(Object.assign(Object.assign({},e),{location:this.getUniformLocation(t,e.name)}));return r}getUniformLocation(t,e){const n=this.glContext.gl.getUniformLocation(t,e);if(null===n)throw new Error(`Uniform ${e} not found.`);return n}getAttribLocation(t,e){return this.glContext.gl.getAttribLocation(t,e)}}},6416:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLSessionHandler=void 0;const r=n(6231),i=n(1047),o=n(8316),a=n(1640),s=n(1958),u=n(7859),c=n(5702);e.WebGLSessionHandler=class{constructor(t,e){this.backend=t,this.context=e,this.layoutStrategy=new u.PreferLogicalStrategy(t.glContext.maxTextureSize),this.programManager=new s.ProgramManager(this.context.profiler,t.glContext,this.layoutStrategy),this.textureManager=new c.TextureManager(t.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===t.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=t.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new o.WebGLInferenceHandler(this)}onGraphInitialized(t){const e=t.getValues().filter((t=>-1===t.from&&t.tensor)).map((t=>t.tensor.dataId));this.initializers=new Set(e)}isInitializer(t){return!!this.initializers&&this.initializers.has(t)}addInitializer(t){this.initializers.add(t)}getTextureData(t,e){return e?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,e,n=!1){r.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),n?this.packedTextureDataCache.set(t,e):this.unpackedTextureDataCache.set(t,e)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((t=>this.textureManager.releaseTexture(t,!0))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((t=>this.textureManager.releaseTexture(t,!0))),this.unpackedTextureDataCache=new Map}resolve(t,e,n){const r=(0,i.resolveOperator)(t,e,a.WEBGL_OP_RESOLVE_RULES);return{impl:r.opImpl,context:r.opInit?r.opInit(t,n):t}}}},7769:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Uint8DataEncoder=e.RGBAFloatDataEncoder=e.RedFloat32DataEncoder=void 0;const r=n(6231);e.RedFloat32DataEncoder=class{constructor(t,e=1){if(1===e)this.internalFormat=t.R32F,this.format=t.RED,this.textureType=t.FLOAT,this.channelSize=e;else{if(4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA32F,this.format=t.RGBA,this.textureType=t.FLOAT,this.channelSize=e}}encode(t,e){let n,i;return t.constructor!==Float32Array&&(r.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),i=new Float32Array(t)),e*this.channelSize>t.length?(r.Logger.warning("Encoder","Source data too small. Allocating larger array"),i=t,n=this.allocate(e*this.channelSize),i.forEach(((t,e)=>n[e]=t))):(i=t,n=i),n}allocate(t){return new Float32Array(4*t)}decode(t,e){return 1===this.channelSize?t.filter(((t,e)=>e%4==0)).subarray(0,e):t.subarray(0,e)}},e.RGBAFloatDataEncoder=class{constructor(t,e=1,n){if(1!==e&&4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.channelSize=e,this.textureType=n||t.FLOAT}encode(t,e){let n=t;return 1===this.channelSize&&(r.Logger.verbose("Encoder","Exploding into a larger array"),n=this.allocate(e),t.forEach(((t,e)=>n[4*e]=t))),n}allocate(t){return new Float32Array(4*t)}decode(t,e){return 1===this.channelSize?t.filter(((t,e)=>e%4==0)).subarray(0,e):t.subarray(0,e)}},e.Uint8DataEncoder=class{constructor(t,e=1){if(this.channelSize=4,1===e)this.internalFormat=t.ALPHA,this.format=t.ALPHA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=e;else{if(4!==e)throw new Error(`Invalid number of channels: ${e}`);this.internalFormat=t.RGBA,this.format=t.RGBA,this.textureType=t.UNSIGNED_BYTE,this.channelSize=e}}encode(t,e){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}allocate(t){return new Uint8Array(t*this.channelSize)}decode(t,e){if(t instanceof Uint8Array)return t.subarray(0,e);throw new Error(`Invalid array type: ${t.constructor}`)}}},7859:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getBatchDim=e.sizeToSquarishShape=e.getRowsCols=e.sizeFromShape=e.isInt=e.parseAxisParam=e.squeezeShape=e.PreferLogicalStrategy=e.AlwaysKeepOriginalSizeStrategy=void 0;const r=n(6231),i=n(2517);function o(t,e){const n=[],r=[],i=null!=e&&Array.isArray(e)&&0===e.length,o=null==e||i?null:a(e,t).sort();let s=0;for(let e=0;e<t.length;++e){if(null!=o){if(o[s]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==o[s]||o[s]>e)&&1===t[e]&&(n.push(t[e]),r.push(e)),o[s]<=e&&s++}1!==t[e]&&(n.push(t[e]),r.push(e))}return{newShape:n,keptDims:r}}function a(t,e){const n=e.length;return t=null==t?e.map(((t,e)=>e)):[].concat(t),(0,i.assert)(t.every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),(0,i.assert)(t.every(s),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function s(t){return t%1==0}function u(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function c(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}e.AlwaysKeepOriginalSizeStrategy=class{constructor(t){this.maxTextureSize=t}computeTextureWH(t,e){if(0===t.length)return[1,1];const n=this.maxTextureSize;if(e&&void 0!==e.breakAxis){const i=e.breakAxis>=t.length?1:t.slice(e.breakAxis).reduce(((t,e)=>t*e)),o=e.breakAxis<=0?1:t.slice(0,e.breakAxis).reduce(((t,e)=>t*e));if(!(i>n||o>n))return[i,o];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`)}const i=t.reduce(((t,e)=>t*e));let o=Math.floor(Math.sqrt(i));for(;o<n&&o<i&&i%o!=0;o++);if(o>=n||i%o!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${t}`);return[o,i/o]}},e.PreferLogicalStrategy=class{constructor(t){this.maxTextureSize=t}computeTextureWH(t,e){const n=this.computeTexture(t,e);return e&&e.isPacked&&(n[0]/=2,n[1]/=2),e&&e.reverseWH?[n[1],n[0]]:n}computeTexture(t,e){const n=e&&e.isPacked;if(0===t.length)return n?[2,2]:[1,1];let i=this.maxTextureSize;if(e&&void 0!==e.breakAxis){const n=e.breakAxis>=t.length?1:t.slice(e.breakAxis).reduce(((t,e)=>t*e)),o=e.breakAxis<=0?1:t.slice(0,e.breakAxis).reduce(((t,e)=>t*e));if(!(n>i||o>i))return[n,o];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`)}let a=t.slice(0);if(n&&(i*=2,a=a.map(((t,e)=>e>=a.length-2?a[e]%2==0?a[e]:a[e]+1:a[e])),1===a.length&&(a=[2,a[0]])),2!==a.length){const t=o(a);a=t.newShape}const s=u(a);return a.length<=1&&s<=i?[1,s]:2===a.length&&a[0]<=i&&a[1]<=i?a:3===a.length&&a[0]*a[1]<=i&&a[2]<=i?[a[0]*a[1],a[2]]:3===a.length&&a[0]<=i&&a[1]*a[2]<=i?[a[0],a[1]*a[2]]:4===a.length&&a[0]*a[1]*a[2]<=i&&a[3]<=i?[a[0]*a[1]*a[2],a[3]]:4===a.length&&a[0]<=i&&a[1]*a[2]*a[3]<=i?[a[0],a[1]*a[2]*a[3]]:n?c(s/4).map((t=>2*t)):c(s)}},e.squeezeShape=o,e.parseAxisParam=a,e.isInt=s,e.sizeFromShape=u,e.getRowsCols=function(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]},e.sizeToSquarishShape=c,e.getBatchDim=function(t,e=2){return u(t.slice(0,t.length-e))}},4057:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createTextureLayoutFromShape=e.calculateTextureWidthAndHeight=e.createTextureLayoutFromTextureType=void 0;const r=n(2517),i=n(2039);e.createTextureLayoutFromTextureType=(t,n,r)=>{const o=r===i.TextureType.unpacked||r===i.TextureType.unpackedReversed?1:4,a=r===i.TextureType.packed,s=r===i.TextureType.unpackedReversed||r===i.TextureType.packed,u=r===i.TextureType.packedLastDimension?n.length-1:void 0,c=r===i.TextureType.packedLastDimension?n.map(((t,e)=>e===n.length-1?4*t:t)):void 0;return(0,e.createTextureLayoutFromShape)(t,n,o,c,{isPacked:a,reverseWH:s,breakAxis:u})},e.calculateTextureWidthAndHeight=(t,n,r)=>{const i=(0,e.createTextureLayoutFromTextureType)(t,n,r);return[i.width,i.height]},e.createTextureLayoutFromShape=(t,e,n=1,i,o)=>{const a=!(!o||!o.isPacked),[s,u]=t.computeTextureWH(a&&i||e,o),c=e.length;let l=e.slice(0);if(0===c&&(l=[1]),1===n)i=e;else if(a){if(4!==n)throw new Error("a packed texture must be 4-channel");i=e,c>0&&(l[c-1]=Math.ceil(l[c-1]/2)),c>1&&(l[c-2]=Math.ceil(l[c-2]/2))}else if(!i)throw new Error("Unpacked shape is needed when using channels > 1");return{width:s,height:u,channels:n,isPacked:a,shape:l,strides:r.ShapeUtil.computeStrides(l),unpackedShape:i,reversedWH:o&&o.reverseWH}}},5702:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.TextureManager=void 0;const r=n(6231);e.TextureManager=class{constructor(t,e,n,r){this.glContext=t,this.layoutStrategy=e,this.profiler=n,this.config=r,this.pendingRead=new Map,r.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(t,e,n,i){const o=this.toEncoderType(t),a=this.glContext.getEncoder(o,e.channels||1,i);if(e.isPacked&&1===i)throw new Error("not implemented");const s=e.width,u=e.height;let c,l;if(this.config.reuseTextures){c=`${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`,l=this.inUseTextures.get(c),l||(l=[],this.inUseTextures.set(c,l));const e=this.idleTextures.get(c);if(e&&e.length>0){const r=e.pop();return l.push(r),1===i&&this.glContext.updateTexture(r,s,u,a,this.toTextureData(t,n)),r}}r.Logger.verbose("TextureManager",`Creating new texture of size ${e.width}x${e.height}`);const p=this.glContext.allocateTexture(s,u,a,this.toTextureData(t,n));return this.config.reuseTextures&&(l.push(p),this.textureLookup.set(p,c)),p}readTexture(t,e,n){return n||(n=1),this.profiler.event("backend","TextureManager.readTexture",(()=>{const r=t.shape.reduce(((t,e)=>t*e))*n,i=this.glContext.readTexture(t.texture,t.width,t.height,r,this.toEncoderType(e),n);return this.toTensorData(e,i)}))}async readTextureAsync(t,e,n){const r=t.tensor.dataId;if(n||(n=1),this.pendingRead.has(r)){const t=this.pendingRead.get(r);return new Promise((e=>null==t?void 0:t.push(e)))}return this.profiler.event("backend","TextureManager.readTextureAsync",(async()=>{this.pendingRead.set(r,[]);const i=t.shape.reduce(((t,e)=>t*e))*n;await this.glContext.createAndWaitForFence();const o=this.glContext.readTexture(t.texture,t.width,t.height,i,this.toEncoderType(e),n),a=this.toTensorData(e,o),s=this.pendingRead.get(r);return this.pendingRead.delete(r),null==s||s.forEach((t=>t(a))),a}))}readUint8TextureAsFloat(t){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",(()=>{const e=t.shape.reduce(((t,e)=>t*e)),n=this.glContext.readTexture(t.texture,t.width,t.height,4*e,"byte",4);return new Float32Array(n.buffer,n.byteOffset,e)}))}releaseTexture(t,e){let n;if(this.config.reuseTextures&&(n=this.textureLookup.get(t.texture),n)){e&&this.textureLookup.delete(n);const r=this.inUseTextures.get(n);if(r){const e=r.indexOf(t.texture);if(-1!==e){r.splice(e,1);let i=this.idleTextures.get(n);i||(i=[],this.idleTextures.set(n,i)),i.push(t.texture)}}}n&&!e||(r.Logger.verbose("TextureManager",`Deleting texture of size ${t.width}x${t.height}`),this.glContext.deleteTexture(t.texture))}toTensorData(t,e){switch(t){case"int16":return e instanceof Int16Array?e:Int16Array.from(e);case"int32":return e instanceof Int32Array?e:Int32Array.from(e);case"int8":return e instanceof Int8Array?e:Int8Array.from(e);case"uint16":return e instanceof Uint16Array?e:Uint16Array.from(e);case"uint32":return e instanceof Uint32Array?e:Uint32Array.from(e);case"uint8":case"bool":return e instanceof Uint8Array?e:Uint8Array.from(e);case"float32":return e instanceof Float32Array?e:Float32Array.from(e);case"float64":return e instanceof Float64Array?e:Float64Array.from(e);default:throw new Error(`TensorData type ${t} is not supported`)}}toTextureData(t,e){if(e)return e instanceof Float32Array?e:new Float32Array(e)}toEncoderType(t){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(t,e)=>{"use strict";var n;Object.defineProperty(e,"__esModule",{value:!0}),e.TextureType=void 0,(n=e.TextureType||(e.TextureType={}))[n.unpacked=0]="unpacked",n[n.unpackedReversed=1]="unpackedReversed",n[n.packed=2]="packed",n[n.downloadUint8AsFloat=3]="downloadUint8AsFloat",n[n.packedLastDimension=4]="packedLastDimension"},9390:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getGlChannels=e.getCoordsDataType=e.getSqueezedParams=e.squeezeInputShape=e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=e.generateShaderFuncNameFromInputSamplerName=e.repeatedTry=e.getPackedShape=void 0;const r=n(2517);e.getPackedShape=function(t){const e=t.length;return t.slice(0,e-1).concat(t[e-1]/4)},e.repeatedTry=async function(t,e=(t=>0),n){return new Promise(((r,i)=>{let o=0;const a=()=>{if(t())return void r();o++;const s=e(o);null!=n&&o>=n?i():setTimeout(a,s)};a()}))},e.generateShaderFuncNameFromInputSamplerName=function(t){return(0,r.assert)(void 0!==t&&0!==t.length,(()=>"empty string found for sampler name")),"get"+t.charAt(0).toUpperCase()+t.slice(1)},e.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(t){return(0,r.assert)(void 0!==t&&0!==t.length,(()=>"empty string found for sampler name")),"get"+t.charAt(0).toUpperCase()+t.slice(1)+"AtOutCoords"},e.squeezeInputShape=function(t,e){let n=JSON.parse(JSON.stringify(t));return n=e,n},e.getSqueezedParams=function(t,e){return e.map((e=>t[e])).join(", ")},e.getCoordsDataType=function(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)},e.getGlChannels=function(t=6){return["x","y","z","w","u","v"].slice(0,t)}},7305:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.createNewWebGLContext=e.createWebGLContext=void 0;const r=n(6231),i=n(1713),o={};function a(t){const e=function(){if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas)throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const t=document.createElement("canvas");return t.width=1,t.height=1,t}();let n;const o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!t||"webgl2"===t)&&(n=e.getContext("webgl2",o),n))try{return new i.WebGLContext(n,2)}catch(t){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${t}`)}if((!t||"webgl"===t)&&(n=e.getContext("webgl",o)||e.getContext("experimental-webgl",o),n))try{return new i.WebGLContext(n,1)}catch(t){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t}`)}throw new Error("WebGL is not supported")}e.createWebGLContext=function t(e){let n;e&&"webgl2"!==e||!("webgl2"in o)?e&&"webgl"!==e||!("webgl"in o)||(n=o.webgl):n=o.webgl2,n=n||a(e),e=e||1===n.version?"webgl":"webgl2";const r=n.gl;return o[e]=n,r.isContextLost()?(delete o[e],t(e)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),n)},e.createNewWebGLContext=a},1713:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return i(e,t),e};Object.defineProperty(e,"__esModule",{value:!0}),e.WebGLContext=e.linearSearchLastTrue=void 0;const a=n(1670),s=o(n(7769)),u=n(9390);function c(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}e.linearSearchLastTrue=c,e.WebGLContext=class{constructor(t,e){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=t,this.version=e,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(t,e,n,r){const i=this.gl,o=i.createTexture();i.bindTexture(i.TEXTURE_2D,o),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE);const a=r?n.encode(r,t*e):null;return i.texImage2D(i.TEXTURE_2D,0,n.internalFormat,t,e,0,n.format,n.textureType,a),this.checkError(),o}updateTexture(t,e,n,r,i){const o=this.gl;o.bindTexture(o.TEXTURE_2D,t);const a=r.encode(i,e*n);o.texSubImage2D(o.TEXTURE_2D,0,0,0,e,n,r.format,r.textureType,a),this.checkError()}attachFramebuffer(t,e,n){const r=this.gl;r.bindTexture(r.TEXTURE_2D,t),r.bindFramebuffer(r.FRAMEBUFFER,this.framebuffer),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0),this.checkError(),r.viewport(0,0,e,n),r.scissor(0,0,e,n)}readTexture(t,e,n,r,i,o){const a=this.gl;o||(o=1),this.frameBufferBound||this.attachFramebuffer(t,e,n);const s=this.getEncoder(i,o),u=s.allocate(e*n);return a.bindTexture(a.TEXTURE_2D,t),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,t,0),a.readPixels(0,0,e,n,a.RGBA,s.textureType,u),this.checkError(),s.decode(u,r)}isFramebufferReady(){return!0}getActiveTexture(){const t=this.gl;return"TEXTURE"+(t.getParameter(this.gl.ACTIVE_TEXTURE)-t.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(t,e){const n=this.gl;n.vertexAttribPointer(t,3,n.FLOAT,!1,20,0),n.enableVertexAttribArray(t),-1!==e&&(n.vertexAttribPointer(e,2,n.FLOAT,!1,20,12),n.enableVertexAttribArray(e)),this.checkError()}createProgram(t,e){const n=this.gl,r=n.createProgram();return n.attachShader(r,t),n.attachShader(r,e),n.linkProgram(r),r}compileShader(t,e){const n=this.gl,r=n.createShader(e);if(!r)throw new Error(`createShader() returned null with type ${e}`);if(n.shaderSource(r,t),n.compileShader(r),!1===n.getShaderParameter(r,n.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(r)}\nShader source:\n${t}`);return r}deleteShader(t){this.gl.deleteShader(t)}bindTextureToUniform(t,e,n){const r=this.gl;r.activeTexture(r.TEXTURE0+e),this.checkError(),r.bindTexture(r.TEXTURE_2D,t),this.checkError(),r.uniform1i(n,e),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(a.env.debug){const t=this.gl,e=t.getError();let n="";switch(e){case t.NO_ERROR:return;case t.INVALID_ENUM:n="INVALID_ENUM";break;case t.INVALID_VALUE:n="INVALID_VALUE";break;case t.INVALID_OPERATION:n="INVALID_OPERATION";break;case t.INVALID_FRAMEBUFFER_OPERATION:n="INVALID_FRAMEBUFFER_OPERATION";break;case t.OUT_OF_MEMORY:n="OUT_OF_MEMORY";break;case t.CONTEXT_LOST_WEBGL:n="CONTEXT_LOST_WEBGL";break;default:n=`Unknown WebGL Error: ${e.toString(16)}`}throw new Error(n)}}deleteTexture(t){this.gl.deleteTexture(t)}deleteProgram(t){this.gl.deleteProgram(t)}getEncoder(t,e,n=0){if(2===this.version)return new s.RedFloat32DataEncoder(this.gl,e);switch(t){case"float":return 1===n||this.isRenderFloat32Supported?new s.RGBAFloatDataEncoder(this.gl,e):new s.RGBAFloatDataEncoder(this.gl,e,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new s.Uint8DataEncoder(this.gl,e);default:throw new Error(`Invalid dataType: ${t}`)}}clearActiveTextures(){const t=this.gl;for(let e=0;e<this.maxTextureImageUnits;++e)t.activeTexture(t.TEXTURE0+e),t.bindTexture(t.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(this.framebuffer),t.bindBuffer(t.ARRAY_BUFFER,null),t.deleteBuffer(this.vertexbuffer),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null),t.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const t=this.gl,e=t.createBuffer();if(!e)throw new Error("createBuffer() returned null");const n=this.createDefaultGeometry();return t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW),this.checkError(),e}createFramebuffer(){const t=this.gl.createFramebuffer();if(!t)throw new Error("createFramebuffer returned null");return t}queryVitalParameters(){const t=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=t.getParameter(t.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const t=this.gl,e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e);const n=2===this.version?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,n,1,1,0,t.RGBA,t.FLOAT,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(r),i}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else{if(!this.textureFloatExtension)return!1;if(!this.gl.getExtension("WEBGL_color_buffer_float"))return!1}return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const t=this.gl;let e,n,r,i,o;try{e=t.createTexture(),n=t.createFramebuffer(),t.bindTexture(t.TEXTURE_2D,e);const a=2===this.version?t.RGBA32F:t.RGBA;return t.texImage2D(t.TEXTURE_2D,0,a,1,1,0,t.RGBA,t.FLOAT,null),t.bindFramebuffer(t.FRAMEBUFFER,n),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0),t.enable(t.BLEND),r=t.createShader(t.VERTEX_SHADER),!!r&&(t.shaderSource(r,"void main(){}"),t.compileShader(r),i=t.createShader(t.FRAGMENT_SHADER),!!i&&(t.shaderSource(i,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),t.compileShader(i),o=t.createProgram(),!!o&&(t.attachShader(o,r),t.attachShader(o,i),t.linkProgram(o),t.useProgram(o),t.drawArrays(t.POINTS,0,1),t.getError()===t.NO_ERROR)))}finally{t.disable(t.BLEND),o&&t.deleteProgram(o),r&&t.deleteShader(r),i&&t.deleteShader(i),n&&(t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(n)),e&&(t.bindTexture(t.TEXTURE_2D,null),t.deleteTexture(e))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const t=this.gl,e=this.disjointTimerQueryWebgl2Extension,n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const t=this.gl,e=this.disjointTimerQueryWebgl2Extension;t.endQuery(e.TIME_ELAPSED_EXT)}}isTimerResultAvailable(t){let e=!1,n=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const r=this.gl,i=this.disjointTimerQueryWebgl2Extension;e=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE),n=r.getParameter(i.GPU_DISJOINT_EXT)}return e&&!n}getTimerResult(t){let e=0;if(2!==this.version)throw new Error("WebGL1 profiling currently not supported");{const n=this.gl;e=n.getQueryParameter(t,n.QUERY_RESULT),n.deleteQuery(t)}return e/1e6}async waitForQueryAndGetTime(t){return await(0,u.repeatedTry)((()=>this.isTimerResultAvailable(t))),this.getTimerResult(t)}async createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e;const n=t,r=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);return t.flush(),e=null===r?()=>!0:()=>{const t=n.clientWaitSync(r,0,0);return t===n.ALREADY_SIGNALED||t===n.CONDITION_SATISFIED},{query:r,isFencePassed:e}}async pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=c(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}async addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||await(0,u.repeatedTry)((()=>(this.pollItems(),0===this.itemsToPoll.length)))}}},1036:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ExecutionPlan=void 0;const r=n(6231);class i{constructor(t,e){this.op=t,this.node=e}}e.ExecutionPlan=class{constructor(t,e,n){this.graph=t,this.profiler=n,this.initialize(e)}initialize(t){this.profiler.event("session","ExecutionPlan.initialize",(()=>{const e=this.graph.getNodes();if(e.length!==t.length)throw new Error("The size of nodes and OPs do not match.");this._ops=t.map(((t,n)=>new i(t,e[n]))),this.reset(),this._starter=[],this._ops.forEach(((t,e)=>{let n=!0;for(const e of t.node.inputs)if(!this._values[e]&&-1===this.graph.getInputIndices().indexOf(e)){n=!1;break}n&&this._starter.push(e)}))}))}reset(){this._values=this.graph.getValues().map((t=>t.tensor))}async execute(t,e){return this.profiler.event("session","ExecutionPlan.execute",(async()=>{this.reset();const n=t.createInferenceHandler(),i=this.graph.getInputIndices();if(e.length!==i.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e.length} expected: ${i.length}`);e.forEach(((t,e)=>{const n=i[e];this._values[n]=t}));const o=this._starter.slice(0),a=this.graph.getValues(),s=this.graph.getNodes();let u=0;for(;u<o.length;){const t=o[u++],e=this._ops[t],i=e.node.inputs.map((t=>this._values[t]));if(-1!==i.indexOf(void 0))throw new Error(`unresolved input detected: op: ${e.node}`);const c=i;r.Logger.verbose("ExecPlan",`Runing op:${e.node.name} (${c.map(((t,n)=>`'${e.node.inputs[n]}': ${t.type}[${t.dims.join(",")}]`)).join(", ")})`);const l=await this.profiler.event("node",e.node.name,(async()=>e.op.impl(n,c,e.op.context)));if(l.length!==e.node.outputs.length)throw new Error("the size of output does not match model definition.");l.forEach(((t,n)=>{const r=e.node.outputs[n];if(this._values[r])throw new Error(`output [${r}] already has value: op:${e.node.name}`);this._values[r]=t}));const p=new Set;l.forEach(((t,n)=>{const r=e.node.outputs[n];for(const t of a[r].to){const e=s[t];let n=!0;for(const t of e.inputs)if(!this._values[t]){n=!1;break}n&&p.add(t)}})),o.push(...p)}const c=[];for(let t=0;t<this.graph.getOutputIndices().length;t++){const e=this.graph.getOutputIndices()[t],n=this._values[e];if(void 0===n)throw new Error(`required output [${e}] does not have value`);0===e?await n.getData():n.data,c.push(n)}return r.Logger.verbose("ExecPlan","disposing of inferenceHandler"),n.dispose(),c}))}}},7070:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Graph=void 0;const r=n(1446),i=n(7778),o=n(9395),a=n(9162),s=n(2517);var u=o.onnxruntime.experimental.fbs;e.Graph={from:(t,e)=>new p(t,e)};class c{constructor(t){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,t&&(this.type=s.ProtoUtil.tensorValueTypeFromProto(t.type.tensorType))}get from(){return this._from}get to(){return this._to}}class l{constructor(t,e){t instanceof r.onnx.NodeProto?(this.name=t.name,this.opType=t.opType,this.attributes=new i.Attribute(t.attribute)):t instanceof u.Node&&(this.name=null!=e?e:t.name(),this.opType=t.opType(),this.attributes=new i.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(t))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class p{constructor(t,e){if(!t)throw new TypeError("graph is empty");this.buildGraph(t),this.transformGraph(e),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(t){if(t instanceof r.onnx.GraphProto)this.buildGraphFromOnnxFormat(t);else{if(!(t instanceof u.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(t)}}buildGraphFromOnnxFormat(t){const e=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const n=new Map;if(!t.input)throw new Error("missing information in graph: input");const r=[];for(const n of t.input){if(e.has(n.name))throw new Error(`duplicated input name: ${n.name}`);const t=this._allData.push(new c(n))-1;e.set(n.name,t),r.push(n.name)}if(!t.initializer)throw new Error("missing information in graph: initializer");for(const n of t.initializer){let t=e.get(n.name);if(void 0===t){const r=new c;r.type={shape:{dims:s.ProtoUtil.tensorDimsFromProto(n.dims)},tensorType:s.ProtoUtil.tensorDataTypeFromProto(n.dataType)},t=this._allData.push(r)-1,e.set(n.name,t)}this._allData[t]._from=-1,this._allData[t].tensor=a.Tensor.fromProto(n)}for(let t=0;t<this._allData.length;t++)this._allData[t].tensor||(this._allInputIndices.push(t),this._allInputNames.push(r[t]));if(!t.output)throw new Error("missing information in graph: output");for(const n of t.output){if(e.has(n.name))throw new Error(`duplicated output name: ${n.name}`);const t=this._allData.push(new c(n))-1;e.set(n.name,t),this._allOutputIndices.push(t),this._allOutputNames.push(n.name)}if(!t.node)throw new Error("missing information in graph: node");for(const e of t.node){if(!e.name)for(let t=0;;t++){const r=`unnamed_${e.opType}_${t}`;if(!n.has(r)){e.name=r;break}}if(n.has(e.name))throw new Error(`duplicated node name: ${e.name}`);const t=this._nodes.push(new l(e))-1;n.set(e.name,t)}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],i=t.node[n];if(!i.output)throw new Error(`missing output for node: ${i.name}`);for(const t of i.output){let o=e.get(t);if(void 0===o&&(o=this._allData.push(new c)-1,e.set(t,o)),r.outputs.push(o),void 0!==this._allData[o]._from)throw new Error(`multiple nodes output to one data value: ${o}`);if(this._allData[o]._from=n,"Constant"===i.opType){if(!i.attribute||1!==i.attribute.length||!i.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!i.output||1!==i.output.length)throw new Error("missing output or incorrect number of outputs for this Constant operator");r.outputs.pop(),r.executeNode=!1,this._allData[o]._from=-1,this._allData[o].tensor=a.Tensor.fromProto(i.attribute[0].t)}}}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],i=t.node[n];if(!i.input)throw new Error(`missing input for node: ${i.name}`);for(const t of i.input){const o=e.get(t);if(void 0===o){if(""===t&&3===i.input.length&&"Resize"===i.opType)continue;throw new Error(`unrecognized input '${t}' for node: ${i.name}`)}r.inputs.push(o),this._allData[o]._to.push(n)}}return!0}buildGraphFromOrtFormat(t){var e,n,r;const i=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const o=new Map,p=[];for(let o=0;o<t.inputsLength();o++){const a=t.inputs(o);if(i.has(a))throw new Error(`duplicated input name: ${a}`);for(let o=0;o<t.nodeArgsLength();o++)if((null===(e=t.nodeArgs(o))||void 0===e?void 0:e.name())===a){const e=new c;if((null===(r=null===(n=t.nodeArgs(o))||void 0===n?void 0:n.type())||void 0===r?void 0:r.valueType())!==u.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const l=t.nodeArgs(o).type().value(new u.TensorTypeAndShape),f=s.ProtoUtil.tensorDataTypeFromProto(l.elemType()),d=l.shape(),h=[];for(let t=0;t<d.dimLength();t++)h.push(s.LongUtil.longToNumber(d.dim(t).value().dimValue()));e.type={shape:{dims:h},tensorType:f};const g=this._allData.push(e)-1;i.set(a,g),p.push(a)}}for(let e=0;e<t.initializersLength();e++){const n=t.initializers(e);let r=i.get(n.name());if(void 0===r){const t=new c,e=s.ProtoUtil.tensorDimsFromORTFormat(n),o=s.ProtoUtil.tensorDataTypeFromProto(n.dataType());t.type={shape:{dims:e},tensorType:o},r=this._allData.push(t)-1,i.set(n.name(),r)}this._allData[r]._from=-1,this._allData[r].tensor=a.Tensor.fromOrtTensor(n)}for(let t=0;t<this._allData.length;t++)this._allData[t].tensor||(this._allInputIndices.push(t),this._allInputNames.push(p[t]));for(let e=0;e<t.outputsLength();e++){const n=t.outputs(e);if(i.has(n))throw new Error(`duplicated output name: ${n}`);const r=this._allData.push(new c)-1;i.set(n,r),this._allOutputIndices.push(r),this._allOutputNames.push(n)}if(!t.nodes)throw new Error("missing information in graph: node");for(let e=0;e<t.nodesLength();e++){const n=t.nodes(e);let r=n.name();if(!r)for(let t=0;r=`unnamed_${n.opType()}_${t}`,o.has(r);t++);if(o.has(r))throw new Error(`duplicated node name: ${r}`);const i=this._nodes.push(new l(n,r))-1;o.set(r,i)}for(let e=0;e<this._nodes.length;e++){const n=this._nodes[e],r=t.nodes(e);if(null==r)throw new Error(`No node exists at index ${e}`);if(0===(null==r?void 0:r.outputsLength()))throw new Error(`missing output for node: ${r.name}`);for(let t=0;t<(null==r?void 0:r.outputsLength());t++){const o=null==r?void 0:r.outputs(t);let s=i.get(o);if(void 0===s&&(s=this._allData.push(new c)-1,i.set(o,s)),n.outputs.push(s),void 0!==this._allData[s]._from)throw new Error(`multiple nodes output to one data value: ${s}`);if(this._allData[s]._from=e,"Constant"===r.opType()){if(1!==r.attributesLength()||!r.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==r.outputsLength())throw new Error("missing output or incorrect number of outputs for this Constant operator");n.outputs.pop(),n.executeNode=!1,this._allData[s]._from=-1,this._allData[s].tensor=a.Tensor.fromOrtTensor(r.attributes(0).t())}}}for(let e=0;e<this._nodes.length;e++){const n=this._nodes[e],r=t.nodes(e);if(0===r.inputsLength())throw new Error(`missing input for node: ${r.name}`);for(let t=0;t<r.inputsLength();t++){const o=r.inputs(t),a=i.get(o);if(void 0===a)throw new Error(`unrecognized input '${o}' for node: ${r.name()}`);n.inputs.push(a),this._allData[a]._to.push(e)}}}checkIsAcyclic(){const t=new Set;this._allInputIndices.forEach((e=>{this._allData[e]._to.forEach((e=>{t.add(e)}))}));const e=Array.from(t),n=new Array(this._nodes.length).fill("white");for(;e.length>0;){const t=e.pop();"gray"===n[t]?n[t]="black":(e.push(t),n[t]="gray",this._nodes[t].outputs.forEach((r=>{const i=this._allData[r];if(void 0!==i.tensor)throw new Error("node outputs should not be initialized");if(i._from!==t)throw new Error("from property of the Value object doesn't match index of Node being processed");i._to.forEach((t=>{if("gray"===n[t])throw new Error("model graph is cyclic");"white"===n[t]&&e.push(t)}))})))}}transformGraph(t){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),t&&t.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let t=0;for(let e=0;e<this._nodes.length;e++)this._nodes[e].executeNode?t>0&&(this._nodes[e].inputs.forEach((n=>{const r=this._allData[n]._to.indexOf(e+t);-1!==r&&(this._allData[n]._to[r]=e)})),this._nodes[e].outputs.forEach((n=>{this._allData[n]._from&&this._allData[n]._from===e+t&&(this._allData[n]._from=e)}))):(t++,this._nodes[e].outputs.forEach((t=>{this._allData[t]._from=-2})),this._nodes.splice(e,1),e--);t=0;for(let e=0;e<this._allData.length;e++)if(-2!==this._allData[e].from||-1!==this._allOutputIndices.indexOf(e+t)){if(t>0){let n=-1;void 0!==this._allData[e].from&&-1!==this._allData[e].from?(n=this._nodes[this._allData[e].from].outputs.indexOf(e+t),-1!==n&&(this._nodes[this._allData[e].from].outputs[n]=e)):(n=this._allInputIndices.indexOf(e+t),-1!==n&&(this._allInputIndices[n]=e)),this._allData[e].to.forEach((r=>{n=this._nodes[r].inputs.indexOf(e+t),-1!==n&&(this._nodes[r].inputs[n]=e)})),0===this._allData[e].to.length&&(n=this._allOutputIndices.indexOf(e+t),-1!==n&&(this._allOutputIndices[n]=e))}}else t++,this._allData.splice(e,1),e--}deleteNode(t){const e=this._nodes[t];if(e.outputs.length>1)for(let t=1;t<e.outputs.length;t++)if(this._allData[e.outputs[t]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");e.executeNode=!1;const n=e.inputs[0],r=e.outputs[0],i=this._allData[r].to,o=this._allData[n].to.indexOf(t);if(-1===o)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[n].to.splice(o,1),this._allData[r]._to=[];const a=this._allOutputIndices.indexOf(r);if(-1!==a&&(this._allOutputIndices[a]=n),i&&i.length>0)for(const t of i){const e=this._nodes[t].inputs.indexOf(r);if(-1===e)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[t].inputs[e]=n,this._allData[n].to.push(t)}}removeAllDropoutNodes(){let t=0;for(const e of this._nodes){if("Dropout"===e.opType){if(1!==e.inputs.length)throw new Error("Dropout nodes should only contain one input. ");if(1!==e.outputs.length&&2!==e.outputs.length)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===e.outputs.length&&0!==this._allData[e.outputs[1]]._to.length)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(t)}t++}}removeAllIdentityNodes(){let t=0;for(const e of this._nodes)"Identity"===e.opType&&this.deleteNode(t),t++}isActivation(t){switch(t.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const t of this._nodes)if("Conv"===t.opType){const e=this._allData[t.outputs[0]]._to;if(1===e.length&&this.isActivation(this._nodes[e[0]])){const n=this._nodes[e[0]];if("Clip"===n.opType)if(1===n.inputs.length)try{t.attributes.set("activation_params","floats",[n.attributes.getFloat("min"),n.attributes.getFloat("max")])}catch(e){t.attributes.set("activation_params","floats",[s.MIN_CLIP,s.MAX_CLIP])}else{if(!(n.inputs.length>=3&&void 0!==this._allData[n.inputs[1]].tensor&&void 0!==this._allData[n.inputs[2]].tensor))continue;t.attributes.set("activation_params","floats",[this._allData[n.inputs[1]].tensor.floatData[0],this._allData[n.inputs[2]].tensor.floatData[0]])}t.attributes.set("activation","string",n.opType),this.deleteNode(e[0])}}}}},6231:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.now=e.Profiler=e.Logger=void 0;const n={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},r={none:new class{log(t,e,n){}},console:new class{log(t,e,n){console.log(`${this.color(t)} ${n?"[35m"+n+"[0m ":""}${e}`)}color(t){switch(t){case"verbose":return"[34;40mv[0m";case"info":return"[32mi[0m";case"warning":return"[30;43mw[0m";case"error":return"[31;40me[0m";case"fatal":return"[101mf[0m";default:throw new Error(`unsupported severity: ${t}`)}}}},i={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let o={"":i};function a(t,e,n,r){if(void 0===e)return i=t,{verbose:a.verbose.bind(null,i),info:a.info.bind(null,i),warning:a.warning.bind(null,i),error:a.error.bind(null,i),fatal:a.fatal.bind(null,i)};if(void 0===n)s(t,e);else if("number"==typeof n&&void 0===r)s(t,e);else if("string"==typeof n&&void 0===r)s(t,n,0,e);else{if("string"!=typeof n||"number"!=typeof r)throw new TypeError("input is valid");s(t,n,0,e)}var i}function s(t,e,i,a){const s=o[a||""]||o[""];n[t]<n[s.minimalSeverity]||(s.logDateTime&&(e=`${(new Date).toISOString()}|${e}`),s.logSourceLocation,r[s.provider].log(t,e,a))}!function(t){function e(t){o={},n("",t||{})}function n(t,n){if("*"===t)e(n);else{const e=o[t]||i;o[t]={provider:n.provider||e.provider,minimalSeverity:n.minimalSeverity||e.minimalSeverity,logDateTime:void 0===n.logDateTime?e.logDateTime:n.logDateTime,logSourceLocation:void 0===n.logSourceLocation?e.logSourceLocation:n.logSourceLocation}}}t.verbose=function(e,n){t("verbose",e,n)},t.info=function(e,n){t("info",e,n)},t.warning=function(e,n){t("warning",e,n)},t.error=function(e,n){t("error",e,n)},t.fatal=function(e,n){t("fatal",e,n)},t.reset=e,t.set=n,t.setWithEnv=function(t){const e={};t.logLevel&&(e.minimalSeverity=t.logLevel),n("",e)}}(a||(a={})),e.Logger=a;class u{constructor(t,e,n,r,i,o){this.category=t,this.name=e,this.startTime=n,this.endCallback=r,this.timer=i,this.ctx=o}end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class c{constructor(t,e,n,r){this.category=t,this.name=e,this.startTime=n,this.endTime=r}}e.Profiler=class{static create(t){return void 0===t?new this:new this(t.maxNumberEvents,t.flushBatchSize,t.flushIntervalInMilliseconds)}constructor(t,e,n){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===t?1e4:t,this._flushBatchSize=void 0===e?10:e,this._flushIntervalInMilliseconds=void 0===n?5e3:n}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,e.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(t,e,n,r){const i=this._started?this.begin(t,e,r):void 0;let o=!1;const a=n();if(a&&"function"==typeof a.then)return o=!0,new Promise(((t,e)=>{a.then((async e=>{i&&await i.end(),t(e)}),(async t=>{i&&await i.end(),e(t)}))}));if(!o&&i){const t=i.end();if(t&&"function"==typeof t.then)return new Promise(((e,n)=>{t.then((()=>{e(a)}),(t=>{n(t)}))}))}return a}begin(t,n,r){if(!this._started)throw new Error("profiler is not started yet");if(void 0===r){const r=(0,e.now)();return this.flush(r),new u(t,n,r,(t=>this.endSync(t)))}{const e=r.beginTimer();return new u(t,n,0,(async t=>this.end(t)),e,r)}}async end(t){const e=await t.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new c(t.category,t.name,t.startTime,e)),this.flush(e))}endSync(t){const n=(0,e.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new c(t.category,t.name,t.startTime,n)),this.flush(n))}logOneEvent(t){e.Logger.verbose(`Profiler.${t.category}`,`${(t.endTime-t.startTime).toFixed(2)}ms on event '${t.name}' at ${t.endTime.toFixed(2)}`)}flush(t){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||t-this._flushTime>=this._flushIntervalInMilliseconds){for(const t=this._flushPointer;this._flushPointer<t+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,e.now)()}}get started(){return this._started}},e.now="undefined"!=typeof performance&&performance.now?()=>performance.now():Date.now},2644:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Model=void 0;const r=n(5686),i=n(1446),o=n(7070),a=n(9395),s=n(2517);var u=a.onnxruntime.experimental.fbs;e.Model=class{constructor(){}load(t,e,n){if(!n)try{return void this.loadFromOnnxFormat(t,e)}catch(t){if(void 0!==n)throw t}this.loadFromOrtFormat(t,e)}loadFromOnnxFormat(t,e){const n=i.onnx.ModelProto.decode(t);if(s.LongUtil.longToNumber(n.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=n.opsetImport.map((t=>({domain:t.domain,version:s.LongUtil.longToNumber(t.version)}))),this._graph=o.Graph.from(n.graph,e)}loadFromOrtFormat(t,e){const n=new r.flatbuffers.ByteBuffer(t),i=u.InferenceSession.getRootAsInferenceSession(n).model();if(s.LongUtil.longToNumber(i.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let t=0;t<i.opsetImportLength();t++){const e=i.opsetImport(t);this._opsets.push({domain:null==e?void 0:e.domain(),version:s.LongUtil.longToNumber(e.version())})}this._graph=o.Graph.from(i.graph(),e)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.FLOAT_TYPES=e.INT_TYPES=e.NUMBER_TYPES=void 0,e.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],e.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],e.FLOAT_TYPES=["float32","float64"]},1047:(t,e)=>{"use strict";function n(t,e){if(e.endsWith("+")){const n=Number.parseInt(e.substring(0,e.length-1),10);return!isNaN(n)&&n<=t}if(2===e.split("-").length){const n=e.split("-"),r=Number.parseInt(n[0],10),i=Number.parseInt(n[1],10);return!isNaN(r)&&!isNaN(i)&&r<=t&&t<=i}return Number.parseInt(e,10)===t}Object.defineProperty(e,"__esModule",{value:!0}),e.resolveOperator=void 0,e.resolveOperator=function(t,e,r){for(const i of r){const r=i[0],o=i[1],a=i[2],s=i[3],u=i[4];if(t.opType===r)for(const t of e)if((t.domain===o||"ai.onnx"===t.domain&&""===o)&&n(t.version,a))return{opImpl:s,opInit:u}}throw new TypeError(`cannot resolve operator '${t.opType}' with opsets: ${e.map((t=>`${t.domain||"ai.onnx"} v${t.version}`)).join(", ")}`)}},9395:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.onnxruntime=void 0;const r=n(5686);var i,o;i=e.onnxruntime||(e.onnxruntime={}),function(t){let e;!function(t){t[t.UNDEFINED=0]="UNDEFINED",t[t.FLOAT=1]="FLOAT",t[t.INT=2]="INT",t[t.STRING=3]="STRING",t[t.TENSOR=4]="TENSOR",t[t.GRAPH=5]="GRAPH",t[t.FLOATS=6]="FLOATS",t[t.INTS=7]="INTS",t[t.STRINGS=8]="STRINGS",t[t.TENSORS=9]="TENSORS",t[t.GRAPHS=10]="GRAPHS",t[t.SPARSE_TENSOR=11]="SPARSE_TENSOR",t[t.SPARSE_TENSORS=12]="SPARSE_TENSORS"}(e=t.AttributeType||(t.AttributeType={}))}((o=i.experimental||(i.experimental={})).fbs||(o.fbs={})),function(t){!function(t){!function(t){let e;!function(t){t[t.UNKNOWN=0]="UNKNOWN",t[t.VALUE=1]="VALUE",t[t.PARAM=2]="PARAM"}(e=t.DimensionValueType||(t.DimensionValueType={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){let e;!function(t){t[t.UNDEFINED=0]="UNDEFINED",t[t.FLOAT=1]="FLOAT",t[t.UINT8=2]="UINT8",t[t.INT8=3]="INT8",t[t.UINT16=4]="UINT16",t[t.INT16=5]="INT16",t[t.INT32=6]="INT32",t[t.INT64=7]="INT64",t[t.STRING=8]="STRING",t[t.BOOL=9]="BOOL",t[t.FLOAT16=10]="FLOAT16",t[t.DOUBLE=11]="DOUBLE",t[t.UINT32=12]="UINT32",t[t.UINT64=13]="UINT64",t[t.COMPLEX64=14]="COMPLEX64",t[t.COMPLEX128=15]="COMPLEX128",t[t.BFLOAT16=16]="BFLOAT16"}(e=t.TensorDataType||(t.TensorDataType={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){let e;!function(t){t[t.Primitive=0]="Primitive",t[t.Fused=1]="Fused"}(e=t.NodeType||(t.NodeType={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){let e;!function(t){t[t.NONE=0]="NONE",t[t.tensor_type=1]="tensor_type",t[t.sequence_type=2]="sequence_type",t[t.map_type=3]="map_type"}(e=t.TypeInfoValue||(t.TypeInfoValue={}))}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShape(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShape(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}dim(e,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new t.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}dimLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startShape(t){t.startObject(1)}static addDim(t,e){t.addFieldOffset(0,e,0)}static createDimVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startDimVector(t,e){t.startVector(4,e,4)}static endShape(t){return t.endObject()}static createShape(t,e){return n.startShape(t),n.addDim(t,e),n.endShape(t)}}e.Shape=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsDimension(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsDimension(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}value(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}denotation(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}static startDimension(t){t.startObject(2)}static addValue(t,e){t.addFieldOffset(0,e,0)}static addDenotation(t,e){t.addFieldOffset(1,e,0)}static endDimension(t){return t.endObject()}static createDimension(t,e,r){return n.startDimension(t),n.addValue(t,e),n.addDenotation(t,r),n.endDimension(t)}}e.Dimension=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsDimensionValue(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsDimensionValue(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}dimType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt8(this.bb_pos+e):t.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}dimParam(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}static startDimensionValue(t){t.startObject(3)}static addDimType(e,n){e.addFieldInt8(0,n,t.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(t,e){t.addFieldInt64(1,e,t.createLong(0,0))}static addDimParam(t,e){t.addFieldOffset(2,e,0)}static endDimensionValue(t){return t.endObject()}static createDimensionValue(t,e,r,i){return n.startDimensionValue(t),n.addDimType(t,e),n.addDimValue(t,r),n.addDimParam(t,i),n.endDimensionValue(t)}}e.DimensionValue=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTensorTypeAndShape(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTensorTypeAndShape(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}elemType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.TensorDataType.UNDEFINED}shape(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startTensorTypeAndShape(t){t.startObject(2)}static addElemType(e,n){e.addFieldInt32(0,n,t.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(t,e){t.addFieldOffset(1,e,0)}static endTensorTypeAndShape(t){return t.endObject()}static createTensorTypeAndShape(t,e,r){return n.startTensorTypeAndShape(t),n.addElemType(t,e),n.addShape(t,r),n.endTensorTypeAndShape(t)}}e.TensorTypeAndShape=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsMapType(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsMapType(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}keyType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.TensorDataType.UNDEFINED}valueType(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startMapType(t){t.startObject(2)}static addKeyType(e,n){e.addFieldInt32(0,n,t.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(t,e){t.addFieldOffset(1,e,0)}static endMapType(t){return t.endObject()}static createMapType(t,e,r){return n.startMapType(t),n.addKeyType(t,e),n.addValueType(t,r),n.endMapType(t)}}e.MapType=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSequenceType(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSequenceType(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}elemType(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSequenceType(t){t.startObject(1)}static addElemType(t,e){t.addFieldOffset(0,e,0)}static endSequenceType(t){return t.endObject()}static createSequenceType(t,e){return n.startSequenceType(t),n.addElemType(t,e),n.endSequenceType(t)}}e.SequenceType=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){(t.fbs||(t.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(t,e,n,r){return t.prep(4,12),t.writeInt32(r),t.writeInt32(n),t.writeInt32(e),t.offset()}}}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsNodeEdge(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsNodeEdge(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}nodeIndex(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}inputEdges(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*e,this.bb):null}inputEdgesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}outputEdges(e,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new t.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*e,this.bb):null}outputEdgesLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startNodeEdge(t){t.startObject(3)}static addNodeIndex(t,e){t.addFieldInt32(0,e,0)}static addInputEdges(t,e){t.addFieldOffset(1,e,0)}static startInputEdgesVector(t,e){t.startVector(12,e,4)}static addOutputEdges(t,e){t.addFieldOffset(2,e,0)}static startOutputEdgesVector(t,e){t.startVector(12,e,4)}static endNodeEdge(t){return t.endObject()}static createNodeEdge(t,e,r,i){return n.startNodeEdge(t),n.addNodeIndex(t,e),n.addInputEdges(t,r),n.addOutputEdges(t,i),n.endNodeEdge(t)}}e.NodeEdge=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsNode(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsNode(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}domain(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}sinceVersion(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):0}index(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint32(this.bb_pos+t):0}opType(t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,t):null}type(){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.NodeType.Primitive}executionProviderType(t){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__string(this.bb_pos+e,t):null}inputs(t,e){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}inputsLength(){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}outputs(t,e){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}outputsLength(){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}attributes(e,n){let r=this.bb.__offset(this.bb_pos,24);return r?(n||new t.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}attributesLength(){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}inputArgCounts(t){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}inputArgCountsLength(){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}inputArgCountsArray(){let t=this.bb.__offset(this.bb_pos,26);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}implicitInputs(t,e){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}implicitInputsLength(){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}static startNode(t){t.startObject(13)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addDomain(t,e){t.addFieldOffset(2,e,0)}static addSinceVersion(t,e){t.addFieldInt32(3,e,0)}static addIndex(t,e){t.addFieldInt32(4,e,0)}static addOpType(t,e){t.addFieldOffset(5,e,0)}static addType(e,n){e.addFieldInt32(6,n,t.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(t,e){t.addFieldOffset(7,e,0)}static addInputs(t,e){t.addFieldOffset(8,e,0)}static createInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInputsVector(t,e){t.startVector(4,e,4)}static addOutputs(t,e){t.addFieldOffset(9,e,0)}static createOutputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOutputsVector(t,e){t.startVector(4,e,4)}static addAttributes(t,e){t.addFieldOffset(10,e,0)}static createAttributesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startAttributesVector(t,e){t.startVector(4,e,4)}static addInputArgCounts(t,e){t.addFieldOffset(11,e,0)}static createInputArgCountsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addInt32(e[n]);return t.endVector()}static startInputArgCountsVector(t,e){t.startVector(4,e,4)}static addImplicitInputs(t,e){t.addFieldOffset(12,e,0)}static createImplicitInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startImplicitInputsVector(t,e){t.startVector(4,e,4)}static endNode(t){return t.endObject()}static createNode(t,e,r,i,o,a,s,u,c,l,p,f,d,h){return n.startNode(t),n.addName(t,e),n.addDocString(t,r),n.addDomain(t,i),n.addSinceVersion(t,o),n.addIndex(t,a),n.addOpType(t,s),n.addType(t,u),n.addExecutionProviderType(t,c),n.addInputs(t,l),n.addOutputs(t,p),n.addAttributes(t,f),n.addInputArgCounts(t,d),n.addImplicitInputs(t,h),n.endNode(t)}}e.Node=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsValueInfo(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsValueInfo(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}type(e){let n=this.bb.__offset(this.bb_pos,8);return n?(e||new t.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startValueInfo(t){t.startObject(3)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addType(t,e){t.addFieldOffset(2,e,0)}static endValueInfo(t){return t.endObject()}static createValueInfo(t,e,r,i){return n.startValueInfo(t),n.addName(t,e),n.addDocString(t,r),n.addType(t,i),n.endValueInfo(t)}}e.ValueInfo=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTypeInfo(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTypeInfo(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}denotation(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}valueType(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint8(this.bb_pos+e):t.experimental.fbs.TypeInfoValue.NONE}value(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__union(t,this.bb_pos+e):null}static startTypeInfo(t){t.startObject(3)}static addDenotation(t,e){t.addFieldOffset(0,e,0)}static addValueType(e,n){e.addFieldInt8(1,n,t.experimental.fbs.TypeInfoValue.NONE)}static addValue(t,e){t.addFieldOffset(2,e,0)}static endTypeInfo(t){return t.endObject()}static createTypeInfo(t,e,r,i){return n.startTypeInfo(t),n.addDenotation(t,e),n.addValueType(t,r),n.addValue(t,i),n.endTypeInfo(t)}}e.TypeInfo=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsOperatorSetId(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsOperatorSetId(t,n){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}domain(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}version(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}static startOperatorSetId(t){t.startObject(2)}static addDomain(t,e){t.addFieldOffset(0,e,0)}static addVersion(t,e){t.addFieldInt64(1,e,t.createLong(0,0))}static endOperatorSetId(t){return t.endObject()}static createOperatorSetId(t,n,r){return e.startOperatorSetId(t),e.addDomain(t,n),e.addVersion(t,r),e.endOperatorSetId(t)}}t.OperatorSetId=e}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTensor(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTensor(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}dims(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}dimsLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}dataType(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.TensorDataType.UNDEFINED}rawData(t){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint8(this.bb.__vector(this.bb_pos+e)+t):0}rawDataLength(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}rawDataArray(){let t=this.bb.__offset(this.bb_pos,12);return t?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}stringData(t,e){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}stringDataLength(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}static startTensor(t){t.startObject(6)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addDims(t,e){t.addFieldOffset(2,e,0)}static createDimsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startDimsVector(t,e){t.startVector(8,e,8)}static addDataType(e,n){e.addFieldInt32(3,n,t.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(t,e){t.addFieldOffset(4,e,0)}static createRawDataVector(t,e){t.startVector(1,e.length,1);for(let n=e.length-1;n>=0;n--)t.addInt8(e[n]);return t.endVector()}static startRawDataVector(t,e){t.startVector(1,e,1)}static addStringData(t,e){t.addFieldOffset(5,e,0)}static createStringDataVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startStringDataVector(t,e){t.startVector(4,e,4)}static endTensor(t){return t.endObject()}static createTensor(t,e,r,i,o,a,s){return n.startTensor(t),n.addName(t,e),n.addDocString(t,r),n.addDims(t,i),n.addDataType(t,o),n.addRawData(t,a),n.addStringData(t,s),n.endTensor(t)}}e.Tensor=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSparseTensor(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSparseTensor(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}values(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}indices(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}dims(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}dimsLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSparseTensor(t){t.startObject(3)}static addValues(t,e){t.addFieldOffset(0,e,0)}static addIndices(t,e){t.addFieldOffset(1,e,0)}static addDims(t,e){t.addFieldOffset(2,e,0)}static createDimsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startDimsVector(t,e){t.startVector(8,e,8)}static endSparseTensor(t){return t.endObject()}static createSparseTensor(t,e,r,i){return n.startSparseTensor(t),n.addValues(t,e),n.addIndices(t,r),n.addDims(t,i),n.endSparseTensor(t)}}e.SparseTensor=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAttribute(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAttribute(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}type(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt32(this.bb_pos+e):t.experimental.fbs.AttributeType.UNDEFINED}f(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}i(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}s(t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,t):null}t(e){let n=this.bb.__offset(this.bb_pos,16);return n?(e||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}g(e){let n=this.bb.__offset(this.bb_pos,18);return n?(e||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}floats(t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}floatsLength(){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}floatsArray(){let t=this.bb.__offset(this.bb_pos,20);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ints(t){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}intsLength(){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}strings(t,e){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}stringsLength(){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}tensors(e,n){let r=this.bb.__offset(this.bb_pos,26);return r?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}tensorsLength(){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}graphs(e,n){let r=this.bb.__offset(this.bb_pos,28);return r?(n||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}graphsLength(){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAttribute(t){t.startObject(13)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addType(e,n){e.addFieldInt32(2,n,t.experimental.fbs.AttributeType.UNDEFINED)}static addF(t,e){t.addFieldFloat32(3,e,0)}static addI(t,e){t.addFieldInt64(4,e,t.createLong(0,0))}static addS(t,e){t.addFieldOffset(5,e,0)}static addT(t,e){t.addFieldOffset(6,e,0)}static addG(t,e){t.addFieldOffset(7,e,0)}static addFloats(t,e){t.addFieldOffset(8,e,0)}static createFloatsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addFloat32(e[n]);return t.endVector()}static startFloatsVector(t,e){t.startVector(4,e,4)}static addInts(t,e){t.addFieldOffset(9,e,0)}static createIntsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startIntsVector(t,e){t.startVector(8,e,8)}static addStrings(t,e){t.addFieldOffset(10,e,0)}static createStringsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startStringsVector(t,e){t.startVector(4,e,4)}static addTensors(t,e){t.addFieldOffset(11,e,0)}static createTensorsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startTensorsVector(t,e){t.startVector(4,e,4)}static addGraphs(t,e){t.addFieldOffset(12,e,0)}static createGraphsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startGraphsVector(t,e){t.startVector(4,e,4)}static endAttribute(t){return t.endObject()}static createAttribute(t,e,r,i,o,a,s,u,c,l,p,f,d,h){return n.startAttribute(t),n.addName(t,e),n.addDocString(t,r),n.addType(t,i),n.addF(t,o),n.addI(t,a),n.addS(t,s),n.addT(t,u),n.addG(t,c),n.addFloats(t,l),n.addInts(t,p),n.addStrings(t,f),n.addTensors(t,d),n.addGraphs(t,h),n.endAttribute(t)}}e.Attribute=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsGraph(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsGraph(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}initializers(e,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new t.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}initializersLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}nodeArgs(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}nodeArgsLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}nodes(e,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new t.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}nodesLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}maxNodeIndex(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readUint32(this.bb_pos+t):0}nodeEdges(e,n){let r=this.bb.__offset(this.bb_pos,12);return r?(n||new t.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}nodeEdgesLength(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}inputs(t,e){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}inputsLength(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}outputs(t,e){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}outputsLength(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}sparseInitializers(e,n){let r=this.bb.__offset(this.bb_pos,18);return r?(n||new t.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}sparseInitializersLength(){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}static startGraph(t){t.startObject(8)}static addInitializers(t,e){t.addFieldOffset(0,e,0)}static createInitializersVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInitializersVector(t,e){t.startVector(4,e,4)}static addNodeArgs(t,e){t.addFieldOffset(1,e,0)}static createNodeArgsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodeArgsVector(t,e){t.startVector(4,e,4)}static addNodes(t,e){t.addFieldOffset(2,e,0)}static createNodesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodesVector(t,e){t.startVector(4,e,4)}static addMaxNodeIndex(t,e){t.addFieldInt32(3,e,0)}static addNodeEdges(t,e){t.addFieldOffset(4,e,0)}static createNodeEdgesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodeEdgesVector(t,e){t.startVector(4,e,4)}static addInputs(t,e){t.addFieldOffset(5,e,0)}static createInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInputsVector(t,e){t.startVector(4,e,4)}static addOutputs(t,e){t.addFieldOffset(6,e,0)}static createOutputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOutputsVector(t,e){t.startVector(4,e,4)}static addSparseInitializers(t,e){t.addFieldOffset(7,e,0)}static createSparseInitializersVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startSparseInitializersVector(t,e){t.startVector(4,e,4)}static endGraph(t){return t.endObject()}static createGraph(t,e,r,i,o,a,s,u,c){return n.startGraph(t),n.addInitializers(t,e),n.addNodeArgs(t,r),n.addNodes(t,i),n.addMaxNodeIndex(t,o),n.addNodeEdges(t,a),n.addInputs(t,s),n.addOutputs(t,u),n.addSparseInitializers(t,c),n.endGraph(t)}}e.Graph=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsModel(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsModel(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}irVersion(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}opsetImport(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}opsetImportLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}producerName(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}producerVersion(t){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.__string(this.bb_pos+e,t):null}domain(t){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__string(this.bb_pos+e,t):null}modelVersion(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}docString(t){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__string(this.bb_pos+e,t):null}graph(e){let n=this.bb.__offset(this.bb_pos,18);return n?(e||new t.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}graphDocString(t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,t):null}static startModel(t){t.startObject(9)}static addIrVersion(t,e){t.addFieldInt64(0,e,t.createLong(0,0))}static addOpsetImport(t,e){t.addFieldOffset(1,e,0)}static createOpsetImportVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOpsetImportVector(t,e){t.startVector(4,e,4)}static addProducerName(t,e){t.addFieldOffset(2,e,0)}static addProducerVersion(t,e){t.addFieldOffset(3,e,0)}static addDomain(t,e){t.addFieldOffset(4,e,0)}static addModelVersion(t,e){t.addFieldInt64(5,e,t.createLong(0,0))}static addDocString(t,e){t.addFieldOffset(6,e,0)}static addGraph(t,e){t.addFieldOffset(7,e,0)}static addGraphDocString(t,e){t.addFieldOffset(8,e,0)}static endModel(t){return t.endObject()}static createModel(t,e,r,i,o,a,s,u,c,l){return n.startModel(t),n.addIrVersion(t,e),n.addOpsetImport(t,r),n.addProducerName(t,i),n.addProducerVersion(t,o),n.addDomain(t,a),n.addModelVersion(t,s),n.addDocString(t,u),n.addGraph(t,c),n.addGraphDocString(t,l),n.endModel(t)}}e.Model=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(t){!function(t){class e{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsKernelCreateInfos(t,n){return(n||new e).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsKernelCreateInfos(t,n){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new e).__init(t.readInt32(t.position())+t.position(),t)}nodeIndices(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}nodeIndicesLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}nodeIndicesArray(){let t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}kernelDefHashes(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}kernelDefHashesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startKernelCreateInfos(t){t.startObject(2)}static addNodeIndices(t,e){t.addFieldOffset(0,e,0)}static createNodeIndicesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addInt32(e[n]);return t.endVector()}static startNodeIndicesVector(t,e){t.startVector(4,e,4)}static addKernelDefHashes(t,e){t.addFieldOffset(1,e,0)}static createKernelDefHashesVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startKernelDefHashesVector(t,e){t.startVector(8,e,8)}static endKernelCreateInfos(t){return t.endObject()}static createKernelCreateInfos(t,n,r){return e.startKernelCreateInfos(t),e.addNodeIndices(t,n),e.addKernelDefHashes(t,r),e.endKernelCreateInfos(t)}}t.KernelCreateInfos=e}(t.fbs||(t.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSubGraphSessionState(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSubGraphSessionState(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}graphId(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}sessionState(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSubGraphSessionState(t){t.startObject(2)}static addGraphId(t,e){t.addFieldOffset(0,e,0)}static addSessionState(t,e){t.addFieldOffset(1,e,0)}static endSubGraphSessionState(t){let e=t.endObject();return t.requiredField(e,4),e}static createSubGraphSessionState(t,e,r){return n.startSubGraphSessionState(t),n.addGraphId(t,e),n.addSessionState(t,r),n.endSubGraphSessionState(t)}}e.SubGraphSessionState=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSessionState(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSessionState(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}kernels(e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new t.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}subGraphSessionStates(e,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new t.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*e),this.bb):null}subGraphSessionStatesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSessionState(t){t.startObject(2)}static addKernels(t,e){t.addFieldOffset(0,e,0)}static addSubGraphSessionStates(t,e){t.addFieldOffset(1,e,0)}static createSubGraphSessionStatesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startSubGraphSessionStatesVector(t,e){t.startVector(4,e,4)}static endSessionState(t){return t.endObject()}static createSessionState(t,e,r){return n.startSessionState(t),n.addKernels(t,e),n.addSubGraphSessionStates(t,r),n.endSessionState(t)}}e.SessionState=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={})),function(t){!function(e){!function(e){class n{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsInferenceSession(t,e){return(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsInferenceSession(t,e){return t.setPosition(t.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(e||new n).__init(t.readInt32(t.position())+t.position(),t)}static bufferHasIdentifier(t){return t.__has_identifier("ORTM")}ortVersion(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}model(e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new t.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}sessionState(e){let n=this.bb.__offset(this.bb_pos,8);return n?(e||new t.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startInferenceSession(t){t.startObject(3)}static addOrtVersion(t,e){t.addFieldOffset(0,e,0)}static addModel(t,e){t.addFieldOffset(1,e,0)}static addSessionState(t,e){t.addFieldOffset(2,e,0)}static endInferenceSession(t){return t.endObject()}static finishInferenceSessionBuffer(t,e){t.finish(e,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(t,e){t.finish(e,"ORTM",!0)}static createInferenceSession(t,e,r,i){return n.startInferenceSession(t),n.addOrtVersion(t,e),n.addModel(t,r),n.addSessionState(t,i),n.endInferenceSession(t)}}e.InferenceSession=n}(e.fbs||(e.fbs={}))}(t.experimental||(t.experimental={}))}(e.onnxruntime||(e.onnxruntime={}))},7448:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.OnnxjsSessionHandler=void 0;const r=n(1670),i=n(9162);e.OnnxjsSessionHandler=class{constructor(t){this.session=t,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(t,e,n){const o=new Map;for(const e in t)if(Object.hasOwnProperty.call(t,e)){const n=t[e];o.set(e,new i.Tensor(n.dims,n.type,void 0,void 0,n.data))}const a=await this.session.run(o),s={};return a.forEach(((t,e)=>{s[e]=new r.Tensor(t.type,t.data,t.dims)})),s}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.Session=void 0;const r=n(7067),i=n(1296),o=n(7091),a=n(1036),s=n(6231),u=n(2644);e.Session=class{constructor(t={}){this._initialized=!1,this.backendHint=t.backendHint,this.profiler=s.Profiler.create(t.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(t,e,n){await this.profiler.event("session","Session.loadModel",(async()=>{const a=await(0,o.resolveBackend)(this.backendHint);if(this.sessionHandler=a.createSessionHandler(this.context),this._model=new u.Model,"string"==typeof t){const e=t.endsWith(".ort");if("undefined"==typeof fetch){const n=await(0,i.promisify)(r.readFile)(t);this.initialize(n,e)}else{const n=await fetch(t),r=await n.arrayBuffer();this.initialize(new Uint8Array(r),e)}}else if(ArrayBuffer.isView(t))this.initialize(t);else{const r=new Uint8Array(t,e||0,n||t.byteLength);this.initialize(r)}}))}initialize(t,e){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",(()=>{const n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(t,n,e),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new a.ExecutionPlan(this._model.graph,this._ops,this.profiler)})),this._initialized=!0}async run(t){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",(async()=>{const e=this.normalizeAndValidateInputs(t),n=await this._executionPlan.execute(this.sessionHandler,e);return this.createOutput(n)}))}normalizeAndValidateInputs(t){const e=this._model.graph.getInputNames();if(Array.isArray(t)){if(t.length!==e.length)throw new Error(`incorrect input array length: expected ${e.length} but got ${t.length}`)}else{if(t.size!==e.length)throw new Error(`incorrect input map size: expected ${e.length} but got ${t.size}`);const n=new Array(t.size);let r=0;for(let i=0;i<e.length;++i){const o=t.get(e[i]);if(!o)throw new Error(`missing input tensor for: '${name}'`);n[r++]=o}t=n}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,t,!1);else{const e=this._model.graph.getInputIndices(),n=this._model.graph.getValues(),r=new Array(e.length);for(let i=0;i<e.length;++i){const o=n[e[i]];r[i]=o.type.shape.dims,this.context.graphInputTypes.push(o.type.tensorType),this.context.graphInputDims.push(t[i].dims)}this.validateInputTensorDims(r,t,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,t),t}validateInputTensorTypes(t,e){for(let n=0;n<e.length;n++){const r=t[n],i=e[n].type;if(r!==i)throw new Error(`input tensor[${n}] check failed: expected type '${r}' but got ${i}`)}}validateInputTensorDims(t,e,n){for(let r=0;r<e.length;r++){const i=t[r],o=e[r].dims;if(!this.compareTensorDims(i,o,n))throw new Error(`input tensor[${r}] check failed: expected shape '[${i.join(",")}]' but got [${o.join(",")}]`)}}compareTensorDims(t,e,n){if(t.length!==e.length)return!1;for(let r=0;r<t.length;++r)if(t[r]!==e[r]&&(!n||0!==t[r]))return!1;return!0}createOutput(t){const e=this._model.graph.getOutputNames();if(t.length!==e.length)throw new Error("expected number of outputs do not match number of generated outputs");const n=new Map;for(let r=0;r<e.length;++r)n.set(e[r],t[r]);return n}initializeOps(t){const e=t.getNodes();this._ops=new Array(e.length);for(let n=0;n<e.length;n++)this._ops[n]=this.sessionHandler.resolve(e[n],this._model.opsets,t)}}},9162:function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.Tensor=void 0;const i=n(3442),o=r(n(3720)),a=n(1446),s=n(9395),u=n(2517);var c=s.onnxruntime.experimental.fbs;class l{get data(){if(void 0===this.cache){const t=this.dataProvider(this.dataId);if(t.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=t}return this.cache}get stringData(){if("string"!==this.type)throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw new TypeError("type cannot be non-number (string)")}get(t){return this.data[u.ShapeUtil.indicesToOffset(t,this.strides)]}set(t,e){this.data[u.ShapeUtil.indicesToOffset(t,this.strides)]=e}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=u.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(t,e,n,r,o,a=i.Guid.create()){this.dims=t,this.type=e,this.dataProvider=n,this.asyncDataProvider=r,this.cache=o,this.dataId=a,this.size=u.ShapeUtil.validateDimsAndCalcSize(t);const s=this.size,c=void 0===n&&void 0===r&&void 0===o;if(void 0!==o&&o.length!==s)throw new RangeError("Input dims doesn't match data length.");if("string"===e){if(!(void 0===o||Array.isArray(o)&&o.every((t=>"string"==typeof t))))throw new TypeError("cache should be a string array");c&&(this.cache=new Array(s))}else{if(void 0!==o){const t=f(e);if(!(o instanceof t))throw new TypeError(`cache should be type ${t.name}`)}if(c){const t=new ArrayBuffer(s*function(t){switch(t){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${t}`)}}(e));this.cache=function(t,e){return new(f(e))(t)}(t,e)}}}static fromProto(t){if(!t)throw new Error("cannot construct Value from an empty tensor");const e=u.ProtoUtil.tensorDataTypeFromProto(t.dataType),n=u.ProtoUtil.tensorDimsFromProto(t.dims),r=new l(n,e);if("string"===e)t.stringData.forEach(((t,e)=>{r.data[e]=(0,u.decodeUtf8String)(t)}));else if(t.rawData&&"number"==typeof t.rawData.byteLength&&t.rawData.byteLength>0){const e=r.data,n=new DataView(t.rawData.buffer,t.rawData.byteOffset,t.rawData.byteLength),i=p(t.dataType),o=t.rawData.byteLength/i;if(t.rawData.byteLength%i!=0)throw new Error("invalid buffer length");if(e.length!==o)throw new Error("buffer length mismatch");for(let r=0;r<o;r++){const o=h(n,t.dataType,r*i);e[r]=o}}else{let e;switch(t.dataType){case a.onnx.TensorProto.DataType.FLOAT:e=t.floatData;break;case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.INT16:case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.BOOL:e=t.int32Data;break;case a.onnx.TensorProto.DataType.INT64:e=t.int64Data;break;case a.onnx.TensorProto.DataType.DOUBLE:e=t.doubleData;break;case a.onnx.TensorProto.DataType.UINT32:case a.onnx.TensorProto.DataType.UINT64:e=t.uint64Data;break;default:throw new Error("unspecific error")}if(null==e)throw new Error("failed to populate data from a tensorproto value");const n=r.data;if(n.length!==e.length)throw new Error("array length mismatch");for(let r=0;r<e.length;r++){const i=e[r];o.default.isLong(i)?n[r]=d(i,t.dataType):n[r]=i}}return r}static fromData(t,e,n){return new l(e,n,void 0,void 0,t)}static fromOrtTensor(t){if(!t)throw new Error("cannot construct Value from an empty tensor");const e=u.ProtoUtil.tensorDimsFromORTFormat(t),n=u.ProtoUtil.tensorDataTypeFromProto(t.dataType()),r=new l(e,n);if("string"===n)for(let e=0;e<t.stringDataLength();e++)r.data[e]=t.stringData(e);else if(t.rawDataArray()&&"number"==typeof t.rawDataLength()&&t.rawDataLength()>0){const e=r.data,n=new DataView(t.rawDataArray().buffer,t.rawDataArray().byteOffset,t.rawDataLength()),i=p(t.dataType()),o=t.rawDataLength()/i;if(t.rawDataLength()%i!=0)throw new Error("invalid buffer length");if(e.length!==o)throw new Error("buffer length mismatch");for(let r=0;r<o;r++){const o=h(n,t.dataType(),r*i);e[r]=o}}return r}}function p(t){switch(t){case a.onnx.TensorProto.DataType.UINT8:case a.onnx.TensorProto.DataType.INT8:case a.onnx.TensorProto.DataType.BOOL:return 1;case a.onnx.TensorProto.DataType.UINT16:case a.onnx.TensorProto.DataType.INT16:return 2;case a.onnx.TensorProto.DataType.FLOAT:case a.onnx.TensorProto.DataType.INT32:case a.onnx.TensorProto.DataType.UINT32:return 4;case a.onnx.TensorProto.DataType.INT64:case a.onnx.TensorProto.DataType.DOUBLE:case a.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[t]}`)}}function f(t){switch(t){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function d(t,e){if(e===a.onnx.TensorProto.DataType.INT64||e===c.TensorDataType.INT64){if(t.greaterThanOrEqual(2147483648)||t.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(e!==a.onnx.TensorProto.DataType.UINT32&&e!==c.TensorDataType.UINT32&&e!==a.onnx.TensorProto.DataType.UINT64&&e!==c.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[e]}`);if(t.greaterThanOrEqual(4294967296)||t.lessThan(0))throw new TypeError("uint64 is not supported")}return t.toNumber()}function h(t,e,n){switch(e){case a.onnx.TensorProto.DataType.BOOL:case a.onnx.TensorProto.DataType.UINT8:return t.getUint8(n);case a.onnx.TensorProto.DataType.INT8:return t.getInt8(n);case a.onnx.TensorProto.DataType.UINT16:return t.getUint16(n,!0);case a.onnx.TensorProto.DataType.INT16:return t.getInt16(n,!0);case a.onnx.TensorProto.DataType.FLOAT:return t.getFloat32(n,!0);case a.onnx.TensorProto.DataType.INT32:return t.getInt32(n,!0);case a.onnx.TensorProto.DataType.UINT32:return t.getUint32(n,!0);case a.onnx.TensorProto.DataType.INT64:return d(o.default.fromBits(t.getUint32(n,!0),t.getUint32(n+4,!0),!1),e);case a.onnx.TensorProto.DataType.DOUBLE:return t.getFloat64(n,!0);case a.onnx.TensorProto.DataType.UINT64:return d(o.default.fromBits(t.getUint32(n,!0),t.getUint32(n+4,!0),!0),e);default:throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[e]}`)}}e.Tensor=l},2517:function(t,e,n){"use strict";var r=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.decodeUtf8String=e.MAX_CLIP=e.MIN_CLIP=e.PoolConvUtil=e.ReduceUtil=e.SplitUtil=e.MathUtil=e.ShapeUtil=e.LongUtil=e.ProtoUtil=e.GemmUtil=e.arrayCopyHelper=e.BroadcastUtil=e.MatMulUtil=e.ArrayUtil=e.assert=e.checkInputsShape=void 0;const i=n(5686),o=r(n(3720)),a=n(1446),s=n(9162);e.checkInputsShape=function(t,...e){if(!t||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].dims||t[n].dims.length!==e[n])return!1;return!0},e.assert=function(t,e){if(!t)throw new Error("string"==typeof e?e:e())},e.ArrayUtil=class{static arraysEqual(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}};class u{static preprocessInputShapes(t,e){return[1===t.length?[1,t[0]]:t,1===e.length?[e[0],1]:e]}static postprocessOutputShape(t,e,n){1===e&&t.splice(t.length-2,1),1===n&&t.pop()}static calcMatMulShape(t,e){return t[1]!==e[0]?void 0:[t[0],e[1]]}}e.MatMulUtil=u;class c{static calcShape(t,e,n=!1){const r=t.length,i=e.length;if(0===r)return e;if(0===i)return t;const o=Math.max(t.length,e.length),a=new Array(o);if(n){if(r<2||i<2)return;const n=u.calcMatMulShape([t[r-2],t[r-1]],[e[i-2],e[i-1]]);if(void 0===n)return;[a[o-2],a[o-1]]=n}for(let s=n?3:1;s<=o;s++){const n=r-s<0?1:t[r-s],u=i-s<0?1:e[i-s];if(n!==u&&n>1&&u>1)return;a[o-s]=Math.max(n,u)}return a}static index(t,e){const n=new Array(e.length);return c.fillIndex(t,e,n),n}static fillIndex(t,e,n){const r=t.length-e.length;for(let i=0;i<e.length;i++)n[i]=t[r+i]%e[i]}static calc(t,e,n,r,i){const o=c.calcShape(t.dims,e.dims);if(o){if(r&&!f.areEqual(o,t.dims))return;const a=f.size(o),u=r?t:new s.Tensor(o,i||t.type);if(0===o.length)u.set([],n(t.get([]),e.get([])));else{const r=new Array(o.length),i=new Array(t.dims.length),s=new Array(e.dims.length);let l,p=0,f=0,d=!1,h=!1;0===t.dims.length&&(p=t.get([]),d=!0),0===e.dims.length&&(f=e.get([]),h=!0);for(let g=0;g<a;g++){l=g;for(let t=o.length-1;t>=0;t--)r[t]=l%o[t],l=Math.floor(l/o[t]);d||(c.fillIndex(r,t.dims,i),p=t.get(i)),h||(c.fillIndex(r,e.dims,s),f=e.get(s)),u.set(r,n(p,f))}}return u}}static isValidBroadcast(t,e){const n=t.length,r=e.length;if(n>r)return!1;for(let i=1;i<=n;i++)if(1!==t[n-i]&&t[n-i]!==e[r-i])return!1;return!0}static getBroadcastDims(t,e){const n=t.length,r=[];for(let i=0;i<n;i++){const o=n-1-i,a=t[o]||1;(e[e.length-1-i]||1)>1&&1===a&&r.unshift(o)}return r}}e.BroadcastUtil=c,e.arrayCopyHelper=function(t,e,n,r,i){if(r<0||r>=e.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=t.length)throw new Error("targetIndex out of bounds");if(r+i>e.length)throw new Error("source indices to be copied are outside bounds");if(n+i>t.length)throw new Error("target array is too small to hold result");for(let o=0;o<i;o++)t[n+o]=e[r+o]},e.GemmUtil=class{static getShapeOfGemmResult(t,e,n,r,i){if(2!==t.length||2!==n.length)throw new Error("shape need to be of size 2");let o,a,s;e?(o=t[1],a=t[0]):(o=t[0],a=t[1]);let u=-1;if(r?(s=n[0],u=1):(s=n[1],u=0),n[u]!==a)throw new Error("dimension mismatch");if(o<=0||s<=0||a<=0)throw new Error("invalid shape specified");if(i&&!c.isValidBroadcast(i,[o,s]))throw new Error("gemm: invalid bias shape for broadcast");return[o,s,a]}};class l{static tensorDataTypeFromProto(t){switch(t){case a.onnx.TensorProto.DataType.INT8:return"int8";case a.onnx.TensorProto.DataType.UINT8:return"uint8";case a.onnx.TensorProto.DataType.BOOL:return"bool";case a.onnx.TensorProto.DataType.INT16:return"int16";case a.onnx.TensorProto.DataType.UINT16:return"uint16";case a.onnx.TensorProto.DataType.INT32:return"int32";case a.onnx.TensorProto.DataType.UINT32:return"uint32";case a.onnx.TensorProto.DataType.FLOAT:return"float32";case a.onnx.TensorProto.DataType.DOUBLE:return"float64";case a.onnx.TensorProto.DataType.STRING:return"string";case a.onnx.TensorProto.DataType.INT64:return"int32";case a.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[t]}`)}}static tensorDataTypeStringToEnum(t){switch(t){case"int8":return a.onnx.TensorProto.DataType.INT8;case"uint8":return a.onnx.TensorProto.DataType.UINT8;case"bool":return a.onnx.TensorProto.DataType.BOOL;case"int16":return a.onnx.TensorProto.DataType.INT16;case"uint16":return a.onnx.TensorProto.DataType.UINT16;case"int32":return a.onnx.TensorProto.DataType.INT32;case"uint32":return a.onnx.TensorProto.DataType.UINT32;case"float32":return a.onnx.TensorProto.DataType.FLOAT;case"float64":return a.onnx.TensorProto.DataType.DOUBLE;case"string":return a.onnx.TensorProto.DataType.STRING;case"int64":return a.onnx.TensorProto.DataType.INT64;case"uint64":return a.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${t}`)}}static tensorDimsFromProto(t){return t.map((t=>o.default.isLong(t)?t.toNumber():t))}static tensorValueTypeFromProto(t){return{tensorType:l.tensorDataTypeFromProto(t.elemType),shape:{dims:l.tensorDimsFromProto(t.shape.dim.map((t=>t.dimValue)))}}}static tensorDimsFromORTFormat(t){const e=[];for(let n=0;n<t.dimsLength();n++)e.push(p.longToNumber(t.dims(n)));return e}static tensorAttributesFromORTFormat(t){const e=[];for(let n=0;n<t.attributesLength();n++)e.push(t.attributes(n));return e}}e.ProtoUtil=l;class p{static longToNumber(t,e){return o.default.isLong(t)?t.toNumber():t instanceof i.flatbuffers.Long?o.default.fromValue({low:t.low,high:t.high,unsigned:null!=e&&e}).toNumber():t}static isLong(t){return o.default.isLong(t)||t instanceof i.flatbuffers.Long}}e.LongUtil=p;class f{static size(t){return f.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,e){if(e<0||e>t.length)throw new Error(`invalid dimension of ${e} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return f.getSizeFromDimensionRange(t,e,t.length)}static sizeToDimension(t,e){if(e<0||e>t.length)throw new Error(`invalid dimension of ${e} for sizeToDimension as Tensor has ${t.length} dimensions.`);return f.getSizeFromDimensionRange(t,0,e)}static getSizeFromDimensionRange(t,e,n){let r=1;for(let i=e;i<n;i++){if(t[i]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");r*=t[i]}return r}static computeStrides(t){const e=t.length;if(0===e)return[];if(1===e)return[1];const n=new Array(e);n[e-1]=1,n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}static transpose(t){return t.slice().reverse()}static indicesToOffset(t,e,n){void 0===n&&(n=t.length);let r=0;for(let i=0;i<n;++i)r+=e[i]*t[i];return r}static offsetToIndices(t,e){const n=e.length;if(0===n)return[];if(1===n)return[t*e[0]];const r=new Array(e.length);for(let n=0;n<r.length-1;++n)r[n]=Math.floor(t/e[n]),t-=r[n]*e[n];return r[r.length-1]=t,r}static normalizeAxis(t,e){if(t<-e&&t>=e)throw new Error("unsupported axis for this operation.");return t<0?t+e:t}static normalizeAxes(t,e){return t.map((t=>this.normalizeAxis(t,e)))}static incrementIndex(t,e,n){if(0===e.length||0===t.length)throw new Error("Index incrementing unsupported for scalar Tensor");if(void 0===n)n=e.length;else if(n<=0||n>e.length)throw new Error("Incorrect axis to increment on");for(let r=n-1;r>=0&&(t[r]++,!(t[r]<e[r]));--r)t[r]=0}static calculateReshapedDims(t,e){if(0===e.length){if(0===t.length||1===f.size(t))return[];throw new Error("cannot reshape to a scalar Tensor")}const n=e.length,r=new Array(n);let i=-1,o=1;for(let a=0;a<n;a++){if(e[a]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(-1===e[a]){if(-1!==i)throw new Error("at most one dimension in shape hints can be -1");i=a}else{if(0===e[a]){if(a>=t.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");r[a]=t[a]}else r[a]=e[a];o*=r[a]}}const a=f.size(t);if(-1!==i){if(a%o!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t}] Output shape: [${e}]`);r[i]=a/o}else if(o!==a)throw new Error("reshapedDims and originalDims don't have matching sizes");return r}static sortBasedOnPerm(t,e){return e?e.map((e=>t[e])):t.slice().reverse()}static padShape(t,e){const n=t.length;return t.map(((t,r)=>t+e[r]+e[r+n]))}static areEqual(t,e){return t.length===e.length&&t.every(((t,n)=>t===e[n]))}static validateDimsAndCalcSize(t){if(t.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let e=1;for(const n of t){if(!Number.isInteger(n))throw new TypeError(`Invalid shape: ${n} is not an integer`);if(n<0||n>2147483647)throw new TypeError(`Invalid shape: length ${n} is not allowed`);e*=n}return e}static flattenShape(t,e){e<0&&(e+=t.length);const n=t.reduce(((t,e)=>t*e),1),r=t.slice(e).reduce(((t,e)=>t*e),1);return[n/r,r]}static squeezeShape(t,e){const n=new Array;e=f.normalizeAxes(e,t.length);for(let r=0;r<t.length;r++){const i=e.indexOf(r)>=0;if(i&&1!==t[r])throw new Error("squeeze an axis of size different than 1");(0===e.length&&t[r]>1||e.length>0&&!i)&&n.push(t[r])}return n}static unsqueezeShape(t,e){const n=new Array(t.length+e.length);n.fill(0);for(let t=0;t<e.length;t++){const r=f.normalizeAxis(e[t],n.length);if(r>=n.length)throw new Error("'axes' has an out of range axis");if(0!==n[r])throw new Error("'axes' has a duplicate axis");n[r]=1}let r=0;for(let e=0;e<n.length;e++)0===n[e]&&(n[e]=t[r++]);if(r!==t.length)throw new Error("the unsqueezed dimension could not be established");return n}}e.ShapeUtil=f,e.MathUtil=class{static sqr(t,e,n,r,i){if(r<0||r>=e.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=t.length)throw new Error("targetIndex out of bounds");if(r+i>e.length)throw new Error("source indices to be copied are outside bounds");if(n+i>t.length)throw new Error("target array is too small to hold result");for(let o=0;o<i;o++)t[n+o]+=Math.pow(e[r+o],2)}static axpy(t,e,n,r,i,o){if(r<0||r>=e.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=t.length)throw new Error("targetIndex out of bounds");if(r+i>e.length)throw new Error("source indices to be copied are outside bounds");if(n+i>t.length)throw new Error("target array is too small to hold result");for(let a=0;a<i;a++)t[n+a]+=o*e[r+a]}static powx(t,e,n,r,i,o){if(r<0||r>=e.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=t.length)throw new Error("targetIndex out of bounds");if(r+i>e.length)throw new Error("source indices to be copied are outside bounds");if(n+i>t.length)throw new Error("target array is too small to hold result");for(let a=0;a<i;a++)t[n+a]=Math.pow(e[r+a],o)}static mul(t,e,n,r,i){if(r<0||r>=e.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=t.length)throw new Error("targetIndex out of bounds");if(r+i>e.length)throw new Error("source indices to be copied are outside bounds");if(n+i>t.length)throw new Error("target array is too small to hold result");for(let o=0;o<i;o++)t[n+o]=e[r+o]*t[n+o]}};class d{static splitShape(t,e,n,r){if(0===n.length){if(!r)throw new Error("need to know number of outputs when the 'split' attribute is not specified");d.determineSplit(t[e],r,n)}const i=[],o=[0];for(let r=0;r<n.length;++r){0!==r&&o.push(o[r-1]+n[r-1]);const a=t.slice();a[e]=n[r],i.push(a)}return[i,o]}static determineSplit(t,e,n){if(t%e!=0)throw new Error("cannot split tensor to equal sized parts");for(let r=0;r<e;++r)n.push(t/e)}}e.SplitUtil=d;class h{static calcReduce(t,e,n,r,i){const o=t.dims.slice(0);0===e.length&&o.forEach(((t,n)=>e.push(n)));const a=h.calcReduceShape(o,e,!0),u=f.size(a),l=new s.Tensor(a,t.type),p=f.computeStrides(a),d=f.computeStrides(o),g=new Array(o.length);for(let n=0;n<u;n++){const a=f.offsetToIndices(n,p);c.fillIndex(a,o,g),l.set(a,h.calcReduceByAxis(t.numberData,e,o,0,f.indicesToOffset(g,d),r,i))}return n?l:new s.Tensor(h.calcReduceShape(o,e,n),l.type,void 0,void 0,l.data,l.dataId)}static calcReduceByAxis(t,e,n,r,i,o,a){let s=0;if(r>=e.length)return o(t[i]);const u=e[r],c=u>=n.length?1:f.size(n.slice(u+1));for(let l=0;l<n[u];l++)s=0===l?h.calcReduceByAxis(t,e,n,r+1,i,o,a):a(s,h.calcReduceByAxis(t,e,n,r+1,i,o,a)),i+=c;return s}static calcReduceShape(t,e,n){const r=t.slice();for(let t=0;t<e.length;t++)r[e[t]]=n?1:0;return r.filter((t=>0!==t))}}e.ReduceUtil=h;class g{static adjustPoolAttributes(t,e,n,r,i,o){if(!t&&n.length!==e.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let t=0;t<e.length-2;t++)t>=n.length?n.push(e[t+2]):n[t]=e[t+2];for(let t=0;t<n.length;t++)if(t<r.length){if(r[t]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let t=0;t<n.length;t++)if(t<i.length){if(i[t]<0)throw new Error("dilations should be greater than or equal to 1")}else i.push(1);for(let t=0;t<2*n.length;t++)if(t<o.length){if(o[t]<0)throw new Error("pad should be greater than or equal to 1")}else o.push(0);for(let t=0;t<n.length;t++){if(n[t]<=0)throw new Error("kernel shapes need to be greater than 0");if(o[t]>=n[t]||o[t+n.length]>=n[t])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,e,n,r,i,o){if(o){if(i.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(e.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<t.length-2;a++)g.adjustPadAndReturnShape(t[a+2],e[a],n[a],r[a],i,a,a+t.length-2,o)}}static computePoolOutputShape(t,e,n,r,i,o,a){if(e.length<=0)throw new Error("input shape must be of size greater than 0");const s=[e[0],e[1]];return g.computeShapeHelper(t,e,s,n,r,i,o,a),s}static computeConvOutputShape(t,e,n,r,i,o,a){if(t.length<=0||e.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const s=[t[0],e[0]];return g.computeShapeHelper(!1,t,s,n,r,i,o,a),s}static computeShapeHelper(t,e,n,r,i,o,a,s){if(t)for(let t=0;t<e.length-2;t++)n.push(1);else for(let t=0;t<e.length-2;t++)n.push(g.adjustPadAndReturnShape(e[t+2],r[t],i[t],o[t],a,t,t+e.length-2,s))}static adjustPadAndReturnShape(t,e,n,r,i,o,a,s){const u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((t+i[o]+i[a]-u)/e+1);switch(s){case"VALID":return i[o]=0,i[a]=0,Math.floor((t-u)/e+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((t+e-1)/e-1)*e+r-t;return i[o]="SAME_LOWER"===s?Math.floor((n+1)/2):Math.floor(n/2),i[a]=n-i[o],Math.floor((t+n-r)/e+1)}default:throw new Error("Unsupported AutoPad type")}}}e.PoolConvUtil=g,e.MIN_CLIP=-34028234663852886e22,e.MAX_CLIP=34028234663852886e22,e.decodeUtf8String=function(t){return(new TextDecoder).decode(t)}},7967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,i)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,o])=>{const a=n?n+t:t;if("object"==typeof o)(0,e.iterateExtraOptions)(o,a+".",r,i);else if("string"==typeof o||"number"==typeof o)i(a,o.toString());else{if("boolean"!=typeof o)throw new Error("Can't handle extra config type: "+typeof o);i(a,o?"1":"0")}}))}},2157:function(t,e,n){"use strict";var r,i=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),o=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),a=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&i(e,t,n);return o(e,t),e};Object.defineProperty(e,"__esModule",{value:!0}),e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=e.initWasm=void 0;const s=n(1670),u=a(n(349)),c=n(6361),l=()=>!!s.env.wasm.proxy&&"undefined"!=typeof document;let p,f,d,h=!1,g=!1,b=!1;const m=[],y=[],_=[],v=[],w=[],x=[],T=()=>{if(h||!g||b||!p)throw new Error("worker not ready")},S=t=>{switch(t.data.type){case"init-wasm":h=!1,t.data.err?(b=!0,f[1](t.data.err)):(g=!0,f[0]());break;case"init-ort":t.data.err?d[1](t.data.err):d[0]();break;case"create_allocate":t.data.err?m.shift()[1](t.data.err):m.shift()[0](t.data.out);break;case"create_finalize":t.data.err?y.shift()[1](t.data.err):y.shift()[0](t.data.out);break;case"create":t.data.err?_.shift()[1](t.data.err):_.shift()[0](t.data.out);break;case"release":t.data.err?v.shift()[1](t.data.err):v.shift()[0]();break;case"run":t.data.err?w.shift()[1](t.data.err):w.shift()[0](t.data.out);break;case"end-profiling":t.data.err?x.shift()[1](t.data.err):x.shift()[0]()}},O="undefined"!=typeof document?null===(r=null===document||void 0===document?void 0:document.currentScript)||void 0===r?void 0:r.src:void 0;e.initWasm=async()=>{if(l()){if(g)return;if(h)throw new Error("multiple calls to 'initWasm()' detected.");if(b)throw new Error("previous call to 'initWasm()' failed.");return h=!0,void 0===s.env.wasm.wasmPaths&&O&&0!==O.indexOf("blob:")&&(s.env.wasm.wasmPaths=O.substr(0,+O.lastIndexOf("/")+1)),new Promise(((t,e)=>{null==p||p.terminate(),p=n(9710).Z(),p.onmessage=S,f=[t,e];const r={type:"init-wasm",in:s.env.wasm};p.postMessage(r)}))}return(0,c.initializeWebAssembly)(s.env.wasm)},e.initOrt=async(t,e)=>{if(l())return T(),new Promise(((n,r)=>{d=[n,r];const i={type:"init-ort",in:{numThreads:t,loggingLevel:e}};p.postMessage(i)}));u.initOrt(t,e)},e.createSessionAllocate=async t=>l()?(T(),new Promise(((e,n)=>{m.push([e,n]);const r={type:"create_allocate",in:{model:t}};p.postMessage(r,[t.buffer])}))):u.createSessionAllocate(t),e.createSessionFinalize=async(t,e)=>l()?(T(),new Promise(((n,r)=>{y.push([n,r]);const i={type:"create_finalize",in:{modeldata:t,options:e}};p.postMessage(i)}))):u.createSessionFinalize(t,e),e.createSession=async(t,e)=>l()?(T(),new Promise(((n,r)=>{_.push([n,r]);const i={type:"create",in:{model:t,options:e}};p.postMessage(i,[t.buffer])}))):u.createSession(t,e),e.releaseSession=async t=>{if(l())return T(),new Promise(((e,n)=>{v.push([e,n]);const r={type:"release",in:t};p.postMessage(r)}));u.releaseSession(t)},e.run=async(t,e,n,r,i)=>l()?(T(),new Promise(((o,a)=>{w.push([o,a]);const s={type:"run",in:{sessionId:t,inputIndices:e,inputs:n,outputIndices:r,options:i}};p.postMessage(s,u.extractTransferableBuffers(n))}))):u.run(t,e,n,r,i),e.endProfiling=async t=>{if(l())return T(),new Promise(((e,n)=>{x.push([e,n]);const r={type:"end-profiling",in:t};p.postMessage(r)}));u.endProfiling(t)}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(7967),i=n(4983),o=n(6361);e.setRunOptions=t=>{const e=(0,o.getInstance)();let n=0;const a=[],s=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==t?void 0:t.tag)&&(o=(0,i.allocWasmString)(t.tag,a)),n=e._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error("Can't create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const o=(0,i.allocWasmString)(t,a),s=(0,i.allocWasmString)(r,a);if(0!==e._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can't set a run config entry: ${t} - ${r}`)})),[n,a]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),a.forEach(e._free),t}}},2306:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.OnnxruntimeWebAssemblySessionHandler=void 0;const r=n(2806),i=n(1670),o=n(2850),a=n(2157);let s;e.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(t){const e=await fetch(t),n=await e.arrayBuffer();return(0,a.createSessionAllocate)(new Uint8Array(n))}async loadModel(t,e){if(s||(await(0,a.initOrt)(i.env.wasm.numThreads,(t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}})(i.env.logLevel)),s=!0),"string"==typeof t)if("undefined"==typeof fetch){const n=await(0,o.promisify)(r.readFile)(t);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(n,e)}else{const n=await this.createSessionAllocate(t);[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSessionFinalize)(n,e)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,a.createSession)(t,e)}async dispose(){return(0,a.releaseSession)(this.sessionId)}async run(t,e,n){const r=[],o=[];Object.entries(t).forEach((t=>{const e=t[0],n=t[1],i=this.inputNames.indexOf(e);if(-1===i)throw new Error(`invalid input '${e}'`);r.push(n),o.push(i)}));const s=[];Object.entries(e).forEach((t=>{const e=t[0],n=this.outputNames.indexOf(e);if(-1===n)throw new Error(`invalid output '${e}'`);s.push(n)}));const u=await(0,a.run)(this.sessionId,o,r.map((t=>[t.type,t.dims,t.data])),s,n),c={};for(let t=0;t<u.length;t++)c[this.outputNames[s[t]]]=new i.Tensor(u[t][0],u[t][2],u[t][1]);return c}startProfiling(){}endProfiling(){(0,a.endProfiling)(this.sessionId)}}},4919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(7967),i=n(4983),o=n(6361);e.setSessionOptions=t=>{const e=(0,o.getInstance)();let n=0;const a=[],s=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(s);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(s.graphOptimizationLevel="all");const u=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(s.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(s.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(s.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(s.executionMode="sequential");const c=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(s.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,i.allocWasmString)(t.logId,a)),void 0===(null==t?void 0:t.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(s.enableProfiling=!1),n=e._OrtCreateSessionOptions(u,!!s.enableCpuMemArena,!!s.enableMemPattern,c,!!s.enableProfiling,0,l,s.logSeverityLevel,s.logVerbosityLevel),0===n)throw new Error("Can't create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const a=(0,i.allocWasmString)(e,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(t,a))throw new Error(`Can't append execution provider: ${e}`)}})(n,t.executionProviders,a),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const o=(0,i.allocWasmString)(t,a),s=(0,i.allocWasmString)(r,a);if(0!==e._OrtAddSessionConfigEntry(n,o,s))throw new Error(`Can't set a session config entry: ${t} - ${r}`)})),[n,a]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),a.forEach(e._free),t}}},4983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(6361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),i=n.lengthBytesUTF8(t)+1,o=n._malloc(i);return n.stringToUTF8(t,o,i),e.push(o),o}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),i=n(4919),o=n(4983),a=n(6361);e.initOrt=(t,e)=>{const n=(0,a.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can't initialize onnxruntime. error code = ${n}`)};const s=new Map;e.createSessionAllocate=t=>{const e=(0,a.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,a.getInstance)();let r=0,o=0,u=[];try{if([o,u]=(0,i.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],o),0===r)throw new Error("Can't create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(o),u.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),p=[],f=[],d=[],h=[];for(let t=0;t<c;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can't get an input name");f.push(e),p.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can't get an output name");h.push(e),d.push(n.UTF8ToString(e))}return s.set(r,[r,f,h]),[r,p,d]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,a.getInstance)(),n=s.get(t);if(!n)throw new Error("invalid session id");const r=n[0],i=n[1],o=n[2];i.forEach(e._OrtFree),o.forEach(e._OrtFree),e._OrtReleaseSession(r),s.delete(t)};const u=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},c=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,i,p)=>{const f=(0,a.getInstance)(),d=s.get(t);if(!d)throw new Error("invalid session id");const h=d[0],g=d[1],b=d[2],m=e.length,y=i.length;let _=0,v=[];const w=[],x=[];try{[_,v]=(0,r.setRunOptions)(p);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],i=n[t][2];let a,s;if(Array.isArray(i)){s=4*i.length,a=f._malloc(s),x.push(a);let t=a/4;for(let e=0;e<i.length;e++){if("string"!=typeof i[e])throw new TypeError(`tensor data at index ${e} is not a string`);f.HEAPU32[t++]=(0,o.allocWasmString)(i[e],x)}}else s=i.byteLength,a=f._malloc(s),x.push(a),f.HEAPU8.set(new Uint8Array(i.buffer,i.byteOffset,s),a);const c=f.stackSave(),l=f.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>f.HEAP32[t++]=e));const n=f._OrtCreateTensor(u(e),a,s,l,r.length);if(0===n)throw new Error("Can't create a tensor");w.push(n)}finally{f.stackRestore(c)}}const t=f.stackSave(),a=f.stackAlloc(4*m),s=f.stackAlloc(4*m),d=f.stackAlloc(4*y),T=f.stackAlloc(4*y);try{let n=a/4,r=s/4,o=d/4,u=T/4;for(let t=0;t<m;t++)f.HEAPU32[n++]=w[t],f.HEAPU32[r++]=g[e[t]];for(let t=0;t<y;t++)f.HEAPU32[o++]=0,f.HEAPU32[u++]=b[i[t]];let p=f._OrtRun(h,s,a,m,T,y,d,_);const v=[];if(0===p)for(let t=0;t<y;t++){const e=f.HEAPU32[d/4+t],n=f.stackSave(),r=f.stackAlloc(16);let i,o=0;try{if(p=f._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==p)throw new Error(`Can't access output tensor data. error code = ${p}`);let t=r/4;const a=f.HEAPU32[t++];o=f.HEAPU32[t++];const s=f.HEAPU32[t++],u=f.HEAPU32[t++],d=[];for(let t=0;t<u;t++)d.push(f.HEAPU32[s/4+t]);f._OrtFree(s);const h=0===d.length?1:d.reduce(((t,e)=>t*e));if(i=c(a),"string"===i){const t=[];let e=o/4;for(let n=0;n<h;n++){const r=f.HEAPU32[e++],i=n===h-1?void 0:f.HEAPU32[e]-r;t.push(f.UTF8ToString(r,i))}v.push([i,d,t])}else{const t=new(l(i))(h);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(f.HEAPU8.subarray(o,o+t.byteLength)),v.push([i,d,t])}}finally{f.stackRestore(n),"string"===i&&o&&f._free(o),f._OrtReleaseTensor(e)}}if(0===p)return v;throw new Error(`failed to call OrtRun(). error code = ${p}.`)}finally{f.stackRestore(t)}}finally{w.forEach(f._OrtReleaseTensor),x.forEach(f._free),f._OrtReleaseRunOptions(_),v.forEach(f._free)}},e.endProfiling=t=>{const e=(0,a.getInstance)(),n=s.get(t);if(!n)throw new Error("invalid session id");const r=n[0],i=e._OrtEndProfiling(r);if(0===i)throw new Error("Can't get an profile file name");e._OrtFree(i)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},6361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var i=Object.getOwnPropertyDescriptor(e,n);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,i)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return i(e,t),e},a=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const s=o(n(6449)),u=a(n(932)),c=n(3474);let l,p=!1,f=!1,d=!1;const h=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(p)return Promise.resolve();if(f)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(d)throw new Error("previous call to 'initializeWebAssembly()' failed.");f=!0;const e=t.initTimeout,r=t.numThreads,i=t.simd,o=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),a=i&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),g="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=h(!1,o),m=h(a,o),y="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let _=!1;const v=[];if(e>0&&v.push(new Promise((t=>{setTimeout((()=>{_=!0,t()}),e)}))),v.push(new Promise(((t,e)=>{const r=o?c:u.default,i={locateFile:(t,e)=>o&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(4154)],{type:"text/javascript"})):t===b?null!=y?y:(null!=g?g:e)+m:e+t};if(o)if("undefined"==typeof Blob)i.mainScriptUrlOrBlob=s.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;i.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(i).then((e=>{f=!1,p=!0,l=e,t()}),(t=>{f=!1,d=!0,e(t)}))}))),await Promise.race(v),_)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(p&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!p||f||d||(f=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,f=!1,p=!1,d=!0)}},9710:(t,e,n)=>{"use strict";n.d(e,{Z:()=>o});var r=n(477),i=n.n(r);function o(){return i()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n',"Worker",void 0,void 0)}},477:t=>{"use strict";t.exports=function(t,e,n,r){var i=self||window;try{try{var o;try{o=new i.Blob([t])}catch(e){(o=new(i.BlobBuilder||i.WebKitBlobBuilder||i.MozBlobBuilder||i.MSBlobBuilder)).append(t),o=o.getBlob()}var a=i.URL||i.webkitURL,s=a.createObjectURL(o),u=new i[e](s,n);return a.revokeObjectURL(s),u}catch(r){return new i[e]("data:application/javascript,".concat(encodeURIComponent(t)),n)}}catch(t){if(!r)throw Error("Inline worker is not supported");return new i[e](r,n)}}},4154:t=>{"use strict";t.exports='"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n'},1670:t=>{"use strict";t.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(t,e,n)=>{"use strict";n.r(e),n.d(e,{flatbuffers:()=>r});var r={};r.Offset,r.Table,r.SIZEOF_SHORT=2,r.SIZEOF_INT=4,r.FILE_IDENTIFIER_LENGTH=4,r.SIZE_PREFIX_LENGTH=4,r.Encoding={UTF8_BYTES:1,UTF16_STRING:2},r.int32=new Int32Array(2),r.float32=new Float32Array(r.int32.buffer),r.float64=new Float64Array(r.int32.buffer),r.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],r.Long=function(t,e){this.low=0|t,this.high=0|e},r.Long.create=function(t,e){return 0==t&&0==e?r.Long.ZERO:new r.Long(t,e)},r.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},r.Long.prototype.equals=function(t){return this.low==t.low&&this.high==t.high},r.Long.ZERO=new r.Long(0,0),r.Builder=function(t){if(t)e=t;else var e=1024;this.bb=r.ByteBuffer.allocate(e),this.space=e,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.forceDefaults=function(t){this.force_defaults=t},r.Builder.prototype.dataBuffer=function(){return this.bb},r.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},r.Builder.prototype.prep=function(t,e){t>this.minalign&&(this.minalign=t);for(var n=1+~(this.bb.capacity()-this.space+e)&t-1;this.space<n+t+e;){var i=this.bb.capacity();this.bb=r.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-i}this.pad(n)},r.Builder.prototype.pad=function(t){for(var e=0;e<t;e++)this.bb.writeInt8(--this.space,0)},r.Builder.prototype.writeInt8=function(t){this.bb.writeInt8(this.space-=1,t)},r.Builder.prototype.writeInt16=function(t){this.bb.writeInt16(this.space-=2,t)},r.Builder.prototype.writeInt32=function(t){this.bb.writeInt32(this.space-=4,t)},r.Builder.prototype.writeInt64=function(t){this.bb.writeInt64(this.space-=8,t)},r.Builder.prototype.writeFloat32=function(t){this.bb.writeFloat32(this.space-=4,t)},r.Builder.prototype.writeFloat64=function(t){this.bb.writeFloat64(this.space-=8,t)},r.Builder.prototype.addInt8=function(t){this.prep(1,0),this.writeInt8(t)},r.Builder.prototype.addInt16=function(t){this.prep(2,0),this.writeInt16(t)},r.Builder.prototype.addInt32=function(t){this.prep(4,0),this.writeInt32(t)},r.Builder.prototype.addInt64=function(t){this.prep(8,0),this.writeInt64(t)},r.Builder.prototype.addFloat32=function(t){this.prep(4,0),this.writeFloat32(t)},r.Builder.prototype.addFloat64=function(t){this.prep(8,0),this.writeFloat64(t)},r.Builder.prototype.addFieldInt8=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt8(e),this.slot(t))},r.Builder.prototype.addFieldInt16=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt16(e),this.slot(t))},r.Builder.prototype.addFieldInt32=function(t,e,n){(this.force_defaults||e!=n)&&(this.addInt32(e),this.slot(t))},r.Builder.prototype.addFieldInt64=function(t,e,n){!this.force_defaults&&e.equals(n)||(this.addInt64(e),this.slot(t))},r.Builder.prototype.addFieldFloat32=function(t,e,n){(this.force_defaults||e!=n)&&(this.addFloat32(e),this.slot(t))},r.Builder.prototype.addFieldFloat64=function(t,e,n){(this.force_defaults||e!=n)&&(this.addFloat64(e),this.slot(t))},r.Builder.prototype.addFieldOffset=function(t,e,n){(this.force_defaults||e!=n)&&(this.addOffset(e),this.slot(t))},r.Builder.prototype.addFieldStruct=function(t,e,n){e!=n&&(this.nested(e),this.slot(t))},r.Builder.prototype.nested=function(t){if(t!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},r.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},r.Builder.prototype.slot=function(t){this.vtable[t]=this.offset()},r.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},r.Builder.growByteBuffer=function(t){var e=t.capacity();if(3221225472&e)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var n=e<<1,i=r.ByteBuffer.allocate(n);return i.setPosition(n-e),i.bytes().set(t.bytes(),n-e),i},r.Builder.prototype.addOffset=function(t){this.prep(r.SIZEOF_INT,0),this.writeInt32(this.offset()-t+r.SIZEOF_INT)},r.Builder.prototype.startObject=function(t){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=t;for(var e=0;e<t;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()},r.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var t=this.offset(),e=this.vtable_in_use-1;e>=0&&0==this.vtable[e];e--);for(var n=e+1;e>=0;e--)this.addInt16(0!=this.vtable[e]?t-this.vtable[e]:0);this.addInt16(t-this.object_start);var i=(n+2)*r.SIZEOF_SHORT;this.addInt16(i);var o=0,a=this.space;t:for(e=0;e<this.vtables.length;e++){var s=this.bb.capacity()-this.vtables[e];if(i==this.bb.readInt16(s)){for(var u=r.SIZEOF_SHORT;u<i;u+=r.SIZEOF_SHORT)if(this.bb.readInt16(a+u)!=this.bb.readInt16(s+u))continue t;o=this.vtables[e];break}}return o?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,o-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t},r.Builder.prototype.finish=function(t,e,n){var i=n?r.SIZE_PREFIX_LENGTH:0;if(e){var o=e;if(this.prep(this.minalign,r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH+i),o.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var a=r.FILE_IDENTIFIER_LENGTH-1;a>=0;a--)this.writeInt8(o.charCodeAt(a))}this.prep(this.minalign,r.SIZEOF_INT+i),this.addOffset(t),i&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},r.Builder.prototype.finishSizePrefixed=function(t,e){this.finish(t,e,!0)},r.Builder.prototype.requiredField=function(t,e){var n=this.bb.capacity()-t,r=n-this.bb.readInt32(n);if(0==this.bb.readInt16(r+e))throw new Error("FlatBuffers: field "+e+" must be set")},r.Builder.prototype.startVector=function(t,e,n){this.notNested(),this.vector_num_elems=e,this.prep(r.SIZEOF_INT,t*e),this.prep(n,t*e)},r.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},r.Builder.prototype.createString=function(t){if(t instanceof Uint8Array)var e=t;else{e=[];for(var n=0;n<t.length;){var r,i=t.charCodeAt(n++);(r=i<55296||i>=56320?i:(i<<10)+t.charCodeAt(n++)+-56613888)<128?e.push(r):(r<2048?e.push(r>>6&31|192):(r<65536?e.push(r>>12&15|224):e.push(r>>18&7|240,r>>12&63|128),e.push(r>>6&63|128)),e.push(63&r|128))}}this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length),n=0;for(var o=this.space,a=this.bb.bytes();n<e.length;n++)a[o++]=e[n];return this.endVector()},r.Builder.prototype.createLong=function(t,e){return r.Long.create(t,e)},r.ByteBuffer=function(t){this.bytes_=t,this.position_=0},r.ByteBuffer.allocate=function(t){return new r.ByteBuffer(new Uint8Array(t))},r.ByteBuffer.prototype.clear=function(){this.position_=0},r.ByteBuffer.prototype.bytes=function(){return this.bytes_},r.ByteBuffer.prototype.position=function(){return this.position_},r.ByteBuffer.prototype.setPosition=function(t){this.position_=t},r.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},r.ByteBuffer.prototype.readInt8=function(t){return this.readUint8(t)<<24>>24},r.ByteBuffer.prototype.readUint8=function(t){return this.bytes_[t]},r.ByteBuffer.prototype.readInt16=function(t){return this.readUint16(t)<<16>>16},r.ByteBuffer.prototype.readUint16=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8},r.ByteBuffer.prototype.readInt32=function(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24},r.ByteBuffer.prototype.readUint32=function(t){return this.readInt32(t)>>>0},r.ByteBuffer.prototype.readInt64=function(t){return new r.Long(this.readInt32(t),this.readInt32(t+4))},r.ByteBuffer.prototype.readUint64=function(t){return new r.Long(this.readUint32(t),this.readUint32(t+4))},r.ByteBuffer.prototype.readFloat32=function(t){return r.int32[0]=this.readInt32(t),r.float32[0]},r.ByteBuffer.prototype.readFloat64=function(t){return r.int32[r.isLittleEndian?0:1]=this.readInt32(t),r.int32[r.isLittleEndian?1:0]=this.readInt32(t+4),r.float64[0]},r.ByteBuffer.prototype.writeInt8=function(t,e){this.bytes_[t]=e},r.ByteBuffer.prototype.writeUint8=function(t,e){this.bytes_[t]=e},r.ByteBuffer.prototype.writeInt16=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8},r.ByteBuffer.prototype.writeUint16=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8},r.ByteBuffer.prototype.writeInt32=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24},r.ByteBuffer.prototype.writeUint32=function(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24},r.ByteBuffer.prototype.writeInt64=function(t,e){this.writeInt32(t,e.low),this.writeInt32(t+4,e.high)},r.ByteBuffer.prototype.writeUint64=function(t,e){this.writeUint32(t,e.low),this.writeUint32(t+4,e.high)},r.ByteBuffer.prototype.writeFloat32=function(t,e){r.float32[0]=e,this.writeInt32(t,r.int32[0])},r.ByteBuffer.prototype.writeFloat64=function(t,e){r.float64[0]=e,this.writeInt32(t,r.int32[r.isLittleEndian?0:1]),this.writeInt32(t+4,r.int32[r.isLittleEndian?1:0])},r.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var t="",e=0;e<r.FILE_IDENTIFIER_LENGTH;e++)t+=String.fromCharCode(this.readInt8(this.position_+r.SIZEOF_INT+e));return t},r.ByteBuffer.prototype.__offset=function(t,e){var n=t-this.readInt32(t);return e<this.readInt16(n)?this.readInt16(n+e):0},r.ByteBuffer.prototype.__union=function(t,e){return t.bb_pos=e+this.readInt32(e),t.bb=this,t},r.ByteBuffer.prototype.__string=function(t,e){t+=this.readInt32(t);var n=this.readInt32(t),i="",o=0;if(t+=r.SIZEOF_INT,e===r.Encoding.UTF8_BYTES)return this.bytes_.subarray(t,t+n);for(;o<n;){var a,s=this.readUint8(t+o++);if(s<192)a=s;else{var u=this.readUint8(t+o++);if(s<224)a=(31&s)<<6|63&u;else{var c=this.readUint8(t+o++);a=s<240?(15&s)<<12|(63&u)<<6|63&c:(7&s)<<18|(63&u)<<12|(63&c)<<6|63&this.readUint8(t+o++)}}a<65536?i+=String.fromCharCode(a):(a-=65536,i+=String.fromCharCode(55296+(a>>10),56320+(1023&a)))}return i},r.ByteBuffer.prototype.__indirect=function(t){return t+this.readInt32(t)},r.ByteBuffer.prototype.__vector=function(t){return t+this.readInt32(t)+r.SIZEOF_INT},r.ByteBuffer.prototype.__vector_len=function(t){return this.readInt32(t+this.readInt32(t))},r.ByteBuffer.prototype.__has_identifier=function(t){if(t.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var e=0;e<r.FILE_IDENTIFIER_LENGTH;e++)if(t.charCodeAt(e)!=this.readInt8(this.position_+r.SIZEOF_INT+e))return!1;return!0},r.ByteBuffer.prototype.createLong=function(t,e){return r.Long.create(t,e)}}},__webpack_module_cache__={};function __nested_webpack_require_546802__(t){var e=__webpack_module_cache__[t];if(void 0!==e)return e.exports;var n=__webpack_module_cache__[t]={exports:{}};return __webpack_modules__[t].call(n.exports,n,n.exports,__nested_webpack_require_546802__),n.exports}__nested_webpack_require_546802__.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return __nested_webpack_require_546802__.d(e,{a:e}),e},__nested_webpack_require_546802__.d=(t,e)=>{for(var n in e)__nested_webpack_require_546802__.o(e,n)&&!__nested_webpack_require_546802__.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},__nested_webpack_require_546802__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),__nested_webpack_require_546802__.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),__nested_webpack_require_546802__.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var __nested_webpack_exports__=__nested_webpack_require_546802__(6018);return __nested_webpack_exports__})()));
//# sourceMappingURL=ort-web.min.js.map

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(/*! is-arguments */ "./node_modules/is-arguments/index.js");
var isGeneratorFunction = __webpack_require__(/*! is-generator-function */ "./node_modules/is-generator-function/index.js");
var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");
var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/is-typed-array/index.js");

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});


/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(/*! ./support/types */ "./node_modules/util/support/types.js");

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;


/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! for-each */ "./node_modules/for-each/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/available-typed-arrays/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var cache = { __proto__: null };
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			cache['$' + typedArray] = callBind(descriptor.get);
		}
	});
} else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		cache['$' + typedArray] = callBind(arr.slice);
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var found = false;
	forEach(cache, function (getter, typedArray) {
		if (!found) {
			try {
				if ('$' + getter(value) === typedArray) {
					found = $slice(typedArray, 1);
				}
			} catch (e) { /**/ }
		}
	});
	return found;
};

var trySlices = function tryAllSlices(value) {
	var found = false;
	forEach(cache, function (getter, name) {
		if (!found) {
			try {
				getter(value);
				found = $slice(name, 1);
			} catch (e) { /**/ }
		}
	});
	return found;
};

module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag) {
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		}
		if (tag !== 'Object') {
			return false;
		}
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	}
	if (!gOPD) { return null; } // unknown engine
	return tryTypedArrays(value);
};


/***/ }),

/***/ "?2ca1":
/*!**********************************!*\
  !*** onnxruntime-node (ignored) ***!
  \**********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?0a40":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?61c2":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?0740":
/*!***********************!*\
  !*** sharp (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?66bb":
/*!****************************!*\
  !*** stream/web (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?0a9a":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?73ea":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?845f":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};


/***/ }),

/***/ "./node_modules/@xenova/transformers/src/backends/onnx.js":
/*!****************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/backends/onnx.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
var onnxruntime_node__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
var onnxruntime_web__WEBPACK_IMPORTED_MODULE_1___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ONNX: () => (/* binding */ ONNX),
/* harmony export */   executionProviders: () => (/* binding */ executionProviders)
/* harmony export */ });
/* harmony import */ var onnxruntime_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! onnxruntime-node */ "?2ca1");
/* harmony import */ var onnxruntime_web__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! onnxruntime-web */ "./node_modules/onnxruntime-web/dist/ort-web.min.js");
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/**
 * @file Handler file for choosing the correct version of ONNX Runtime, based on the environment.
 * Ideally, we could import the `onnxruntime-web` and `onnxruntime-node` packages only when needed,
 * but dynamic imports don't seem to work with the current webpack version and/or configuration.
 * This is possibly due to the experimental nature of top-level await statements.
 * So, we just import both packages, and use the appropriate one based on the environment:
 *   - When running in node, we use `onnxruntime-node`.
 *   - When running in the browser, we use `onnxruntime-web` (`onnxruntime-node` is not bundled).
 * 
 * This module is not directly exported, but can be accessed through the environment variables:
 * ```javascript
 * import { env } from '@xenova/transformers';
 * console.log(env.backends.onnx);
 * ```
 * 
 * @module backends/onnx
 */

// NOTE: Import order matters here. We need to import `onnxruntime-node` before `onnxruntime-web`.
// In either case, we select the default export if it exists, otherwise we use the named export.



/** @type {module} The ONNX runtime module. */
let ONNX;

const executionProviders = [
    // 'webgpu',
    'wasm'
];

if (typeof process !== 'undefined' && process?.release?.name === 'node') {
    // Running in a node-like environment.
    ONNX = onnxruntime_node__WEBPACK_IMPORTED_MODULE_0__ ?? /*#__PURE__*/ (onnxruntime_node__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (onnxruntime_node__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(onnxruntime_node__WEBPACK_IMPORTED_MODULE_0__, 2)));

    // Add `cpu` execution provider, with higher precedence that `wasm`.
    executionProviders.unshift('cpu');

} else {
    // Running in a browser-environment
    ONNX = onnxruntime_web__WEBPACK_IMPORTED_MODULE_1__ ?? /*#__PURE__*/ (onnxruntime_web__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (onnxruntime_web__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(onnxruntime_web__WEBPACK_IMPORTED_MODULE_1__, 2)));

    // SIMD for WebAssembly does not operate correctly in some recent versions of iOS (16.4.x).
    // As a temporary fix, we disable it for now.
    // For more information, see: https://github.com/microsoft/onnxruntime/issues/15644
    const isIOS = typeof navigator !== 'undefined' && /iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent);
    if (isIOS) {
        ONNX.env.wasm.simd = false;
    }
}


/***/ }),

/***/ "./node_modules/@xenova/transformers/src/configs.js":
/*!**********************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/configs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutoConfig: () => (/* binding */ AutoConfig),
/* harmony export */   PretrainedConfig: () => (/* binding */ PretrainedConfig)
/* harmony export */ });
/* harmony import */ var _utils_hub_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/hub.js */ "./node_modules/@xenova/transformers/src/utils/hub.js");

/**
 * @file Helper module for using model configs. For more information, see the corresponding
 * [Python documentation](https://huggingface.co/docs/transformers/main/en/model_doc/auto#transformers.AutoConfig).
 * 
 * **Example:** Load an `AutoConfig`.
 * 
 * ```javascript
 * import { AutoConfig } from '@xenova/transformers';
 * let config = await AutoConfig.from_pretrained('bert-base-uncased');
 * console.log(config);
 * // PretrainedConfig {
 * //   "model_type": "bert",
 * //   "is_encoder_decoder": false,
 * //   "architectures": [
 * //       "BertForMaskedLM"
 * //   ],
 * //   "vocab_size": 30522
 * //   "num_attention_heads": 12,
 * //   "num_hidden_layers": 12,
 * //   "hidden_size": 768,
 * //   "max_position_embeddings": 512,
 * //   ...
 * // }
 * ```
 * 
 * @module configs
 */



/**
 * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions
 */


/**
 * Loads a config from the specified path.
 * @param {string} pretrained_model_name_or_path The path to the config directory.
 * @param {PretrainedOptions} options Additional options for loading the config.
 * @returns {Promise<Array>} A promise that resolves with information about the loaded config.
 */
async function loadConfig(pretrained_model_name_or_path, options) {
    let info = await (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_0__.getModelJSON)(pretrained_model_name_or_path, 'config.json', true, options);
    return info;
}

/**
 * Base class for all configuration classes. For more information, see the corresponding
 * [Python documentation](https://huggingface.co/docs/transformers/main/en/main_classes/configuration#transformers.PretrainedConfig).
 */
class PretrainedConfig {
    // NOTE: Typo in original

    /**
     * Create a new PreTrainedTokenizer instance.
     * @param {Object} configJSON The JSON of the config.
     */
    constructor(configJSON) {
        this.model_type = null;
        this.is_encoder_decoder = false;

        Object.assign(this, configJSON);
    }

    /**
     * Loads a pre-trained config from the given `pretrained_model_name_or_path`. 
     * 
     * @param {string} pretrained_model_name_or_path The path to the pre-trained config.
     * @param {PretrainedOptions} options Additional options for loading the config.
     * @throws {Error} Throws an error if the config.json is not found in the `pretrained_model_name_or_path`.
     * 
     * @returns {Promise<PretrainedConfig>} A new instance of the `PretrainedConfig` class.
     */
    static async from_pretrained(pretrained_model_name_or_path, {
        progress_callback = null,
        config = null,
        cache_dir = null,
        local_files_only = false,
        revision = 'main',
    } = {}) {

        let data = config ?? await loadConfig(pretrained_model_name_or_path, {
            progress_callback,
            config,
            cache_dir,
            local_files_only,
            revision,
        })
        return new this(data);
    }
}

/**
 * Helper class which is used to instantiate pretrained configs with the `from_pretrained` function.
 * 
 * @example
 * let config = await AutoConfig.from_pretrained('bert-base-uncased'); 
 */
class AutoConfig {
    /** @type {PretrainedConfig.from_pretrained} */
    static async from_pretrained(...args) {
        return PretrainedConfig.from_pretrained(...args);
    }
}


/***/ }),

/***/ "./node_modules/@xenova/transformers/src/env.js":
/*!******************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/env.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   env: () => (/* binding */ env)
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "?0a9a");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "?73ea");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ "?845f");
/* harmony import */ var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./backends/onnx.js */ "./node_modules/@xenova/transformers/src/backends/onnx.js");
/**
 * @file Module used to configure Transformers.js.
 * 
 * **Example:** Disable remote models.
 * ```javascript
 * import { env } from '@xenova/transformers';
 * env.allowRemoteModels = false;
 * ```
 * 
 * **Example:** Set local model path.
 * ```javascript
 * import { env } from '@xenova/transformers';
 * env.localModelPath = '/path/to/local/models/';
 * ```
 * 
 * **Example:** Set cache directory.
 * ```javascript
 * import { env } from '@xenova/transformers';
 * env.cacheDir = '/path/to/cache/directory/';
 * ```
 * 
 * @module env
 */






const { env: onnx_env } = _backends_onnx_js__WEBPACK_IMPORTED_MODULE_3__.ONNX;

const VERSION = '2.5.0';

// Check if various APIs are available (depends on environment)
const WEB_CACHE_AVAILABLE = typeof self !== 'undefined' && 'caches' in self;
const FS_AVAILABLE = !isEmpty(fs__WEBPACK_IMPORTED_MODULE_0__); // check if file system is available
const PATH_AVAILABLE = !isEmpty(path__WEBPACK_IMPORTED_MODULE_1__); // check if path is available

const RUNNING_LOCALLY = FS_AVAILABLE && PATH_AVAILABLE;

const __dirname = RUNNING_LOCALLY
    ? path__WEBPACK_IMPORTED_MODULE_1__.dirname(path__WEBPACK_IMPORTED_MODULE_1__.dirname(url__WEBPACK_IMPORTED_MODULE_2__.fileURLToPath("file:///mnt/c/Users/dome/Downloads/SemanticFinder/extension/node_modules/@xenova/transformers/src/env.js")))
    : './';

// Only used for environments with access to file system
const DEFAULT_CACHE_DIR = RUNNING_LOCALLY
    ? path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, '/.cache/')
    : null;

// Set local model path, based on available APIs
const DEFAULT_LOCAL_MODEL_PATH = '/models/';
const localModelPath = RUNNING_LOCALLY
    ? path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, DEFAULT_LOCAL_MODEL_PATH)
    : DEFAULT_LOCAL_MODEL_PATH;

// Set path to wasm files. This is needed when running in a web worker.
// https://onnxruntime.ai/docs/api/js/interfaces/Env.WebAssemblyFlags.html#wasmPaths
// We use remote wasm files by default to make it easier for newer users.
// In practice, users should probably self-host the necessary .wasm files.
onnx_env.wasm.wasmPaths = RUNNING_LOCALLY
    ? path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, '/dist/')
    : `https://cdn.jsdelivr.net/npm/@xenova/transformers@${VERSION}/dist/`;


/**
 * Global variable used to control execution. This provides users a simple way to configure Transformers.js.
 * @property {Object} backends Expose environment variables of different backends,
 * allowing users to set these variables if they want to.
 * @property {string} __dirname Directory name of module. Useful for resolving local paths.
 * @property {string} version This version of Transformers.js.
 * @property {boolean} allowRemoteModels Whether to allow loading of remote files, defaults to `true`.
 * If set to `false`, it will have the same effect as setting `local_files_only=true` when loading pipelines, models, tokenizers, processors, etc.
 * @property {string} remoteHost Host URL to load models from. Defaults to the Hugging Face Hub.
 * @property {string} remotePathTemplate Path template to fill in and append to `remoteHost` when loading models.
 * @property {boolean} allowLocalModels Whether to allow loading of local files, defaults to `true`.
 * If set to `false`, it will skip the local file check and try to load the model from the remote host.
 * @property {string} localModelPath Path to load local models from. Defaults to `/models/`.
 * @property {boolean} useFS Whether to use the file system to load files. By default, it is `true` if available.
 * @property {boolean} useBrowserCache Whether to use Cache API to cache models. By default, it is `true` if available.
 * @property {boolean} useFSCache Whether to use the file system to cache files. By default, it is `true` if available.
 * @property {string} cacheDir The directory to use for caching files with the file system. By default, it is `./.cache`.
 * @property {boolean} useCustomCache Whether to use a custom cache system (defined by `customCache`), defaults to `false`.
 * @property {Object} customCache The custom cache to use. Defaults to `null`. Note: this must be an object which
 * implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache
 */
const env = {
    /////////////////// Backends settings ///////////////////
    backends: {
        // onnxruntime-web/onnxruntime-node
        onnx: onnx_env,

        // TensorFlow.js
        tfjs: {},
    },

    __dirname,
    version: VERSION,

    /////////////////// Model settings ///////////////////
    allowRemoteModels: true,
    remoteHost: 'https://huggingface.co/',
    remotePathTemplate: '{model}/resolve/{revision}/',

    allowLocalModels: true,
    localModelPath: localModelPath,
    useFS: FS_AVAILABLE,

    /////////////////// Cache settings ///////////////////
    useBrowserCache: WEB_CACHE_AVAILABLE,

    useFSCache: FS_AVAILABLE,
    cacheDir: DEFAULT_CACHE_DIR,

    useCustomCache: false,
    customCache: null,
    //////////////////////////////////////////////////////
}


/**
 * @param {Object} obj
 * @private
 */
function isEmpty(obj) {
    return Object.keys(obj).length === 0;
}



/***/ }),

/***/ "./node_modules/@xenova/transformers/src/models.js":
/*!*********************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/models.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AlbertForMaskedLM: () => (/* binding */ AlbertForMaskedLM),
/* harmony export */   AlbertForQuestionAnswering: () => (/* binding */ AlbertForQuestionAnswering),
/* harmony export */   AlbertForSequenceClassification: () => (/* binding */ AlbertForSequenceClassification),
/* harmony export */   AlbertModel: () => (/* binding */ AlbertModel),
/* harmony export */   AlbertPreTrainedModel: () => (/* binding */ AlbertPreTrainedModel),
/* harmony export */   AutoModel: () => (/* binding */ AutoModel),
/* harmony export */   AutoModelForCausalLM: () => (/* binding */ AutoModelForCausalLM),
/* harmony export */   AutoModelForImageClassification: () => (/* binding */ AutoModelForImageClassification),
/* harmony export */   AutoModelForImageSegmentation: () => (/* binding */ AutoModelForImageSegmentation),
/* harmony export */   AutoModelForMaskGeneration: () => (/* binding */ AutoModelForMaskGeneration),
/* harmony export */   AutoModelForMaskedLM: () => (/* binding */ AutoModelForMaskedLM),
/* harmony export */   AutoModelForObjectDetection: () => (/* binding */ AutoModelForObjectDetection),
/* harmony export */   AutoModelForQuestionAnswering: () => (/* binding */ AutoModelForQuestionAnswering),
/* harmony export */   AutoModelForSeq2SeqLM: () => (/* binding */ AutoModelForSeq2SeqLM),
/* harmony export */   AutoModelForSequenceClassification: () => (/* binding */ AutoModelForSequenceClassification),
/* harmony export */   AutoModelForTokenClassification: () => (/* binding */ AutoModelForTokenClassification),
/* harmony export */   AutoModelForVision2Seq: () => (/* binding */ AutoModelForVision2Seq),
/* harmony export */   BartForConditionalGeneration: () => (/* binding */ BartForConditionalGeneration),
/* harmony export */   BartForSequenceClassification: () => (/* binding */ BartForSequenceClassification),
/* harmony export */   BartModel: () => (/* binding */ BartModel),
/* harmony export */   BartPretrainedModel: () => (/* binding */ BartPretrainedModel),
/* harmony export */   BaseModelOutput: () => (/* binding */ BaseModelOutput),
/* harmony export */   BertForMaskedLM: () => (/* binding */ BertForMaskedLM),
/* harmony export */   BertForQuestionAnswering: () => (/* binding */ BertForQuestionAnswering),
/* harmony export */   BertForSequenceClassification: () => (/* binding */ BertForSequenceClassification),
/* harmony export */   BertForTokenClassification: () => (/* binding */ BertForTokenClassification),
/* harmony export */   BertModel: () => (/* binding */ BertModel),
/* harmony export */   BertPreTrainedModel: () => (/* binding */ BertPreTrainedModel),
/* harmony export */   CLIPModel: () => (/* binding */ CLIPModel),
/* harmony export */   CLIPPreTrainedModel: () => (/* binding */ CLIPPreTrainedModel),
/* harmony export */   CLIPTextModelWithProjection: () => (/* binding */ CLIPTextModelWithProjection),
/* harmony export */   CLIPVisionModelWithProjection: () => (/* binding */ CLIPVisionModelWithProjection),
/* harmony export */   CausalLMOutputWithPast: () => (/* binding */ CausalLMOutputWithPast),
/* harmony export */   CodeGenForCausalLM: () => (/* binding */ CodeGenForCausalLM),
/* harmony export */   CodeGenModel: () => (/* binding */ CodeGenModel),
/* harmony export */   CodeGenPreTrainedModel: () => (/* binding */ CodeGenPreTrainedModel),
/* harmony export */   DetrForObjectDetection: () => (/* binding */ DetrForObjectDetection),
/* harmony export */   DetrForSegmentation: () => (/* binding */ DetrForSegmentation),
/* harmony export */   DetrObjectDetectionOutput: () => (/* binding */ DetrObjectDetectionOutput),
/* harmony export */   DetrPreTrainedModel: () => (/* binding */ DetrPreTrainedModel),
/* harmony export */   DetrSegmentationOutput: () => (/* binding */ DetrSegmentationOutput),
/* harmony export */   DistilBertForMaskedLM: () => (/* binding */ DistilBertForMaskedLM),
/* harmony export */   DistilBertForQuestionAnswering: () => (/* binding */ DistilBertForQuestionAnswering),
/* harmony export */   DistilBertForSequenceClassification: () => (/* binding */ DistilBertForSequenceClassification),
/* harmony export */   DistilBertForTokenClassification: () => (/* binding */ DistilBertForTokenClassification),
/* harmony export */   DistilBertModel: () => (/* binding */ DistilBertModel),
/* harmony export */   DistilBertPreTrainedModel: () => (/* binding */ DistilBertPreTrainedModel),
/* harmony export */   GPT2LMHeadModel: () => (/* binding */ GPT2LMHeadModel),
/* harmony export */   GPT2Model: () => (/* binding */ GPT2Model),
/* harmony export */   GPT2PreTrainedModel: () => (/* binding */ GPT2PreTrainedModel),
/* harmony export */   GPTBigCodeForCausalLM: () => (/* binding */ GPTBigCodeForCausalLM),
/* harmony export */   GPTBigCodeModel: () => (/* binding */ GPTBigCodeModel),
/* harmony export */   GPTBigCodePreTrainedModel: () => (/* binding */ GPTBigCodePreTrainedModel),
/* harmony export */   GPTNeoForCausalLM: () => (/* binding */ GPTNeoForCausalLM),
/* harmony export */   GPTNeoModel: () => (/* binding */ GPTNeoModel),
/* harmony export */   GPTNeoPreTrainedModel: () => (/* binding */ GPTNeoPreTrainedModel),
/* harmony export */   M2M100ForConditionalGeneration: () => (/* binding */ M2M100ForConditionalGeneration),
/* harmony export */   M2M100Model: () => (/* binding */ M2M100Model),
/* harmony export */   M2M100PreTrainedModel: () => (/* binding */ M2M100PreTrainedModel),
/* harmony export */   MPNetForMaskedLM: () => (/* binding */ MPNetForMaskedLM),
/* harmony export */   MPNetForQuestionAnswering: () => (/* binding */ MPNetForQuestionAnswering),
/* harmony export */   MPNetForSequenceClassification: () => (/* binding */ MPNetForSequenceClassification),
/* harmony export */   MPNetForTokenClassification: () => (/* binding */ MPNetForTokenClassification),
/* harmony export */   MPNetModel: () => (/* binding */ MPNetModel),
/* harmony export */   MPNetPreTrainedModel: () => (/* binding */ MPNetPreTrainedModel),
/* harmony export */   MT5ForConditionalGeneration: () => (/* binding */ MT5ForConditionalGeneration),
/* harmony export */   MT5Model: () => (/* binding */ MT5Model),
/* harmony export */   MT5PreTrainedModel: () => (/* binding */ MT5PreTrainedModel),
/* harmony export */   MarianMTModel: () => (/* binding */ MarianMTModel),
/* harmony export */   MarianModel: () => (/* binding */ MarianModel),
/* harmony export */   MarianPreTrainedModel: () => (/* binding */ MarianPreTrainedModel),
/* harmony export */   MaskedLMOutput: () => (/* binding */ MaskedLMOutput),
/* harmony export */   MobileBertForMaskedLM: () => (/* binding */ MobileBertForMaskedLM),
/* harmony export */   MobileBertForQuestionAnswering: () => (/* binding */ MobileBertForQuestionAnswering),
/* harmony export */   MobileBertForSequenceClassification: () => (/* binding */ MobileBertForSequenceClassification),
/* harmony export */   MobileBertModel: () => (/* binding */ MobileBertModel),
/* harmony export */   MobileBertPreTrainedModel: () => (/* binding */ MobileBertPreTrainedModel),
/* harmony export */   MobileViTForImageClassification: () => (/* binding */ MobileViTForImageClassification),
/* harmony export */   MobileViTPreTrainedModel: () => (/* binding */ MobileViTPreTrainedModel),
/* harmony export */   ModelOutput: () => (/* binding */ ModelOutput),
/* harmony export */   PreTrainedModel: () => (/* binding */ PreTrainedModel),
/* harmony export */   PretrainedMixin: () => (/* binding */ PretrainedMixin),
/* harmony export */   QuestionAnsweringModelOutput: () => (/* binding */ QuestionAnsweringModelOutput),
/* harmony export */   RobertaForMaskedLM: () => (/* binding */ RobertaForMaskedLM),
/* harmony export */   RobertaForQuestionAnswering: () => (/* binding */ RobertaForQuestionAnswering),
/* harmony export */   RobertaForSequenceClassification: () => (/* binding */ RobertaForSequenceClassification),
/* harmony export */   RobertaForTokenClassification: () => (/* binding */ RobertaForTokenClassification),
/* harmony export */   RobertaModel: () => (/* binding */ RobertaModel),
/* harmony export */   RobertaPreTrainedModel: () => (/* binding */ RobertaPreTrainedModel),
/* harmony export */   SamImageSegmentationOutput: () => (/* binding */ SamImageSegmentationOutput),
/* harmony export */   SamModel: () => (/* binding */ SamModel),
/* harmony export */   SamPreTrainedModel: () => (/* binding */ SamPreTrainedModel),
/* harmony export */   Seq2SeqLMOutput: () => (/* binding */ Seq2SeqLMOutput),
/* harmony export */   SequenceClassifierOutput: () => (/* binding */ SequenceClassifierOutput),
/* harmony export */   SqueezeBertForMaskedLM: () => (/* binding */ SqueezeBertForMaskedLM),
/* harmony export */   SqueezeBertForQuestionAnswering: () => (/* binding */ SqueezeBertForQuestionAnswering),
/* harmony export */   SqueezeBertForSequenceClassification: () => (/* binding */ SqueezeBertForSequenceClassification),
/* harmony export */   SqueezeBertModel: () => (/* binding */ SqueezeBertModel),
/* harmony export */   SqueezeBertPreTrainedModel: () => (/* binding */ SqueezeBertPreTrainedModel),
/* harmony export */   T5ForConditionalGeneration: () => (/* binding */ T5ForConditionalGeneration),
/* harmony export */   T5Model: () => (/* binding */ T5Model),
/* harmony export */   T5PreTrainedModel: () => (/* binding */ T5PreTrainedModel),
/* harmony export */   TokenClassifierOutput: () => (/* binding */ TokenClassifierOutput),
/* harmony export */   ViTForImageClassification: () => (/* binding */ ViTForImageClassification),
/* harmony export */   ViTPreTrainedModel: () => (/* binding */ ViTPreTrainedModel),
/* harmony export */   VisionEncoderDecoderModel: () => (/* binding */ VisionEncoderDecoderModel),
/* harmony export */   WhisperForConditionalGeneration: () => (/* binding */ WhisperForConditionalGeneration),
/* harmony export */   WhisperModel: () => (/* binding */ WhisperModel),
/* harmony export */   WhisperPreTrainedModel: () => (/* binding */ WhisperPreTrainedModel),
/* harmony export */   XLMRobertaForMaskedLM: () => (/* binding */ XLMRobertaForMaskedLM),
/* harmony export */   XLMRobertaForQuestionAnswering: () => (/* binding */ XLMRobertaForQuestionAnswering),
/* harmony export */   XLMRobertaForSequenceClassification: () => (/* binding */ XLMRobertaForSequenceClassification),
/* harmony export */   XLMRobertaForTokenClassification: () => (/* binding */ XLMRobertaForTokenClassification),
/* harmony export */   XLMRobertaModel: () => (/* binding */ XLMRobertaModel),
/* harmony export */   XLMRobertaPreTrainedModel: () => (/* binding */ XLMRobertaPreTrainedModel)
/* harmony export */ });
/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./configs.js */ "./node_modules/@xenova/transformers/src/configs.js");
/* harmony import */ var _utils_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/core.js */ "./node_modules/@xenova/transformers/src/utils/core.js");
/* harmony import */ var _utils_hub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/hub.js */ "./node_modules/@xenova/transformers/src/utils/hub.js");
/* harmony import */ var _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/generation.js */ "./node_modules/@xenova/transformers/src/utils/generation.js");
/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/tensor.js */ "./node_modules/@xenova/transformers/src/utils/tensor.js");
/* harmony import */ var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./backends/onnx.js */ "./node_modules/@xenova/transformers/src/backends/onnx.js");
/* harmony import */ var _transformers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transformers.js */ "./node_modules/@xenova/transformers/src/transformers.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");

/**
 * @file Definitions of all models available in Transformers.js.
 * 
 * **Example:** Load and run an `AutoModel`.
 * 
 * ```javascript
 * import { AutoModel, AutoTokenizer } from '@xenova/transformers';
 *
 * let tokenizer = await AutoTokenizer.from_pretrained('Xenova/bert-base-uncased');
 * let model = await AutoModel.from_pretrained('Xenova/bert-base-uncased');
 *
 * let inputs = await tokenizer('I love transformers!');
 * let { logits } = await model(inputs);
 * // Tensor {
 * //     data: Float32Array(183132) [-7.117443084716797, -7.107812881469727, -7.092104911804199, ...]
 * //     dims: (3) [1, 6, 30522],
 * //     type: "float32",
 * //     size: 183132,
 * // }
 * ```
 * 
 * We also provide other `AutoModel`s (listed below), which you can use in the same way as the Python library. For example:
 * 
 * **Example:** Load and run a `AutoModelForSeq2SeqLM`.
 * ```javascript
 * import { AutoModelForSeq2SeqLM, AutoTokenizer } from '@xenova/transformers';
 * 
 * let tokenizer = await AutoTokenizer.from_pretrained('Xenova/t5-small');
 * let model = await AutoModelForSeq2SeqLM.from_pretrained('Xenova/t5-small');
 *
 * let { input_ids } = await tokenizer('translate English to German: I love transformers!');
 * let outputs = await model.generate(input_ids);
 * let decoded = tokenizer.decode(outputs[0], { skip_special_tokens: true });
 * // 'Ich liebe Transformatoren!'
 * ```
 * 
 * @module models
 */













const { InferenceSession, Tensor: ONNXTensor } = _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.ONNX;

/**
 * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions
 */


//////////////////////////////////////////////////
// Model types: used internally
class ModelType { };

// Either encoder-only or encoder-decoder (and will be decided by `model.config.is_encoder_decoder`)
class EncoderOnlyModelType extends ModelType { };
class EncoderDecoderModelType extends ModelType { };
class Seq2SeqModelType extends EncoderDecoderModelType { };
class DecoderOnlyModelType extends ModelType { };
//////////////////////////////////////////////////


//////////////////////////////////////////////////
// Helper functions

// Will be populated fully later
const MODEL_TYPE_MAPPING = new Map([
    ['CLIPTextModelWithProjection', EncoderOnlyModelType],
    ['CLIPVisionModelWithProjection', EncoderOnlyModelType],
]);

/**
 * Helper function to determine which `forward` method to run for a specific model.
 * @param {Object} self The calling object
 * @param {Object} model_inputs The inputs to be sent to the model
 * @returns {Promise<Object>} The model output
 */
async function forward(self, model_inputs) {
    if (MODEL_TYPE_MAPPING.get(self.constructor.name) === DecoderOnlyModelType) {
        return await decoderForward(self, model_inputs);
    } else {
        return await encoderForward(self, model_inputs);
    }
}

/**
 * Constructs an InferenceSession using a model file located at the specified path.
 * @param {string} pretrained_model_name_or_path The path to the directory containing the model file.
 * @param {string} fileName The name of the model file.
 * @param {PretrainedOptions} options Additional options for loading the model.
 * @returns {Promise<InferenceSession>} A Promise that resolves to an InferenceSession object.
 * @private
 */
async function constructSession(pretrained_model_name_or_path, fileName, options) {
    // TODO add option for user to force specify their desired execution provider
    let modelFileName = `onnx/${fileName}${options.quantized ? '_quantized' : ''}.onnx`;
    let buffer = await (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelFile)(pretrained_model_name_or_path, modelFileName, true, options);

    try {
        return await InferenceSession.create(buffer, {
            executionProviders: _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.executionProviders,
        });
    } catch (err) {
        // If the execution provided was only wasm, throw the error
        if (_backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.executionProviders.length === 1 && _backends_onnx_js__WEBPACK_IMPORTED_MODULE_5__.executionProviders[0] === 'wasm') {
            throw err;
        }

        console.warn(err);
        console.warn(
            'Something went wrong during model construction (most likely a missing operation). ' +
            'Using `wasm` as a fallback. '
        )
        return await InferenceSession.create(buffer, {
            executionProviders: ['wasm']
        });
    }
}

/**
 * Validate model inputs
 * @param {InferenceSession} session The InferenceSession object that will be run.
 * @param {Object} inputs The inputs to check.
 * @returns {Promise<Object>} A Promise that resolves to the checked inputs.
 * @throws {Error} If any inputs are missing.
 * @private
 */
async function validateInputs(session, inputs) {
    // NOTE: Only create a shallow copy
    const checkedInputs = {};
    const missingInputs = [];
    for (let inputName of session.inputNames) {
        if (inputs[inputName] === undefined) {
            missingInputs.push(inputName);
        } else {
            checkedInputs[inputName] = inputs[inputName];
        }
    }
    if (missingInputs.length > 0) {
        throw new Error(
            `An error occurred during model execution: "Missing the following inputs: ${missingInputs.join(', ')}.`);
    }

    const numInputsProvided = Object.keys(inputs).length;
    const numInputsNeeded = session.inputNames.length;
    if (numInputsProvided > numInputsNeeded) {
        // No missing inputs, but too many inputs were provided.
        // Warn the user and ignore the extra inputs.
        let ignored = Object.keys(inputs).filter(inputName => !session.inputNames.includes(inputName));
        console.warn(`WARNING: Too many inputs were provided (${numInputsProvided} > ${numInputsNeeded}). The following inputs will be ignored: "${ignored.join(', ')}".`);
    }

    return checkedInputs;
}

/**
 * Executes an InferenceSession using the specified inputs.
 * NOTE: `inputs` must contain at least the input names of the model.
 *  - If additional inputs are passed, they will be ignored.
 *  - If inputs are missing, an error will be thrown.
 * 
 * @param {InferenceSession} session The InferenceSession object to run.
 * @param {Object} inputs An object that maps input names to input tensors.
 * @returns {Promise<Object>} A Promise that resolves to an object that maps output names to output tensors.
 * @private
 */
async function sessionRun(session, inputs) {
    const checkedInputs = await validateInputs(session, inputs);
    try {
        let output = await session.run(checkedInputs);
        output = replaceTensors(output);
        return output;
    } catch (e) {
        // This usually occurs when the inputs are of the wrong type.
        console.error(`An error occurred during model execution: "${e}".`);
        console.error('Inputs given to model:', checkedInputs);
        throw e;
    }
}

/**
 * Replaces ONNX Tensor objects with custom Tensor objects to support additional functions.
 * @param {Object} obj The object to replace tensor objects in.
 * @returns {Object} The object with tensor objects replaced by custom Tensor objects.
 * @private
 */
function replaceTensors(obj) {
    for (let prop in obj) {
        if (obj[prop] instanceof ONNXTensor) {
            obj[prop] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(obj[prop]);
        } else if (typeof obj[prop] === 'object') {
            replaceTensors(obj[prop]);
        }
    }
    return obj;
}


/**
 * Converts an array or Tensor of integers to an int64 Tensor.
 * @param {Array|Tensor} items The input integers to be converted.
 * @returns {Tensor} The int64 Tensor with the converted values.
 * @throws {Error} If the input array is empty or the input is a batched Tensor and not all sequences have the same length.
 * @private
 */
function toI64Tensor(items) {
    if (items instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor) {
        return items;
    }
    // items is an array
    if (items.length === 0) {
        throw Error("items must be non-empty");
    }

    if (Array.isArray(items[0])) {
        // batched
        if (items.some(x => x.length !== items[0].length)) {
            throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.")
        }

        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('int64',
            BigInt64Array.from(items.flat().map(x => BigInt(x))),
            [items.length, items[0].length]
        );
    } else {
        //flat
        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('int64',
            BigInt64Array.from(items.map(x => BigInt(x))),
            [1, items.length]
        );
    }
}

/**
 * Prepares an attention mask for a sequence of tokens based on configuration options.
 * @param {Object} self The calling object instance.
 * @param {Tensor} tokens The input tokens.
 * @returns {Tensor} The attention mask tensor.
 * @private
 */
function prepareAttentionMask(self, tokens) {

    // Prepare attention mask
    let pad_token_id = self.config.pad_token_id ?? null;
    let eos_token_id = self.config.eos_token_id ?? null;
    if ((0,_utils_core_js__WEBPACK_IMPORTED_MODULE_1__.isIntegralNumber)(eos_token_id)) {
        eos_token_id = [eos_token_id];
    }

    let is_pad_token_in_inputs = tokens.indexOf(pad_token_id) !== -1;
    let is_pad_token_not_equal_to_eos_token_id = (eos_token_id === null) || !eos_token_id.includes(pad_token_id)

    if (is_pad_token_in_inputs && is_pad_token_not_equal_to_eos_token_id) {
        let data = BigInt64Array.from(
            // Note: != so that int matches bigint
            tokens.data.map(x => x != pad_token_id)
        )
        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('int64', data, tokens.dims)
    } else {
        return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(
            'int64',
            new BigInt64Array(tokens.data.length).fill(1n),
            tokens.dims
        )
    }
}

/**
 * Creates a boolean tensor with a single value.
 * @param {boolean} value The value of the tensor.
 * @returns {Tensor} The boolean tensor.
 * @private
 */
function boolTensor(value) {
    return new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('bool', [value], [1]);
}

// JS doesn't support mixins, so we define some reused functions here, and allow "this" to be passed in
/**
 * Perform forward pass on the seq2seq model (both encoder and decoder).
 * @param {Object} self The seq2seq model object.
 * @param {Object} model_inputs The input object for the model containing encoder and decoder inputs.
 * @param {Object} options The options
 * @param {boolean} [options.add_decoder_pkv=true] Flag to add the decoder past key values.
 * @returns {Promise<Seq2SeqLMOutput>} Promise that resolves with the output of the seq2seq model.
 * @private
 */
async function seq2seqForward(self, model_inputs, {
    add_decoder_pkv = true
} = {}) {
    let { encoder_outputs, past_key_values } = model_inputs;

    if (!encoder_outputs) {
        // Encoder outputs are not given, so we must compute them.
        encoder_outputs = (await encoderForward(self, model_inputs)).last_hidden_state;
    }
    let decoderFeeds = {
        input_ids: model_inputs.decoder_input_ids,
        encoder_hidden_states: encoder_outputs,
        use_cache_branch: boolTensor(!!past_key_values)
    };

    if (self.decoder_merged_session.inputNames.includes('encoder_attention_mask')) {
        decoderFeeds.encoder_attention_mask = model_inputs.attention_mask
    }
    self.addPastKeyValues(decoderFeeds, past_key_values, add_decoder_pkv);

    const decoderResults = await sessionRun(self.decoder_merged_session, decoderFeeds);
    let logits = decoderResults.logits;
    past_key_values = self.getPastKeyValues(decoderResults, past_key_values);

    // Get cross attention and/or decoder attentions if they are present
    const attns = self.getAttentions(decoderResults);

    return new Seq2SeqLMOutput({ logits, past_key_values, encoder_outputs, ...attns });
}

/**
 * Start the beam search process for the seq2seq model.
 * @param {Object} self The seq2seq model object.
 * @param {Object[]} inputTokenIds Array of input token ids for each input sequence.
 * @param {number} numOutputTokens The maximum number of output tokens for the model.
 * @param {boolean} [requires_attention_mask=true] Flag to indicate if the model requires an attention mask.
 * @returns {Object[]} Array of beam search objects.
 * @private
 */
function seq2seqStartBeams(self, inputTokenIds, numOutputTokens, requires_attention_mask = true) {
    let beams = [];
    let beamId = 0;

    // decoder_input_ids == output_token_ids
    let decoder_input_ids = self.config.decoder_start_token_id;
    if (!Array.isArray(decoder_input_ids)) {
        decoder_input_ids = [decoder_input_ids];
    }

    for (let tokens of inputTokenIds) {
        // TODO: Improve
        // Currently, just add back batch dimension.
        // In future, allow for true parallel execution
        tokens.dims = [1, ...tokens.dims]

        // Create beam
        let start = {
            inputs: tokens,
            encoder_outputs: null,
            prev_model_outputs: null,

            output_token_ids: decoder_input_ids,
            done: false,
            score: 0,
            id: beamId++ // assign unique id to beams
        }

        if (requires_attention_mask) {
            start.attention_mask = prepareAttentionMask(self, tokens);
        }

        beams.push(start);
    }

    return beams;
}

/**
 * Run beam search on the seq2seq model for a single beam.
 * @param {Object} self The seq2seq model object.
 * @param {Object} beam The beam search object for which to run the model.
 * @param {Object} options options
 * @param {string} [options.input_name='input_ids'] The name of the input tensor for the encoder.
 * @returns {Promise<Object>} Promise that resolves with the output of the seq2seq model for the given beam.
 * @private
 */
async function seq2seqRunBeam(self, beam, {
    input_name = 'input_ids',
} = {}
) {
    // 1. Prepare
    let model_inputs = {
        [input_name]: beam.inputs,
        decoder_input_ids: toI64Tensor(beam.output_token_ids.slice(-1)),
        encoder_outputs: beam.encoder_outputs,
        past_key_values: beam.prev_model_outputs?.past_key_values,
    }
    if (beam.attention_mask) {
        model_inputs.attention_mask = beam.attention_mask
    }

    // 2. Run
    let output = await self.forward(model_inputs);

    // 3. Update
    beam.prev_model_outputs = output;
    beam.encoder_outputs = output.encoder_outputs;

    return output;
}

/**
 * Forward pass of an encoder model.
 * @param {Object} self The encoder model.
 * @param {Object} model_inputs The input data to be used for the forward pass.
 * @returns {Promise<Object>} Promise that resolves with an object containing the model's outputs.
 * @private
 */
async function encoderForward(self, model_inputs) {
    let encoderFeeds = {};
    for (let key of self.session.inputNames) {
        encoderFeeds[key] = model_inputs[key];
    }
    return await sessionRun(self.session, encoderFeeds);
}


/**
 * Forward pass of a decoder model.
 * @param {Object} self The decoder model.
 * @param {Object} model_inputs The input data to be used for the forward pass.
 * @returns {Promise<Object>} Promise that resolves with an object containing the logits and past key values.
 * @private
 */
async function decoderForward(self, model_inputs) {
    let { input_ids, past_key_values, attention_mask } = model_inputs;
    let decoderFeeds = {
        input_ids: input_ids,
        attention_mask: attention_mask ?? prepareAttentionMask(self, input_ids),
        use_cache_branch: boolTensor(past_key_values !== null)
    }

    self.addPastKeyValues(decoderFeeds, past_key_values);

    let decoderResults = await sessionRun(self.session, decoderFeeds);

    let logits = decoderResults.logits;

    past_key_values = self.getPastKeyValues(decoderResults, past_key_values);
    return { logits, past_key_values };
}

/**
 * Starts the generation of text by initializing the beams for the given input token IDs.
 * @param {Object} self The text generation model object.
 * @param {any} inputTokenIds An array of input token IDs to generate text from.
 * @param {number} numOutputTokens The maximum number of tokens to generate for each beam.
 * @param {Tensor} [inputs_attention_mask] The attention mask tensor for the input token IDs.
 * @returns {Object[]} An array of beams initialized with the given inputs and parameters.
 * @private
 */
function decoderStartBeams(self, inputTokenIds, numOutputTokens, inputs_attention_mask) {
    let beams = [];

    let beamId = 0;
    for (let tokens of inputTokenIds) {
        let output_token_ids = tokens.tolist().map(Number);

        // TODO: Improve
        // Currently, just add back batch dimension.
        // In future, allow for true parallel execution
        tokens.dims = [1, ...tokens.dims]

        let attn_mask;
        if (inputs_attention_mask) {
            attn_mask = inputs_attention_mask[beamId];
            attn_mask.dims = [1, ...attn_mask.dims]

        } else {
            attn_mask = prepareAttentionMask(self, tokens)
        }

        let start = {
            input: tokens,
            model_input_ids: tokens,
            attention_mask: attn_mask,
            prev_model_outputs: null,

            output_token_ids: output_token_ids,
            num_output_tokens: numOutputTokens,

            done: false,
            score: 0,
            id: beamId++ // assign unique id to beams
        }

        beams.push(start);
    }
    return beams;
}

/**
 * Runs a single step of the text generation process for a given beam.
 *
 * @param {Object} self The decoder object.
 * @param {Object} beam The beam to run.
 * @param {Tensor} beam.input The input tensor.
 * @param {Tensor} beam.model_input_ids The input ids to the model.
 * @param {Tensor} beam.attention_mask The attention mask.
 * @param {Object} beam.prev_model_outputs The past key values.
 * @param {number[]} beam.output_token_ids The output token ids.
 * @returns {Promise<Object>} The output of the generation step.
 * @private
 */
async function decoderRunBeam(self, beam) {
    let attnMaskData = new BigInt64Array(beam.output_token_ids.length).fill(1n)

    // 1. Prepare
    let model_inputs = {
        input_ids: beam.model_input_ids,
        attention_mask: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(
            'int64',
            attnMaskData,
            [1, attnMaskData.length]
        ),
        past_key_values: beam.prev_model_outputs?.past_key_values,
    }

    // 2. Run
    let output = await self.forward(model_inputs);

    // 3. Update
    beam.prev_model_outputs = output;

    return output;
}

/**
 * Update a beam with a new token ID.
 * @param {Object} beam The beam to update.
 * @param {number} newTokenId The new token ID to add to the beam's output.
 * @private
 */
function decoderUpdatebeam(beam, newTokenId) {
    beam.output_token_ids = [...beam.output_token_ids, newTokenId];
    beam.model_input_ids = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('int64', [BigInt(newTokenId)], [1, 1]);
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
/**
 * A base class for pre-trained models that provides the model configuration and an ONNX session.
 * @extends Callable
 */
class PreTrainedModel extends _utils_core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {

    /**
     * Creates a new instance of the `PreTrainedModel` class.
     * @param {Object} config The model configuration.
     * @param {any} session session for the model.
     */
    constructor(config, session) {
        super();

        this.config = config;
        this.session = session;
    }

    /**
    * Disposes of all the ONNX sessions that were created during inference.
    * @returns {Promise<unknown[]>} An array of promises, one for each ONNX session that is being disposed.
    * @todo Use https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry
    */
    async dispose() {
        let promises = [];
        for (let key of Object.keys(this)) {
            let item = this[key];
            if (item instanceof InferenceSession) {
                promises.push(item.handler.dispose())
            }
        }
        return await Promise.all(promises);
    }

    /**
     * Instantiate one of the model classes of the library from a pretrained model.
     * 
     * The model class to instantiate is selected based on the `model_type` property of the config object
     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)
     * 
     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:
     * - A string, the *model id* of a pretrained model hosted inside a model repo on huggingface.co.
     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a
     *   user or organization name, like `dbmdz/bert-base-german-cased`.
     * - A path to a *directory* containing model weights, e.g., `./my_model_directory/`.
     * @param {PretrainedOptions} options Additional options for loading the model.
     * 
     * @returns {Promise<PreTrainedModel>} A new instance of the `PreTrainedModel` class.
     */
    static async from_pretrained(pretrained_model_name_or_path, {
        quantized = true,
        progress_callback = null,
        config = null,
        cache_dir = null,
        local_files_only = false,
        revision = 'main',
        model_file_name = null,
    } = {}) {

        let options = {
            quantized,
            progress_callback,
            config,
            cache_dir,
            local_files_only,
            revision,
            model_file_name,
        }

        let modelType = MODEL_TYPE_MAPPING.get(this.name);

        let info;
        if (modelType === DecoderOnlyModelType) {
            info = await Promise.all([
                _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
                constructSession(pretrained_model_name_or_path, options.model_file_name ?? 'decoder_model_merged', options),
            ]);

        } else if (modelType === Seq2SeqModelType) {
            info = await Promise.all([
                _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
                constructSession(pretrained_model_name_or_path, 'encoder_model', options),
                constructSession(pretrained_model_name_or_path, 'decoder_model_merged', options),
                (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_2__.getModelJSON)(pretrained_model_name_or_path, 'generation_config.json', false, options),
            ]);

        } else if (modelType === EncoderDecoderModelType) {
            info = await Promise.all([
                _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
                constructSession(pretrained_model_name_or_path, 'encoder_model', options),
                constructSession(pretrained_model_name_or_path, 'decoder_model_merged', options),
            ]);

        } else if (modelType === EncoderOnlyModelType) {
            info = await Promise.all([
                _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
                constructSession(pretrained_model_name_or_path, options.model_file_name ?? 'model', options)
            ]);

        } else {
            console.warn('Malformed class definition.', this);
            throw Error(`Unable to load model: ${pretrained_model_name_or_path}. Please report this bug at https://github.com/xenova/transformers.js/issues/new/choose.`);
        }

        // @ts-ignore
        return new this(...info);
    }

    /**
     * Runs the model with the provided inputs
     * @param {Object} model_inputs Object containing input tensors
     * @returns {Promise<Object>} Object containing output tensors
     */
    async _call(model_inputs) {
        return await this.forward(model_inputs);
    }

    /**
     * Forward method for a pretrained model. If not overridden by a subclass, the correct forward method
     * will be chosen based on the model type.
     * @param {Object} model_inputs The input data to the model in the format specified in the ONNX model.
     * @returns {Promise<Object>} The output data from the model in the format specified in the ONNX model.
     * @throws {Error} This method must be implemented in subclasses.
     */
    async forward(model_inputs) {
        return await forward(this, model_inputs);
    }

    /**
     * @param {GenerationConfig} generation_config 
     * @param {number} input_ids_seq_length The starting sequence length for the input ids.
     * @returns {LogitsProcessorList}
     */
    _get_logits_processor(
        generation_config,
        input_ids_seq_length,
        // encoder_input_ids, TODO
        // prefix_allowed_tokens_fn, TODO
        logits_processor = null
    ) {
        const processors = new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.LogitsProcessorList();

        // if (generation_config.diversity_penalty !== null && generation_config.diversity_penalty > 0.0) {
        //     processors.push(new HammingDiversityLogitsProcessor(
        //         generation_config.diversity_penalty,
        //         generation_config.num_beams,
        //         generation_config.num_beam_groups
        //     ));
        // }

        // if (generation_config.encoder_repetition_penalty !== null && generation_config.encoder_repetition_penalty !== 1.0) {
        //     processors.push(new EncoderRepetitionPenaltyLogitsProcessor(
        //         generation_config.encoder_repetition_penalty,
        //         encoder_input_ids
        //     ));
        // }

        if (generation_config.repetition_penalty !== null && generation_config.repetition_penalty !== 1.0) {
            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.RepetitionPenaltyLogitsProcessor(generation_config.repetition_penalty));
        }

        if (generation_config.no_repeat_ngram_size !== null && generation_config.no_repeat_ngram_size > 0) {
            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.NoRepeatNGramLogitsProcessor(generation_config.no_repeat_ngram_size));
        }

        // if (generation_config.encoder_no_repeat_ngram_size !== null && generation_config.encoder_no_repeat_ngram_size > 0) {
        //     if (this.config.is_encoder_decoder) {
        //         processors.push(new EncoderNoRepeatNGramLogitsProcessor(
        //             generation_config.encoder_no_repeat_ngram_size,
        //             encoder_input_ids
        //         ));
        //     } else {
        //         throw new Error("It's impossible to use `encoder_no_repeat_ngram_size` with decoder-only architecture");
        //     }
        // }

        // if (generation_config.bad_words_ids !== null) {
        //     processors.push(new NoBadWordsLogitsProcessor(generation_config.bad_words_ids, generation_config.eos_token_id));
        // }

        // if (generation_config.min_length !== null && generation_config.eos_token_id !== null && generation_config.min_length > 0) {
        //     processors.push(new MinLengthLogitsProcessor(generation_config.min_length, generation_config.eos_token_id));
        // }

        // if (generation_config.min_new_tokens !== null && generation_config.eos_token_id !== null && generation_config.min_new_tokens > 0) {
        //     processors.push(new MinNewTokensLengthLogitsProcessor(
        //         input_ids_seq_length,
        //         generation_config.min_new_tokens,
        //         generation_config.eos_token_id
        //     ));
        // }

        // if (prefix_allowed_tokens_fn !== null) {
        //     processors.push(new PrefixConstrainedLogitsProcessor(
        //         prefix_allowed_tokens_fn,
        //         generation_config.num_beams / generation_config.num_beam_groups
        //     ));
        // }


        if (generation_config.forced_bos_token_id !== null) {
            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.ForcedBOSTokenLogitsProcessor(generation_config.forced_bos_token_id));
        }

        if (generation_config.forced_eos_token_id !== null) {
            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.ForcedEOSTokenLogitsProcessor(
                generation_config.max_length,
                generation_config.forced_eos_token_id
            ));
        }

        // if (generation_config.remove_invalid_values === true) {
        //     processors.push(new InfNanRemoveLogitsProcessor());
        // }

        // if (generation_config.exponential_decay_length_penalty !== null) {
        //     processors.push(new ExponentialDecayLengthPenalty(
        //         generation_config.exponential_decay_length_penalty,
        //         generation_config.eos_token_id,
        //         input_ids_seq_length
        //     ));
        // }

        // if (generation_config.suppress_tokens !== null) {
        //     processors.push(new SuppressTokensLogitsProcessor(generation_config.suppress_tokens));
        // }

        if (generation_config.begin_suppress_tokens !== null) {
            let begin_index = (input_ids_seq_length > 1 || generation_config.forced_bos_token_id === null)
                ? input_ids_seq_length
                : input_ids_seq_length + 1;

            if (generation_config.forced_decoder_ids !== null) {
                // generation starts after the last token that is forced
                begin_index += generation_config.forced_decoder_ids[generation_config.forced_decoder_ids.length - 1][0];
            }
            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.SuppressTokensAtBeginLogitsProcessor(generation_config.begin_suppress_tokens, begin_index));
        }

        if (generation_config.forced_decoder_ids !== null) {
            processors.push(new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.ForceTokensLogitsProcessor(generation_config.forced_decoder_ids));
        }

        if (logits_processor !== null) {
            processors.extend(logits_processor)
        }

        // `LogitNormalization` should always be the last logit processor, when present
        // if (generation_config.renormalize_logits === true) {
        //     processors.push(new LogitNormalization());
        // }

        return processors;
    }

    /**
     * This function merges multiple generation configs together to form a final generation config to be used by the model for text generation.
     * It first creates an empty `GenerationConfig` object, then it applies the model's own `generation_config` property to it. Finally, if a `generation_config` object was passed in the arguments, it overwrites the corresponding properties in the final config with those of the passed config object.
     *
     * @param {GenerationConfig} generation_config A `GenerationConfig` object containing generation parameters.
     * @returns {GenerationConfig} The final generation config object to be used by the model for text generation.
     */
    _get_generation_config(generation_config) {
        // Create empty generation config (contains defaults)
        let gen_config = new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.GenerationConfig();

        // Apply model's generation config, if it exists
        if ('generation_config' in this) {
            Object.assign(gen_config, this.generation_config);
        }

        // Finally, use any generation config specified by the user
        // when calling `generate`
        if (generation_config !== null) {
            Object.assign(gen_config, generation_config);
        }
        return gen_config;
    }

    /**
     * @typedef {import('./utils/maths.js').TypedArray} TypedArray
     */

    /**
     * @typedef {{ sequences: Tensor, decoder_attentions: Tensor, cross_attentions: Tensor }} EncoderDecoderOutput
     * @typedef {Object} DecoderOutput
     * 
     * Generates text based on the given inputs and generation configuration using the model.
     * @param {Tensor|Array|TypedArray} inputs An array of input token IDs.
     * @param {Object|GenerationConfig|null} generation_config The generation configuration to use. If null, default configuration will be used.
     * @param {Object|null} logits_processor An optional logits processor to use. If null, a new LogitsProcessorList instance will be created.
     * @param {Object} options options
     * @param {Object} [options.inputs_attention_mask=null] An optional attention mask for the inputs.
     * @returns {Promise<number[][]|EncoderDecoderOutput|DecoderOutput>} An array of generated output sequences, where each sequence is an array of token IDs.
     * @throws {Error} Throws an error if the inputs array is empty.
     */
    async generate(
        inputs,
        generation_config = null,
        logits_processor = null,
        {
            inputs_attention_mask = null
        } = {},
    ) {

        if (!(inputs instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor) && !(0,_utils_core_js__WEBPACK_IMPORTED_MODULE_1__.isTypedArray)(inputs) && !Array.isArray(inputs)) {
            throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${inputs.constructor.name}".`);
        }

        let input_ids_seq_length;

        // Prepare `input_ids` which will be used for auto-regressive generation
        // TODO: Update to align with HF transformers' implementation
        if (this.config.is_encoder_decoder) {
            // Generating from the encoder outputs
            input_ids_seq_length = 0;

        } else {
            input_ids_seq_length = inputs instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor ? inputs.dims[0] : inputs.length;

            // decoder-only
            if (input_ids_seq_length === 0) {
                throw Error("Must supply a non-empty array of input token ids.")
            }
        }

        // Update generation config with defaults
        generation_config = this._get_generation_config(generation_config);

        logits_processor = logits_processor ?? new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.LogitsProcessorList()

        // Update logits processor
        logits_processor = this._get_logits_processor(
            generation_config,
            input_ids_seq_length,
            logits_processor
        )

        // TODO implement early_stopping
        // https://huggingface.co/blog/how-to-generate

        let numOutputTokens = 1;
        const maxOutputTokens = numOutputTokens + (generation_config.max_new_tokens ?? Infinity);

        // Only use max length if max_new_tokens is not provided
        const useMaxLength = Number.isInteger(generation_config.max_length) && (generation_config.max_new_tokens ?? null) === null;
        let sampler = _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.Sampler.getSampler(generation_config);

        // @ts-ignore
        let beams = this.getStartBeams(inputs, numOutputTokens, inputs_attention_mask);

        while (beams.some(x => !x.done) && numOutputTokens < maxOutputTokens) {
            let newest_beams = [];
            for (let beam of beams) {
                if (beam.done) {
                    // Add this beam back into the pool
                    newest_beams.push(beam);
                    continue
                }
                if (useMaxLength && beam.output_token_ids.length >= generation_config.max_length) {
                    // Set this beam to done and add it back into the pool
                    beam.done = true;
                    newest_beams.push(beam);
                    continue
                }

                // @ts-ignore
                let output = await this.runBeam(beam);

                // add attentions/scores to beam only if user requested
                if (generation_config.output_attentions) {
                    this.addAttentionsToBeam(beam, output);
                }
                if (generation_config.output_scores) {
                    // TODO add
                }

                // Logits are of the form [batch_size, out_seq_length, vocab_size]
                // In most cases, this will be [batch_size, 1, vocab_size]
                // So, we select the last token's logits:
                // (equivalent to `logits = outputs.logits[:, -1, :]`)
                let logits = output.logits.slice(null, -1, null);

                // Apply logits processor
                logits_processor(beam.output_token_ids, logits);

                let sampledTokens = sampler(logits);
                for (let [newTokenId, logProb] of sampledTokens) {
                    // use previous beam as a starting point
                    let newBeam = { ...beam };

                    // update new beam
                    // @ts-ignore
                    this.updateBeam(newBeam, newTokenId);

                    newBeam.score += logProb;

                    if (newTokenId === this.config.eos_token_id) {
                        newBeam.done = true;
                    }

                    newest_beams.push(newBeam);
                }
            }
            ++numOutputTokens;

            // Next, we get the best beams, per ID
            newest_beams = this.groupBeams(newest_beams).map(
                group => group
                    .sort((a, b) => b.score - a.score)      // sort by score
                    .slice(0, generation_config.num_beams)  // remove outside beam width
            );

            // Flatten beams
            beams = newest_beams.flat();

            // Run callback
            if (generation_config.callback_function) {
                generation_config.callback_function(beams);
            }
        }

        // TODO: Ensure that we can return non-batched outputs

        const groupedBeams = this.groupBeams(beams);

        const getFlattened = (key) => groupedBeams.map(
            batch => {
                if (generation_config.num_return_sequences > 1) {
                    return batch.slice(0, generation_config.num_return_sequences).map(x => x[key]);
                } else {
                    return [batch[0][key]];
                }
            }
        ).flat(); // Flatten across batches (depth=1)

        const sequences = getFlattened('output_token_ids'); // [1, seqLength]

        if (generation_config.return_dict_in_generate) {
            // NOTE: `decoder_attentions` and `cross_attentions` should be:
            //    list (one element for each generated token)
            //    of list (one element for each layer of the decoder)
            //    of torch.FloatTensor of shape (batch_size, num_heads, generated_length, sequence_length)
            // However, since we are only generating one batch at a time, they are of the form:
            //   list (batches)
            //   of list (one element for each generated token)
            //   of list (one element for each layer of the decoder)
            //   of torch.FloatTensor of shape (1, num_heads, generated_length, sequence_length)
            // 
            // TODO: In future (when true parallelism, we should be able to return the correct shape)

            const decoder_attentions = getFlattened('decoder_attentions');
            const cross_attentions = getFlattened('cross_attentions');

            return {
                sequences,

                decoder_attentions,
                cross_attentions,
            }
        } else {
            return sequences;
        }
    }

    /**
     * Helper function to add attentions to beam
     * @param {Object} beam 
     * @param {Object} output
     * @private 
     */
    addAttentionsToBeam(beam, output) {
        if (this.config.is_encoder_decoder) {
            if (!output.cross_attentions || output.cross_attentions.length === 0) {
                throw Error(
                    "`output_attentions` is true, but the model did not produce cross-attentions. " +
                    "This is most likely because the model was not exported with `output_attentions=True`."
                )
            }
            if (!beam.cross_attentions) {
                beam.cross_attentions = [];
            }
            beam.cross_attentions.push(output.cross_attentions);
        }

        if (!output.decoder_attentions || output.decoder_attentions.length === 0) {
            throw Error(
                "`output_attentions` is true, but the model did not produce decoder-attentions. " +
                "This is most likely because the model was not exported with `output_attentions=True`."
            )
        }
        if (!beam.decoder_attentions) {
            beam.decoder_attentions = [];
        }
        beam.decoder_attentions.push(output.decoder_attentions);
    }

    /**
     * Groups an array of beam objects by their ids.
     *
     * @param {Array} beams The array of beam objects to group.
     * @returns {Array} An array of arrays, where each inner array contains beam objects with the same id.
     */
    groupBeams(beams) {
        // Group beams by their ids
        const groups = Object.create(null);
        for (const obj of beams) {
            if (groups[obj.id] === undefined) {
                groups[obj.id] = [obj];
            } else {
                groups[obj.id].push(obj);
            }
        }

        return Object.values(groups);
    }

    /**
     * Returns an object containing past key values from the given decoder results object.
     *
     * @param {Object} decoderResults The decoder results object.
     * @param {Object} pastKeyValues The previous past key values.
     * @returns {Object} An object containing past key values.
     * @private
     */
    getPastKeyValues(decoderResults, pastKeyValues) {

        const pkvs = Object.create(null);

        for (const name in decoderResults) {
            if (name.startsWith('present')) {
                let newName = name.replace('present', 'past_key_values');

                if (pastKeyValues && name.includes('encoder')) {
                    // Optimization introduced by optimum to reuse past key values. So, we just replace the constant
                    // outputs with the previous past key values.
                    // https://github.com/huggingface/optimum/blob/0bf2c05fb7e1182b52d21b703cfc95fd9e4ea3dc/optimum/onnxruntime/base.py#L677-L704
                    pkvs[newName] = pastKeyValues[newName];
                } else {
                    pkvs[newName] = decoderResults[name];
                }
            }
        }
        return pkvs;
    }

    /**
     * Returns an object containing attentions from the given decoder results object.
     *
     * @param {Object} decoderResults The decoder results object.
     * @returns {Object} An object containing attentions.
     * @private
     */
    getAttentions(decoderResults) {
        const attns = Object.create(null);

        for (const attnName of ['cross_attentions', 'decoder_attentions']) {
            const result = [];
            for (const name in decoderResults) {
                if (name.startsWith(attnName)) {
                    const index = name.split('.').pop()
                    result[index] = decoderResults[name];
                }
            }
            attns[attnName] = result;
        }
        return attns;
    }

    /**
     * Adds past key values to the decoder feeds object. If pastKeyValues is null, creates new tensors for past key values.
     *
     * @param {Object} decoderFeeds The decoder feeds object to add past key values to.
     * @param {Object} pastKeyValues An object containing past key values.
     * @param {boolean} [hasDecoder=false] Whether the model has a decoder.
     */
    addPastKeyValues(decoderFeeds, pastKeyValues, hasDecoder = false) {
        if (pastKeyValues) {
            Object.assign(decoderFeeds, pastKeyValues)
        } else {
            // TODO support batches (i.e., batch_size > 1)
            if (hasDecoder) {
                // @ts-ignore
                let encoder_dims = [1, this.num_encoder_heads, 0, this.encoder_dim_kv];
                // @ts-ignore
                for (let i = 0; i < this.num_encoder_layers; ++i) {
                    decoderFeeds[`past_key_values.${i}.encoder.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], encoder_dims)
                    decoderFeeds[`past_key_values.${i}.encoder.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], encoder_dims)
                }

                // @ts-ignore
                let decoder_dims = [1, this.num_decoder_heads, 0, this.decoder_dim_kv];
                // @ts-ignore
                for (let i = 0; i < this.num_decoder_layers; ++i) {
                    decoderFeeds[`past_key_values.${i}.decoder.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], decoder_dims)
                    decoderFeeds[`past_key_values.${i}.decoder.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], decoder_dims)
                }

            } else {
                if (this.config.multi_query) {
                    // @ts-ignore
                    let dims = [1, 0, 2 * this.dim_kv]
                    // @ts-ignore
                    for (let i = 0; i < this.num_layers; ++i) {
                        decoderFeeds[`past_key_values.${i}.key_value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], dims)
                    }
                } else {
                    // @ts-ignore
                    let dims = [1, this.num_heads, 0, this.dim_kv]
                    // @ts-ignore
                    for (let i = 0; i < this.num_layers; ++i) {
                        decoderFeeds[`past_key_values.${i}.key`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], dims)
                        decoderFeeds[`past_key_values.${i}.value`] = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor('float32', [], dims)
                    }
                }
            }
        }
    }
}
//////////////////////////////////////////////////
// Base model output class
class ModelOutput { }

/**
 * Base class for model's outputs, with potential hidden states and attentions.
 */
class BaseModelOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.last_hidden_state Sequence of hidden-states at the output of the last layer of the model.
     * @param {Tensor} [output.hidden_states] Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.
     * @param {Tensor} [output.attentions] Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads.
     */
    constructor({ last_hidden_state, hidden_states = null, attentions = null }) {
        super();
        this.last_hidden_state = last_hidden_state;
        this.hidden_states = hidden_states;
        this.attentions = attentions;
    }
}
//////////////////////////////////////////////////
// Bert models
class BertPreTrainedModel extends PreTrainedModel { }
class BertModel extends BertPreTrainedModel { }

/**
 * BertForMaskedLM is a class representing a BERT model for masked language modeling.
 * @extends BertPreTrainedModel
 */
class BertForMaskedLM extends BertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */
    async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
    }
}

/**
 * BertForSequenceClassification is a class representing a BERT model for sequence classification.
 * @extends BertPreTrainedModel
 */
class BertForSequenceClassification extends BertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
    }
}

/**
 * BertForTokenClassification is a class representing a BERT model for token classification.
 * @extends BertPreTrainedModel
 */
class BertForTokenClassification extends BertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
    }
}

/**
 * BertForQuestionAnswering is a class representing a BERT model for question answering.
 * @extends BertPreTrainedModel
 */
class BertForQuestionAnswering extends BertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */
    async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
    }
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
// DistilBert models
class DistilBertPreTrainedModel extends PreTrainedModel { }
class DistilBertModel extends DistilBertPreTrainedModel { }

/**
 * DistilBertForSequenceClassification is a class representing a DistilBERT model for sequence classification.
 * @extends DistilBertPreTrainedModel
 */
class DistilBertForSequenceClassification extends DistilBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
    }
}

/**
 * DistilBertForTokenClassification is a class representing a DistilBERT model for token classification.
 * @extends DistilBertPreTrainedModel
 */
class DistilBertForTokenClassification extends DistilBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
    }
}


/**
 * DistilBertForQuestionAnswering is a class representing a DistilBERT model for question answering.
 * @extends DistilBertPreTrainedModel
 */
class DistilBertForQuestionAnswering extends DistilBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */
    async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
    }
}

/**
 * DistilBertForMaskedLM is a class representing a DistilBERT model for masking task.
 * @extends DistilBertPreTrainedModel
 */
class DistilBertForMaskedLM extends DistilBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
    }
}
//////////////////////////////////////////////////


//////////////////////////////////////////////////
// MobileBert models
class MobileBertPreTrainedModel extends PreTrainedModel { }
class MobileBertModel extends MobileBertPreTrainedModel { }

/**
 * MobileBertForMaskedLM is a class representing a MobileBERT model for masking task.
 * @extends MobileBertPreTrainedModel
 */
class MobileBertForMaskedLM extends MobileBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
    }
}

/**
 * @extends MobileBertPreTrainedModel
 */
class MobileBertForSequenceClassification extends MobileBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */
    async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
    }
}

/**
 * @extends MobileBertPreTrainedModel
 */
class MobileBertForQuestionAnswering extends MobileBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */
    async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
    }
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
// MPNet models
class MPNetPreTrainedModel extends PreTrainedModel { }

/**
 * The bare MPNet Model transformer outputting raw hidden-states without any specific head on top.
 * @extends MPNetPreTrainedModel
 */
class MPNetModel extends MPNetPreTrainedModel { }

/**
 * MPNetForMaskedLM is a class representing a MPNet model for masked language modeling.
 * @extends MPNetPreTrainedModel
 */
class MPNetForMaskedLM extends MPNetPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */
    async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
    }
}

/**
 * MPNetForSequenceClassification is a class representing a MPNet model for sequence classification.
 * @extends MPNetPreTrainedModel
 */
class MPNetForSequenceClassification extends MPNetPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
    }
}

/**
 * MPNetForTokenClassification is a class representing a MPNet model for token classification.
 * @extends MPNetPreTrainedModel
 */
class MPNetForTokenClassification extends MPNetPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
    }
}

/**
 * MPNetForQuestionAnswering is a class representing a MPNet model for question answering.
 * @extends MPNetPreTrainedModel
 */
class MPNetForQuestionAnswering extends MPNetPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */
    async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
    }
}
//////////////////////////////////////////////////


//////////////////////////////////////////////////
// SqueezeBert models
class SqueezeBertPreTrainedModel extends PreTrainedModel { }
class SqueezeBertModel extends SqueezeBertPreTrainedModel { }
class SqueezeBertForMaskedLM extends SqueezeBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
    }
}
class SqueezeBertForSequenceClassification extends SqueezeBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */
    async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
    }
}
class SqueezeBertForQuestionAnswering extends SqueezeBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */
    async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
    }
}
//////////////////////////////////////////////////


//////////////////////////////////////////////////
// Albert models
class AlbertPreTrainedModel extends PreTrainedModel { }
class AlbertModel extends AlbertPreTrainedModel { }
class AlbertForSequenceClassification extends AlbertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */
    async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
    }
}
class AlbertForQuestionAnswering extends AlbertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */
    async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
    }
}
class AlbertForMaskedLM extends AlbertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
    }
}
//////////////////////////////////////////////////


//////////////////////////////////////////////////
// T5 models
class T5PreTrainedModel extends PreTrainedModel { };

class T5Model extends T5PreTrainedModel {
    /**
     * Generates text based on the provided arguments.
     * @throws {Error} Throws an error as the current model class (T5Model) is not compatible with `.generate()`.
     * @returns {Promise<any>}
     * @param {any[]} args
     */
    async generate(...args) {
        throw Error(
            "The current model class (T5Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'T5ForConditionalGeneration'}"
        )
    }
}

/**
 * T5Model is a class representing a T5 model for conditional generation.
 * @extends T5PreTrainedModel
 */
class T5ForConditionalGeneration extends T5PreTrainedModel {

    /**
     * Creates a new instance of the `T5ForConditionalGeneration` class.
     * @param {Object} config The model configuration.
     * @param {any} session session for the model.
     * @param {any} decoder_merged_session session for the decoder.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
        super(config, session);
        this.decoder_merged_session = decoder_merged_session;
        this.generation_config = generation_config;

        this.num_decoder_layers = this.config.num_decoder_layers;
        this.num_decoder_heads = this.config.num_heads;
        this.decoder_dim_kv = this.config.d_kv;

        this.num_encoder_layers = this.config.num_layers;
        this.num_encoder_heads = this.config.num_heads;
        this.encoder_dim_kv = this.config.d_kv;
    }

    /**
     * Generates the start beams for a given set of inputs and output length.
     * @param {number[][]} inputs The input token IDs.
     * @param {number} numOutputTokens The desired output length.
     * @returns {Array} The start beams.
     */
    getStartBeams(inputs, numOutputTokens, ...args) {
        return seq2seqStartBeams(this, inputs, numOutputTokens);
    }

    /**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     */
    async runBeam(beam) {
        return await seq2seqRunBeam(this, beam);
    }

    /**
     * Updates the given beam with a new token ID.
     * @param {any} beam The current beam.
     * @param {number} newTokenId The new token ID to add to the output sequence.
     */
    updateBeam(beam, newTokenId) {
        beam.output_token_ids = [...beam.output_token_ids, newTokenId];
    }

    /**
     * Runs the forward pass of the model for a given set of inputs.
     * @param {Object} model_inputs The model inputs.
     * @returns {Promise<Object>} The model output.
     */
    async forward(model_inputs) {
        return await seq2seqForward(this, model_inputs);
    }
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
// MT5 models
class MT5PreTrainedModel extends PreTrainedModel { };

class MT5Model extends MT5PreTrainedModel {
    /**
     * 
     * @param  {...any} args
     * @returns {Promise<any>}
     * @throws {Error}
     */
    async generate(...args) {
        throw Error(
            "The current model class (MT5Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'MT5ForConditionalGeneration'}"
        )
    }
}

/**
 * A class representing a conditional sequence-to-sequence model based on the MT5 architecture.
 *
 * @extends MT5PreTrainedModel
 */
class MT5ForConditionalGeneration extends MT5PreTrainedModel {

    /**
     * Creates a new instance of the `MT5ForConditionalGeneration` class.
     * @param {any} config The model configuration.
     * @param {any} session The ONNX session containing the encoder weights.
     * @param {any} decoder_merged_session The ONNX session containing the merged decoder weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
        super(config, session);
        this.decoder_merged_session = decoder_merged_session;
        this.generation_config = generation_config;

        this.num_decoder_layers = this.config.num_decoder_layers;
        this.num_decoder_heads = this.config.num_heads;
        this.decoder_dim_kv = this.config.d_kv;

        this.num_encoder_layers = this.config.num_layers;
        this.num_encoder_heads = this.config.num_heads;
        this.encoder_dim_kv = this.config.d_kv;
    }

    /**
   * Generates the start beams for the given input tokens and output sequence length.
   *
   * @param {any[]} inputs The input sequence.
   * @param {number} numOutputTokens The desired length of the output sequence.
   * @param {...*} args Additional arguments to pass to the `seq2seqStartBeams` function.
   * @returns {any[]} An array of `Beam` objects representing the start beams.
   */
    getStartBeams(inputs, numOutputTokens, ...args) {
        return seq2seqStartBeams(this, inputs, numOutputTokens);
    }

    /**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     */
    async runBeam(beam) {
        return await seq2seqRunBeam(this, beam);
    }

    /**
     * Updates the given beam with the new predicted token.
     * @param {any} beam The beam to update.
     * @param {number} newTokenId The index of the predicted token.
    */
    updateBeam(beam, newTokenId) {
        beam.output_token_ids = [...beam.output_token_ids, newTokenId];
    }

    /**
    * Runs the forward pass of the model on the given inputs.
    * @param {any} model_inputs The model inputs.
    * @returns {Promise<any>} A Promise that resolves to the model outputs.
    */
    async forward(model_inputs) {
        return await seq2seqForward(this, model_inputs);
    }
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
// Bart models
class BartPretrainedModel extends PreTrainedModel { };

/**
 * BART encoder and decoder model.
 * 
 * @hideconstructor
 * @extends BartPretrainedModel
 */
class BartModel extends BartPretrainedModel {
    /**
     * Throws an error because the current model class (BartModel) is not compatible with `.generate()`.
     * 
     * @throws {Error} The current model class (BartModel) is not compatible with `.generate()`.
     * @returns {Promise<any>}
     */
    async generate(...args) {
        throw Error(
            "The current model class (BartModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'BartForConditionalGeneration'}"
        )
    }
}

/**
 * BART model with a language model head for conditional generation.
 * @extends BartPretrainedModel
 */
class BartForConditionalGeneration extends BartPretrainedModel {

    /**
     * Creates a new instance of the `BartForConditionalGeneration` class.
     * @param {Object} config The configuration object for the Bart model.
     * @param {Object} session The ONNX session used to execute the model.
     * @param {Object} decoder_merged_session The ONNX session used to execute the decoder.
     * @param {Object} generation_config The generation configuration object.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
        super(config, session);
        this.decoder_merged_session = decoder_merged_session;
        this.generation_config = generation_config;

        this.num_decoder_layers = this.config.decoder_layers;
        this.num_decoder_heads = this.config.decoder_attention_heads;
        this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;

        this.num_encoder_layers = this.config.encoder_layers;
        this.num_encoder_heads = this.config.encoder_attention_heads;
        this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
    }

    /**
     * Returns the initial beam for generating output text.
     * @param {Object} inputs The input object containing the encoded input text.
     * @param {number} numOutputTokens The maximum number of output tokens to generate.
     * @param  {...any} args Additional arguments to pass to the sequence-to-sequence generation function.
     * @returns {any} The initial beam for generating output text.
     */
    getStartBeams(inputs, numOutputTokens, ...args) {
        return seq2seqStartBeams(this, inputs, numOutputTokens);
    }

    /**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     */
    async runBeam(beam) {
        return await seq2seqRunBeam(this, beam);
    }

    /**
     * Updates the beam by appending the newly generated token ID to the list of output token IDs.
     * @param {any} beam The current beam being generated.
     * @param {number} newTokenId The ID of the newly generated token to append to the list of output token IDs.
     */
    updateBeam(beam, newTokenId) {
        beam.output_token_ids = [...beam.output_token_ids, newTokenId];
    }

    /**
     * Runs the forward pass of the model for a given set of inputs.
     * @param {Object} model_inputs The model inputs.
     * @returns {Promise<Object>} The model output.
     */
    async forward(model_inputs) {
        return await seq2seqForward(this, model_inputs);
    }
}

class BartForSequenceClassification extends BartPretrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
    }
}

//////////////////////////////////////////////////

//////////////////////////////////////////////////
// Roberta models
class RobertaPreTrainedModel extends PreTrainedModel { }
class RobertaModel extends RobertaPreTrainedModel { }

/**
 * RobertaForMaskedLM class for performing masked language modeling on Roberta models.
 * @extends RobertaPreTrainedModel
 */
class RobertaForMaskedLM extends RobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
    }
}

/**
 * RobertaForSequenceClassification class for performing sequence classification on Roberta models.
 * @extends RobertaPreTrainedModel
 */
class RobertaForSequenceClassification extends RobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */
    async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
    }
}

/**
 * RobertaForTokenClassification class for performing token classification on Roberta models.
 * @extends RobertaPreTrainedModel
 */
class RobertaForTokenClassification extends RobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
    }
}

/**
 * RobertaForQuestionAnswering class for performing question answering on Roberta models.
 * @extends RobertaPreTrainedModel
 */
class RobertaForQuestionAnswering extends RobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */
    async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
    }
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
// XLMRoberta models
class XLMRobertaPreTrainedModel extends PreTrainedModel { }
class XLMRobertaModel extends XLMRobertaPreTrainedModel { }

/**
 * XLMRobertaForMaskedLM class for performing masked language modeling on XLMRoberta models.
 * @extends XLMRobertaPreTrainedModel
 */
class XLMRobertaForMaskedLM extends XLMRobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    async _call(model_inputs) {
        return new MaskedLMOutput(await super._call(model_inputs));
    }
}

/**
 * XLMRobertaForSequenceClassification class for performing sequence classification on XLMRoberta models.
 * @extends XLMRobertaPreTrainedModel
 */
class XLMRobertaForSequenceClassification extends XLMRobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */
    async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
    }
}

/**
 * XLMRobertaForTokenClassification class for performing token classification on XLMRoberta models.
 * @extends XLMRobertaPreTrainedModel
 */
class XLMRobertaForTokenClassification extends XLMRobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    async _call(model_inputs) {
        return new TokenClassifierOutput(await super._call(model_inputs));
    }
}

/**
 * XLMRobertaForQuestionAnswering class for performing question answering on XLMRoberta models.
 * @extends XLMRobertaPreTrainedModel
 */
class XLMRobertaForQuestionAnswering extends XLMRobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */
    async _call(model_inputs) {
        return new QuestionAnsweringModelOutput(await super._call(model_inputs));
    }
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
// T5 models
class WhisperPreTrainedModel extends PreTrainedModel { };

/**
 * WhisperModel class for training Whisper models without a language model head.
 * @extends WhisperPreTrainedModel
 */
class WhisperModel extends WhisperPreTrainedModel {
    /**
     * Throws an error when attempting to generate output since this model doesn't have a language model head.
     * @throws Error
     * @returns {Promise<any>}
     * @param {any[]} args
     */
    async generate(...args) {
        throw Error(
            "The current model class (WhisperModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'WhisperForConditionalGeneration'}"
        )
    }
}

/**
 * WhisperForConditionalGeneration class for generating conditional outputs from Whisper models.
 * @extends WhisperPreTrainedModel
 */
class WhisperForConditionalGeneration extends WhisperPreTrainedModel {

    /**
     * Creates a new instance of the `WhisperForConditionalGeneration` class.
     * @param {Object} config Configuration object for the model.
     * @param {Object} session ONNX Session object for the model.
     * @param {Object} decoder_merged_session ONNX Session object for the decoder.
     * @param {Object} generation_config Configuration object for the generation process.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
        super(config, session);
        this.decoder_merged_session = decoder_merged_session;
        this.generation_config = generation_config;

        this.num_decoder_layers = this.config.decoder_layers;
        this.num_decoder_heads = this.config.decoder_attention_heads;
        this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;

        this.num_encoder_layers = this.config.encoder_layers;
        this.num_encoder_heads = this.config.encoder_attention_heads;
        this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;


    }

    /**
     * Generates outputs based on input and generation configuration.
     * @param {Object} inputs Input data for the model.
     * @param {Object} generation_config Configuration object for the generation process.
     * @param {Object} logits_processor Optional logits processor object.
     * @param {Object} options options
     * @param {Object} [options.return_timestamps=null] Whether to return the timestamps with the text. This enables the `WhisperTimestampsLogitsProcessor`.
     * @param {Object} [options.return_token_timestamps=null] Whether to return token-level timestamps
     * with the text. This can be used with or without the `return_timestamps` option. To get word-level
     * timestamps, use the tokenizer to group the tokens into words.
     * @returns {Promise<Object>} Promise object represents the generated outputs.
     */
    // @ts-ignore
    async generate(
        inputs,
        generation_config = null,
        logits_processor = null,
        // {
        //     return_timestamps = null,
        //     return_token_timestamps = null,
        //     language = null,
        //     task = null,
        // } = {},
    ) {
        // Create generation config object
        generation_config = this._get_generation_config(generation_config);


        // Whisper has additional options for returning timestamps
        generation_config.return_timestamps ??= false;

        // TODO add language and task

        if (generation_config.return_timestamps) {
            logits_processor = [new _utils_generation_js__WEBPACK_IMPORTED_MODULE_3__.WhisperTimeStampLogitsProcessor(generation_config)]
        }

        if (generation_config.return_token_timestamps) {
            generation_config.output_attentions = true;
            generation_config.return_dict_in_generate = true;

            if (generation_config.task === 'translate') {
                console.warn("Token-level timestamps may not be reliable for task 'translate'.")
            }

            if (!generation_config.alignment_heads) {
                throw new Error(
                    "Model generation config has no `alignment_heads`, token-level timestamps not available. " +
                    "See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config."
                )
            }
        }

        const outputs = await super.generate(inputs, generation_config, logits_processor);

        if (generation_config.return_token_timestamps && generation_config.alignment_heads) {
            outputs["token_timestamps"] = this._extract_token_timestamps(outputs, generation_config.alignment_heads)
        }

        return outputs
    }

    /**
     * Gets the start beams for generating outputs.
     * @param {Array} inputTokenIds Array of input token IDs.
     * @param {number} numOutputTokens Number of output tokens to generate.
     * @returns {Array} Array of start beams.
     */
    getStartBeams(inputTokenIds, numOutputTokens, ...args) {
        // arguments ignored in this case
        return seq2seqStartBeams(this, inputTokenIds, numOutputTokens, false);
    }

    /**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     */
    async runBeam(beam) {
        return await seq2seqRunBeam(this, beam, {
            input_name: 'input_features',
        });
    }

    /**
     * Updates the beam by appending the newly generated token ID to the list of output token IDs.
     * @param {any} beam The current beam being generated.
     * @param {number} newTokenId The ID of the newly generated token to append to the list of output token IDs.
     */
    updateBeam(beam, newTokenId) {
        beam.output_token_ids = [...beam.output_token_ids, newTokenId];
    }

    /**
     * Runs the forward pass of the model for a given set of inputs.
     * @param {Object} model_inputs The model inputs.
     * @returns {Promise<Object>} The model output.
     */
    async forward(model_inputs) {
        return await seq2seqForward(this, model_inputs);
    }

    /**
     * Calculates token-level timestamps using the encoder-decoder cross-attentions and
     * dynamic time-warping (DTW) to map each output token to a position in the input audio.
     * @param {Object} generate_outputs Outputs generated by the model
     * @param {Tensor[][][]} generate_outputs.cross_attentions The cross attentions output by the model
     * @param {Tensor[][][]} generate_outputs.decoder_attentions The decoder attentions output by the model
     * @param {number[][]} generate_outputs.sequences The sequences output by the model
     * @param {number[][]} alignment_heads Alignment heads of the model
     * @param {number} time_precision Precision of the timestamps in seconds
     * @returns {Tensor} tensor containing the timestamps in seconds for each predicted token
     */
    _extract_token_timestamps(generate_outputs, alignment_heads, time_precision = 0.02) {
        if (!generate_outputs.cross_attentions) {
            throw new Error(
                "Model outputs must contain cross attentions to extract timestamps. " +
                "This is most likely because the model was not exported with `output_attentions=True`."
            )
        }

        let median_filter_width = this.config.median_filter_width;
        if (median_filter_width === undefined) {
            console.warn("Model config has no `median_filter_width`, using default value of 7.")
            median_filter_width = 7;
        }

        const batchedMatrices = generate_outputs.cross_attentions.map(batch => {
            // Create a list with `decoder_layers` elements, each a tensor of shape
            // (batch size, attention_heads, output length, input length).
            let cross_attentions = Array.from({ length: this.config.decoder_layers },
                (_, i) => (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.cat)(batch.map(x => x[i]), 2)
            );

            let weights = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.stack)(alignment_heads.map(([l, h]) => cross_attentions[l].slice(null, h)));
            weights = weights.transpose(1, 0, 2, 3)

            let [std, calculatedMean] = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.std_mean)(weights, -2, 0, true);

            // Normalize and smoothen the weights.
            let smoothedWeights = weights.clone(); // [1, 8, seqLength, 1500]

            for (let a = 0; a < smoothedWeights.dims[0]; ++a) {
                let aTensor = smoothedWeights[a]; // [8, seqLength, 1500]

                for (let b = 0; b < aTensor.dims[0]; ++b) {
                    let bTensor = aTensor[b]; // [seqLength, 1500]

                    const stdTensor = std[a][b][0]; // [1500]
                    const meanTensor = calculatedMean[a][b][0]; // [1500]

                    for (let c = 0; c < bTensor.dims[0]; ++c) {

                        let cTensor = bTensor[c]; // [1500]
                        for (let d = 0; d < cTensor.data.length; ++d) {
                            cTensor.data[d] = (cTensor.data[d] - meanTensor.data[d]) / stdTensor.data[d]
                        }

                        // Apply median filter.
                        cTensor.data.set((0,_transformers_js__WEBPACK_IMPORTED_MODULE_6__.medianFilter)(cTensor.data, median_filter_width))
                    }
                }
            }

            // Average the different cross-attention heads.
            const matrix = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.mean)(smoothedWeights, 1);
            return matrix;
        });

        const timestampsShape = [generate_outputs.sequences.length, generate_outputs.sequences[0].length];

        const timestamps = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.Tensor(
            'float32',
            new Float32Array(timestampsShape[0] * timestampsShape[1]),
            timestampsShape
        );

        // Perform dynamic time warping on each element of the batch.
        for (let batch_idx = 0; batch_idx < timestampsShape[0]; ++batch_idx) {
            // NOTE: Since we run only one batch at a time, we can squeeze to get the same dimensions
            // as the python implementation
            const matrix = batchedMatrices[batch_idx].neg().squeeze_(0);
            let [text_indices, time_indices] = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_4__.dynamicTimeWarping)(matrix);

            let diffs = Array.from({ length: text_indices.length - 1 }, (v, i) => text_indices[i + 1] - text_indices[i]);
            let jumps = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_1__.mergeArrays)([1], diffs).map(x => !!x); // convert to boolean

            let jump_times = [];
            for (let i = 0; i < jumps.length; ++i) {
                if (jumps[i]) {
                    jump_times.push(time_indices[i] * time_precision);
                    // NOTE: No point in rounding here, since we set to Float32Array later
                }
            }
            timestamps[batch_idx].data.set(jump_times, 1)
        }

        return timestamps;
    }
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
/**
 * Vision Encoder-Decoder model based on OpenAI's GPT architecture for image captioning and other vision tasks
 * @extends PreTrainedModel
 */
class VisionEncoderDecoderModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `VisionEncoderDecoderModel` class.
     * @param {Object} config The configuration object specifying the hyperparameters and other model settings.
     * @param {Object} session The ONNX session containing the encoder model.
     * @param {any} decoder_merged_session The ONNX session containing the merged decoder model.
     */
    constructor(config, session, decoder_merged_session) {
        super(config, session);
        this.decoder_merged_session = decoder_merged_session;

        this.num_layers = this.config.decoder.n_layer;
        this.num_heads = this.config.decoder.n_head;
        this.dim_kv = this.config.decoder.n_embd / this.num_heads;
    }

    /**
     * Generate beam search outputs for the given input pixels and number of output tokens.
     *
     * @param {array} inputs The input pixels as a Tensor.
     * @param {number} numOutputTokens The number of output tokens to generate.
     * @param {...*} args Optional additional arguments to pass to seq2seqStartBeams.
     * @returns {any} An array of Beam objects representing the top-K output sequences.
     */
    getStartBeams(inputs, numOutputTokens, ...args) {
        return seq2seqStartBeams(this, inputs, numOutputTokens);
    }

    /**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     */
    async runBeam(beam) {
        return seq2seqRunBeam(this, beam, {
            input_name: 'pixel_values',
        });
    }

    /**
     * Update the given beam with the additional predicted token ID.
     *
     * @param {any} beam The current beam.
     * @param {number} newTokenId The new predicted token ID to add to the beam's output sequence.
     */
    updateBeam(beam, newTokenId) {
        beam.output_token_ids = [...beam.output_token_ids, newTokenId];
    }

    /**
     * Compute the forward pass of the model on the given input tensors.
     *
     * @param {Object} model_inputs The input tensors as an object with keys 'pixel_values' and 'decoder_input_ids'.
     * @returns {Promise<any>} The output tensor of the model.
     */
    async forward(model_inputs) {
        return await seq2seqForward(this, model_inputs, {
            add_decoder_pkv: false
        })
    }
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
// CLIP models
class CLIPPreTrainedModel extends PreTrainedModel { }

/**
 * CLIP Text and Vision Model with a projection layers on top
 * 
 * **Example:** Perform zero-shot image classification with a `CLIPModel`.
 * 
 * ```javascript
 * import { AutoTokenizer, AutoProcessor, CLIPModel, RawImage } from '@xenova/transformers';
 * 
 * // Load tokenizer, processor, and model
 * let tokenizer = await AutoTokenizer.from_pretrained('Xenova/clip-vit-base-patch16');
 * let processor = await AutoProcessor.from_pretrained('Xenova/clip-vit-base-patch16');
 * let model = await CLIPModel.from_pretrained('Xenova/clip-vit-base-patch16');
 * 
 * // Run tokenization
 * let texts = ['a photo of a car', 'a photo of a football match']
 * let text_inputs = tokenizer(texts, { padding: true, truncation: true });
 * 
 * // Read image and run processor
 * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');
 * let image_inputs = await processor(image);
 * 
 * // Run model with both text and pixel inputs
 * let output = await model({ ...text_inputs, ...image_inputs });
 * // {
 * //   logits_per_image: Tensor {
 * //     dims: [ 1, 2 ],
 * //     data: Float32Array(2) [ 18.579734802246094, 24.31830596923828 ],
 * //   },
 * //   logits_per_text: Tensor {
 * //     dims: [ 2, 1 ],
 * //     data: Float32Array(2) [ 18.579734802246094, 24.31830596923828 ],
 * //   },
 * //   text_embeds: Tensor {
 * //     dims: [ 2, 512 ],
 * //     data: Float32Array(1024) [ ... ],
 * //   },
 * //   image_embeds: Tensor {
 * //     dims: [ 1, 512 ],
 * //     data: Float32Array(512) [ ... ],
 * //   }
 * // }
 * ```
 */
class CLIPModel extends CLIPPreTrainedModel { }

/**
 * CLIP Text Model with a projection layer on top (a linear layer on top of the pooled output)
 * 
 * **Example:** Compute text embeddings with `CLIPTextModelWithProjection`.
 * 
 * ```javascript
 * import { AutoTokenizer, CLIPTextModelWithProjection } from '@xenova/transformers';
 * 
 * // Load tokenizer and text model
 * const tokenizer = await AutoTokenizer.from_pretrained('Xenova/clip-vit-base-patch16');
 * const text_model = await CLIPTextModelWithProjection.from_pretrained('Xenova/clip-vit-base-patch16');
 * 
 * // Run tokenization
 * let texts = ['a photo of a car', 'a photo of a football match'];
 * let text_inputs = tokenizer(texts, { padding: true, truncation: true });
 * 
 * // Compute embeddings
 * const { text_embeds } = await text_model(text_inputs);
 * // Tensor {
 * //   dims: [ 2, 512 ],
 * //   type: 'float32',
 * //   data: Float32Array(1024) [ ... ],
 * //   size: 1024
 * // }
 * ```
 */
class CLIPTextModelWithProjection extends CLIPPreTrainedModel {

    /** @type {PreTrainedModel.from_pretrained} */
    static async from_pretrained(pretrained_model_name_or_path, options = {}) {
        // Update default model file name if not provided
        options.model_file_name ??= 'text_model';
        return super.from_pretrained(pretrained_model_name_or_path, options);
    }
}

/**
 * CLIP Vision Model with a projection layer on top (a linear layer on top of the pooled output)
 * 
 * **Example:** Compute vision embeddings with `CLIPVisionModelWithProjection`.
 * 
 * ```javascript
 * import { AutoProcessor, CLIPVisionModelWithProjection, RawImage} from '@xenova/transformers';
 * 
 * // Load processor and vision model
 * const processor = await AutoProcessor.from_pretrained('Xenova/clip-vit-base-patch16');
 * const vision_model = await CLIPVisionModelWithProjection.from_pretrained('Xenova/clip-vit-base-patch16');
 * 
 * // Read image and run processor
 * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');
 * let image_inputs = await processor(image);
 * 
 * // Compute embeddings
 * const { image_embeds } = await vision_model(image_inputs);
 * // Tensor {
 * //   dims: [ 1, 512 ],
 * //   type: 'float32',
 * //   data: Float32Array(512) [ ... ],
 * //   size: 512
 * // }
 * ```
 */
class CLIPVisionModelWithProjection extends CLIPPreTrainedModel {
    /** @type {PreTrainedModel.from_pretrained} */
    static async from_pretrained(pretrained_model_name_or_path, options = {}) {
        // Update default model file name if not provided
        options.model_file_name ??= 'vision_model';
        return super.from_pretrained(pretrained_model_name_or_path, options);
    }
}

//////////////////////////////////////////////////

//////////////////////////////////////////////////
// GPT2 models
class GPT2PreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `GPT2PreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     */
    constructor(config, session) {
        super(config, session);

        // config doesn't contain pad_token_id, so we assume it is the eos_token_id
        this.config.pad_token_id = this.config.eos_token_id

        this.num_heads = this.config.n_head
        this.num_layers = this.config.n_layer
        this.dim_kv = this.config.n_embd / this.num_heads;
    }
}

class GPT2Model extends GPT2PreTrainedModel {

    /**
     * GPT2Model is not compatible with `.generate()`, as it doesn't have a language model head.
     * @param  {...any} args 
     * @throws {Error}
     * @returns {Promise<any>}
     */
    async generate(...args) {
        throw Error(
            "The current model class (GPT2Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'GPT2LMHeadModel'}"
        )
    }
}

/**
 * GPT-2 language model head on top of the GPT-2 base model. This model is suitable for text generation tasks.
 * @extends GPT2PreTrainedModel
 */
class GPT2LMHeadModel extends GPT2PreTrainedModel {

    /**
     * Initializes and returns the beam for text generation task
     * @param {Tensor} inputTokenIds The input token ids.
     * @param {number} numOutputTokens The number of tokens to be generated.
     * @param {Tensor} inputs_attention_mask Optional input attention mask.
     * @returns {any} A Beam object representing the initialized beam.
     */
    getStartBeams(inputTokenIds, numOutputTokens, inputs_attention_mask) {
        return decoderStartBeams(this, inputTokenIds, numOutputTokens, inputs_attention_mask)
    }

    /**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     */
    async runBeam(beam) {
        return await decoderRunBeam(this, beam);
    }

    /**
     * Updates the given beam with the new generated token id.
     * @param {any} beam The Beam object representing the beam.
     * @param {number} newTokenId The new generated token id to be added to the beam.
     */
    updateBeam(beam, newTokenId) {
        return decoderUpdatebeam(beam, newTokenId);
    }

    /**
     * Forward pass for the model.
     * @param {Object} model_inputs The inputs for the model.
     * @returns {Promise<any>} The output tensor of the model.
     */
    async forward(model_inputs) {
        return await decoderForward(this, model_inputs);
    }

}
// export class GPT2ForSequenceClassification extends GPT2PreTrainedModel {
// TODO
// }
//////////////////////////////////////////////////
class GPTNeoPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `GPTNeoPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     */
    constructor(config, session) {
        super(config, session);

        // config doesn't contain pad_token_id, so we assume it is the eos_token_id
        this.config.pad_token_id = this.config.eos_token_id

        this.num_heads = this.config.num_heads;
        this.num_layers = this.config.num_layers;
        this.dim_kv = this.config.hidden_size / this.num_heads;
    }
}
class GPTNeoModel extends GPTNeoPreTrainedModel {
    /**
     * 
     * @param  {...any} args 
     * @throws {Error}
     * @returns {Promise<any>}
     */
    async generate(...args) {
        throw Error(
            "The current model class (GPTNeoModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'GPTNeoForCausalLM'}"
        )
    }
}

class GPTNeoForCausalLM extends GPTNeoPreTrainedModel {

    /**
     * Initializes and returns the beam for text generation task
     * @param {Tensor} inputTokenIds The input token ids.
     * @param {number} numOutputTokens The number of tokens to be generated.
     * @param {Tensor} inputs_attention_mask Optional input attention mask.
     * @returns {any} A Beam object representing the initialized beam.
     */
    getStartBeams(inputTokenIds, numOutputTokens, inputs_attention_mask) {
        return decoderStartBeams(this, inputTokenIds, numOutputTokens, inputs_attention_mask)
    }

    /**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     */
    async runBeam(beam) {
        return await decoderRunBeam(this, beam);
    }

    /**
     * Updates the given beam with the new generated token id.
     * @param {any} beam The Beam object representing the beam.
     * @param {number} newTokenId The new generated token id to be added to the beam.
     */
    updateBeam(beam, newTokenId) {
        return decoderUpdatebeam(beam, newTokenId);
    }

    /**
     * Forward pass for the model.
     * @param {Object} model_inputs The inputs for the model.
     * @returns {Promise<any>} The output tensor of the model.
     */
    async forward(model_inputs) {
        return await decoderForward(this, model_inputs);
    }
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
// GPTBigCode models
class GPTBigCodePreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `GPTBigCodePreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     */
    constructor(config, session) {
        super(config, session);

        // config doesn't contain pad_token_id, so we assume it is the eos_token_id
        this.config.pad_token_id = this.config.eos_token_id

        this.num_heads = this.config.n_head
        this.num_layers = this.config.n_layer
        this.dim_kv = this.config.n_embd / this.num_heads;
    }
}

class GPTBigCodeModel extends GPTBigCodePreTrainedModel {
    /**
     * 
     * @param  {...any} args 
     * @throws {Error}
     * @returns {Promise<any>}
     */
    async generate(...args) {
        throw Error(
            "The current model class (GPTBigCodeModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'GPTBigCodeForCausalLM'}"
        )
    }
}

class GPTBigCodeForCausalLM extends GPTBigCodePreTrainedModel {

    /**
     * Initializes and returns the beam for text generation task
     * @param {Tensor} inputTokenIds The input token ids.
     * @param {number} numOutputTokens The number of tokens to be generated.
     * @param {Tensor} inputs_attention_mask Optional input attention mask.
     * @returns {any} A Beam object representing the initialized beam.
     */
    getStartBeams(inputTokenIds, numOutputTokens, inputs_attention_mask) {
        return decoderStartBeams(this, inputTokenIds, numOutputTokens, inputs_attention_mask)
    }

    /**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     */
    async runBeam(beam) {
        return await decoderRunBeam(this, beam);
    }

    /**
     * Updates the given beam with the new generated token id.
     * @param {any} beam The Beam object representing the beam.
     * @param {number} newTokenId The new generated token id to be added to the beam.
     */
    updateBeam(beam, newTokenId) {
        return decoderUpdatebeam(beam, newTokenId);
    }

    /**
     * Forward pass for the model.
     * @param {Object} model_inputs The inputs for the model.
     * @returns {Promise<any>} The output tensor of the model.
     */
    async forward(model_inputs) {
        return await decoderForward(this, model_inputs);
    }
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
// CodeGen models
class CodeGenPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `CodeGenPreTrainedModel` class.
    * @param {Object} config The model configuration object.
    * @param {Object} session The ONNX session object.
    */
    constructor(config, session) {
        super(config, session);

        // config doesn't contain pad_token_id, so we assume it is the eos_token_id
        this.config.pad_token_id = this.config.eos_token_id

        this.num_heads = this.config.n_head
        this.num_layers = this.config.n_layer
        this.dim_kv = this.config.n_embd / this.num_heads;
    }
}
/**
 * CodeGenModel is a class representing a code generation model without a language model head.
 * 
 * @extends CodeGenPreTrainedModel
 */
class CodeGenModel extends CodeGenPreTrainedModel {
    /**
     * Throws an error indicating that the current model class is not compatible with `.generate()`,
     * as it doesn't have a language model head.
     * 
     * @throws {Error} The current model class is not compatible with `.generate()`
     * 
     * @param  {...any} args Arguments passed to the generate function
     * @returns {Promise<any>}
     */
    async generate(...args) {
        throw Error(
            "The current model class (CodeGenModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'CodeGenForCausalLM'}"
        )
    }
}

/**
 * CodeGenForCausalLM is a class that represents a code generation model based on the GPT-2 architecture. It extends the `CodeGenPreTrainedModel` class.
 * @extends CodeGenPreTrainedModel
 */
class CodeGenForCausalLM extends CodeGenPreTrainedModel {

    /**
     * Initializes and returns the beam for text generation task
     * @param {Tensor} inputTokenIds The input token ids.
     * @param {number} numOutputTokens The number of tokens to be generated.
     * @param {Tensor} inputs_attention_mask Optional input attention mask.
     * @returns {any} A Beam object representing the initialized beam.
     */
    getStartBeams(inputTokenIds, numOutputTokens, inputs_attention_mask) {
        return decoderStartBeams(this, inputTokenIds, numOutputTokens, inputs_attention_mask)
    }

    /**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     */
    async runBeam(beam) {
        return await decoderRunBeam(this, beam);
    }

    /**
     * Updates the given beam with the new generated token id.
     * @param {any} beam The Beam object representing the beam.
     * @param {number} newTokenId The new generated token id to be added to the beam.
     */
    updateBeam(beam, newTokenId) {
        return decoderUpdatebeam(beam, newTokenId);
    }

    /**
     * Forward pass for the model.
     * @param {Object} model_inputs The inputs for the model.
     * @returns {Promise<any>} The output tensor of the model.
     */
    async forward(model_inputs) {
        return await decoderForward(this, model_inputs);
    }

}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
class ViTPreTrainedModel extends PreTrainedModel { }
class ViTForImageClassification extends ViTPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
    }
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
class MobileViTPreTrainedModel extends PreTrainedModel { }
class MobileViTForImageClassification extends MobileViTPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    async _call(model_inputs) {
        return new SequenceClassifierOutput(await super._call(model_inputs));
    }
}
// TODO: MobileViTForSemanticSegmentation

//////////////////////////////////////////////////



//////////////////////////////////////////////////
class DetrPreTrainedModel extends PreTrainedModel { }
class DetrForObjectDetection extends DetrPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    async _call(model_inputs) {
        return new DetrObjectDetectionOutput(await super._call(model_inputs));
    }
}

class DetrForSegmentation extends DetrPreTrainedModel {
    /**
     * Runs the model with the provided inputs
     * @param {Object} model_inputs Model inputs
     * @returns {Promise<DetrSegmentationOutput>} Object containing segmentation outputs
     */
    async _call(model_inputs) {
        return new DetrSegmentationOutput(await super._call(model_inputs));
    }
}

class DetrObjectDetectionOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Classification logits (including no-object) for all queries.
     * @param {Tensor} output.pred_boxes Normalized boxes coordinates for all queries, represented as (center_x, center_y, width, height).
     * These values are normalized in [0, 1], relative to the size of each individual image in the batch (disregarding possible padding).
     */
    constructor({ logits, pred_boxes }) {
        super();
        this.logits = logits;
        this.pred_boxes = pred_boxes;
    }
}

class DetrSegmentationOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits The output logits of the model.
     * @param {Tensor} output.pred_boxes Predicted boxes.
     * @param {Tensor} output.pred_masks Predicted masks.
     */
    constructor({ logits, pred_boxes, pred_masks }) {
        super();
        this.logits = logits;
        this.pred_boxes = pred_boxes;
        this.pred_masks = pred_masks;
    }
}
//////////////////////////////////////////////////


//////////////////////////////////////////////////
class SamPreTrainedModel extends PreTrainedModel { }
class SamModel extends SamPreTrainedModel {
    /**
     * @param {Object} model_inputs
     * @param {Tensor} model_inputs.pixel_values Pixel values as a Tensor with shape `(batch_size, num_channels, height, width)`.
     * @param {Tensor} model_inputs.input_points Input 2D spatial points with shape `(batch_size, num_points, 2)`. This is used by the prompt encoder to encode the prompt.
     * @todo Add support for `input_labels`, `input_boxes`, `input_masks`, and `image_embeddings`.
     */
    async _call(model_inputs) {
        return new SamImageSegmentationOutput(await super._call(model_inputs));
    }
}


/**
 * Base class for Segment-Anything model's output.
 */
class SamImageSegmentationOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.iou_scores The output logits of the model.
     * @param {Tensor} output.pred_masks Predicted boxes.
     */
    constructor({ iou_scores, pred_masks }) {
        super();
        this.iou_scores = iou_scores;
        this.pred_masks = pred_masks;
    }
}
//////////////////////////////////////////////////


//////////////////////////////////////////////////
// MarianMT models
class MarianPreTrainedModel extends PreTrainedModel { };

class MarianModel extends MarianPreTrainedModel {
    /**
     * 
     * @param  {...any} args 
     * @throws {Error}
     * @returns {Promise<any>}
     */
    async generate(...args) {
        throw Error(
            "The current model class (MarianModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'MarianMTModel'}"
        )
    }
}

class MarianMTModel extends MarianPreTrainedModel {

    /**
     * Creates a new instance of the `MarianMTModel` class.
    * @param {Object} config The model configuration object.
    * @param {Object} session The ONNX session object.
    * @param {any} decoder_merged_session 
    * @param {any} generation_config 
    */
    constructor(config, session, decoder_merged_session, generation_config) {
        super(config, session);
        this.decoder_merged_session = decoder_merged_session;
        this.generation_config = generation_config;

        this.num_decoder_layers = this.config.decoder_layers;
        this.num_decoder_heads = this.config.decoder_attention_heads;
        this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;

        this.num_encoder_layers = this.config.encoder_layers;
        this.num_encoder_heads = this.config.encoder_attention_heads;
        this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
    }

    /**
     * Initializes and returns the beam for text generation task
     * @param {any[]} inputs The input token ids.
     * @param {number} numOutputTokens The number of tokens to be generated.
     * @returns {any} A Beam object representing the initialized beam.
     * @param {any[]} args
     */
    getStartBeams(inputs, numOutputTokens, ...args) {
        return seq2seqStartBeams(this, inputs, numOutputTokens);
    }

    /**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     */
    async runBeam(beam) {
        return await seq2seqRunBeam(this, beam);
    }

    /**
     * @param {any} beam
     * @param {any} newTokenId
     */
    updateBeam(beam, newTokenId) {
        beam.output_token_ids = [...beam.output_token_ids, newTokenId];
    }

    /**
     * @param {any} model_inputs
     * @returns {Promise<Seq2SeqLMOutput>}
     */
    async forward(model_inputs) {
        return await seq2seqForward(this, model_inputs);
    }
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
// M2M100 models
class M2M100PreTrainedModel extends PreTrainedModel { };

class M2M100Model extends M2M100PreTrainedModel {
    /**
     * 
     * @param  {...any} args 
     * @throws {Error}
     * @returns {Promise<any>}
     */
    async generate(...args) {
        throw Error(
            "The current model class (M2M100Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'M2M100ForConditionalGeneration'}"
        )
    }
}

class M2M100ForConditionalGeneration extends M2M100PreTrainedModel {

    /**
     * Creates a new instance of the `M2M100ForConditionalGeneration` class.
    * @param {Object} config The model configuration object.
    * @param {Object} session The ONNX session object.
    * @param {any} decoder_merged_session 
    * @param {any} generation_config 
    */
    constructor(config, session, decoder_merged_session, generation_config) {
        super(config, session);
        this.decoder_merged_session = decoder_merged_session;
        this.generation_config = generation_config;

        this.num_decoder_layers = this.config.decoder_layers;
        this.num_decoder_heads = this.config.decoder_attention_heads;
        this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;

        this.num_encoder_layers = this.config.encoder_layers;
        this.num_encoder_heads = this.config.encoder_attention_heads;
        this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
    }


    /**
     * Initializes and returns the beam for text generation task
     * @param {any[]} inputs The input token ids.
     * @param {number} numOutputTokens The number of tokens to be generated.
     * @returns {any} A Beam object representing the initialized beam.
     * @param {any[]} args
     */
    getStartBeams(inputs, numOutputTokens, ...args) {
        return seq2seqStartBeams(this, inputs, numOutputTokens);
    }

    /**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     */
    async runBeam(beam) {
        return await seq2seqRunBeam(this, beam);
    }

    /**
     * @param {any} beam
     * @param {any} newTokenId
     */
    updateBeam(beam, newTokenId) {
        beam.output_token_ids = [...beam.output_token_ids, newTokenId];
    }

    /**
     * @param {any} model_inputs
     * @returns {Promise<Seq2SeqLMOutput>}
     */
    async forward(model_inputs) {
        return await seq2seqForward(this, model_inputs);
    }
}
//////////////////////////////////////////////////


//////////////////////////////////////////////////
// AutoModels, used to simplify construction of PreTrainedModels
// (uses config to instantiate correct class)

/**
 * Base class of all AutoModels. Contains the `from_pretrained` function
 * which is used to instantiate pretrained models.
 */
class PretrainedMixin {
    /**
     * Mapping from model type to model class.
     * @type {Map<string, Object>[]}
     */
    static MODEL_CLASS_MAPPINGS = null;

    /**
     * Whether to attempt to instantiate the base class (`PretrainedModel`) if 
     * the model type is not found in the mapping.
     */
    static BASE_IF_FAIL = false;


    /** @type {PreTrainedModel.from_pretrained} */
    static async from_pretrained(pretrained_model_name_or_path, {
        quantized = true,
        progress_callback = null,
        config = null,
        cache_dir = null,
        local_files_only = false,
        revision = 'main',
        model_file_name = null,
    } = {}) {

        let options = {
            quantized,
            progress_callback,
            config,
            cache_dir,
            local_files_only,
            revision,
            model_file_name,
        }
        config = await _configs_js__WEBPACK_IMPORTED_MODULE_0__.AutoConfig.from_pretrained(pretrained_model_name_or_path, options);
        if (!options.config) {
            // If no config was passed, reuse this config for future processing
            options.config = config;
        }

        if (!this.MODEL_CLASS_MAPPINGS) {
            throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: " + this.name);
        }

        let modelClass;
        for (let MODEL_CLASS_MAPPING of this.MODEL_CLASS_MAPPINGS) {
            modelClass = MODEL_CLASS_MAPPING.get(config.model_type);
            if (!modelClass) {
                continue; // Item not found in this mapping
            }

            return await modelClass.from_pretrained(pretrained_model_name_or_path, options);
        }

        if (this.BASE_IF_FAIL) {
            console.warn(`Unknown model class "${config.model_type}", attempting to construct from base class.`);
            return await PreTrainedModel.from_pretrained(pretrained_model_name_or_path, options);
        } else {
            throw Error(`Unsupported model type: ${config.model_type}`)
        }
    }
}

const MODEL_MAPPING_NAMES_ENCODER_ONLY = new Map([
    ['bert', BertModel],
    ['mpnet', MPNetModel],
    ['albert', AlbertModel],
    ['distilbert', DistilBertModel],
    ['roberta', RobertaModel],
    ['xlm-roberta', XLMRobertaModel],
    ['clip', CLIPModel],
    ['mobilebert', MobileBertModel],
    ['squeezebert', SqueezeBertModel],

    ['sam', SamModel], // TODO change to encoder-decoder when model is split correctly
]);

const MODEL_MAPPING_NAMES_ENCODER_DECODER = new Map([
    ['t5', T5Model],
    ['mt5', MT5Model],
    ['bart', BartModel],
    ['marian', MarianModel],
    ['whisper', WhisperModel],
    ['m2m_100', M2M100Model],
]);


const MODEL_MAPPING_NAMES_DECODER_ONLY = new Map([
    ['gpt2', GPT2Model],
    ['gpt_bigcode', GPTBigCodeModel],
    ['gpt_neo', GPTNeoModel],
    ['codegen', CodeGenModel],
]);

const MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES = new Map([
    ['bert', BertForSequenceClassification],
    ['mpnet', MPNetForSequenceClassification],
    ['albert', AlbertForSequenceClassification],
    ['distilbert', DistilBertForSequenceClassification],
    ['roberta', RobertaForSequenceClassification],
    ['xlm-roberta', XLMRobertaForSequenceClassification],
    ['bart', BartForSequenceClassification],
    ['mobilebert', MobileBertForSequenceClassification],
    ['squeezebert', SqueezeBertForSequenceClassification],
]);

const MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES = new Map([
    ['bert', BertForTokenClassification],
    ['mpnet', MPNetForTokenClassification],
    ['distilbert', DistilBertForTokenClassification],
    ['roberta', RobertaForTokenClassification],
    ['xlm-roberta', XLMRobertaForTokenClassification],
]);

const MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES = new Map([
    ['t5', T5ForConditionalGeneration],
    ['mt5', MT5ForConditionalGeneration],
    ['bart', BartForConditionalGeneration],
    ['whisper', WhisperForConditionalGeneration],
    ['marian', MarianMTModel],
    ['m2m_100', M2M100ForConditionalGeneration],
]);

const MODEL_WITH_LM_HEAD_MAPPING_NAMES = new Map([
    ['gpt2', GPT2LMHeadModel],
    ['gpt_bigcode', GPTBigCodeForCausalLM],
    ['gpt_neo', GPTNeoForCausalLM],
    ['codegen', CodeGenForCausalLM],
]);

const MODEL_FOR_MASKED_LM_MAPPING_NAMES = new Map([
    ['bert', BertForMaskedLM],
    ['mpnet', MPNetForMaskedLM],
    ['albert', AlbertForMaskedLM],
    ['distilbert', DistilBertForMaskedLM],
    ['roberta', RobertaForMaskedLM],
    ['xlm-roberta', XLMRobertaForMaskedLM],
    ['mobilebert', MobileBertForMaskedLM],
    ['squeezebert', SqueezeBertForMaskedLM],
]);

const MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES = new Map([
    ['bert', BertForQuestionAnswering],
    ['mpnet', MPNetForQuestionAnswering],
    ['albert', AlbertForQuestionAnswering],
    ['distilbert', DistilBertForQuestionAnswering],
    ['roberta', RobertaForQuestionAnswering],
    ['xlm-roberta', XLMRobertaForQuestionAnswering],
    ['mobilebert', MobileBertForQuestionAnswering],
    ['squeezebert', SqueezeBertForQuestionAnswering],
]);

const MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES = new Map([
    ['vision-encoder-decoder', VisionEncoderDecoderModel],
]);

const MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES = new Map([
    ['vit', ViTForImageClassification],
    ['mobilevit', MobileViTForImageClassification],
]);

const MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES = new Map([
    ['detr', DetrForObjectDetection],
]);

const MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES = new Map([
    ['detr', DetrForSegmentation],
]);

const MODEL_FOR_MASK_GENERATION_MAPPING_NAMES = new Map([
    ['sam', SamModel],
]);

const MODEL_CLASS_TYPE_MAPPING = [
    [MODEL_MAPPING_NAMES_ENCODER_ONLY, EncoderOnlyModelType],
    [MODEL_MAPPING_NAMES_ENCODER_DECODER, EncoderDecoderModelType],
    [MODEL_MAPPING_NAMES_DECODER_ONLY, DecoderOnlyModelType],
    [MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES, EncoderOnlyModelType],
    [MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES, EncoderOnlyModelType],
    [MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES, Seq2SeqModelType],
    [MODEL_WITH_LM_HEAD_MAPPING_NAMES, DecoderOnlyModelType],
    [MODEL_FOR_MASKED_LM_MAPPING_NAMES, EncoderOnlyModelType],
    [MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES, EncoderOnlyModelType],
    [MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES, EncoderDecoderModelType],
    [MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES, EncoderOnlyModelType],
    [MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES, EncoderOnlyModelType],
    [MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES, EncoderOnlyModelType],
    [MODEL_FOR_MASK_GENERATION_MAPPING_NAMES, EncoderOnlyModelType],
];

for (const [mappings, type] of MODEL_CLASS_TYPE_MAPPING) {
    // @ts-ignore
    for (const model of mappings.values()) {
        // @ts-ignore
        MODEL_TYPE_MAPPING.set(model.name, type);
    }
}


/**
 * Helper class which is used to instantiate pretrained models with the `from_pretrained` function.
 * The chosen model class is determined by the type specified in the model config.
 * 
 * @example
 * let model = await AutoModel.from_pretrained('bert-base-uncased');
 */
class AutoModel extends PretrainedMixin {
    static MODEL_CLASS_MAPPINGS = [MODEL_MAPPING_NAMES_ENCODER_ONLY, MODEL_MAPPING_NAMES_ENCODER_DECODER, MODEL_MAPPING_NAMES_DECODER_ONLY];
    static BASE_IF_FAIL = true;
}

/**
 * Helper class which is used to instantiate pretrained sequence classification models with the `from_pretrained` function.
 * The chosen model class is determined by the type specified in the model config.
 * 
 * @example
 * let model = await AutoModelForSequenceClassification.from_pretrained('distilbert-base-uncased-finetuned-sst-2-english');
 */
class AutoModelForSequenceClassification extends PretrainedMixin {
    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES];
}

/**
 * Helper class which is used to instantiate pretrained token classification models with the `from_pretrained` function.
 * The chosen model class is determined by the type specified in the model config.
 * 
 * @example
 * let model = await AutoModelForTokenClassification.from_pretrained('Davlan/distilbert-base-multilingual-cased-ner-hrl');
 */
class AutoModelForTokenClassification extends PretrainedMixin {
    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES];
}

/**
 * Helper class which is used to instantiate pretrained sequence-to-sequence models with the `from_pretrained` function.
 * The chosen model class is determined by the type specified in the model config.
 * 
 * @example
 * let model = await AutoModelForSeq2SeqLM.from_pretrained('t5-small');
 */
class AutoModelForSeq2SeqLM extends PretrainedMixin {
    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES];
}

/**
 * Helper class which is used to instantiate pretrained causal language models with the `from_pretrained` function.
 * The chosen model class is determined by the type specified in the model config.
 * 
 * @example
 * let model = await AutoModelForCausalLM.from_pretrained('gpt2');
 */
class AutoModelForCausalLM extends PretrainedMixin {
    static MODEL_CLASS_MAPPINGS = [MODEL_WITH_LM_HEAD_MAPPING_NAMES];
}

/**
 * Helper class which is used to instantiate pretrained masked language models with the `from_pretrained` function.
 * The chosen model class is determined by the type specified in the model config.
 * 
 * @example
 * let model = await AutoModelForMaskedLM.from_pretrained('bert-base-uncased');
 */
class AutoModelForMaskedLM extends PretrainedMixin {
    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_MASKED_LM_MAPPING_NAMES];
}

/**
 * Helper class which is used to instantiate pretrained question answering models with the `from_pretrained` function.
 * The chosen model class is determined by the type specified in the model config.
 * 
 * @example
 * let model = await AutoModelForQuestionAnswering.from_pretrained('distilbert-base-cased-distilled-squad');
 */
class AutoModelForQuestionAnswering extends PretrainedMixin {
    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES];
}

/**
 * Helper class which is used to instantiate pretrained vision-to-sequence models with the `from_pretrained` function.
 * The chosen model class is determined by the type specified in the model config.
 * 
 * @example
 * let model = await AutoModelForVision2Seq.from_pretrained('nlpconnect/vit-gpt2-image-captioning');
 */
class AutoModelForVision2Seq extends PretrainedMixin {
    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES];
}

/**
 * Helper class which is used to instantiate pretrained image classification models with the `from_pretrained` function.
 * The chosen model class is determined by the type specified in the model config.
 * 
 * @example
 * let model = await AutoModelForImageClassification.from_pretrained('google/vit-base-patch16-224');
 */
class AutoModelForImageClassification extends PretrainedMixin {
    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES];
}

/**
 * Helper class which is used to instantiate pretrained image segmentation models with the `from_pretrained` function.
 * The chosen model class is determined by the type specified in the model config.
 * 
 * @example
 * let model = await AutoModelForImageSegmentation.from_pretrained('facebook/detr-resnet-50-panoptic');
 */
class AutoModelForImageSegmentation extends PretrainedMixin {
    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES];
}

/**
 * Helper class which is used to instantiate pretrained object detection models with the `from_pretrained` function.
 * The chosen model class is determined by the type specified in the model config.
 * 
 * @example
 * let model = await AutoModelForObjectDetection.from_pretrained('facebook/detr-resnet-50');
 */
class AutoModelForObjectDetection extends PretrainedMixin {
    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES];
}

/**
 * Helper class which is used to instantiate pretrained object detection models with the `from_pretrained` function.
 * The chosen model class is determined by the type specified in the model config.
 * 
 * @example
 * let model = await AutoModelForMaskGeneration.from_pretrained('Xenova/sam-vit-base');
 */
class AutoModelForMaskGeneration extends PretrainedMixin {
    static MODEL_CLASS_MAPPINGS = [MODEL_FOR_MASK_GENERATION_MAPPING_NAMES];
}
//////////////////////////////////////////////////

//////////////////////////////////////////////////
class Seq2SeqLMOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits The output logits of the model.
     * @param {Tensor} output.past_key_values An tensor of key/value pairs that represent the previous state of the model.
     * @param {Tensor} output.encoder_outputs The output of the encoder in a sequence-to-sequence model.
     * @param {Tensor} [output.decoder_attentions] Attentions weights of the decoder, after the attention softmax, used to compute the weighted average in the self-attention heads.
     * @param {Tensor} [output.cross_attentions] Attentions weights of the decoder's cross-attention layer, after the attention softmax, used to compute the weighted average in the cross-attention heads.
     */
    constructor({ logits, past_key_values, encoder_outputs, decoder_attentions = null, cross_attentions = null }) {
        super();
        this.logits = logits;
        this.past_key_values = past_key_values;
        this.encoder_outputs = encoder_outputs;
        this.decoder_attentions = decoder_attentions;
        this.cross_attentions = cross_attentions;
    }
}

/**
 * Base class for outputs of sentence classification models.
 */
class SequenceClassifierOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits classification (or regression if config.num_labels==1) scores (before SoftMax).
     */
    constructor({ logits }) {
        super();
        this.logits = logits;
    }
}

/**
 * Base class for outputs of token classification models.
 */
class TokenClassifierOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Classification scores (before SoftMax).
     */
    constructor({ logits }) {
        super();
        this.logits = logits;
    }
}

/**
 * Base class for masked language models outputs.
 */
class MaskedLMOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).
     */
    constructor({ logits }) {
        super();
        this.logits = logits;
    }
}

/**
 * Base class for outputs of question answering models.
 */
class QuestionAnsweringModelOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.start_logits Span-start scores (before SoftMax).
     * @param {Tensor} output.end_logits Span-end scores (before SoftMax).
     */
    constructor({ start_logits, end_logits }) {
        super();
        this.start_logits = start_logits;
        this.end_logits = end_logits;
    }
}


/**
 * Base class for causal language model (or autoregressive) outputs.
 */
class CausalLMOutputWithPast extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before softmax).
     * @param {Tensor} output.past_key_values Contains pre-computed hidden-states (key and values in the self-attention blocks)
     * that can be used (see `past_key_values` input) to speed up sequential decoding.
     */
    constructor({ logits, past_key_values }) {
        super();
        this.logits = logits;
        this.past_key_values = past_key_values;
    }
}

/***/ }),

/***/ "./node_modules/@xenova/transformers/src/pipelines.js":
/*!************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/pipelines.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutomaticSpeechRecognitionPipeline: () => (/* binding */ AutomaticSpeechRecognitionPipeline),
/* harmony export */   FeatureExtractionPipeline: () => (/* binding */ FeatureExtractionPipeline),
/* harmony export */   FillMaskPipeline: () => (/* binding */ FillMaskPipeline),
/* harmony export */   ImageClassificationPipeline: () => (/* binding */ ImageClassificationPipeline),
/* harmony export */   ImageSegmentationPipeline: () => (/* binding */ ImageSegmentationPipeline),
/* harmony export */   ImageToTextPipeline: () => (/* binding */ ImageToTextPipeline),
/* harmony export */   ObjectDetectionPipeline: () => (/* binding */ ObjectDetectionPipeline),
/* harmony export */   Pipeline: () => (/* binding */ Pipeline),
/* harmony export */   QuestionAnsweringPipeline: () => (/* binding */ QuestionAnsweringPipeline),
/* harmony export */   SummarizationPipeline: () => (/* binding */ SummarizationPipeline),
/* harmony export */   Text2TextGenerationPipeline: () => (/* binding */ Text2TextGenerationPipeline),
/* harmony export */   TextClassificationPipeline: () => (/* binding */ TextClassificationPipeline),
/* harmony export */   TextGenerationPipeline: () => (/* binding */ TextGenerationPipeline),
/* harmony export */   TokenClassificationPipeline: () => (/* binding */ TokenClassificationPipeline),
/* harmony export */   TranslationPipeline: () => (/* binding */ TranslationPipeline),
/* harmony export */   ZeroShotClassificationPipeline: () => (/* binding */ ZeroShotClassificationPipeline),
/* harmony export */   ZeroShotImageClassificationPipeline: () => (/* binding */ ZeroShotImageClassificationPipeline),
/* harmony export */   pipeline: () => (/* binding */ pipeline)
/* harmony export */ });
/* harmony import */ var _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tokenizers.js */ "./node_modules/@xenova/transformers/src/tokenizers.js");
/* harmony import */ var _models_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models.js */ "./node_modules/@xenova/transformers/src/models.js");
/* harmony import */ var _processors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./processors.js */ "./node_modules/@xenova/transformers/src/processors.js");
/* harmony import */ var _utils_core_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/core.js */ "./node_modules/@xenova/transformers/src/utils/core.js");
/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/maths.js */ "./node_modules/@xenova/transformers/src/utils/maths.js");
/* harmony import */ var _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/audio.js */ "./node_modules/@xenova/transformers/src/utils/audio.js");
/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/tensor.js */ "./node_modules/@xenova/transformers/src/utils/tensor.js");
/* harmony import */ var _utils_image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/image.js */ "./node_modules/@xenova/transformers/src/utils/image.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
/**
 * @file Pipelines provide a high-level, easy to use, API for running machine learning models.
 * 
 * **Example:** Instantiate pipeline using the `pipeline` function.
 * ```javascript
 * import { pipeline } from '@xenova/transformers';
 * 
 * let classifier = await pipeline('sentiment-analysis');
 * let result = await classifier('I love transformers!');
 * // [{'label': 'POSITIVE', 'score': 0.999817686}]
 * ```
 * 
 * @module pipelines
 */












/**
 * Prepare images for further tasks.
 * @param {any[]} images images to prepare.
 * @returns {Promise<any[]>} returns processed images.
 * @private
 */
async function prepareImages(images) {
    if (!Array.isArray(images)) {
        images = [images];
    }

    // Possibly convert any non-images to images
    images = await Promise.all(images.map(x => _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage.read(x)));
    return images;
}

/**
 * The Pipeline class is the class from which all pipelines inherit.
 * Refer to this class for methods shared across different pipelines.
 * @extends Callable
 */
class Pipeline extends _utils_core_js__WEBPACK_IMPORTED_MODULE_3__.Callable {
    /**
     * Create a new Pipeline.
     * @param {string} task The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.
     * @param {PreTrainedModel} model The model to use.
     */
    constructor(task, tokenizer, model) {
        super();
        this.task = task;
        this.tokenizer = tokenizer;
        this.model = model;
    }

    /**
     * Disposes the model.
     * @returns {Promise<void>} A promise that resolves when the model has been disposed.
     */
    async dispose() {
        await this.model.dispose();
    }

    /**
     * Executes the task associated with the pipeline.
     * @param {any} texts The input texts to be processed.
     * @returns {Promise<any>} A promise that resolves to an array containing the inputs and outputs of the task.
     */
    async _call(texts) {
        // Run tokenization
        let inputs = this.tokenizer(texts, {
            padding: true,
            truncation: true
        });

        // Run model
        let outputs = await this.model(inputs)

        return [inputs, outputs];
    }
}

/**
 * Text classification pipeline using any `ModelForSequenceClassification`.
 * @extends Pipeline
 */
class TextClassificationPipeline extends Pipeline {
    /**
     * Executes the text classification task.
     * @param {any} texts The input texts to be classified.
     * @param {Object} options An optional object containing the following properties:
     * @param {number} [options.topk=1] The number of top predictions to be returned.
     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted labels and scores.
     */
    async _call(texts, {
        topk = 1
    } = {}) {

        let [inputs, outputs] = await super._call(texts);

        let id2label = this.model.config.id2label;
        let toReturn = [];
        for (let batch of outputs.logits) {
            let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(batch.data), topk);

            let vals = scores.map(function (x) {
                return {
                    label: id2label[x[0]],
                    score: x[1],
                }
            });
            if (topk === 1) {
                toReturn.push(...vals);
            } else {
                toReturn.push(vals);
            }
        }

        return Array.isArray(texts) || topk === 1 ? toReturn : toReturn[0];
    }
}


/**
 * Named Entity Recognition pipeline using any `ModelForTokenClassification`.
 * @extends Pipeline
 */
class TokenClassificationPipeline extends Pipeline {
    /**
     * Executes the token classification task.
     * @param {any} texts The input texts to be classified.
     * @param {Object} options An optional object containing the following properties:
     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted labels and scores.
     */
    async _call(texts, {
        ignore_labels = ['O'], // TODO init param?
    } = {}) {

        let isBatched = Array.isArray(texts);

        if (!isBatched) {
            texts = [texts];
        }

        let tokenizer = this.tokenizer;
        let [inputs, outputs] = await super._call(texts);

        let logits = outputs.logits;
        let id2label = this.model.config.id2label;

        let toReturn = [];
        for (let i = 0; i < logits.dims[0]; ++i) {
            let ids = inputs.input_ids[i];
            let batch = logits[i];

            // List of tokens that aren't ignored
            let tokens = [];
            for (let j = 0; j < batch.dims[0]; ++j) {
                let tokenData = batch[j];
                let topScoreIndex = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.max)(tokenData.data)[1];

                let entity = id2label[topScoreIndex];
                if (ignore_labels.includes(entity)) {
                    // We predicted a token that should be ignored. So, we skip it.
                    continue;
                }

                // TODO add option to keep special tokens?
                let word = tokenizer.decode([ids[j].item()], { skip_special_tokens: true });
                if (word === '') {
                    // Was a special token. So, we skip it.
                    continue;
                }

                let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(tokenData.data);

                tokens.push({
                    entity: entity,
                    score: scores[topScoreIndex],
                    index: j,
                    word: word,

                    // TODO: null for now, but will add
                    start: null,
                    end: null,
                });
            }
            toReturn.push(tokens);
        }
        return isBatched ? toReturn : toReturn[0];
    }
}
/**
 * Question Answering pipeline using any `ModelForQuestionAnswering`.
 * 
 * **Example:** Run question answering with `distilbert-base-uncased-distilled-squad`.
 * ```javascript
 * let question = 'Who was Jim Henson?';
 * let context = 'Jim Henson was a nice puppet.';
 * 
 * let answerer = await pipeline('question-answering', 'Xenova/distilbert-base-uncased-distilled-squad');
 * let outputs = await answerer(question, context);
 * console.log(outputs);
 * // {
 * //     "answer": "a nice puppet",
 * //     "score": 0.5768911502526741
 * // }
 * ```
 * @extends Pipeline
 */
class QuestionAnsweringPipeline extends Pipeline {
    /**
     * Executes the question answering task.
     * @param {string|string[]} question The question(s) to be answered.
     * @param {string|string[]} context The context(s) where the answer(s) can be found.
     * @param {Object} options An optional object containing the following properties:
     * @param {number} [options.topk=1] The number of top answer predictions to be returned.
     * @returns {Promise<any>} A promise that resolves to an array or object containing the predicted answers and scores.
     */
    // @ts-ignore
    async _call(question, context, {
        topk = 1
    } = {}) {

        // Run tokenization
        let inputs = this.tokenizer(question, {
            text_pair: context,
            padding: true,
            truncation: true
        });

        let output = await this.model(inputs);

        let toReturn = [];
        for (let j = 0; j < output.start_logits.dims[0]; ++j) {
            let ids = inputs.input_ids[j];
            let sepIndex = ids.indexOf(this.tokenizer.sep_token_id);

            let s1 = Array.from((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(output.start_logits[j].data))
                .map((x, i) => [x, i])
                .filter(x => x[1] > sepIndex);
            let e1 = Array.from((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(output.end_logits[j].data))
                .map((x, i) => [x, i])
                .filter(x => x[1] > sepIndex);

            let options = product(s1, e1)
                .filter(x => x[0][1] <= x[1][1])
                .map(x => [x[0][1], x[1][1], x[0][0] * x[1][0]])
                .sort((a, b) => b[2] - a[2]);

            for (let k = 0; k < Math.min(options.length, topk); ++k) {
                let [start, end, score] = options[k];

                let answer_tokens = [...ids].slice(start, end + 1)

                let answer = this.tokenizer.decode(answer_tokens, {
                    skip_special_tokens: true,
                });

                // TODO add start and end?
                // NOTE: HF returns character index
                toReturn.push({
                    answer, score
                });
            }
        }

        // Mimic HF's return type based on topk
        return (topk === 1) ? toReturn[0] : toReturn;

    }
}

/**
 * Masked language modeling prediction pipeline using any `ModelWithLMHead`.
 * @extends Pipeline
 */
class FillMaskPipeline extends Pipeline {
    /**
     * Fill the masked token in the text(s) given as inputs.
     * @param {any} texts The masked input texts.
     * @param {Object} options An optional object containing the following properties:
     * @param {number} [options.topk=5] The number of top predictions to be returned.
     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted tokens and scores.
     */
    async _call(texts, {
        topk = 5
    } = {}) {
        // Run tokenization
        let [inputs, outputs] = await super._call(texts);

        // Determine indices of mask tokens
        // let mask_token_indices = inputs.input_ids.data.map(x => )

        // let logits = reshape(outputs.logits.data, outputs.logits.dims);

        let tokenizer = this.tokenizer;

        let toReturn = [];

        for (let i = 0; i < inputs.input_ids.dims[0]; ++i) {
            let ids = inputs.input_ids[i];
            let mask_token_index = ids.indexOf(this.tokenizer.mask_token_id)

            if (mask_token_index === -1) {
                throw Error(`Mask token (${tokenizer.mask_token}) not found in text.`)
            }
            let logits = outputs.logits[i];
            let itemLogits = logits[mask_token_index];

            let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(itemLogits.data), topk);

            toReturn.push(scores.map(x => {
                let sequence = [...ids];
                sequence[mask_token_index] = x[0];

                return {
                    score: x[1],
                    token: x[0],
                    token_str: tokenizer.model.vocab[x[0]],
                    sequence: tokenizer.decode(sequence, { skip_special_tokens: true }),
                }
            }));
        }
        return Array.isArray(texts) ? toReturn : toReturn[0];
    }
}

/**
 * Text2TextGenerationPipeline class for generating text using a model that performs text-to-text generation tasks.
 * @extends Pipeline
 */
class Text2TextGenerationPipeline extends Pipeline {
    _key = null;

    /**
     * Fill the masked token in the text(s) given as inputs.
     * @param {string|string[]} texts The text or array of texts to be processed.
     * @param {Object} [options={}] Options for the fill-mask pipeline.
     * @param {number} [options.topk=5] The number of top-k predictions to return.
     * @returns {Promise<any>} An array of objects containing the score, predicted token, predicted token string,
     * and the sequence with the predicted token filled in, or an array of such arrays (one for each input text).
     * If only one input text is given, the output will be an array of objects.
     * @throws {Error} When the mask token is not found in the input text.
     */
    async _call(texts, generate_kwargs = {}) {
        if (!Array.isArray(texts)) {
            texts = [texts];
        }

        // Add global prefix, if present
        if (this.model.config.prefix) {
            texts = texts.map(x => this.model.config.prefix + x)
        }

        // Handle task specific params:
        let task_specific_params = this.model.config.task_specific_params
        if (task_specific_params && task_specific_params[this.task]) {
            // Add prefixes, if present
            if (task_specific_params[this.task].prefix) {
                texts = texts.map(x => task_specific_params[this.task].prefix + x)
            }

            // TODO update generation config
        }

        let tokenizer_options = {
            padding: true,
            truncation: true,
        }
        let input_ids;
        if (this instanceof TranslationPipeline && '_build_translation_inputs' in this.tokenizer) {
            // TODO: move to Translation pipeline?
            // Currently put here to avoid code duplication
            // @ts-ignore
            input_ids = this.tokenizer._build_translation_inputs(texts, tokenizer_options, generate_kwargs).input_ids;

        } else {
            input_ids = this.tokenizer(texts, tokenizer_options).input_ids;
        }

        let outputTokenIds = await this.model.generate(input_ids, generate_kwargs);

        /**
         * @type {any[]}
         */
        let toReturn = this.tokenizer.batch_decode(outputTokenIds, {
            skip_special_tokens: true,
        });
        if (this._key !== null) {
            toReturn = toReturn.map(text => {
                return (this._key === null) ? text : { [this._key]: text }
            })
        }
        return toReturn
    }
}


/**
 * A pipeline for summarization tasks, inheriting from Text2TextGenerationPipeline.
 * @extends Text2TextGenerationPipeline
 */
class SummarizationPipeline extends Text2TextGenerationPipeline {
    _key = 'summary_text';
}

/**
 * TranslationPipeline class to translate text from one language to another using the provided model and tokenizer.
 * @extends Text2TextGenerationPipeline
 */
class TranslationPipeline extends Text2TextGenerationPipeline {
    _key = 'translation_text';
}

/**
 * Language generation pipeline using any `ModelWithLMHead` or `ModelForCausalLM`.
 * This pipeline predicts the words that will follow a specified text prompt.
 * NOTE: For the full list of generation parameters, see [`GenerationConfig`](./utils/generation#module_utils/generation.GenerationConfig).
 * 
 * **Example:** Text generation with `Xenova/distilgpt2` (default settings).
 * ```javascript
 * let text = 'I enjoy walking with my cute dog,';
 * let generator = await pipeline('text-generation', 'Xenova/distilgpt2');
 * let output = await generator(text);
 * console.log(output);
 * // [{ generated_text: "I enjoy walking with my cute dog, and I love to play with the other dogs." }]
 * ```
 * 
 * **Example:** Text generation with `Xenova/distilgpt2` (custom settings).
 * ```javascript
 * let text = 'Once upon a time, there was';
 * let generator = await pipeline('text-generation', 'Xenova/distilgpt2');
 * let output = await generator(text, {
 *     temperature: 2,
 *     max_new_tokens: 10,
 *     repetition_penalty: 1.5,
 *     no_repeat_ngram_size: 2,
 *     num_beams: 2,
 *     num_return_sequences: 2,
 * });
 * console.log(output);
 * // [{
 * //   "generated_text": "Once upon a time, there was an abundance of information about the history and activities that"
 * // }, {
 * //   "generated_text": "Once upon a time, there was an abundance of information about the most important and influential"
 * // }]
 * ```
 * 
 * **Example:** Run code generation with `Xenova/codegen-350M-mono`.
 * ```javascript
 * let text = 'def fib(n):';
 * let generator = await pipeline('text-generation', 'Xenova/codegen-350M-mono');
 * let output = await generator(text, {
 *     max_new_tokens: 40,
 * });
 * console.log(output[0].generated_text);
 * // def fib(n):
 * //     if n == 0:
 * //         return 0
 * //     if n == 1:
 * //         return 1
 * //     return fib(n-1) + fib(n-2)
 * ```
 * 
 * @extends Pipeline
 */
class TextGenerationPipeline extends Pipeline {
    /**
     * Generates text based on an input prompt.
     * @param {any} texts The input prompt or prompts to generate text from.
     * @param {Object} [generate_kwargs={}] Additional arguments for text generation.
     * @returns {Promise<any>} The generated text or texts.
     */
    async _call(texts, generate_kwargs = {}) {
        let stringInput = typeof texts === 'string' || texts instanceof String;
        if (stringInput) {
            texts = [texts];
        }

        this.tokenizer.padding_side = 'left';
        let inputs = this.tokenizer(texts, {
            padding: true,
            truncation: true,
        });

        let input_ids = inputs.input_ids;
        let attention_mask = inputs.attention_mask;

        let outputTokenIds = await this.model.generate(input_ids, generate_kwargs, null, {
            inputs_attention_mask: attention_mask
        });

        const decoded = this.tokenizer.batch_decode(outputTokenIds, {
            skip_special_tokens: true,
        });
        const toReturn = Array.from({ length: texts.length }, _ => []);
        for (let i = 0; i < decoded.length; ++i) {
            const textIndex = Math.floor(i / outputTokenIds.length * texts.length);

            toReturn[textIndex].push({
                generated_text: decoded[i]
            });
        }
        return (stringInput && toReturn.length === 1) ? toReturn[0] : toReturn;
    }
}

/**
 * NLI-based zero-shot classification pipeline using a `ModelForSequenceClassification`
 * trained on NLI (natural language inference) tasks. Equivalent of `text-classification`
 * pipelines, but these models don't require a hardcoded number of potential classes, they
 * can be chosen at runtime. It usually means it's slower but it is **much** more flexible.
 * @extends Pipeline
 */
class ZeroShotClassificationPipeline extends Pipeline {

    /**
     * Create a new ZeroShotClassificationPipeline.
     * @param {string} task The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.
     * @param {PreTrainedModel} model The model to use.
     */
    constructor(task, tokenizer, model) {
        super(task, tokenizer, model);

        // Use model config to get label2id mapping
        this.label2id = Object.fromEntries(
            Object.entries(this.model.config.label2id).map(
                ([k, v]) => [k.toLowerCase(), v]
            )
        );

        this.entailment_id = this.label2id['entailment'];
        if (this.entailment_id === undefined) {
            console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id.");
            this.entailment_id = 2;
        }

        this.contradiction_id = this.label2id['contradiction'];
        if (this.contradiction_id === undefined) {
            console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id.");
            this.contradiction_id = 0;
        }
    }
    /**
     * @param {any[]} texts
     * @param {string[]} candidate_labels
     * @param {Object} options Additional options:
     * @param {string} [options.hypothesis_template="This example is {}."] The template used to turn each
     * candidate label into an NLI-style hypothesis. The candidate label will replace the {} placeholder.
     * @param {boolean} [options.multi_label=false] Whether or not multiple candidate labels can be true.
     * If `false`, the scores are normalized such that the sum of the label likelihoods for each sequence
     * is 1. If `true`, the labels are considered independent and probabilities are normalized for each
     * candidate by doing a softmax of the entailment score vs. the contradiction score.
     * @return {Promise<Object|Object[]>} The prediction(s), as a map (or list of maps) from label to score.
     */
    // @ts-ignore
    async _call(texts, candidate_labels, {
        hypothesis_template = "This example is {}.",
        multi_label = false,
    } = {}) {

        let isBatched = Array.isArray(texts);

        if (!isBatched) {
            texts = [texts];
        }
        if (!Array.isArray(candidate_labels)) {
            candidate_labels = [candidate_labels];
        }

        // Insert labels into hypothesis template
        let hypotheses = candidate_labels.map(
            x => hypothesis_template.replace('{}', x)
        );

        // How to perform the softmax over the logits:
        //  - true:  softmax over the entailment vs. contradiction dim for each label independently
        //  - false: softmax the "entailment" logits over all candidate labels
        let softmaxEach = multi_label || candidate_labels.length === 1;

        let toReturn = [];
        for (let premise of texts) {
            let entails_logits = [];

            for (let hypothesis of hypotheses) {
                let inputs = this.tokenizer(premise, {
                    text_pair: hypothesis,
                    padding: true,
                    truncation: true,
                })
                let outputs = await this.model(inputs)

                if (softmaxEach) {
                    entails_logits.push([
                        outputs.logits.data[this.contradiction_id],
                        outputs.logits.data[this.entailment_id]
                    ])
                } else {
                    entails_logits.push(outputs.logits.data[this.entailment_id])
                }
            }

            let scores;
            if (softmaxEach) {
                scores = entails_logits.map(x => (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(x)[1]);
            } else {
                scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(entails_logits);
            }

            // Sort by scores (desc) and return scores with indices
            let scores_sorted = scores
                .map((x, i) => [x, i])
                .sort((a, b) => {
                    return b[0] - a[0];
                });

            toReturn.push({
                sequence: premise,
                labels: scores_sorted.map(x => candidate_labels[x[1]]),
                scores: scores_sorted.map(x => x[0]),
            });
        }
        return isBatched ? toReturn : toReturn[0];
    }
}


/**
 * Feature extraction pipeline using no model head. This pipeline extracts the hidden
 * states from the base transformer, which can be used as features in downstream tasks.
 * 
 * **Example:** Run feature extraction with `bert-base-uncased` (without pooling/normalization).
 * ```javascript
 * let extractor = await pipeline('feature-extraction', 'Xenova/bert-base-uncased', { revision: 'default' });
 * let result = await extractor('This is a simple test.');
 * console.log(result);
 * // Tensor {
 * //     type: 'float32',
 * //     data: Float32Array [0.05939924716949463, 0.021655935794115067, ...],
 * //     dims: [1, 8, 768]
 * // }
 * ```
 * 
 * **Example:** Run feature extraction with `bert-base-uncased` (with pooling/normalization).
 * ```javascript
 * let extractor = await pipeline('feature-extraction', 'Xenova/bert-base-uncased', { revision: 'default' });
 * let result = await extractor('This is a simple test.', { pooling: 'mean', normalize: true });
 * console.log(result);
 * // Tensor {
 * //     type: 'float32',
 * //     data: Float32Array [0.03373778983950615, -0.010106077417731285, ...],
 * //     dims: [1, 768]
 * // }
 * ```
 * 
 * **Example:** Calculating embeddings with `sentence-transformers` models.
 * ```javascript
 * let extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
 * let result = await extractor('This is a simple test.', { pooling: 'mean', normalize: true });
 * console.log(result);
 * // Tensor {
 * //     type: 'float32',
 * //     data: Float32Array [0.09094982594251633, -0.014774246141314507, ...],
 * //     dims: [1, 384]
 * // }
 * ```
 * @extends Pipeline
 */
class FeatureExtractionPipeline extends Pipeline {

    /**
     * Extract the features of the input(s).
     * 
     * @param {string|string[]} texts The input texts
     * @param {Object} options Additional options:
     * @param {string} [options.pooling="none"] The pooling method to use. Can be one of: "none", "mean".
     * @param {boolean} [options.normalize=false] Whether or not to normalize the embeddings in the last dimension.
     * @returns The features computed by the model.
     */
    async _call(texts, {
        pooling = 'none',
        normalize = false,
    } = {}) {
        let [inputs, outputs] = await super._call(texts);

        // TODO: Provide warning to the user that they might be using model which was not exported
        // specifically for feature extraction
        // console.log(this.model.config)
        // console.log(outputs)

        let result = outputs.last_hidden_state ?? outputs.logits;
        if (pooling === 'none') {
            // Skip pooling
        } else if (pooling === 'mean') {
            result = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_6__.mean_pooling)(result, inputs.attention_mask);
        } else {
            throw Error(`Pooling method '${pooling}' not supported.`);
        }

        if (normalize) {
            result = result.normalize(2, -1);
        }

        return result;
    }
}

// TODO
// export class SentenceSimilarityPipeline extends Pipeline {
// }


/**
 * Pipeline that aims at extracting spoken text contained within some audio.
 *
 * **Example:** Transcribe English.
 * ```javascript
 * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/jfk.wav';
 * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en');
 * let output = await transcriber(url);
 * // { text: " And so my fellow Americans ask not what your country can do for you, ask what you can do for your country." }
 * ```
 * 
 * **Example:** Transcribe English w/ timestamps.
 * ```javascript
 * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/jfk.wav';
 * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en');
 * let output = await transcriber(url, { return_timestamps: true });
 * // {
 * //   text: " And so my fellow Americans ask not what your country can do for you, ask what you can do for your country."
 * //   chunks: [
 * //     { timestamp: [0, 8],  text: " And so my fellow Americans ask not what your country can do for you" }
 * //     { timestamp: [8, 11], text: " ask what you can do for your country." }
 * //   ]
 * // }
 * ```
 * 
 * **Example:** Transcribe English w/ word-level timestamps.
 * ```javascript
 * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/jfk.wav';
 * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en', {
 *     revision: 'output_attentions',
 * });
 * let output = await transcriber(url, { return_timestamps: 'word' });
 * // {
 * //   "text": " And so my fellow Americans ask not what your country can do for you ask what you can do for your country.",
 * //   "chunks": [
 * //     { "text": " And", "timestamp": [0, 0.78] },
 * //     { "text": " so", "timestamp": [0.78, 1.06] },
 * //     { "text": " my", "timestamp": [1.06, 1.46] },
 * //     ...
 * //     { "text": " for", "timestamp": [9.72, 9.92] },
 * //     { "text": " your", "timestamp": [9.92, 10.22] },
 * //     { "text": " country.", "timestamp": [10.22, 13.5] }
 * //   ]
 * // }
 * ```
 * 
 * **Example:** Transcribe French.
 * ```javascript
 * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/french-audio.mp3';
 * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-small');
 * let output = await transcriber(url, { language: 'french', task: 'transcribe' });
 * // { text: " J'adore, j'aime, je n'aime pas, je déteste." }
 * ```
 * 
 * **Example:** Translate French to English.
 * ```javascript
 * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/french-audio.mp3';
 * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-small');
 * let output = await transcriber(url, { language: 'french', task: 'translate' });
 * // { text: " I love, I like, I don't like, I hate." }
 * ```
 * 
 * **Example:** Transcribe/translate audio longer than 30 seconds.
 * ```javascript
 * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/ted_60.wav';
 * let transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en');
 * let output = await transcriber(url, { chunk_length_s: 30, stride_length_s: 5 });
 * // { text: " So in college, I was a government major, which means [...] So I'd start off light and I'd bump it up" }
 * ```
 * @extends Pipeline
 */
class AutomaticSpeechRecognitionPipeline extends Pipeline {

    /**
     * Create a new AutomaticSpeechRecognitionPipeline.
     * @param {string} task The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.
     * @param {PreTrainedModel} model The model to use.
     * @param {Processor} processor The processor to use.
     */
    constructor(task, tokenizer, model, processor) {
        super(task, tokenizer, model);
        this.processor = processor;
    }

    /**
     * Preprocesses the input audio for the AutomaticSpeechRecognitionPipeline.
     * @param {any} audio The audio to be preprocessed.
     * @param {number} sampling_rate The sampling rate of the audio.
     * @returns {Promise<Float32Array>} A promise that resolves to the preprocessed audio data.
     * @private
     */
    async _preprocess(audio, sampling_rate) {
        if ((0,_utils_core_js__WEBPACK_IMPORTED_MODULE_3__.isString)(audio)) {
            audio = await (0,_utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.read_audio)(audio, sampling_rate);
        }

        return audio;
    }

    /**
     * @typedef {import('./utils/tensor.js').Tensor} Tensor
     * @typedef {{stride: number[], input_features: Tensor, is_last: boolean, tokens?: number[], token_timestamps?: number[]}} Chunk
     * 
     * @callback ChunkCallback
     * @param {Chunk} chunk The chunk to process.
     */

    /**
     * Asynchronously processes audio and generates text transcription using the model.
     * @param {Float32Array|Float32Array[]} audio The audio to be transcribed. Can be a single Float32Array or an array of Float32Arrays.
     * @param {Object} [kwargs={}] Optional arguments.
     * @param {boolean|'word'} [kwargs.return_timestamps] Whether to return timestamps or not. Default is `false`.
     * @param {number} [kwargs.chunk_length_s] The length of audio chunks to process in seconds. Default is 0 (no chunking).
     * @param {number} [kwargs.stride_length_s] The length of overlap between consecutive audio chunks in seconds. If not provided, defaults to `chunk_length_s / 6`.
     * @param {ChunkCallback} [kwargs.chunk_callback] Callback function to be called with each chunk processed.
     * @param {boolean} [kwargs.force_full_sequences] Whether to force outputting full sequences or not. Default is `false`.
     * @param {string} [kwargs.language] The source language. Default is `null`, meaning it should be auto-detected. Use this to potentially improve performance if the source language is known.
     * @param {string} [kwargs.task] The task to perform. Default is `null`, meaning it should be auto-detected.
     * @param {number[][]} [kwargs.forced_decoder_ids] A list of pairs of integers which indicates a mapping from generation indices to token indices
     * that will be forced before sampling. For example, [[1, 123]] means the second generated token will always be a token of index 123.
     * @returns {Promise<Object>} A Promise that resolves to an object containing the transcription text and optionally timestamps if `return_timestamps` is `true`.
     */
    async _call(audio, kwargs = {}) {
        let return_timestamps = kwargs.return_timestamps ?? false;
        let chunk_length_s = kwargs.chunk_length_s ?? 0;
        let stride_length_s = kwargs.stride_length_s ?? null;
        let chunk_callback = kwargs.chunk_callback ?? null;
        let force_full_sequences = kwargs.force_full_sequences ?? false;

        if (return_timestamps === 'word') {
            kwargs['return_token_timestamps'] = true;
        }

        let language = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_3__.pop)(kwargs, 'language', null);
        let task = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_3__.pop)(kwargs, 'task', null);

        if (language || task || return_timestamps) {
            if (kwargs.forced_decoder_ids) {
                throw new Error("Cannot specify `language`/`task`/`return_timestamps` and `forced_decoder_ids` at the same time.")
            }
            // @ts-ignore
            let decoder_prompt_ids = this.tokenizer.get_decoder_prompt_ids({ language, task, no_timestamps: !return_timestamps })
            if (decoder_prompt_ids.length > 0) {
                kwargs.forced_decoder_ids = decoder_prompt_ids;
            }
        }

        let single = !Array.isArray(audio);
        if (single) {
            // @ts-ignore
            audio = [audio];
        }

        const sampling_rate = this.processor.feature_extractor.config.sampling_rate;
        const time_precision = this.processor.feature_extractor.config.chunk_length / this.model.config.max_source_positions;

        let toReturn = [];
        for (let aud of audio) {
            aud = await this._preprocess(aud, sampling_rate)

            /** @type {Chunk[]} */
            let chunks = [];
            if (chunk_length_s > 0) {
                if (stride_length_s === null) {
                    stride_length_s = chunk_length_s / 6;
                } else if (chunk_length_s <= stride_length_s) {
                    throw Error("`chunk_length_s` must be larger than `stride_length_s`.")
                }

                // TODO support different stride_length_s (for left and right)

                const window = sampling_rate * chunk_length_s;
                const stride = sampling_rate * stride_length_s;
                const jump = window - 2 * stride;
                let offset = 0;

                // Create subarrays of audio with overlaps

                while (offset < aud.length) {
                    let subarr = aud.subarray(offset, offset + window);
                    let feature = await this.processor(subarr);

                    let isFirst = offset === 0;
                    let isLast = offset + jump >= aud.length;
                    chunks.push({
                        stride: [
                            subarr.length,
                            isFirst ? 0 : stride,
                            isLast ? 0 : stride
                        ],
                        input_features: feature.input_features,
                        is_last: isLast
                    })
                    offset += jump;
                }

            } else {
                chunks = [{
                    stride: [aud.length, 0, 0],
                    input_features: (await this.processor(aud)).input_features,
                    is_last: true
                }]
            }

            // Generate for each set of input features
            for (let chunk of chunks) {
                // NOTE: doing sequentially for now
                let data = await this.model.generate(chunk.input_features, kwargs);

                // TODO: Right now we only get top beam
                if (return_timestamps === 'word') {
                    chunk.tokens = data.sequences[0];
                    chunk.token_timestamps = data.token_timestamps.tolist()[0].map(
                        x => (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.round)(x, 2)
                    );

                } else {
                    chunk.tokens = data[0];
                }

                // convert stride to seconds
                chunk.stride = chunk.stride.map(x => x / sampling_rate);

                if (chunk_callback !== null) {
                    chunk_callback(chunk)
                }
            }

            // Merge text chunks
            // @ts-ignore
            let [full_text, optional] = this.tokenizer._decode_asr(chunks, {
                time_precision, return_timestamps, force_full_sequences
            });

            toReturn.push({ text: full_text, ...optional })
        }
        return single ? toReturn[0] : toReturn;
    }
}

/**
 * Image To Text pipeline using a `AutoModelForVision2Seq`. This pipeline predicts a caption for a given image.
 * @extends Pipeline
 */
class ImageToTextPipeline extends Pipeline {
    /**
     * Create a new ImageToTextPipeline.
     * @param {string} task The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.
     * @param {PreTrainedModel} model The model to use.
     * @param {Processor} processor The processor to use.
     */
    constructor(task, tokenizer, model, processor) {
        super(task, tokenizer, model);
        this.processor = processor;
    }

    /**
     * Assign labels to the image(s) passed as inputs.
     * @param {any[]} images The images to be captioned.
     * @param {Object} [generate_kwargs={}] Optional generation arguments.
     * @returns {Promise<Object|Object[]>} A Promise that resolves to an object (or array of objects) containing the generated text(s).
     */
    async _call(images, generate_kwargs = {}) {
        let isBatched = Array.isArray(images);

        images = await prepareImages(images);

        let { pixel_values } = await this.processor(images);

        let toReturn = [];
        for (let batch of pixel_values) {
            batch.dims = [1, ...batch.dims]
            let output = await this.model.generate(batch, generate_kwargs);
            let decoded = this.tokenizer.batch_decode(output, {
                skip_special_tokens: true,
            }).map(x => {
                return { generated_text: x.trim() }
            })
            toReturn.push(decoded);
        }

        return isBatched ? toReturn : toReturn[0];
    }
}

/**
 * Image classification pipeline using any `AutoModelForImageClassification`.
 * This pipeline predicts the class of an image.
 * 
 * **Example:** Classify an image.
 * ```javascript
 * let classifier = await pipeline('image-classification', 'Xenova/vit-base-patch16-224');
 * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/tiger.jpg';
 * let outputs = await classifier(url);
 * // Array(1) [
 * //   {label: 'tiger, Panthera tigris', score: 0.632695734500885},
 * // ]
 * ```
 * 
 * **Example:** Classify an image and return top `n` classes.
 * ```javascript
 * let classifier = await pipeline('image-classification', 'Xenova/vit-base-patch16-224');
 * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/tiger.jpg';
 * let outputs = await classifier(url, { topk: 3 });
 * // Array(3) [
 * //   {label: 'tiger, Panthera tigris', score: 0.632695734500885},
 * //   {label: 'tiger cat', score: 0.3634825646877289},
 * //   {label: 'lion, king of beasts, Panthera leo', score: 0.00045060308184474707},
 * // ]
 * ```
 * 
 * **Example:** Classify an image and return all classes.
 * ```javascript
 * let classifier = await pipeline('image-classification', 'Xenova/vit-base-patch16-224');
 * let url = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/tiger.jpg';
 * let outputs = await classifier(url, { topk: 0 });
 * // Array(1000) [
 * //   {label: 'tiger, Panthera tigris', score: 0.632695734500885},
 * //   {label: 'tiger cat', score: 0.3634825646877289},
 * //   {label: 'lion, king of beasts, Panthera leo', score: 0.00045060308184474707},
 * //   {label: 'jaguar, panther, Panthera onca, Felis onca', score: 0.00035465499968267977},
 * //   ...
 * // ]
 * ```
 * @extends Pipeline
 */
class ImageClassificationPipeline extends Pipeline {
    /**
     * Create a new ImageClassificationPipeline.
     * @param {string} task The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedModel} model The model to use.
     * @param {Processor} processor The processor to use.
     */
    constructor(task, model, processor) {
        super(task, null, model); // TODO tokenizer
        this.processor = processor;
    }

    /**
     * Classify the given images.
     * @param {any} images The images to classify.
     * @param {Object} options The options to use for classification.
     * @param {number} [options.topk=1] The number of top results to return.
     * @returns {Promise<any>} The top classification results for the images.
     */
    async _call(images, {
        topk = 1
    } = {}) {
        let isBatched = Array.isArray(images);
        images = await prepareImages(images);

        let { pixel_values } = await this.processor(images);
        let output = await this.model({ pixel_values });

        let id2label = this.model.config.id2label;
        let toReturn = [];
        for (let batch of output.logits) {
            let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.getTopItems)((0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(batch.data), topk);

            let vals = scores.map(function (x) {
                return {
                    label: id2label[x[0]],
                    score: x[1],
                }
            });
            if (topk === 1) {
                toReturn.push(...vals);
            } else {
                toReturn.push(vals);
            }
        }

        return isBatched || topk === 1 ? toReturn : toReturn[0];
    }

}

/**
 * Image segmentation pipeline using any `AutoModelForXXXSegmentation`.
 * This pipeline predicts masks of objects and their classes.
 * @extends Pipeline
 */
class ImageSegmentationPipeline extends Pipeline {
    /**
     * Create a new ImageSegmentationPipeline.
     * @param {string} task The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedModel} model The model to use.
     * @param {Processor} processor The processor to use.
     */
    constructor(task, model, processor) {
        super(task, null, model); // TODO tokenizer
        this.processor = processor;

        this.subtasks_mapping = {
            // Mapping of subtasks to their corresponding post-processing function names.
            panoptic: 'post_process_panoptic_segmentation',
            instance: 'post_process_instance_segmentation',
            semantic: 'post_process_semantic_segmentation'
        }
    }

    /**
     * Segment the input images.
     * @param {Array} images The input images.
     * @param {Object} options The options to use for segmentation.
     * @param {number} [options.threshold=0.5] Probability threshold to filter out predicted masks.
     * @param {number} [options.mask_threshold=0.5] Threshold to use when turning the predicted masks into binary values.
     * @param {number} [options.overlap_mask_area_threshold=0.8] Mask overlap threshold to eliminate small, disconnected segments.
     * @param {null|string} [options.subtask=null] Segmentation task to be performed. One of [`panoptic`, `instance`, and `semantic`], depending on model capabilities. If not set, the pipeline will attempt to resolve (in that order).
     * @param {Array} [options.label_ids_to_fuse=null] List of label ids to fuse. If not set, do not fuse any labels.
     * @param {Array} [options.target_sizes=null] List of target sizes for the input images. If not set, use the original image sizes.
     * @returns {Promise<Array>} The annotated segments.
     */
    async _call(images, {
        threshold = 0.5,
        mask_threshold = 0.5,
        overlap_mask_area_threshold = 0.8,
        label_ids_to_fuse = null,
        target_sizes = null,
        subtask = null, // TODO use
    } = {}) {
        let isBatched = Array.isArray(images);

        if (isBatched && images.length !== 1) {
            throw Error("Image segmentation pipeline currently only supports a batch size of 1.");
        }

        images = await prepareImages(images);
        let imageSizes = images.map(x => [x.height, x.width]);

        let { pixel_values, pixel_mask } = await this.processor(images);
        let output = await this.model({ pixel_values, pixel_mask });

        let fn = null;
        if (subtask !== null) {
            fn = this.subtasks_mapping[subtask];
        } else {
            for (let [task, func] of Object.entries(this.subtasks_mapping)) {
                if (func in this.processor.feature_extractor) {
                    fn = this.processor.feature_extractor[func].bind(this.processor.feature_extractor);
                    subtask = task;
                    break;
                }
            }
        }

        // add annotations
        let annotation = [];

        if (subtask === 'panoptic' || subtask === 'instance') {

            let processed = fn(
                output,
                threshold,
                mask_threshold,
                overlap_mask_area_threshold,
                label_ids_to_fuse,
                target_sizes ?? imageSizes, // TODO FIX?
            )[0];

            let segmentation = processed.segmentation;
            let id2label = this.model.config.id2label;

            for (let segment of processed.segments_info) {
                let maskData = new Uint8ClampedArray(segmentation.data.length);
                for (let i = 0; i < segmentation.data.length; ++i) {
                    if (segmentation.data[i] === segment.id) {
                        maskData[i] = 255;
                    }
                }

                let mask = new _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage(maskData, segmentation.dims[1], segmentation.dims[0], 1)

                annotation.push({
                    score: segment.score,
                    label: id2label[segment.label_id],
                    mask: mask
                })
            }

        } else if (subtask === 'semantic') {
            throw Error(`semantic segmentation not yet supported.`);

        } else {
            throw Error(`Subtask ${subtask} not supported.`);
        }

        return annotation;
    }
}


/**
 * Zero shot image classification pipeline. This pipeline predicts the class of
 * an image when you provide an image and a set of `candidate_labels`.
 * @extends Pipeline
 */
class ZeroShotImageClassificationPipeline extends Pipeline {

    /**
     * Create a new ZeroShotImageClassificationPipeline.
     * @param {string} task The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedTokenizer} tokenizer The tokenizer to use.
     * @param {PreTrainedModel} model The model to use.
     * @param {Processor} processor The processor to use.
     */
    constructor(task, tokenizer, model, processor) {
        super(task, tokenizer, model);
        this.processor = processor;
    }

    /**
     * Classify the input images with candidate labels using a zero-shot approach.
     * @param {Array} images The input images.
     * @param {Array} candidate_labels The candidate labels.
     * @param {Object} options The options for the classification.
     * @param {string} [options.hypothesis_template] The hypothesis template to use for zero-shot classification. Default: "This is a photo of {}".
     * @returns {Promise<any>} An array of classifications for each input image or a single classification object if only one input image is provided.
     */
    // @ts-ignore
    async _call(images, candidate_labels, {
        hypothesis_template = "This is a photo of {}"
    } = {}) {
        let isBatched = Array.isArray(images);
        images = await prepareImages(images);

        // Insert label into hypothesis template 
        let texts = candidate_labels.map(
            x => hypothesis_template.replace('{}', x)
        );

        // Run tokenization
        let text_inputs = this.tokenizer(texts, {
            padding: true,
            truncation: true
        });

        // Run processor
        let { pixel_values } = await this.processor(images);

        // Run model with both text and pixel inputs
        let output = await this.model({ ...text_inputs, pixel_values });

        // Compare each image with each candidate label
        let toReturn = [];
        for (let batch of output.logits_per_image) {
            // Compute softmax per image
            let probs = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_4__.softmax)(batch.data);

            toReturn.push([...probs].map((x, i) => {
                return {
                    score: x,
                    label: candidate_labels[i]
                }
            }));
        }

        return isBatched ? toReturn : toReturn[0];
    }
}

/**
 * Object detection pipeline using any `AutoModelForObjectDetection`.
 * This pipeline predicts bounding boxes of objects and their classes.
 * 
 * **Example:** Run object-detection with `facebook/detr-resnet-50`.
 * ```javascript
 * let img = 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/cats.jpg';
 * 
 * let detector = await pipeline('object-detection', 'Xenova/detr-resnet-50');
 * let output = await detector(img, { threshold: 0.9 });
 * // [{
 * //   "score": 0.9976370930671692,
 * //   "label": "remote",
 * //   "box": { "xmin": 31, "ymin": 68, "xmax": 190, "ymax": 118 }
 * // },
 * // ...
 * // {
 * //   "score": 0.9984092116355896,
 * //   "label": "cat",
 * //   "box": { "xmin": 331, "ymin": 19, "xmax": 649, "ymax": 371 }
 * // }]
 * ```
 * 
 * @extends Pipeline
 */
class ObjectDetectionPipeline extends Pipeline {
    /**
     * Create a new ObjectDetectionPipeline.
     * @param {string} task The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedModel} model The model to use.
     * @param {Processor} processor The processor to use.
     */
    constructor(task, model, processor) {
        super(task, null, model); // TODO tokenizer
        this.processor = processor;
    }

    /**
     * Detect objects (bounding boxes & classes) in the image(s) passed as inputs.
     * @param {any[]} images The input images.
     * @param {Object} options The options for the object detection.
     * @param {number} [options.threshold=0.9] The threshold used to filter boxes by score.
     * @param {boolean} [options.percentage=false] Whether to return the boxes coordinates in percentage (true) or in pixels (false).
     */
    async _call(images, {
        threshold = 0.9,
        percentage = false,
    } = {}) {
        let isBatched = Array.isArray(images);

        if (isBatched && images.length !== 1) {
            throw Error("Object detection pipeline currently only supports a batch size of 1.");
        }
        images = await prepareImages(images);

        let imageSizes = percentage ? null : images.map(x => [x.height, x.width]);

        let { pixel_values, pixel_mask } = await this.processor(images);
        let output = await this.model({ pixel_values, pixel_mask });

        // @ts-ignore
        let processed = this.processor.feature_extractor.post_process_object_detection(output, threshold, imageSizes);

        // Add labels
        let id2label = this.model.config.id2label;

        // Format output
        const result = processed.map(batch => {
            return batch.boxes.map((box, i) => {
                return {
                    score: batch.scores[i],
                    label: id2label[batch.classes[i]],
                    box: this._get_bounding_box(box, !percentage),
                }
            })
        })

        return isBatched ? result : result[0];
    }

    /**
     * Helper function to convert list [xmin, xmax, ymin, ymax] into object { "xmin": xmin, ... }
     * @param {number[]} box The bounding box as a list.
     * @param {boolean} asInteger Whether to cast to integers.
     * @returns {Object} The bounding box as an object.
     * @private
     */
    _get_bounding_box(box, asInteger) {
        if (asInteger) {
            box = box.map(x => x | 0);
        }
        const [xmin, ymin, xmax, ymax] = box;

        return { xmin, ymin, xmax, ymax };
    }
}

const SUPPORTED_TASKS = {
    "text-classification": {
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": TextClassificationPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSequenceClassification,
        "default": {
            // TODO: replace with original
            // "model": "distilbert-base-uncased-finetuned-sst-2-english",
            "model": "Xenova/distilbert-base-uncased-finetuned-sst-2-english",
        },
        "type": "text",
    },
    "token-classification": {
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": TokenClassificationPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForTokenClassification,
        "default": {
            // TODO: replace with original
            // "model": "Davlan/bert-base-multilingual-cased-ner-hrl",
            "model": "Xenova/bert-base-multilingual-cased-ner-hrl",
        },
        "type": "text",
    },
    "question-answering": {
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": QuestionAnsweringPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForQuestionAnswering,
        "default": {
            // TODO: replace with original
            // "model": "distilbert-base-cased-distilled-squad",
            "model": "Xenova/distilbert-base-cased-distilled-squad",
        },
        "type": "text",
    },

    "fill-mask": {
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": FillMaskPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForMaskedLM,
        "default": {
            // TODO: replace with original
            // "model": "bert-base-uncased",
            "model": "Xenova/bert-base-uncased",
        },
        "type": "text",
    },
    "summarization": {
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": SummarizationPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,
        "default": {
            // TODO: replace with original
            // "model": "sshleifer/distilbart-cnn-6-6",
            "model": "Xenova/distilbart-cnn-6-6",
        },
        "type": "text",
    },
    "translation": {
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": TranslationPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,
        "default": {
            // TODO: replace with original
            // "model": "t5-small",
            "model": "Xenova/t5-small",
        },
        "type": "text",
    },
    "text2text-generation": {
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": Text2TextGenerationPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,
        "default": {
            // TODO: replace with original
            // "model": "google/flan-t5-small",
            "model": "Xenova/flan-t5-small",
        },
        "type": "text",
    },
    "text-generation": {
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": TextGenerationPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForCausalLM,
        "default": {
            // TODO: replace with original
            // "model": "gpt2",
            "model": "Xenova/gpt2",
        },
        "type": "text",
    },
    "zero-shot-classification": {
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": ZeroShotClassificationPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSequenceClassification,
        "default": {
            // TODO: replace with original
            // "model": "typeform/distilbert-base-uncased-mnli",
            "model": "Xenova/distilbert-base-uncased-mnli",
        },
        "type": "text",
    },

    "automatic-speech-recognition": {
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": AutomaticSpeechRecognitionPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForSeq2SeqLM,
        "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        "default": {
            // TODO: replace with original
            // "model": "openai/whisper-tiny.en",
            "model": "Xenova/whisper-tiny.en",
        },
        "type": "multimodal",
    },

    "image-to-text": {
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": ImageToTextPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForVision2Seq,
        "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        "default": {
            // TODO: replace with original
            // "model": "nlpconnect/vit-gpt2-image-captioning",
            "model": "Xenova/vit-gpt2-image-captioning",
        },
        "type": "multimodal",
    },

    "image-classification": {
        // no tokenizer
        "pipeline": ImageClassificationPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageClassification,
        "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        "default": {
            // TODO: replace with original
            // "model": "google/vit-base-patch16-224",
            "model": "Xenova/vit-base-patch16-224",
        },
        "type": "multimodal",
    },

    "image-segmentation": {
        // no tokenizer
        "pipeline": ImageSegmentationPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForImageSegmentation,
        "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        "default": {
            // TODO: replace with original
            // "model": "facebook/detr-resnet-50-panoptic",
            "model": "Xenova/detr-resnet-50-panoptic",
        },
        "type": "multimodal",
    },

    "zero-shot-image-classification": {
        // no tokenizer
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": ZeroShotImageClassificationPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel,
        "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        "default": {
            // TODO: replace with original
            // "model": "openai/clip-vit-base-patch32",
            "model": "Xenova/clip-vit-base-patch32",
        },
        "type": "multimodal",
    },

    "object-detection": {
        // no tokenizer
        "pipeline": ObjectDetectionPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModelForObjectDetection,
        "processor": _processors_js__WEBPACK_IMPORTED_MODULE_2__.AutoProcessor,
        "default": {
            // TODO: replace with original
            // "model": "facebook/detr-resnet-50",
            "model": "Xenova/detr-resnet-50",
        },
        "type": "multimodal",
    },

    // This task serves as a useful interface for dealing with sentence-transformers (https://huggingface.co/sentence-transformers).
    "feature-extraction": {
        "tokenizer": _tokenizers_js__WEBPACK_IMPORTED_MODULE_0__.AutoTokenizer,
        "pipeline": FeatureExtractionPipeline,
        "model": _models_js__WEBPACK_IMPORTED_MODULE_1__.AutoModel,
        "default": {
            // TODO: replace with original
            // "model": "sentence-transformers/all-MiniLM-L6-v2",
            "model": "Xenova/all-MiniLM-L6-v2",
        },
        "type": "text",
    },
}


const TASK_ALIASES = {
    "sentiment-analysis": "text-classification",
    "ner": "token-classification",
    "vqa": "visual-question-answering",
    "asr": "automatic-speech-recognition",

    // Add for backwards compatibility
    "embeddings": "feature-extraction",
}

/**
 * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions
 */

/**
 * Utility factory method to build a [`Pipeline`] object.
 *
 * @param {string} task The task of the pipeline.
 * @param {string} [model=null] The name of the pre-trained model to use. If not specified, the default model for the task will be used.
 * @param {PretrainedOptions} [options] Optional parameters for the pipeline.
 * @returns {Promise<Pipeline>} A Pipeline object for the specified task.
 * @throws {Error} If an unsupported pipeline is requested.
 */
async function pipeline(
    task,
    model = null,
    {
        quantized = true,
        progress_callback = null,
        config = null,
        cache_dir = null,
        local_files_only = false,
        revision = 'main',
    } = {}
) {
    // Helper method to construct pipeline

    // Apply aliases
    task = TASK_ALIASES[task] ?? task;

    // Get pipeline info
    let pipelineInfo = SUPPORTED_TASKS[task.split('_', 1)[0]];
    if (!pipelineInfo) {
        throw Error(`Unsupported pipeline: ${task}. Must be one of [${Object.keys(SUPPORTED_TASKS)}]`)
    }

    // Use model if specified, otherwise, use default
    if (!model) {
        model = pipelineInfo.default.model
        console.log(`No model specified. Using default model: "${model}".`);
    }

    let tokenizerClass = pipelineInfo.tokenizer;
    let modelClass = pipelineInfo.model;
    let pipelineClass = pipelineInfo.pipeline;
    let processorClass = pipelineInfo.processor;

    let promises = [];

    let pretrainedOptions = {
        quantized,
        progress_callback,
        config,
        cache_dir,
        local_files_only,
        revision,
    }
    if (tokenizerClass) {
        promises.push(
            tokenizerClass.from_pretrained(model, pretrainedOptions),
        )
    }
    if (modelClass) {
        promises.push(
            modelClass.from_pretrained(model, pretrainedOptions)
        )
    }

    if (processorClass) {
        promises.push(
            processorClass.from_pretrained(model, pretrainedOptions)
        )
    }

    // Load tokenizer and model
    let items = await Promise.all(promises)

    ;(0,_utils_core_js__WEBPACK_IMPORTED_MODULE_3__.dispatchCallback)(progress_callback, {
        'status': 'ready',
        'task': task,
        'model': model,
    });

    return new pipelineClass(task, ...items);

}

/**
 * Compute the Cartesian product of given arrays
 * @param {...Array} a Arrays to compute the product
 * @returns {Array} Returns the computed Cartesian product as an array
 * @private
 */
function product(...a) {
    // Cartesian product of items
    // Adapted from https://stackoverflow.com/a/43053803
    return a.reduce((a, b) => a.flatMap(d => b.map(e => [d, e])));
}


/***/ }),

/***/ "./node_modules/@xenova/transformers/src/processors.js":
/*!*************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/processors.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutoProcessor: () => (/* binding */ AutoProcessor),
/* harmony export */   DetrFeatureExtractor: () => (/* binding */ DetrFeatureExtractor),
/* harmony export */   FeatureExtractor: () => (/* binding */ FeatureExtractor),
/* harmony export */   ImageFeatureExtractor: () => (/* binding */ ImageFeatureExtractor),
/* harmony export */   MobileViTFeatureExtractor: () => (/* binding */ MobileViTFeatureExtractor),
/* harmony export */   Processor: () => (/* binding */ Processor),
/* harmony export */   SamImageProcessor: () => (/* binding */ SamImageProcessor),
/* harmony export */   SamProcessor: () => (/* binding */ SamProcessor),
/* harmony export */   ViTFeatureExtractor: () => (/* binding */ ViTFeatureExtractor),
/* harmony export */   WhisperFeatureExtractor: () => (/* binding */ WhisperFeatureExtractor),
/* harmony export */   WhisperProcessor: () => (/* binding */ WhisperProcessor)
/* harmony export */ });
/* harmony import */ var _utils_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/core.js */ "./node_modules/@xenova/transformers/src/utils/core.js");
/* harmony import */ var _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/hub.js */ "./node_modules/@xenova/transformers/src/utils/hub.js");
/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/maths.js */ "./node_modules/@xenova/transformers/src/utils/maths.js");
/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/tensor.js */ "./node_modules/@xenova/transformers/src/utils/tensor.js");
/* harmony import */ var _utils_image_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/image.js */ "./node_modules/@xenova/transformers/src/utils/image.js");
/* harmony import */ var _utils_audio_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/audio.js */ "./node_modules/@xenova/transformers/src/utils/audio.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");

/**
 * @file Processors are used to prepare non-textual inputs (e.g., image or audio) for a model.
 * 
 * **Example:** Using a `WhisperProcessor` to prepare an audio input for a model.
 * ```javascript
 * import { AutoProcessor, read_audio } from '@xenova/transformers';
 *
 * let processor = await AutoProcessor.from_pretrained('openai/whisper-tiny.en');
 * let audio = await read_audio('https://huggingface.co/datasets/Narsil/asr_dummy/resolve/main/mlk.flac', 16000);
 * let { input_features } = await processor(audio);
 * // Tensor {
 * //   data: Float32Array(240000) [0.4752984642982483, 0.5597258806228638, 0.56434166431427, ...],
 * //   dims: [1, 80, 3000],
 * //   type: 'float32',
 * //   size: 240000,
 * // }
 * ```
 * 
 * @module processors
 */













/**
 * Base class for feature extractors.
 *
 * @extends Callable
 */
class FeatureExtractor extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
    /**
     * Constructs a new FeatureExtractor instance.
     *
     * @param {Object} config The configuration for the feature extractor.
     */
    constructor(config) {
        super();
        this.config = config
    }
}

/**
 * Feature extractor for image models.
 *
 * @extends FeatureExtractor
 */
class ImageFeatureExtractor extends FeatureExtractor {

    /**
     * Constructs a new ImageFeatureExtractor instance.
     *
     * @param {Object} config The configuration for the feature extractor.
     * @param {number[]} config.image_mean The mean values for image normalization.
     * @param {number[]} config.image_std The standard deviation values for image normalization.
     * @param {boolean} config.do_rescale Whether to rescale the image pixel values to the [0,1] range.
     * @param {number} config.rescale_factor The factor to use for rescaling the image pixel values.
     * @param {boolean} config.do_normalize Whether to normalize the image pixel values.
     * @param {boolean} config.do_resize Whether to resize the image.
     * @param {number} config.resample What method to use for resampling.
     * @param {number} config.size The size to resize the image to.
     */
    constructor(config) {
        super(config);

        this.image_mean = this.config.image_mean;
        this.image_std = this.config.image_std;

        this.resample = this.config.resample ?? 2; // 2 => bilinear
        this.do_rescale = this.config.do_rescale ?? true;
        this.rescale_factor = this.config.rescale_factor ?? (1 / 255);
        this.do_normalize = this.config.do_normalize;

        this.do_resize = this.config.do_resize;
        this.size = this.config.size;

        this.do_center_crop = this.config.do_center_crop;
        this.crop_size = this.config.crop_size;
        this.do_convert_rgb = this.config.do_convert_rgb ?? true;

        this.pad_size = this.config.pad_size;
        this.do_pad = (this.config.do_pad ?? false) && this.pad_size;
    }

    /**
     * Preprocesses the given image.
     *
     * @param {RawImage} image The image to preprocess.
     * @returns {Promise<any>} The preprocessed image as a Tensor.
     */
    async preprocess(image) {

        // First, convert image to RGB if specified in config.
        if (this.do_convert_rgb) {
            image = image.rgb();
        }

        const srcWidth = image.width;   // original width
        const srcHeight = image.height; // original height

        // Next, resize all images
        if (this.do_resize) {
            // TODO:
            // For efficiency reasons, it might be best to merge the resize and center crop operations into one.

            // `this.size` comes in many forms, so we need to handle them all here:
            // 1. `this.size` is an integer, in which case we resize the image to be a square 

            let shortest_edge;
            let longest_edge;

            // Support both formats for backwards compatibility
            if (Number.isInteger(this.size)) {
                shortest_edge = this.size;
                longest_edge = this.config.max_size ?? shortest_edge;

            } else {
                // Extract known properties from `this.size`
                shortest_edge = this.size.shortest_edge;
                longest_edge = this.size.longest_edge;
            }

            // If `longest_edge` and `shortest_edge` are set, maintain aspect ratio and resize to `shortest_edge`
            // while keeping the largest dimension <= `longest_edge`
            if (shortest_edge !== undefined || longest_edge !== undefined) {
                // http://opensourcehacker.com/2011/12/01/calculate-aspect-ratio-conserving-resize-for-images-in-javascript/
                // Try resize so that shortest edge is `this.shortest_edge` (target)
                const shortResizeFactor = shortest_edge === undefined
                    ? 1 // If `shortest_edge` is not set, don't upscale
                    : Math.max(shortest_edge / srcWidth, shortest_edge / srcHeight);

                const newWidth = srcWidth * shortResizeFactor;
                const newHeight = srcHeight * shortResizeFactor;

                // The new width and height might be greater than `this.longest_edge`, so
                // we downscale again to ensure the largest dimension is `this.longest_edge` 
                const longResizeFactor = longest_edge === undefined
                    ? 1 // If `longest_edge` is not set, don't downscale
                    : Math.min(longest_edge / newWidth, longest_edge / newHeight);

                // To avoid certain floating point precision issues, we round to 3 decimal places
                const finalWidth = Math.floor(Number((newWidth * longResizeFactor).toPrecision(3)));
                const finalHeight = Math.floor(Number((newHeight * longResizeFactor).toPrecision(3)));

                // Perform resize
                image = await image.resize(finalWidth, finalHeight, {
                    resample: this.resample,
                });

            } else if (this.size.width !== undefined && this.size.height !== undefined) {
                // If `width` and `height` are set, resize to those dimensions
                image = await image.resize(this.size.width, this.size.height, {
                    resample: this.resample,
                });
            } else {
                throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(this.size)}`);
            }
        }

        if (this.do_center_crop) {

            let crop_width;
            let crop_height;
            if (Number.isInteger(this.crop_size)) {
                crop_width = this.crop_size;
                crop_height = this.crop_size;
            } else {
                crop_width = this.crop_size.width;
                crop_height = this.crop_size.height;
            }

            image = await image.center_crop(crop_width, crop_height);
        }

        let reshaped_input_size = [image.height, image.width];

        // TODO is it okay to pad before rescaling/normalizing?
        if (this.do_pad) {
            let left = 0;
            let right = this.pad_size.width - image.width;
            let top = 0;
            let bottom = this.pad_size.height - image.height;

            image = await image.pad([left, right, top, bottom]);
        }

        const pixelData = Float32Array.from(image.data);

        if (this.do_rescale) {
            for (let i = 0; i < pixelData.length; ++i) {
                pixelData[i] = this.rescale_factor * pixelData[i];
            }
        }

        if (this.do_normalize) {
            let image_mean = this.image_mean;
            if (!Array.isArray(this.image_mean)) {
                image_mean = new Array(image.channels).fill(image_mean);
            }

            let image_std = this.image_std;
            if (!Array.isArray(this.image_std)) {
                image_std = new Array(image.channels).fill(image_mean);
            }

            if (image_mean.length !== image.channels || image_std.length !== image.channels) {
                throw new Error(`When set to arrays, the length of \`image_mean\` (${image_mean.length}) and \`image_std\` (${image_std.length}) must match the number of channels in the image (${image.channels}).`);
            }

            for (let i = 0; i < pixelData.length; i += image.channels) {
                for (let j = 0; j < image.channels; ++j) {
                    pixelData[i + j] = (pixelData[i + j] - this.image_mean[j]) / this.image_std[j];
                }
            }
        }

        // convert to channel dimension format:
        let imgDims = [image.height, image.width, image.channels];
        let img = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor('float32', pixelData, imgDims);
        let transposed = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.transpose)(img, [2, 0, 1]); // hwc -> chw

        return {
            original_size: [srcHeight, srcWidth],
            reshaped_input_size: reshaped_input_size,
            pixel_values: transposed,
        }
    }

    /**
     * Calls the feature extraction process on an array of image
     * URLs, preprocesses each image, and concatenates the resulting
     * features into a single Tensor.
     * @param {any} images The URL(s) of the image(s) to extract features from.
     * @returns {Promise<Object>} An object containing the concatenated pixel values (and other metadata) of the preprocessed images.
     */
    async _call(images) {
        if (!Array.isArray(images)) {
            images = [images];
        }

        let imageData = await Promise.all(images.map(x => this.preprocess(x)));

        // TODO:

        // Concatenate pixel values
        // TEMP: Add batch dimension so that concat works
        imageData.forEach(x => x.pixel_values.dims = [1, ...x.pixel_values.dims]);
        let pixel_values = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.cat)(imageData.map(x => x.pixel_values));

        return {
            pixel_values: pixel_values,

            // Original sizes of images
            original_sizes: imageData.map(x => x.original_size),

            // Reshaped sizes of images, before padding or cropping
            reshaped_input_sizes: imageData.map(x => x.reshaped_input_size),
        }
    }

}

class ViTFeatureExtractor extends ImageFeatureExtractor { }
class MobileViTFeatureExtractor extends ImageFeatureExtractor { }

/**
 * Detr Feature Extractor.
 *
 * @extends ImageFeatureExtractor
 */
class DetrFeatureExtractor extends ImageFeatureExtractor {
    /**
     * Calls the feature extraction process on an array of image
     * URLs, preprocesses each image, and concatenates the resulting
     * features into a single Tensor.
     * @param {any} urls The URL(s) of the image(s) to extract features from.
     * @returns {Promise<Object>} An object containing the concatenated pixel values of the preprocessed images.
     */
    async _call(urls) {
        let result = await super._call(urls);

        // TODO support differently-sized images, for now assume all images are the same size.
        // TODO support different mask sizes (not just 64x64)
        // Currently, just fill pixel mask with 1s
        let maskSize = [result.pixel_values.dims[0], 64, 64];
        result.pixel_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
            'int64',
            // TODO: fix error below
            new BigInt64Array(maskSize.reduce((a, b) => a * b)).fill(1n),
            maskSize
        );

        return result;
    }

    /**
     * @param {number[]} arr The URL(s) of the image(s) to extract features from.
     * @returns {number[]} An object containing the concatenated pixel values of the preprocessed images.
     */
    center_to_corners_format([centerX, centerY, width, height]) {
        return [
            centerX - width / 2,
            centerY - height / 2,
            centerX + width / 2,
            centerY + height / 2
        ];
    }

    /**
     * Post-processes the outputs of the model (for object detection).
     * @param {Object} outputs The outputs of the model that must be post-processed
     * @param {Tensor} outputs.logits The logits
     * @param {Tensor} outputs.pred_boxes The predicted boxes.
     * @return {Object[]} An array of objects containing the post-processed outputs.
     */
    post_process_object_detection(outputs, threshold = 0.5, target_sizes = null) {
        const out_logits = outputs.logits;
        const out_bbox = outputs.pred_boxes;
        const [batch_size, num_boxes, num_classes] = out_logits.dims;

        if (target_sizes !== null && target_sizes.length !== batch_size) {
            throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits")
        }
        let toReturn = [];
        for (let i = 0; i < batch_size; ++i) {
            let target_size = target_sizes !== null ? target_sizes[i] : null;
            let info = {
                boxes: [],
                classes: [],
                scores: []
            }
            let logits = out_logits[i];
            let bbox = out_bbox[i];

            for (let j = 0; j < num_boxes; ++j) {
                let logit = logits[j];

                // Get most probable class
                let maxIndex = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logit.data)[1];

                if (maxIndex === num_classes - 1) {
                    // This is the background class, skip it
                    continue;
                }

                // Compute softmax over classes
                let probs = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(logit.data);

                let score = probs[maxIndex];
                if (score > threshold) {
                    // Some class has a high enough probability
                    /** @type {number[]} */
                    let box = bbox[j].data;

                    // convert to [x0, y0, x1, y1] format
                    box = this.center_to_corners_format(box)
                    if (target_size !== null) {
                        box = box.map((x, i) => x * target_size[(i + 1) % 2])
                    }

                    info.boxes.push(box);
                    info.classes.push(maxIndex);
                    info.scores.push(score);
                }
            }
            toReturn.push(info);
        }
        return toReturn;
    }

    /**
     * Binarize the given masks using `object_mask_threshold`, it returns the associated values of `masks`, `scores` and `labels`.
     * @param {Tensor} class_logits The class logits.
     * @param {Tensor} mask_logits The mask logits.
     * @param {number} object_mask_threshold A number between 0 and 1 used to binarize the masks.
     * @param {number} num_labels The number of labels.
     * @returns {[Tensor[], number[], number[]]} The binarized masks, the scores, and the labels.
     */
    remove_low_and_no_objects(class_logits, mask_logits, object_mask_threshold, num_labels) {

        let mask_probs_item = [];
        let pred_scores_item = [];
        let pred_labels_item = [];

        for (let j = 0; j < class_logits.dims[0]; ++j) {
            let cls = class_logits[j];
            let mask = mask_logits[j];

            let pred_label = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(cls.data)[1];
            if (pred_label === num_labels) {
                // Is the background, so we ignore it
                continue;
            }

            let scores = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(cls.data);
            let pred_score = scores[pred_label];
            if (pred_score > object_mask_threshold) {
                mask_probs_item.push(mask);
                pred_scores_item.push(pred_score);
                pred_labels_item.push(pred_label);
            }
        }

        return [mask_probs_item, pred_scores_item, pred_labels_item];

    }

    /**
     * Checks whether the segment is valid or not.
     * @param {Int32Array} mask_labels Labels for each pixel in the mask.
     * @param {Tensor[]} mask_probs Probabilities for each pixel in the masks.
     * @param {number} k The class id of the segment.
     * @param {number} mask_threshold The mask threshold.
     * @param {number} overlap_mask_area_threshold The overlap mask area threshold.
     * @returns {[boolean, number[]]} Whether the segment is valid or not, and the indices of the valid labels.
     */
    check_segment_validity(
        mask_labels,
        mask_probs,
        k,
        mask_threshold = 0.5,
        overlap_mask_area_threshold = 0.8
    ) {
        // mask_k is a 1D array of indices, indicating where the mask is equal to k
        let mask_k = [];
        let mask_k_area = 0;
        let original_area = 0;

        // Compute the area of all the stuff in query k
        for (let i = 0; i < mask_labels.length; ++i) {
            if (mask_labels[i] === k) {
                mask_k.push(i);
                ++mask_k_area;
            }

            if (mask_probs[k].data[i] >= mask_threshold) {
                ++original_area;
            }
        }
        let mask_exists = mask_k_area > 0 && original_area > 0;

        // Eliminate disconnected tiny segments
        if (mask_exists) {
            // Perform additional check
            let area_ratio = mask_k_area / original_area;
            mask_exists = area_ratio > overlap_mask_area_threshold;
        }

        return [mask_exists, mask_k]
    }

    /**
     * Computes the segments.
     * @param {Tensor[]} mask_probs The mask probabilities.
     * @param {number[]} pred_scores The predicted scores.
     * @param {number[]} pred_labels The predicted labels.
     * @param {number} mask_threshold The mask threshold.
     * @param {number} overlap_mask_area_threshold The overlap mask area threshold.
     * @param {Set<number>} label_ids_to_fuse The label ids to fuse.
     * @param {number[]} target_size The target size of the image.
     * @returns {[Tensor, Array<{id: number, label_id: number, score: number}>]} The computed segments.
     */
    compute_segments(
        mask_probs,
        pred_scores,
        pred_labels,
        mask_threshold,
        overlap_mask_area_threshold,
        label_ids_to_fuse = null,
        target_size = null,
    ) {
        let [height, width] = target_size ?? mask_probs[0].dims;

        let segmentation = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
            'int32',
            new Int32Array(height * width),
            [height, width]
        );
        let segments = [];

        // 1. If target_size is not null, we need to resize the masks to the target size
        if (target_size !== null) {
            // resize the masks to the target size
            for (let i = 0; i < mask_probs.length; ++i) {
                mask_probs[i] = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(mask_probs[i], target_size, 'bilinear', false);
            }
        }

        // 2. Weigh each mask by its prediction score
        // NOTE: `mask_probs` is updated in-place
        // 
        // Temporary storage for the best label/scores for each pixel ([height, width]):
        let mask_labels = new Int32Array(mask_probs[0].data.length);
        let bestScores = new Float32Array(mask_probs[0].data.length);

        for (let i = 0; i < mask_probs.length; ++i) {
            let score = pred_scores[i];

            for (let j = 0; j < mask_probs[i].data.length; ++j) {
                mask_probs[i].data[j] *= score
                if (mask_probs[i].data[j] > bestScores[j]) {
                    mask_labels[j] = i;
                    bestScores[j] = mask_probs[i].data[j];
                }
            }
        }

        let current_segment_id = 0;

        // let stuff_memory_list = {}
        for (let k = 0; k < pred_labels.length; ++k) {
            let pred_class = pred_labels[k];

            // TODO add `should_fuse`
            // let should_fuse = pred_class in label_ids_to_fuse

            // Check if mask exists and large enough to be a segment
            let [mask_exists, mask_k] = this.check_segment_validity(
                mask_labels,
                mask_probs,
                k,
                mask_threshold,
                overlap_mask_area_threshold
            )

            if (!mask_exists) {
                // Nothing to see here
                continue;
            }

            // TODO
            // if (pred_class in stuff_memory_list) {
            //     current_segment_id = stuff_memory_list[pred_class]
            // } else {
            //     current_segment_id += 1;
            // }
            ++current_segment_id;


            // Add current object segment to final segmentation map
            for (let index of mask_k) {
                segmentation.data[index] = current_segment_id;
            }

            segments.push({
                id: current_segment_id,
                label_id: pred_class,
                // was_fused: should_fuse, TODO
                score: pred_scores[k],
            })

            // TODO
            // if(should_fuse){
            //     stuff_memory_list[pred_class] = current_segment_id
            // }
        }

        return [segmentation, segments];
    }

    /**
     * Post-process the model output to generate the final panoptic segmentation.
     * @param {*} outputs The model output to post process
     * @param {number} [threshold=0.5] The probability score threshold to keep predicted instance masks.
     * @param {number} [mask_threshold=0.5] Threshold to use when turning the predicted masks into binary values.
     * @param {number} [overlap_mask_area_threshold=0.8] The overlap mask area threshold to merge or discard small disconnected parts within each binary instance mask.
     * @param {Set<number>} [label_ids_to_fuse=null] The labels in this state will have all their instances be fused together.
     * @param {number[][]} [target_sizes=null] The target sizes to resize the masks to.
     * @returns {Array<{ segmentation: Tensor, segments_info: Array<{id: number, label_id: number, score: number}>}>}
     */
    post_process_panoptic_segmentation(
        outputs,
        threshold = 0.5,
        mask_threshold = 0.5,
        overlap_mask_area_threshold = 0.8,
        label_ids_to_fuse = null,
        target_sizes = null,
    ) {
        if (label_ids_to_fuse === null) {
            console.warn("`label_ids_to_fuse` unset. No instance will be fused.")
            label_ids_to_fuse = new Set();
        }

        const class_queries_logits = outputs.logits; // [batch_size, num_queries, num_classes+1]
        const masks_queries_logits = outputs.pred_masks; // [batch_size, num_queries, height, width]

        const mask_probs = masks_queries_logits.sigmoid()  // [batch_size, num_queries, height, width]

        let [batch_size, num_queries, num_labels] = class_queries_logits.dims;
        num_labels -= 1; // Remove last class (background)

        if (target_sizes !== null && target_sizes.length !== batch_size) {
            throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits")
        }

        let toReturn = [];
        for (let i = 0; i < batch_size; ++i) {
            let target_size = target_sizes !== null ? target_sizes[i] : null;

            let class_logits = class_queries_logits[i];
            let mask_logits = mask_probs[i];

            let [mask_probs_item, pred_scores_item, pred_labels_item] = this.remove_low_and_no_objects(class_logits, mask_logits, threshold, num_labels);

            if (pred_labels_item.length === 0) {
                // No mask found
                let [height, width] = target_size ?? mask_logits.dims.slice(-2);

                let segmentation = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                    'int32',
                    new Int32Array(height * width).fill(-1),
                    [height, width]
                )
                toReturn.push({
                    segmentation: segmentation,
                    segments_info: []
                });
                continue;
            }


            // Get segmentation map and segment information of batch item
            let [segmentation, segments] = this.compute_segments(
                mask_probs_item,
                pred_scores_item,
                pred_labels_item,
                mask_threshold,
                overlap_mask_area_threshold,
                label_ids_to_fuse,
                target_size,
            )

            toReturn.push({
                segmentation: segmentation,
                segments_info: segments
            })
        }

        return toReturn;
    }

    post_process_instance_segmentation() {
        // TODO
        throw Error("Not implemented yet");
    }
}

class SamImageProcessor extends ImageFeatureExtractor {
    async _call(images, input_points) {
        let {
            pixel_values,
            original_sizes,
            reshaped_input_sizes,
        } = await super._call(images);

        let shape = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.calculateDimensions)(input_points);

        if (shape.length === 3) {
            // Correct user's input
            shape = [1, ...shape];
            input_points = [input_points];
        } else if (shape.length !== 4) {
            throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.")
        }

        // Reshape input points
        for (let i = 0; i < input_points.length; ++i) { // batch_size
            let originalImageSize = original_sizes[i];
            let reshapedImageSize = reshaped_input_sizes[i];

            let resizeFactors = [
                reshapedImageSize[0] / originalImageSize[0],
                reshapedImageSize[1] / originalImageSize[1]
            ]

            for (let j = 0; j < input_points[i].length; ++j) { // point_batch_size
                for (let k = 0; k < input_points[i][j].length; ++k) { // nb_points_per_image
                    for (let w = 0; w < input_points[i][j][k].length; ++w) { // 2
                        input_points[i][j][k][w] *= resizeFactors[w];
                    }
                }
            }
        }

        let input_points_tensor = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
            'int64',
            BigInt64Array.from(input_points.flat(Infinity)
                .map(x => BigInt(Math.round(x)))),
            shape
        )

        // TODO: allowed to be floats?
        // let input_points_tensor = new Tensor(
        //     'float32',
        //     Float32Array.from(input_points.flat(Infinity)),
        //     shape
        // )

        return {
            pixel_values,
            original_sizes: original_sizes,
            reshaped_input_sizes: reshaped_input_sizes,
            input_points: input_points_tensor
        }
    }

    /**
     * Remove padding and upscale masks to the original image size.
     * @param {Tensor} masks Batched masks from the mask_decoder in (batch_size, num_channels, height, width) format.
     * @param {number[][]} original_sizes The original sizes of each image before it was resized to the model's expected input shape, in (height, width) format.
     * @param {number[][]} reshaped_input_sizes The size of each image as it is fed to the model, in (height, width) format. Used to remove padding.
     * @param {Object} options Optional parameters for post-processing.
     * @param {number} [options.mask_threshold] The threshold to use for binarizing the masks.
     * @param {boolean} [options.binarize] Whether to binarize the masks.
     * @param {Object} [options.pad_size] The target size the images were padded to before being passed to the model. If `null`, the target size is assumed to be the processor's `pad_size`.
     * @param {number} [options.pad_size.height] The height the images were padded to.
     * @param {number} [options.pad_size.width] The width the images were padded to.
     * @returns {Tensor[]} Batched masks in batch_size, num_channels, height, width) format, where (height, width) is given by original_size.
     */
    post_process_masks(masks, original_sizes, reshaped_input_sizes, {
        mask_threshold = 0.0,
        binarize = true,
        pad_size = null,
    } = {}) {
        // masks: [1, 1, 3, 256, 256]

        let output_masks = [];

        pad_size = pad_size ?? this.pad_size;

        let target_image_size = [pad_size.height, pad_size.width];

        for (let i = 0; i < original_sizes.length; ++i) {
            let original_size = original_sizes[i];
            let reshaped_input_size = reshaped_input_sizes[i];

            let mask = masks[i]; // [b, c, h, w]

            // TODO: improve
            let interpolated_masks = [];
            for (let j = 0; j < mask.dims[0]; ++j) {
                let m = mask[j]; // 3d tensor

                // Upscale mask to padded size
                let interpolated_mask = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(m, target_image_size, 'bilinear', false);

                // Crop mask
                interpolated_mask = interpolated_mask.slice(null, [0, reshaped_input_size[0]], [0, reshaped_input_size[1]]);

                // Downscale mask
                interpolated_mask = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.interpolate)(mask, original_size, 'bilinear', false);

                if (binarize) {
                    interpolated_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                        'bool',
                        Array.from(interpolated_mask.data).map(x => x > mask_threshold),
                        interpolated_mask.dims
                    )
                }

                // add back batch dim for concat
                interpolated_mask.dims = [1, ...interpolated_mask.dims];

                interpolated_masks.push(interpolated_mask);
            }

            let concatenated = (0,_utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.cat)(interpolated_masks);
            output_masks.push(concatenated);
        }

        return output_masks;

    }
}


class WhisperFeatureExtractor extends FeatureExtractor {

    constructor(config) {
        super(config);

        // Prefer given `mel_filters` from preprocessor_config.json, or calculate them if they don't exist.
        this.config.mel_filters ??= (0,_utils_audio_js__WEBPACK_IMPORTED_MODULE_5__.getMelFilters)(this.config.sampling_rate, this.config.n_fft, this.config.feature_size);
    }
    /**
     * Calculates the index offset for a given index and window size.
     * @param {number} i The index.
     * @param {number} w The window size.
     * @returns {number} The index offset.
     */
    calcOffset(i, w) {
        return Math.abs((i + w) % (2 * w) - w);
    }

    /**
     * Pads an array with a reflected version of itself on both ends.
     * @param {Float32Array} array The array to pad.
     * @param {number} left The amount of padding to add to the left.
     * @param {number} right The amount of padding to add to the right.
     * @returns {Float32Array} The padded array.
     */
    padReflect(array, left, right) {
        const padded = new Float32Array(array.length + left + right);
        const w = array.length - 1;

        for (let i = 0; i < array.length; ++i) {
            padded[left + i] = array[i];
        }

        for (let i = 1; i <= left; ++i) {
            padded[left - i] = array[this.calcOffset(i, w)];
        }

        for (let i = 1; i <= right; ++i) {
            padded[w + left + i] = array[this.calcOffset(w - i, w)];
        }

        return padded;
    }

    /**
     * Calculates the complex Short-Time Fourier Transform (STFT) of the given framed signal.
     * 
     * @param {number[][]} frames A 2D array representing the signal frames.
     * @param {number[]} window A 1D array representing the window to be applied to the frames.
     * @returns {Object} An object with the following properties:
     * - data: A 1D array representing the complex STFT of the signal.
     * - dims: An array representing the dimensions of the STFT data, i.e. [num_frames, num_fft_bins].
     */
    stft(frames, window) {
        // Calculates the complex Short-Time Fourier Transform (STFT) of the given framed signal.
        // 
        // NOTE: Since the window width is not a power of 2, we must 
        // perform Fast Fourier Transform with chirp-z transform:
        // https://math.stackexchange.com/questions/77118/non-power-of-2-ffts/77156#77156

        // Helper variables
        const fft_size = this.config.n_fft;
        const a = 2 * (fft_size - 1);
        const b = 2 * (2 * fft_size - 1);
        const nextP2 = 2 ** (Math.ceil(Math.log2(b)))
        const num_fft_bins = fft_size + 2;

        // Preallocate array to store output
        // double since we store complex numbers
        const data = new Float32Array(num_fft_bins * frames.length);

        // Define buffers
        // Compute chirp for transform
        const chirp = new Float32Array(b);
        const ichirp = new Float32Array(nextP2);
        const buffer1 = new Float32Array(nextP2);
        const buffer2 = new Float32Array(nextP2);
        const outBuffer = new Float32Array(nextP2);
        const outBuffer2 = new Float32Array(nextP2);
        const outBuffer3 = new Float32Array(nextP2);

        // Compute complex exponentiation
        const theta = -2 * Math.PI / fft_size;
        const baseR = Math.cos(theta);
        const baseI = Math.sin(theta);

        // Precompute helper for chirp-z transform
        for (let i = 0; i < b >> 1; ++i) {
            // Compute complex power:
            const e = (i + 1 - fft_size) ** 2 / 2.0;

            // Compute the modulus and argument of the result
            const result_mod = Math.sqrt(baseR ** 2 + baseI ** 2) ** e;
            const result_arg = e * Math.atan2(baseI, baseR);

            // Convert the result back to rectangular form
            // and assign to chirp and ichirp
            let i2 = 2 * i;
            chirp[i2] = result_mod * Math.cos(result_arg);
            chirp[i2 + 1] = result_mod * Math.sin(result_arg);

            // conjugate
            ichirp[i2] = chirp[i2];
            ichirp[i2 + 1] = - chirp[i2 + 1];
        }
        const slicedChirp = chirp.subarray(a, b);

        // create object to perform Fast Fourier Transforms
        // with `nextP2` complex numbers
        const f = new _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.FFT(nextP2 >> 1);
        // TODO: decide between Float32Array and Float64Array
        f.transform(outBuffer, ichirp);

        for (let i = 0; i < frames.length; ++i) {
            const frame = frames[i];

            for (let j = 0; j < slicedChirp.length; j += 2) {
                const j2 = j + 1
                const j3 = j >> 1;

                const a_real = frame[j3] * window[j3];
                buffer1[j] = a_real * slicedChirp[j];
                buffer1[j2] = a_real * slicedChirp[j2];
            }
            // TODO: decide between Float32Array and Float64Array
            f.transform(outBuffer2, buffer1);

            for (let j = 0; j < outBuffer.length; j += 2) {
                const j2 = j + 1;

                buffer2[j] = outBuffer2[j] * outBuffer[j] - outBuffer2[j2] * outBuffer[j2]
                buffer2[j2] = outBuffer2[j] * outBuffer[j2] + outBuffer2[j2] * outBuffer[j]
            }
            // TODO: decide between Float32Array and Float64Array
            f.inverseTransform(outBuffer3, buffer2)

            const offset = i * num_fft_bins;
            for (let j = 0; j < num_fft_bins; j += 2) {
                const a_real = outBuffer3[j + a];
                const a_imag = outBuffer3[j + a + 1];
                const b_real = slicedChirp[j];
                const b_imag = slicedChirp[j + 1];

                // TODO write as transpose
                const o1 = offset + j;
                data[o1] = a_real * b_real - a_imag * b_imag
                data[o1 + 1] = a_real * b_imag + a_imag * b_real
            }
        }

        return {
            data: data,
            dims: [frames.length, num_fft_bins] // [3001, 402]
        };
    }

    /**
     * Creates an array of frames from a given waveform.
     *
     * @param {Float32Array} waveform The waveform to create frames from.
     * @param {boolean} [center=true] Whether to center the frames on their corresponding positions in the waveform. Defaults to true.
     * @returns {Array} An array of frames.
     */
    fram_wave(waveform, center = true) {
        const frames = [];
        const half_window = Math.floor((this.config.n_fft - 1) / 2) + 1;
        const waveformLength = waveform.length;

        for (let i = 0; i < waveformLength + 1; i += this.config.hop_length) {

            let frame;
            if (center) {

                let frameStart = i > half_window ? i - half_window : 0;
                let frameEnd =
                    i < waveformLength - half_window
                        ? i + half_window
                        : waveformLength;

                frame = waveform.subarray(frameStart, frameEnd)

                if (frameStart === 0) {
                    frame = this.padReflect(
                        frame,
                        -i + half_window,
                        0
                    )

                } else if (frameEnd === waveformLength) {
                    frame = this.padReflect(
                        frame,
                        0,
                        i - waveformLength + half_window
                    )
                }

            } else {
                frame = new Float32Array(this.config.n_fft);
                const frameArray = waveform.subarray(i, i + this.config.n_fft);

                if (frameArray.length < this.config.n_fft) {
                    frame.set(frameArray);
                    frame.fill(0, frameArray.length, this.config.n_fft)
                } else {
                    frame = frameArray;
                }

            }
            frames.push(frame);
        }

        return frames;
    }

    /**
     * Generates a Hanning window of length M.
     *
     * @param {number} M The length of the Hanning window to generate.
     * @returns {*} The generated Hanning window.
     */
    hanning(M) {
        if (M < 1) {
            return [];
        }
        if (M === 1) {
            return [1];
        }
        const denom = M - 1;
        const cos_vals = new Float32Array(denom);
        for (let i = 0; i < denom; ++i) {
            const n = 2 * i - M + 1;
            cos_vals[i] = 0.5 + 0.5 * Math.cos(Math.PI * n / denom);
        }
        return cos_vals;
    }

    /**
     * Computes the log-Mel spectrogram of the provided audio waveform.
     * @param {Float32Array|Float64Array} waveform The audio waveform to process.
     * @returns {{data: Float32Array, dims: number[]}} An object containing the log-Mel spectrogram data as a Float32Array and its dimensions as an array of numbers.
     */
    _extract_fbank_features(waveform) {
        // Compute the log-Mel spectrogram of the provided audio

        const buffer = new Float32Array(this.config.n_samples);
        buffer.set(waveform)

        const window = this.hanning(this.config.n_fft + 1)
        const frames = this.fram_wave(buffer)

        const stft = this.stft(frames, window)

        const stftData = stft.data;
        const d1 = stft.dims[0] - 1; // Ignore last row
        const d2 = stft.dims[1] >> 1; // Only need to store real numbers now

        // compute magnitudes
        // NOTE: Unlike the original implementation, we do not
        // transpose since we perform matrix multiplication later
        const magnitudes = new Float32Array(d1 * d2);
        for (let i = 0; i < d1; ++i) {
            for (let j = 0; j < d2; ++j) {
                // let outOffset = (j * d1 + i); // transpose
                let outOffset = i * d2 + j;
                let inOffset = outOffset << 1; // * 2 since complex
                let magnitude = stftData[inOffset] ** 2 + stftData[inOffset + 1] ** 2
                magnitudes[outOffset] = magnitude;
            }
        }

        const mel_filters = this.config.mel_filters;
        const num_mel_filters = mel_filters.length;

        const mel_spec = new Float32Array(num_mel_filters * d1);
        let mIndex = 0;

        // Perform matrix muliplication:
        // mel_spec = filters @ magnitudes
        //  - filters.shape=(80, 201)
        //  - magnitudes.shape=(201, 3000)
        //  - mel_spec.shape=(80, 3000)
        for (let i = 0; i < num_mel_filters; ++i) {
            const mel_filter = mel_filters[i];

            for (let j = 0; j < d1; ++j) {
                let sum = 0;

                // perform dot product
                for (let k = 0; k < d2; ++k) {
                    sum += mel_filter[k] * magnitudes[j * d2 + k];
                }

                mel_spec[mIndex++] = sum;
            }
        }

        const a_min = 1e-10;
        const log_spec = new Float32Array(mel_spec.length);

        let maxLogSpec = 0;
        for (let i = 0; i < mel_spec.length; ++i) {
            const clipped = Math.max(a_min, mel_spec[i]);
            const log10 = Math.log10(clipped);
            log_spec[i] = log10;
            maxLogSpec = Math.max(log10, maxLogSpec)
        }

        for (let i = 0; i < log_spec.length; ++i) {
            log_spec[i] = Math.max(log_spec[i], maxLogSpec - 8);
            log_spec[i] = (log_spec[i] + 4) / 4;
        }

        return {
            data: log_spec,
            dims: [num_mel_filters, d1]
        };
    }

    /**
     * Asynchronously extracts features from a given audio using the provided configuration.
     * @param {Float32Array|Float64Array} audio The audio data as a Float32Array.
     * @returns {Promise<{ input_features: Tensor }>} A Promise resolving to an object containing the extracted input features as a Tensor.
    */
    async _call(audio) {
        if (!(audio instanceof Float32Array || audio instanceof Float64Array)) {
            throw new Error(
                // @ts-ignore
                `WhisperFeatureExtractor expects input to be a Float32Array or a Float64Array, but got ${audio?.constructor?.name ?? typeof audio} instead.` +
                `If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`
            )
        }

        if (audio.length > this.config.n_samples) {
            console.warn(
                "Attempting to extract features for audio longer than 30 seconds. " +
                "If using a pipeline to extract transcript from a long audio clip, " +
                "remember to specify `chunk_length_s` and/or `stride_length_s`."
            );
        }
        let waveform = audio.slice(0, this.config.n_samples);

        let features = this._extract_fbank_features(waveform);

        return {
            input_features: new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor('float32',
                features.data,
                [1, ...features.dims]
            )
        };
    }
}

/**
 * Represents a Processor that extracts features from an input.
 * @extends Callable
 */
class Processor extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
    /**
     * Creates a new Processor with the given feature extractor.
     * @param {FeatureExtractor} feature_extractor The function used to extract features from the input.
     */
    constructor(feature_extractor) {
        super();
        this.feature_extractor = feature_extractor;
        // TODO use tokenizer here?
    }

    /**
     * Calls the feature_extractor function with the given input.
     * @param {any} input The input to extract features from.
     * @returns {Promise<any>} A Promise that resolves with the extracted features.
     */
    async _call(input) {
        return await this.feature_extractor(input);
    }
}

class SamProcessor extends Processor {

    async _call(images, input_points) {
        return await this.feature_extractor(images, input_points);
    }

    /**
     * @borrows SamImageProcessor#post_process_masks as post_process_masks
     */
    post_process_masks(...args) {
        // @ts-ignore
        return this.feature_extractor.post_process_masks(...args);
    }
}

/**
 * Represents a WhisperProcessor that extracts features from an audio input.
 * @extends Processor
 */
class WhisperProcessor extends Processor {
    /**
     * Calls the feature_extractor function with the given audio input.
     * @param {any} audio The audio input to extract features from.
     * @returns {Promise<any>} A Promise that resolves with the extracted features.
     */
    async _call(audio) {
        return await this.feature_extractor(audio)
    }
}

//////////////////////////////////////////////////
/**
 * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions
 */
/**
 * Helper class which is used to instantiate pretrained processors with the `from_pretrained` function.
 * The chosen processor class is determined by the type specified in the processor config.
 * 
 * **Example:** Load a processor using `from_pretrained`.
 * ```javascript
 * let processor = await AutoProcessor.from_pretrained('openai/whisper-tiny.en');
 * ```
 * 
 * **Example:** Run an image through a processor.
 * ```javascript
 * let processor = await AutoProcessor.from_pretrained('Xenova/clip-vit-base-patch16');
 * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');
 * let image_inputs = await processor(image);
 * // {
 * //   "pixel_values": {
 * //     "dims": [ 1, 3, 224, 224 ],
 * //     "type": "float32",
 * //     "data": Float32Array [ -1.558687686920166, -1.558687686920166, -1.5440893173217773, ... ],
 * //     "size": 150528
 * //   },
 * //   "original_sizes": [
 * //     [ 533, 800 ]
 * //   ],
 * //   "reshaped_input_sizes": [
 * //     [ 224, 224 ]
 * //   ]
 * // }
 * ```
 */
class AutoProcessor {
    static FEATURE_EXTRACTOR_CLASS_MAPPING = {
        'WhisperFeatureExtractor': WhisperFeatureExtractor,
        'ViTFeatureExtractor': ViTFeatureExtractor,
        'MobileViTFeatureExtractor': MobileViTFeatureExtractor,
        'DetrFeatureExtractor': DetrFeatureExtractor,

        'SamImageProcessor': SamImageProcessor,
    }

    static PROCESSOR_CLASS_MAPPING = {
        'WhisperProcessor': WhisperProcessor,
        'SamProcessor': SamProcessor,
    }

    /**
     * Instantiate one of the processor classes of the library from a pretrained model.
     * 
     * The processor class to instantiate is selected based on the `feature_extractor_type` property of the config object
     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)
     * 
     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:
     * - A string, the *model id* of a pretrained processor hosted inside a model repo on huggingface.co.
     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a
     *   user or organization name, like `dbmdz/bert-base-german-cased`.
     * - A path to a *directory* containing processor files, e.g., `./my_model_directory/`.
     * @param {PretrainedOptions} options Additional options for loading the processor.
     * 
     * @returns {Promise<Processor>} A new instance of the Processor class.
     */
    static async from_pretrained(pretrained_model_name_or_path, {
        progress_callback = null,
        config = null,
        cache_dir = null,
        local_files_only = false,
        revision = 'main',
    } = {}) {

        let preprocessorConfig = config ?? await (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, 'preprocessor_config.json', true, {
            progress_callback,
            config,
            cache_dir,
            local_files_only,
            revision,
        })

        // Determine feature extractor class
        // TODO: Ensure backwards compatibility with old configs
        let key = preprocessorConfig.feature_extractor_type ?? preprocessorConfig.image_processor_type;
        let feature_extractor_class = this.FEATURE_EXTRACTOR_CLASS_MAPPING[key];

        if (!feature_extractor_class) {
            if (preprocessorConfig.size !== undefined) {
                // Assume ImageFeatureExtractor
                console.warn('Feature extractor type not specified, assuming ImageFeatureExtractor due to size parameter in config.');
                feature_extractor_class = ImageFeatureExtractor;
            } else {
                throw new Error(`Unknown Feature Extractor type: ${preprocessorConfig.feature_extractor_type}`);
            }
        }

        // If no associated processor class, use default
        let processor_class = this.PROCESSOR_CLASS_MAPPING[preprocessorConfig.processor_class] ?? Processor;

        // Instantiate processor and feature extractor
        let feature_extractor = new feature_extractor_class(preprocessorConfig);
        return new processor_class(feature_extractor);
    }
}
//////////////////////////////////////////////////



/***/ }),

/***/ "./node_modules/@xenova/transformers/src/tokenizers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/tokenizers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AlbertTokenizer: () => (/* binding */ AlbertTokenizer),
/* harmony export */   AutoTokenizer: () => (/* binding */ AutoTokenizer),
/* harmony export */   BartTokenizer: () => (/* binding */ BartTokenizer),
/* harmony export */   BertTokenizer: () => (/* binding */ BertTokenizer),
/* harmony export */   BloomTokenizer: () => (/* binding */ BloomTokenizer),
/* harmony export */   CLIPTokenizer: () => (/* binding */ CLIPTokenizer),
/* harmony export */   CodeGenTokenizer: () => (/* binding */ CodeGenTokenizer),
/* harmony export */   DistilBertTokenizer: () => (/* binding */ DistilBertTokenizer),
/* harmony export */   FalconTokenizer: () => (/* binding */ FalconTokenizer),
/* harmony export */   GPT2Tokenizer: () => (/* binding */ GPT2Tokenizer),
/* harmony export */   GPTNeoXTokenizer: () => (/* binding */ GPTNeoXTokenizer),
/* harmony export */   LlamaTokenizer: () => (/* binding */ LlamaTokenizer),
/* harmony export */   MPNetTokenizer: () => (/* binding */ MPNetTokenizer),
/* harmony export */   MarianTokenizer: () => (/* binding */ MarianTokenizer),
/* harmony export */   MobileBertTokenizer: () => (/* binding */ MobileBertTokenizer),
/* harmony export */   NllbTokenizer: () => (/* binding */ NllbTokenizer),
/* harmony export */   PreTrainedTokenizer: () => (/* binding */ PreTrainedTokenizer),
/* harmony export */   RobertaTokenizer: () => (/* binding */ RobertaTokenizer),
/* harmony export */   SqueezeBertTokenizer: () => (/* binding */ SqueezeBertTokenizer),
/* harmony export */   T5Tokenizer: () => (/* binding */ T5Tokenizer),
/* harmony export */   TokenizerModel: () => (/* binding */ TokenizerModel),
/* harmony export */   WhisperTokenizer: () => (/* binding */ WhisperTokenizer),
/* harmony export */   XLMRobertaTokenizer: () => (/* binding */ XLMRobertaTokenizer)
/* harmony export */ });
/* harmony import */ var _utils_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/core.js */ "./node_modules/@xenova/transformers/src/utils/core.js");
/* harmony import */ var _utils_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/hub.js */ "./node_modules/@xenova/transformers/src/utils/hub.js");
/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/maths.js */ "./node_modules/@xenova/transformers/src/utils/maths.js");
/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/tensor.js */ "./node_modules/@xenova/transformers/src/utils/tensor.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");

/**
 * @file Tokenizers are used to prepare textual inputs for a model.
 * 
 * **Example:** Create an `AutoTokenizer` and use it to tokenize a sentence.
 * This will automatically detect the tokenizer type based on the tokenizer class defined in `tokenizer.json`.
 * ```javascript
 * import { AutoTokenizer } from '@xenova/transformers';
 * 
 * let tokenizer = await AutoTokenizer.from_pretrained('bert-base-uncased');
 * let { input_ids } = await tokenizer('I love transformers!');
 * // Tensor {
 * //   data: BigInt64Array(6) [101n, 1045n, 2293n, 19081n, 999n, 102n],
 * //   dims: [1, 6],
 * //   type: 'int64',
 * //   size: 6,
 * // }
 * ```
 * 
 * @module tokenizers
 */








/**
 * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions
 */

/**
 * Loads a tokenizer from the specified path.
 * @param {string} pretrained_model_name_or_path The path to the tokenizer directory.
 * @param {PretrainedOptions} options Additional options for loading the tokenizer.
 * @returns {Promise<Array>} A promise that resolves with information about the loaded tokenizer.
 */
async function loadTokenizer(pretrained_model_name_or_path, options) {

    let info = await Promise.all([
        (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, 'tokenizer.json', true, options),
        (0,_utils_hub_js__WEBPACK_IMPORTED_MODULE_1__.getModelJSON)(pretrained_model_name_or_path, 'tokenizer_config.json', true, options),
    ])
    return info;
}

/**
 * Helper method to construct a pattern from a config object.
 * @param {Object} pattern The pattern object.
 * @param {boolean} invert Whether to invert the pattern (only applicable for Regex patterns).
 * @returns {RegExp|string|null} The compiled pattern.
 */
function createPattern(pattern, invert = true) {

    if (pattern.Regex) {
        // NOTE: if invert is true, we wrap the pattern in a group so that it is kept when performing .split()
        return new RegExp(invert ? pattern.Regex : `(${pattern.Regex})`, 'gu');

    } else if (pattern.String) {
        return pattern.String;

    } else {
        console.warn('Unknown pattern type:', pattern)
        return null;
    }
}

/**
 * Clean up a list of simple English tokenization artifacts like spaces before punctuations and abbreviated forms
 * @param {string} text The text to clean up.
 * @returns {string} The cleaned up text.
 */
function clean_up_tokenization(text) {
    // Clean up a list of simple English tokenization artifacts
    // like spaces before punctuations and abbreviated forms
    return text.replace(/ \./g, '.')
        .replace(/ \?/g, '?')
        .replace(/ \!/g, '!')
        .replace(/ ,/g, ',')
        .replace(/ \' /g, "'")
        .replace(/ n\'t/g, "n't")
        .replace(/ \'m/g, "'m")
        .replace(/ \'s/g, "'s")
        .replace(/ \'ve/g, "'ve")
        .replace(/ \'re/g, "'re");
}

/**
 * Helper function to fuse consecutive values in an array equal to the specified value.
 * @param {Array} arr The input array
 * @param {any} value The value to fuse on.
 */
function fuse(arr, value) {
    let fused = [];
    let i = 0;
    while (i < arr.length) {
        fused.push(arr[i])
        if (arr[i] !== value) {
            ++i;
            continue;
        }

        while (i < arr.length && arr[i] === value) {
            ++i;
        }
    }

    return fused;
}

/**
 * Split a string on whitespace.
 * @param {string} text The text to split.
 * @returns {string[]} The split string.
 */
function whitespace_split(text) {
    return text.match(/\S+/g) || [];
}

const PUNCTUATION_REGEX = '\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E';

/**
 * Abstract base class for tokenizer models.
 *
 * @extends Callable
 */
class TokenizerModel extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
    /**
     * Creates a new instance of TokenizerModel.
     * @param {Object} config The configuration object for the TokenizerModel.
     */
    constructor(config) {
        super();
        this.config = config;

        /** @type {string[]} */
        this.vocab = [];

        /**
         * A mapping of tokens to ids.
         * @type {Map<string, number>}
         */
        this.tokens_to_ids = new Map();

        this.unk_token_id = undefined;
        this.unk_token = undefined;
        this.end_of_word_suffix = undefined;

        /** @type {boolean} Whether to fuse unknown tokens when encoding. Defaults to false. */
        this.fuse_unk = false;
    }

    /**
     * Instantiates a new TokenizerModel instance based on the configuration object provided.
     * @param {Object} config The configuration object for the TokenizerModel.
     * @param {...*} args Optional arguments to pass to the specific TokenizerModel constructor.
     * @returns {TokenizerModel} A new instance of a TokenizerModel.
     * @throws Will throw an error if the TokenizerModel type in the config is not recognized.
     */
    static fromConfig(config, ...args) {
        switch (config.type) {
            case 'WordPiece':
                return new WordPieceTokenizer(config);
            case 'Unigram':
                // @ts-ignore
                return new Unigram(config, ...args);

            case 'BPE':
                // @ts-ignore
                return new BPE(config, ...args);
            default:
                throw new Error(`Unknown TokenizerModel type: ${config.type}`);
        }
    }

    /**
     * Internal function to call the TokenizerModel instance.
     * @param {string[]} tokens The tokens to encode.
     * @returns {number[]} The encoded token IDs.
     */
    _call(tokens) {
        return this.encode(tokens);
    }

    /**
     * Encodes a list of tokens into a list of token IDs.
     * @param {string[]} tokens The tokens to encode.
     * @returns {number[]} The encoded token IDs.
     * @throws Will throw an error if not implemented in a subclass.
     */
    encode(tokens) {
        throw Error("encode should be implemented in subclass.")
    }

    /**
     * Converts a list of tokens into a list of token IDs.
     * @param {string[]} tokens The tokens to convert.
     * @returns {number[]} The converted token IDs.
     */
    convert_tokens_to_ids(tokens) {
        let ids = tokens.map(t => this.tokens_to_ids.get(t) ?? this.unk_token_id);

        if (this.fuse_unk) {
            // Fuse unknown tokens
            ids = fuse(ids, this.unk_token_id);
        }
        return ids;
    }

    /**
     * Converts a list of token IDs into a list of tokens.
     * @param {number[]} ids The token IDs to convert.
     * @returns {string[]} The converted tokens.
     */
    convert_ids_to_tokens(ids) {
        return ids.map(i => this.vocab[i] ?? this.unk_token);
    }
}

/**
 * A subclass of TokenizerModel that uses WordPiece encoding to encode tokens.
 * @extends TokenizerModel
 */
class WordPieceTokenizer extends TokenizerModel {
    /**
     * @param {Object} config The configuration object.
     * @param {Map<string, number>} config.vocab A mapping of tokens to ids.
     * @param {string} config.unk_token The unknown token string.
     * @param {string} config.continuing_subword_prefix The prefix to use for continuing subwords.
     */
    constructor(config) {
        super(config);
        /**
         * A mapping of tokens to ids.
         * @type {Map<string, number>}
         */
        this.tokens_to_ids = config.vocab;

        /**
         * The id of the unknown token.
         * @type {number}
         */
        this.unk_token_id = this.tokens_to_ids.get(config.unk_token);

        /**
         * The unknown token string.
         * @type {string}
         */
        this.unk_token = config.unk_token;

        /**
         * An array of tokens.
         * @type {string[]}
         */
        this.vocab = new Array(this.tokens_to_ids.size);

        for (const [key, value] of this.tokens_to_ids) {
            this.vocab[value] = key;
        }
    }

    /**
     * Encodes an array of tokens using WordPiece encoding.
     * @param {Array} tokens The tokens to encode.
     * @returns {Array} An array of encoded tokens.
     */
    encode(tokens) {
        let outputTokens = [];
        for (let token of tokens) {
            let chars = [...token];
            // TODO add
            // if len(chars) > self.max_input_chars_per_word:
            //     output_tokens.append(self.unk_token)
            //     continue

            let isUnknown = false;
            let start = 0;
            let subTokens = [];

            while (start < chars.length) {
                let end = chars.length;
                let currentSubstring = null;
                while (start < end) {
                    let substr = chars.slice(start, end).join('');

                    if (start > 0) {
                        substr = this.config.continuing_subword_prefix + substr;
                    }
                    if (this.tokens_to_ids.has(substr)) {
                        currentSubstring = substr;
                        break;
                    }

                    --end;
                }
                if (currentSubstring === null) {
                    isUnknown = true;
                    break;
                }
                subTokens.push(currentSubstring);
                start = end;
            }
            if (isUnknown) {
                outputTokens.push(this.unk_token);
            } else {
                outputTokens.push(...subTokens);
            }
        }

        return outputTokens;
    }

}

/**
 * Class representing a Unigram tokenizer model.
 * @extends TokenizerModel
 */
class Unigram extends TokenizerModel {
    /**
     * Create a new Unigram tokenizer model.
     * @param {Object} config The configuration object for the Unigram model.
     * @param {number} config.unk_id The ID of the unknown token
     * @param {Map<string, number>} config.vocab A mapping of tokens to scores.
     * @param {Object} moreConfig Additional configuration object for the Unigram model.
     */
    constructor(config, moreConfig) {
        super(config);

        this.vocab = new Array(config.vocab.size);
        this.scores = new Array(config.vocab.size);
        let count = 0;
        config.vocab.forEach((value, key) => {
            this.vocab[count] = key;
            this.scores[count] = value;
            ++count;
        });

        this.unk_token_id = config.unk_id;
        this.unk_token = this.vocab[config.unk_id];

        this.tokens_to_ids = new Map(this.vocab.map((x, i) => [x, i]));
        this.bosToken = ' '; // beginning of a sentence token

        this.bosTokenId = this.tokens_to_ids.get(this.bosToken); // NOTE: may be undefined
        this.eosToken = moreConfig.eos_token;

        this.eosTokenId = this.tokens_to_ids.get(this.eosToken);
        this.unkToken = this.vocab[this.unk_token_id];

        this.minScore = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.min)(this.scores)[0];

        this.unkScore = this.minScore - 10.0;
        this.scores[this.unk_token_id] = this.unkScore;

        this.trie = new CharTrie();
        this.trie.extend(this.vocab);

        // NOTE: `fuse_unk` is hardcoded to true for Unigram models
        // See: https://github.com/huggingface/tokenizers/blob/b58227c7f1ccf8b73ee2268354336da56d91e492/tokenizers/src/models/unigram/model.rs#L119
        this.fuse_unk = true;
    }

    /**
     * Populates lattice nodes.
     * @param {TokenLattice} lattice The token lattice to populate with nodes.
     */
    populateNodes(lattice) {
        const sentence = lattice.sentence;
        const len = sentence.length;
        let beginPos = 0;
        while (beginPos < len) {
            const mblen = 1;
            let hasSingleNode = false;
            const tokens = [];

            for (let token of this.trie.commonPrefixSearch(sentence.slice(beginPos))) {
                tokens.push(token);
                const tokenId = this.tokens_to_ids.get(token);
                const tokenScore = this.scores[tokenId];
                const n = token.length;
                lattice.insert(beginPos, n, tokenScore, tokenId);
                if (!hasSingleNode && n === mblen) {
                    hasSingleNode = true;
                }
            }
            if (!hasSingleNode) {
                lattice.insert(beginPos, mblen, this.unkScore, this.unk_token_id);
            }
            beginPos += mblen;
        }
    }

    /**
     * Encodes an array of tokens into an array of subtokens using the unigram model.
     *
     * @param {string} normalized The normalized string.
     * @returns {string[]} An array of subtokens obtained by encoding the input tokens using the unigram model.
     */
    tokenize(normalized) {
        const lattice = new TokenLattice(normalized, this.bosTokenId, this.eosTokenId);
        this.populateNodes(lattice);
        return lattice.tokens();
    }

    /**
     * Encodes an array of tokens using WordPiece encoding.
     * @param {Array} tokens The tokens to encode.
     * @returns {Array} An array of encoded tokens.
     */
    encode(tokens) {
        let toReturn = [];
        for (let token of tokens) {
            const tokenized = this.tokenize(token);
            toReturn.push(...tokenized);
        }
        return toReturn;
    }

}

/**
 * Returns list of utf-8 byte and a mapping to unicode strings.
 * Specifically avoids mapping to whitespace/control characters the BPE code barfs on.
 * @returns {Object} Object with utf-8 byte keys and unicode string values.
 */
const BYTES_TO_UNICODE = (() => {
    // Returns list of utf-8 byte and a mapping to unicode strings.
    // We specifically avoids mapping to whitespace/control characters
    // the bpe code barfs on.

    const bs = [
        ...Array.from({ length: "~".charCodeAt(0) - "!".charCodeAt(0) + 1 }, (_, i) => i + "!".charCodeAt(0)),
        ...Array.from({ length: "¬".charCodeAt(0) - "¡".charCodeAt(0) + 1 }, (_, i) => i + "¡".charCodeAt(0)),
        ...Array.from({ length: "ÿ".charCodeAt(0) - "®".charCodeAt(0) + 1 }, (_, i) => i + "®".charCodeAt(0)),
    ];
    let cs = bs.slice();
    let n = 0;
    for (let b = 0; b < 256; ++b) {
        if (!bs.includes(b)) {
            bs.push(b);
            cs.push(256 + n);
            n += 1;
        }
    }
    let ccs = cs.map(n => String.fromCharCode(n));
    return Object.fromEntries(bs.map((b, i) => [b, ccs[i]]));
})();

const UNICODE_TO_BYTES = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.reverseDictionary)(BYTES_TO_UNICODE);

/**
 * BPE class for encoding text into Byte-Pair-Encoding (BPE) tokens.
 * @extends TokenizerModel
 */
class BPE extends TokenizerModel {
    /**
     * Create a BPE instance.
     * @param {Object} config The configuration object for BPE.
     * @param {Map<string, number>} config.vocab A mapping of tokens to ids.
     * @param {string} config.unk_token The unknown token used for out of vocabulary words.
     * @param {string} config.end_of_word_suffix The suffix to place at the end of each word.
     * @param {Array} config.merges An array of BPE merges as strings.
     */
    constructor(config) {
        super(config);

        this.BPE_SPLIT_TOKEN = ' ';

        this.tokens_to_ids = config.vocab;

        this.unk_token_id = this.tokens_to_ids.get(config.unk_token);
        this.unk_token = config.unk_token;

        this.vocab = new Array(this.tokens_to_ids.size);
        for (const [key, value] of this.tokens_to_ids) {
            this.vocab[value] = key;
        }

        this.bpe_ranks = Object.fromEntries(config.merges.map((x, i) => [x, i]));
        this.merges = config.merges.map(x => x.split(this.BPE_SPLIT_TOKEN));

        this.end_of_word_suffix = config.end_of_word_suffix;

        this.byte_fallback = this.config.byte_fallback ?? false;

        if (this.byte_fallback) {
            this.text_encoder = new TextEncoder();
        }

        this.cache = Object.create(null);

        this.fuse_unk ??= this.config.fuse_unk;
    }

    /**
     * Get all the possible pairs of characters in a word.
     * @param {string[]} word The word to get pairs from.
     * @returns {Array} An array of pairs.
     */
    get_pairs(word) {
        let pairs = new Set();
        let prev_char = word[0];
        for (let i = 1; i < word.length; ++i) {
            let char = word[i];
            pairs.add(prev_char + this.BPE_SPLIT_TOKEN + char);
            prev_char = char;
        }
        return Array.from(pairs);
    }

    /**
     * Apply Byte-Pair-Encoding (BPE) to a given token.
     * @param {string} token The token to encode.
     * @returns {string} The BPE encoded token.
     */
    bpe(token) {
        if (token in this.cache) {
            return this.cache[token];
        }
        let word = Array.from(token);
        if (this.end_of_word_suffix) {
            word[word.length - 1] += this.end_of_word_suffix;
        }
        let pairs = this.get_pairs(word);

        if (!pairs.length) {
            if (this.end_of_word_suffix) {
                token += this.end_of_word_suffix;
            }
            return token;
        }

        while (true) {
            let bigram = pairs.reduce((a, b) => {
                let c = this.bpe_ranks[a] ?? Infinity
                let d = this.bpe_ranks[b] ?? Infinity
                return c <= d ? a : b;
            });
            if (!(bigram in this.bpe_ranks)) {
                break;
            }
            let [first, second] = bigram.split(this.BPE_SPLIT_TOKEN);
            let new_word = [];
            let i = 0;
            let j = -1;

            while (i < word.length) {
                try {
                    j = word.indexOf(first, i);
                    if (j === -1) throw "Error";
                } catch (e) {
                    new_word.push(...word.slice(i));
                    break;
                }
                new_word.push(...word.slice(i, j));
                i = j;

                if (word[i] === first && i < word.length - 1 && word[i + 1] === second) {
                    new_word.push(first + second);
                    i += 2;
                } else {
                    new_word.push(word[i]);
                    i += 1;
                }
            }
            word = new_word
            if (word.length === 1) {
                break;
            } else {
                pairs = this.get_pairs(word);
            }
        }
        let final_word = word.join(this.BPE_SPLIT_TOKEN);
        this.cache[token] = final_word;
        return final_word;
    }

    /**
     * Encodes the input sequence of tokens using the BPE algorithm and returns the resulting subword tokens.
     * @param {Array} tokens The input sequence of tokens to encode.
     * @returns {Array} The resulting subword tokens after applying the BPE algorithm to the input sequence of tokens.
     */
    encode(tokens) {
        let outputTokens = [];

        for (let token of tokens) {
            let bpe_token_list = this.bpe(token).split(this.BPE_SPLIT_TOKEN);

            for (let t of bpe_token_list) {
                if (this.tokens_to_ids.has(t)) {
                    outputTokens.push(t);
                } else {
                    if (this.byte_fallback) {
                        outputTokens.push(
                            ...Array.from(this.text_encoder.encode(t))
                                .map(x => `<0x${x.toString(16).toUpperCase().padStart(2, '0')}>`)
                        );
                    } else {
                        outputTokens.push(this.unk_token);
                    }
                }
            }
        }

        return outputTokens;
    }

}

/**
 * A base class for text normalization.
 * @abstract
 */
class Normalizer extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
    /**
     * @param {Object} config The configuration object for the normalizer.
     */
    constructor(config) {
        super();
        this.config = config;
    }

    /**
     * Factory method for creating normalizers from config objects.
     * @static
     * @param {Object} config The configuration object for the normalizer.
     * @returns {Normalizer} A Normalizer object.
     * @throws {Error} If an unknown Normalizer type is specified in the config.
     */
    static fromConfig(config) {
        if (config === null) return null;
        switch (config.type) {
            case 'BertNormalizer':
                return new BertNormalizer(config);
            case 'Precompiled':
                return new Precompiled(config);
            case 'Sequence':
                return new NormalizerSequence(config);
            case 'Replace':
                return new Replace(config);
            case 'NFC':
                return new NFC(config);
            case 'NFKD':
                return new NFKD(config);
            case 'StripAccents':
                return new StripAccents(config);
            case 'Lowercase':
                return new Lowercase(config);
            case 'Prepend':
                return new Prepend(config);
            default:
                throw new Error(`Unknown Normalizer type: ${config.type}`);
        }
    }

    /**
     * Normalize the input text.
     * @abstract
     * @param {string} text The text to normalize.
     * @returns {string} The normalized text.
     * @throws {Error} If this method is not implemented in a subclass.
     */
    normalize(text) {
        throw Error("normalize should be implemented in subclass.")
    }

    /**
     * Alias for {@link Normalizer#normalize}.
     * @param {string} text The text to normalize.
     * @returns {string} The normalized text.
     */
    _call(text) {
        return this.normalize(text);
    }

}

/**
 * Replace normalizer that replaces occurrences of a pattern with a given string or regular expression.
 * @extends Normalizer
 */
class Replace extends Normalizer {
    /**
     * Normalize the input text by replacing the pattern with the content.
     * @param {string} text The input text to be normalized.
     * @returns {string} The normalized text after replacing the pattern with the content.
     */
    normalize(text) {
        let pattern = createPattern(this.config.pattern);
        if (pattern === null) {
            return text;
        }

        text = text.replaceAll(pattern, this.config.content)

        return text;
    }
}

/**
 * A normalizer that applies Unicode normalization form C (NFC) to the input text.
 * @extends Normalizer
 */
class NFC extends Normalizer {
    /**
     * Normalize the input text by applying Unicode normalization form C (NFC).
     * @param {string} text The input text to be normalized.
     * @returns {string} The normalized text.
     */
    normalize(text) {
        text = text.normalize('NFC')
        return text;
    }
}

/**
 * NFKD Normalizer.
 * @extends Normalizer
 */
class NFKD extends Normalizer {
    /**
     * Normalize text using NFKD normalization.
     * @param {string} text The text to be normalized.
     * @returns {string} The normalized text.
     */
    normalize(text) {
        text = text.normalize('NFKD')
        return text;
    }
}

/**
 * StripAccents normalizer removes all accents from the text.
 * @extends Normalizer
 */
class StripAccents extends Normalizer {
    /**
     * Remove all accents from the text.
     * @param {string} text The input text.
     * @returns {string} The normalized text without accents.
     */
    normalize(text) {
        text = text.replace(/[\u0300-\u036f]/g, '');
        return text;
    }
}

/**
 * A Normalizer that lowercases the input string.
 * @extends Normalizer
 */
class Lowercase extends Normalizer {
    /**
     * Lowercases the input string.
     * @param {string} text The text to normalize.
     * @returns {string} The normalized text.
     */
    normalize(text) {
        text = text.toLowerCase();
        return text;
    }
}

/**
 * A Normalizer that prepends a string to the input string.
 * @extends Normalizer
 */
class Prepend extends Normalizer {
    /**
     * Prepends the input string.
     * @param {string} text The text to normalize.
     * @returns {string} The normalized text.
     */
    normalize(text) {
        text = this.config.prepend + text;
        return text;
    }
}

/**
 * A Normalizer that applies a sequence of Normalizers.
 * @extends Normalizer
 */
class NormalizerSequence extends Normalizer {
    /**
   * Create a new instance of NormalizerSequence.
   * @param {Object} config The configuration object.
   * @param {Object[]} config.normalizers An array of Normalizer configuration objects.
   */
    constructor(config) {
        super(config);
        this.normalizers = config.normalizers.map(x => Normalizer.fromConfig(x));
    }
    /**
    * Apply a sequence of Normalizers to the input text.
    * @param {string} text The text to normalize.
    * @returns {string} The normalized text.
    */
    normalize(text) {
        return this.normalizers.reduce((t, normalizer) => {
            return normalizer.normalize(t);
        }, text);
    }
}

/**
 * A class representing a normalizer used in BERT tokenization.
 * @extends Normalizer
 */
class BertNormalizer extends Normalizer {
    /**
     * Adds whitespace around any CJK (Chinese, Japanese, or Korean) character in the input text.
     *
     * @param {string} text The input text to tokenize.
     * @returns {string} The tokenized text with whitespace added around CJK characters.
     */
    _tokenize_chinese_chars(text) {
        /* Adds whitespace around any CJK character. */
        let output = [];
        for (let i = 0; i < text.length; ++i) {
            let char = text[i];
            let cp = char.charCodeAt(0);
            if (this._is_chinese_char(cp)) {
                output.push(" ");
                output.push(char);
                output.push(" ");
            } else {
                output.push(char);
            }
        }
        return output.join("");
    }

    /**
     * Checks whether the given Unicode codepoint represents a CJK (Chinese, Japanese, or Korean) character.
     *
     * A "chinese character" is defined as anything in the CJK Unicode block:
     * https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)
     *
     * Note that the CJK Unicode block is NOT all Japanese and Korean characters, despite its name.
     * The modern Korean Hangul alphabet is a different block, as is Japanese Hiragana and Katakana.
     * Those alphabets are used to write space-separated words, so they are not treated specially
     * and are handled like all other languages.
     *
     * @param {number} cp The Unicode codepoint to check.
     * @returns {boolean} True if the codepoint represents a CJK character, false otherwise.
     */
    _is_chinese_char(cp) {
        return (
            (cp >= 0x4E00 && cp <= 0x9FFF)
            || (cp >= 0x3400 && cp <= 0x4DBF)
            || (cp >= 0x20000 && cp <= 0x2A6DF)
            || (cp >= 0x2A700 && cp <= 0x2B73F)
            || (cp >= 0x2B740 && cp <= 0x2B81F)
            || (cp >= 0x2B820 && cp <= 0x2CEAF)
            || (cp >= 0xF900 && cp <= 0xFAFF)
            || (cp >= 0x2F800 && cp <= 0x2FA1F)
        )
    }
    /**
     * Strips accents from the given text.
     * @param {string} text The text to strip accents from.
     * @returns {string} The text with accents removed.
     */
    stripAccents(text) {
        return text.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }

    /**
     * Normalizes the given text based on the configuration.
     * @param {string} text The text to normalize.
     * @returns {string} The normalized text.
     */
    normalize(text) {
        // TODO use rest of config
        // config.clean_text,
        // config.handle_chinese_chars,
        // config.strip_accents,
        // config.lowercase,

        if (this.config.handle_chinese_chars) {
            text = this._tokenize_chinese_chars(text);
        }

        if (this.config.lowercase) {
            text = text.toLowerCase();

            if (this.config.strip_accents !== false) {
                text = this.stripAccents(text);
            }
        } else if (this.config.strip_accents) {
            text = this.stripAccents(text);
        }

        return text;
    }
}

/**
 * A callable class representing a pre-tokenizer used in tokenization. Subclasses
 * should implement the `pre_tokenize_text` method to define the specific pre-tokenization logic.
 * @extends Callable
 */
class PreTokenizer extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
    /**
   * Factory method that returns an instance of a subclass of `PreTokenizer` based on the provided configuration.
   *
   * @static
   * @param {Object} config A configuration object for the pre-tokenizer.
   * @returns {PreTokenizer} An instance of a subclass of `PreTokenizer`.
   * @throws {Error} If the provided configuration object does not correspond to any known pre-tokenizer.
   */
    static fromConfig(config) {
        if (config === null) return null;

        switch (config.type) {
            case 'BertPreTokenizer':
                return new BertPreTokenizer(config);
            case 'Sequence':
                return new PreTokenizerSequence(config);
            case 'WhitespaceSplit':
                return new WhitespaceSplit(config);
            case 'Metaspace':
                return new MetaspacePreTokenizer(config);

            case 'ByteLevel':
                return new ByteLevelPreTokenizer(config);
            case 'Split':
                return new SplitPreTokenizer(config);
            case 'Punctuation':
                return new PunctuationPreTokenizer(config);
            case 'Digits':
                return new DigitsPreTokenizer(config);
            default:
                throw new Error(`Unknown PreTokenizer type: ${config.type}`);
        }
    }

    /**
   * Method that should be implemented by subclasses to define the specific pre-tokenization logic.
   *
   * @abstract
   * @param {string} text The text to pre-tokenize.
   * @returns {string[]} The pre-tokenized text.
   * @throws {Error} If the method is not implemented in the subclass.
   */
    pre_tokenize_text(text) {
        throw Error("pre_tokenize_text should be implemented in subclass.")
    }

    /**
     * Tokenizes the given text into pre-tokens.
     * @param {string|string[]} text The text or array of texts to pre-tokenize.
     * @returns {string[]} An array of pre-tokens.
     */
    pre_tokenize(text) {
        let result = [];
        if (Array.isArray(text)) {
            result = text.map(x => this.pre_tokenize_text(x))
        } else {
            result = this.pre_tokenize_text(text);
        }
        return result.flat();
    }

    /**
     * Alias for {@link PreTokenizer#pre_tokenize}.
     * @param {string|string[]} text The text or array of texts to pre-tokenize.
     * @returns {string[]} An array of pre-tokens.
     */
    _call(text) {
        return this.pre_tokenize(text);
    }
}

/**
 * @extends PreTokenizer
 */
class BertPreTokenizer extends PreTokenizer {
    /**
     * A PreTokenizer that splits text into wordpieces using a basic tokenization scheme
     * similar to that used in the original implementation of BERT.
     * 
     * @param {Object} config The configuration object.
     */
    constructor(config) {
        super();
        // Construct a pattern which matches the rust implementation:
        // https://github.com/huggingface/tokenizers/blob/b4fcc9ce6e4ad5806e82826f816acfdfdc4fcc67/tokenizers/src/pre_tokenizers/bert.rs#L11
        // Equivalent to removing whitespace and splitting on punctuation (both \p{P} and other ascii characters)
        this.pattern = new RegExp(`[^\\s${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]`, 'gu');
    }
    /**
     * Tokenizes a single text using the BERT pre-tokenization scheme.
     * 
     * @param {string} text The text to tokenize.
     * @returns {string[]} An array of tokens.
     */
    pre_tokenize_text(text) {
        return text.trim().match(this.pattern) || [];
    }
}

/**
 * A pre-tokenizer that splits text into Byte-Pair-Encoding (BPE) subwords.
 * @extends PreTokenizer
 */
class ByteLevelPreTokenizer extends PreTokenizer {
    /**
     * Creates a new instance of the `ByteLevelPreTokenizer` class.
     * @param {Object} config The configuration object.
     */
    constructor(config) {
        super();
        this.config = config;

        /**
         * @type {boolean} Whether to add a leading space to the first word.
         * This allows to treat the leading word just as any other word.
         */
        this.add_prefix_space = this.config.add_prefix_space;

        /**
         * @type {boolean} Whether the post processing step should trim offsets
         * to avoid including whitespaces.
         * @todo Use this in the pretokenization step.
         */
        this.trim_offsets = this.config.trim_offsets;

        /**
         * @type {boolean} Whether to use the standard GPT2 regex for whitespace splitting.
         * Set it to False if you want to use your own splitting. Defaults to true.
         */
        this.use_regex = this.config.use_regex ?? true;
        this.pattern = /'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu;

        this.byte_encoder = BYTES_TO_UNICODE;
        this.text_encoder = new TextEncoder();
    }

    /**
     * Tokenizes a single piece of text using byte-level tokenization.
     * @param {string} text The text to tokenize.
     * @returns {string[]} An array of tokens.
     */
    pre_tokenize_text(text) {
        // Split on whitespace and punctuation
        let tokens = this.use_regex ? (text.match(this.pattern) || []) : [text];

        return tokens.map(token => {
            if (this.add_prefix_space && !token.startsWith(' ')) {
                token = ' ' + token;
            }

            // Maps all our bytes to unicode strings, avoiding control tokens of the BPE (spaces in our case)
            token = Array.from(this.text_encoder.encode(token), byte => this.byte_encoder[byte]).join('');

            return token;
        });
    }
}

/**
 * @typedef {'removed'|'isolated'|'mergedWithPrevious'|'mergedWithNext'|'contiguous'} SplitDelimiterBehavior
 */

/**
 * Splits text using a given pattern.
 * @extends PreTokenizer
 */
class SplitPreTokenizer extends PreTokenizer {
    /**
     * @param {Object} config The configuration options for the pre-tokenizer.
     * @param {Object} config.pattern The pattern used to split the text. Can be a string or a regex object.
     * @param {string|undefined} config.pattern.String The string to use for splitting. Only defined if the pattern is a string.
     * @param {string|undefined} config.pattern.Regex The regex to use for splitting. Only defined if the pattern is a regex.
     * @param {SplitDelimiterBehavior} config.behavior The behavior to use when splitting.
     * @param {boolean} config.invert Whether to split (invert=false) or match (invert=true) the pattern.
     */
    constructor(config) {
        super();
        this.config = config;
        // TODO support all behaviours (config.behavior)

        this.pattern = createPattern(this.config.pattern, this.config.invert);
    }

    /**
     * Tokenizes text by splitting it using the given pattern.
     * @param {string} text The text to tokenize.
     * @returns {string[]} An array of tokens.
     */
    pre_tokenize_text(text) {
        if (this.pattern === null) {
            return [];
        }

        if (this.config.invert) {
            return text.match(this.pattern) || [];
        } else {
            return text.split(this.pattern).filter(x => x);
        }
    }
}

/**
 * Splits text based on punctuation.
 * @extends PreTokenizer
 */
class PunctuationPreTokenizer extends PreTokenizer {
    /**
     * @param {Object} config The configuration options for the pre-tokenizer.
     * @param {SplitDelimiterBehavior} config.behavior The behavior to use when splitting.
     */
    constructor(config) {
        super();
        this.config = config;
        this.pattern = new RegExp(`[^${PUNCTUATION_REGEX}]+|[${PUNCTUATION_REGEX}]+`, 'gu');
    }

    /**
     * Tokenizes text by splitting it using the given pattern.
     * @param {string} text The text to tokenize.
     * @returns {string[]} An array of tokens.
     */
    pre_tokenize_text(text) {
        return text.match(this.pattern) || [];
    }
}


/**
 * Splits text based on digits.
 * @extends PreTokenizer
 */
class DigitsPreTokenizer extends PreTokenizer {
    /**
     * @param {Object} config The configuration options for the pre-tokenizer.
     * @param {boolean} config.individual_digits Whether to split on individual digits.
     */
    constructor(config) {
        super();
        this.config = config;

        // Construct a pattern which matches the rust implementation:
        const digit_pattern = `[^\\d]+|\\d${this.config.individual_digits ? '' : '+'}`;
        this.pattern = new RegExp(digit_pattern, 'gu');
    }

    /**
     * Tokenizes text by splitting it using the given pattern.
     * @param {string} text The text to tokenize.
     * @returns {string[]} An array of tokens.
     */
    pre_tokenize_text(text) {
        return text.match(this.pattern) || [];
    }
}

/**
 * @extends Callable
 */
class PostProcessor extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {

    /**
     * @param {Object} config The configuration for the post-processor.
     */
    constructor(config) {
        super();
        this.config = config;
    }

    /**
     * Factory method to create a PostProcessor object from a configuration object.
     *
     * @param {Object} config Configuration object representing a PostProcessor.
     * @returns {PostProcessor} A PostProcessor object created from the given configuration.
     * @throws {Error} If an unknown PostProcessor type is encountered.
     */
    static fromConfig(config) {
        if (config === null) return null;
        switch (config.type) {
            case 'TemplateProcessing':
                return new TemplateProcessing(config);

            case 'ByteLevel':
                return new ByteLevelPostProcessor(config);

            case 'RobertaProcessing':
                return new RobertaProcessing(config);

            default:
                throw new Error(`Unknown PostProcessor type: ${config.type}`);
        }
    }

    /**
     * Method to be implemented in subclass to apply post-processing on the given tokens.
     *
     * @param {Array} tokens The input tokens to be post-processed.
     * @param {...*} args Additional arguments required by the post-processing logic.
     * @returns {Array} The post-processed tokens.
     * @throws {Error} If the method is not implemented in subclass.
     */
    post_process(tokens, ...args) {
        throw Error("post_process should be implemented in subclass.")
    }

    /**
     * Alias for {@link PostProcessor#post_process}.
     * @param {Array} tokens The text or array of texts to post-process.
     * @param {...*} args Additional arguments required by the post-processing logic.
     * @returns {Array} An array of post-processed tokens.
     */
    _call(tokens, ...args) {
        return this.post_process(tokens, ...args);
    }
}

/**
 * A post-processor that adds special tokens to the beginning and end of the input.
 * @extends PostProcessor
 */
class RobertaProcessing extends PostProcessor {
    /**
     * @param {Object} config The configuration for the post-processor.
     * @param {string[]} config.cls The special tokens to add to the beginning of the input.
     * @param {string[]} config.sep The special tokens to add to the end of the input.
     */
    constructor(config) {
        super(config);
        // TODO use all of config: add_prefix_space, trim_offsets

        this.cls = config.cls[0];
        this.sep = config.sep[0];
    }

    /**
     * Adds the special tokens to the beginning and end of the input.
     * @param {string[]} tokens The input tokens.
     * @param {string[]|null} tokens_pair An optional second set of input tokens.
     * @returns {string[]} The input tokens with the special tokens added to the beginning and end.
     */
    post_process(tokens, tokens_pair = null) {
        tokens = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)([this.cls], tokens, [this.sep]);

        // NOTE: It is intended to add 2 EOS tokens after the first set of tokens
        // https://github.com/huggingface/tokenizers/issues/983
        if (tokens_pair !== null) {
            tokens = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(tokens, [this.sep], tokens_pair, [this.sep]);
        }
        return tokens;
    }
}

/**
 * Post processor that replaces special tokens in a template with actual tokens.
 * @extends PostProcessor
 */
class TemplateProcessing extends PostProcessor {
    /**
     * Creates a new instance of `TemplateProcessing`.
     * @param {Object} config The configuration options for the post processor.
     * @param {Array} config.single The template for a single sequence of tokens.
     * @param {Array} config.pair The template for a pair of sequences of tokens.
     */
    constructor(config) {
        super(config);

        this.single = config.single;
        this.pair = config.pair;
    }

    /**
     * Replaces special tokens in the template with actual tokens.
     * @param {Array} tokens The list of tokens for the first sequence.
     * @param {Array} [tokens_pair=null] The list of tokens for the second sequence (optional).
     * @returns {Array} The list of tokens with the special tokens replaced with actual tokens.
     */
    post_process(tokens, tokens_pair = null) {
        let type = tokens_pair === null ? this.single : this.pair

        let toReturn = [];
        for (let item of type) {
            if ('SpecialToken' in item) {
                toReturn.push(item.SpecialToken.id);

            } else if ('Sequence' in item) {
                if (item.Sequence.id === 'A') {
                    toReturn = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(toReturn, tokens);

                } else if (item.Sequence.id === 'B') {
                    toReturn = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(toReturn, tokens_pair);
                }
            }
        }
        return toReturn;
    }
}

/**
 * A PostProcessor that returns the given tokens as is.
 * @extends PostProcessor
 */
class ByteLevelPostProcessor extends PostProcessor {
    /**
     * Post process the given tokens.
     * @param {string[]} tokens The tokens to be post processed.
     * @returns {string[]} The post processed tokens.
     */
    post_process(tokens) {
        return tokens;
    }
}

/**
 * The base class for token decoders.
 * @extends Callable
 */
class Decoder extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {

    /**
    * Creates an instance of `Decoder`.
    *
    * @param {Object} config The configuration object.
    */
    constructor(config) {
        super();
        this.config = config;

        this.added_tokens = [];
        this.end_of_word_suffix = null;
        this.trim_offsets = config.trim_offsets;
    }

    /**
   * Creates a decoder instance based on the provided configuration.
   *
   * @param {Object} config The configuration object.
   * @returns {Decoder} A decoder instance.
   * @throws {Error} If an unknown decoder type is provided.
   */
    static fromConfig(config) {
        switch (config.type) {
            case 'WordPiece':
                return new WordPieceDecoder(config);
            case 'Metaspace':
                return new MetaspaceDecoder(config);
            case 'ByteLevel':
                return new ByteLevelDecoder(config);

            case 'Replace':
                return new ReplaceDecoder(config);
            case 'ByteFallback':
                return new ByteFallback(config);
            case 'Fuse':
                return new FuseDecoder(config);
            case 'Strip':
                return new StripDecoder(config);

            case 'Sequence':
                return new DecoderSequence(config);

            default:
                throw new Error(`Unknown Decoder type: ${config.type}`);
        }
    }

    /**
    * Calls the `decode` method.
    *
    * @param {string[]} tokens The list of tokens.
    * @returns {string} The decoded string.
    */
    _call(tokens) {
        return this.decode(tokens);
    }

    /**
    * Decodes a list of tokens.
    * @param {string[]} tokens The list of tokens.
    * @returns {string} The decoded string.
    */
    decode(tokens) {
        return this.decode_chain(tokens).join('');
    }

    /**
     * Apply the decoder to a list of tokens.
     * 
     * @param {string[]} tokens The list of tokens.
     * @returns {string[]} The decoded list of tokens.
     * @throws {Error} If the `decode_chain` method is not implemented in the subclass.
     */
    decode_chain(tokens) {
        throw Error("`decode_chain` should be implemented in subclass.")
    }

}

class ReplaceDecoder extends Decoder {
    constructor(config) {
        super(config);
    }

    /** @type {Decoder['decode_chain']} */
    decode_chain(tokens) {
        let pattern = createPattern(this.config.pattern);
        if (pattern === null) {
            return tokens;
        }

        return tokens.map(token => token.replaceAll(pattern, this.config.content))
    }
}


class ByteFallback extends Decoder {
    constructor(config) {
        super(config);

        this.text_decoder = new TextDecoder();
    }

    /** @type {Decoder['decode_chain']} */
    decode_chain(tokens) {

        let new_tokens = [];
        let previous_byte_tokens = [];

        for (let token of tokens) {
            let bytes = null;
            if (token.length === 6 && token.startsWith('<0x') && token.endsWith('>')) {
                let byte = parseInt(token.slice(3, 5), 16);
                if (!isNaN(byte)) {
                    bytes = byte;
                }
            }
            if (bytes !== null) {
                previous_byte_tokens.push(bytes);
            } else {
                if (previous_byte_tokens.length > 0) {
                    let string = this.text_decoder.decode(Uint8Array.from(previous_byte_tokens));
                    new_tokens.push(string);
                    previous_byte_tokens = [];
                }
                new_tokens.push(token);
            }
        }
        if (previous_byte_tokens.length > 0) {
            let string = this.text_decoder.decode(Uint8Array.from(previous_byte_tokens));
            new_tokens.push(string);
            previous_byte_tokens = [];
        }

        return new_tokens;
    }
}

/**
 * Fuse simply fuses all tokens into one big string.
 * It's usually the last decoding step anyway, but this decoder
 * exists incase some decoders need to happen after that step
 */
class FuseDecoder extends Decoder {
    constructor(config) {
        super(config);
    }

    /** @type {Decoder['decode_chain']} */
    decode_chain(tokens) {
        return [tokens.join('')];
    }
}

class StripDecoder extends Decoder {
    constructor(config) {
        super(config);

        this.content = this.config.content;
        this.start = this.config.start;
        this.stop = this.config.stop;
    }

    /** @type {Decoder['decode_chain']} */
    decode_chain(tokens) {
        return tokens.map(token => {
            let start_cut = 0;
            for (let i = 0; i < this.start; ++i) {
                if (token[i] === this.content) {
                    start_cut = i + 1;
                    continue;
                } else {
                    break;
                }
            }

            let stop_cut = token.length;
            for (let i = 0; i < this.stop; ++i) {
                const index = token.length - i - 1;
                if (token[index] === this.content) {
                    stop_cut = index;
                    continue;
                } else {
                    break;
                }
            }

            return token.slice(start_cut, stop_cut)
        });
    }
}

/**
 * A decoder that decodes a list of WordPiece tokens into a single string.
 * @extends Decoder
 */
class WordPieceDecoder extends Decoder {

    /**
     * Creates a new instance of WordPieceDecoder.
     * @param {Object} config The configuration object.
     * @param {string} config.prefix The prefix used for WordPiece encoding.
     * @param {boolean} config.cleanup Whether to cleanup the decoded string.
     */
    constructor(config) {
        super(config);
        this.cleanup = config.cleanup;
    }

    /** @type {Decoder['decode_chain']} */
    decode_chain(tokens) {
        return tokens.map((token, i) => {
            if (i !== 0) {
                if (token.startsWith(this.config.prefix)) {
                    // NOTE: .replace() is intended; only replace first occurrence
                    token = token.replace(this.config.prefix, '');
                } else {
                    token = ' ' + token;
                }
            }
            if (this.cleanup) {
                token = clean_up_tokenization(token)
            }

            return token;
        });
    }
}

/**
 * Byte-level decoder for tokenization output. Inherits from the `Decoder` class.
 * @extends Decoder
 */
class ByteLevelDecoder extends Decoder {

    /**
     * Create a `ByteLevelDecoder` object.
     * @param {Object} config Configuration object.
     */
    constructor(config) {
        super(config);

        this.byte_decoder = UNICODE_TO_BYTES;
        this.text_decoder = new TextDecoder("utf-8", {
            fatal: false,
            ignoreBOM: true,
        });

        this.end_of_word_suffix = null;
    }

    /**
     * Convert an array of tokens to string by decoding each byte.
     * @param {string[]} tokens Array of tokens to be decoded.
     * @returns {string} The decoded string.
     */
    convert_tokens_to_string(tokens) {
        let text = tokens.join('');

        let byteArray = new Uint8Array([...text].map(c => this.byte_decoder[c]));
        let decoded_text = this.text_decoder.decode(byteArray);
        return decoded_text;
    }

    /** @type {Decoder['decode_chain']} */
    decode_chain(tokens) {
        // TODO move to base class (like HF)
        // tokens === filtered_tokens

        // To avoid mixing byte-level and unicode for byte-level BPT
        // we need to build string separately for added tokens and byte-level tokens
        // cf. https://github.com/huggingface/transformers/issues/1133
        let sub_texts = [];
        let current_sub_text = [];
        for (let token of tokens) {
            // tokens sent here are already filtered, so we don't need to do this
            // if (skip_special_tokens && this.all_special_ids.includes(token)) {
            //     continue;
            // }

            if (this.added_tokens.includes(token)) {
                if (current_sub_text.length > 0) {
                    sub_texts.push(this.convert_tokens_to_string(current_sub_text));
                    current_sub_text = [];
                }
                sub_texts.push(token);
            } else {
                current_sub_text.push(token);
            }
        }
        if (current_sub_text.length > 0) {
            sub_texts.push(this.convert_tokens_to_string(current_sub_text));
        }

        // TODO add spaces_between_special_tokens and clean_up_tokenization_spaces options

        return sub_texts;
    }
}


/**
 * Apply a sequence of decoders.
 * @extends Decoder
 */
class DecoderSequence extends Decoder {

    /**
     * Creates a new instance of DecoderSequence.
     * @param {Object} config The configuration object.
     * @param {Decoder[]} config.decoders The list of decoders to apply.
     */
    constructor(config) {
        super(config);
        this.decoders = config.decoders.map(x => Decoder.fromConfig(x));
    }

    /** @type {Decoder['decode_chain']} */
    decode_chain(tokens) {
        // Use reduce to apply each decoder to the tokens
        return this.decoders.reduce((toks, decoder) => {
            return decoder.decode_chain(toks);
        }, tokens);
    }

}

/**
 * This PreTokenizer replaces spaces with the given replacement character, adds a prefix space if requested,
 * and returns a list of tokens.
 * @extends PreTokenizer
 */
class MetaspacePreTokenizer extends PreTokenizer {
    /**
     * @param {Object} config The configuration object for the MetaspacePreTokenizer.
     * @param {boolean} config.add_prefix_space Whether to add a prefix space to the first token.
     * @param {string} config.replacement The character to replace spaces with.
     * @param {string} [config.str_rep=config.replacement] An optional string representation of the replacement character.
     */
    constructor(config) {
        super();

        this.addPrefixSpace = config.add_prefix_space;
        this.replacement = config.replacement;
        this.strRep = config.str_rep || this.replacement;
    }

    /**
     * This method takes a list of normalized tokens, replaces spaces with the replacement character,
     * adds a prefix space if requested, and returns a new list of tokens.
     * @param {string[]|string} normalizedTokens The list of normalized tokens to pre-tokenize.
     * @returns {string[]} A new list of pre-tokenized tokens.
     */
    pre_tokenize(normalizedTokens) {
        if (typeof normalizedTokens === 'string') {
            // Metaspace acts on a list of tokens. If passing in a string, first split on whitespace
            // NOTE: For some reason, metaspace includes trailing whitespace, so we only trim leading whitespace.
            // See: https://github.com/huggingface/tokenizers/issues/1250
            normalizedTokens = normalizedTokens.trimStart().split(/\s+/);
        }

        const result = [];
        for (let token of normalizedTokens) {
            let normalized = token.replaceAll(' ', this.strRep);
            if (this.addPrefixSpace && !normalized.startsWith(this.replacement)) {
                normalized = this.strRep + normalized;
            }
            result.push(normalized);
        }
        return result;
    }
}

/**
 * MetaspaceDecoder class extends the Decoder class and decodes Metaspace tokenization.
 * @extends Decoder
 */
class MetaspaceDecoder extends Decoder {
    /**
     * Constructs a new MetaspaceDecoder object.
     * @param {Object} config The configuration object for the MetaspaceDecoder.
     * @param {boolean} config.add_prefix_space Whether to add a prefix space to the decoded string.
     * @param {string} config.replacement The string to replace spaces with.
     */
    constructor(config) {
        super(config);

        this.addPrefixSpace = config.add_prefix_space;
        this.replacement = config.replacement;
    }

    /** @type {Decoder['decode_chain']} */
    decode_chain(tokens) {
        let result = [];
        for (let i = 0; i < tokens.length; ++i) {
            let normalized = tokens[i].replaceAll(this.replacement, ' ');
            if (this.addPrefixSpace && i == 0 && normalized.startsWith(' ')) {
                normalized = normalized.substring(1);
            }
            result.push(normalized);
        }
        return result;
    }
}

/**
 * A normalizer that applies a precompiled charsmap.
 * This is useful for applying complex normalizations in C++ and exposing them to JavaScript.
 * @extends Normalizer
 * @param {Object} config The configuration object for the Precompiled normalizer.
 * @param {Object} config.precompiled_charsmap The precompiled charsmap object.
 */
class Precompiled extends Normalizer {
    /**
     * Create a new instance of Precompiled normalizer.
     * @param {Object} config The configuration object.
     * @param {any} config.precompiled_charsmap Precompiled chars mapping.
     */
    constructor(config) {
        super(config);
        this.charsmap = config.precompiled_charsmap;
    }

    /**
     * Normalizes the given text by applying the precompiled charsmap.
     * @param {string} text The text to normalize.
     * @returns {string} The normalized text.
     */
    normalize(text) {
        // TODO use this.charsmap
        // For now, we just apply NFKC normalization
        // https://github.com/huggingface/tokenizers/blob/291b2e23ae81cf94738835852213ce120152d121/bindings/python/py_src/tokenizers/implementations/sentencepiece_bpe.py#L34
        text = text.normalize('NFKC');
        return text;
    }
}

/**
 * A pre-tokenizer that applies a sequence of pre-tokenizers to the input text.
 * @extends PreTokenizer
 */
class PreTokenizerSequence extends PreTokenizer {
    /**
     * Creates an instance of PreTokenizerSequence.
     * @param {Object} config The configuration object for the pre-tokenizer sequence.
     * @param {Object[]} config.pretokenizers An array of pre-tokenizer configurations.
     */
    constructor(config) {
        super();
        this.tokenizers = config.pretokenizers.map(x => PreTokenizer.fromConfig(x));
    }

    /**
     * Applies each pre-tokenizer in the sequence to the input text in turn.
     * @param {string|string[]} text The text(s) to pre-tokenize.
     * @returns {string[]} The pre-tokenized text.
     */
    pre_tokenize_text(text) {
        if (typeof text === 'string') {
            text = [text];
        }
        // Use reduce to apply each tokenizer to the text
        return this.tokenizers.reduce((preTokenizedText, tokenizer) => {
            return tokenizer.pre_tokenize(preTokenizedText);
        }, text);
    }
}

/**
 * Splits a string of text by whitespace characters into individual tokens.
 * @extends PreTokenizer
 */
class WhitespaceSplit extends PreTokenizer {
    /**
     * Creates an instance of WhitespaceSplit.
     * @param {Object} config The configuration object for the pre-tokenizer sequence.
     */
    constructor(config) {
        super();
    }
    /**
     * Pre-tokenizes the input text by splitting it on whitespace characters.
     * @param {string} text The text to be pre-tokenized.
     * @returns {string[]} An array of tokens produced by splitting the input text on whitespace.
     */
    pre_tokenize_text(text) {
        return whitespace_split(text);
    }
}

class PreTrainedTokenizer extends _utils_core_js__WEBPACK_IMPORTED_MODULE_0__.Callable {
    /**
     * Create a new PreTrainedTokenizer instance.
     * @param {Object} tokenizerJSON The JSON of the tokenizer.
     * @param {Object} tokenizerConfig The config of the tokenizer.
     */
    constructor(tokenizerJSON, tokenizerConfig) {
        super();

        // Construct parts of the tokenizer from the JSON
        this.normalizer = Normalizer.fromConfig(tokenizerJSON.normalizer);
        this.pre_tokenizer = PreTokenizer.fromConfig(tokenizerJSON.pre_tokenizer);

        // Convert the vocabulary to a map, if it exists
        if (tokenizerJSON.model.vocab) {
            if (!Array.isArray(tokenizerJSON.model.vocab)) {
                tokenizerJSON.model.vocab = Object.entries(tokenizerJSON.model.vocab);
            }
            tokenizerJSON.model.vocab = new Map(tokenizerJSON.model.vocab);
        }
        this.model = TokenizerModel.fromConfig(tokenizerJSON.model, tokenizerConfig);
        this.post_processor = PostProcessor.fromConfig(tokenizerJSON.post_processor);

        // TODO: maybe, allow this to be null; in which case, we use model as decoder too?
        this.decoder = Decoder.fromConfig(tokenizerJSON.decoder);


        // Another slight hack to add `end_of_word_suffix` (if present) to the decoder
        // This is needed for cases where BPE model and ByteLevel decoder are used
        // For more information, see https://github.com/xenova/transformers.js/issues/74
        // TODO: save this to the decoder when exporting?
        this.decoder.end_of_word_suffix = this.model.end_of_word_suffix;

        // Add added_tokens to model
        this.special_tokens = [];
        this.all_special_ids = [];
        this.added_tokens = [];
        for (let addedToken of tokenizerJSON.added_tokens) {
            let id = addedToken.id;
            let content = addedToken.content;

            this.added_tokens.push(content);

            this.model.tokens_to_ids.set(content, id);
            this.model.vocab[id] = content;

            if (addedToken.special) {
                this.special_tokens.push(content);
                this.all_special_ids.push(id);
            }
        }

        // Slight hack, but it prevents code duplication:
        this.decoder.added_tokens = this.added_tokens;

        this.added_tokens_regex = new RegExp(
            '(' + this.added_tokens.map(_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.escapeRegExp).join('|') + ')'
        );

        // Set mask token if present (otherwise will be undefined, which is fine)
        this.mask_token = this.getToken(tokenizerConfig, 'mask_token');
        this.mask_token_id = this.model.tokens_to_ids.get(this.mask_token);

        this.pad_token = this.getToken(tokenizerConfig, 'pad_token', 'eos_token');
        this.pad_token_id = this.model.tokens_to_ids.get(this.pad_token);

        this.sep_token = this.getToken(tokenizerConfig, 'sep_token');
        this.sep_token_id = this.model.tokens_to_ids.get(this.sep_token);

        this.model_max_length = tokenizerConfig.model_max_length;

        /** @type {boolean} Whether or not to strip the text when tokenizing (removing excess spaces before and after the string). */
        this.remove_space = tokenizerConfig.remove_space;

        this.clean_up_tokenization_spaces = tokenizerConfig.clean_up_tokenization_spaces ?? true;

        // TODO allow user to change this
        this.padding_side = 'right';
    }

    /**
     * Returns the value of the first matching key in the tokenizer config object.
     * @param {...string} keys One or more keys to search for in the tokenizer config object.
     * @returns {string|null} The value associated with the first matching key, or null if no match is found.
     * @throws {Error} If an object is found for a matching key and its __type property is not "AddedToken".
     */
    getToken(tokenizerConfig, ...keys) {
        for (let key of keys) {
            let item = tokenizerConfig[key];

            if (!item) continue;

            if (typeof item === 'object') {
                if (item.__type === 'AddedToken') {
                    return item.content;
                } else {
                    throw Error(`Unknown token: ${item}`);
                }
            } else {
                return item;
            }
        }
        return null;
    }

    /**
     * Loads a pre-trained tokenizer from the given `pretrained_model_name_or_path`. 
     * 
     * @param {string} pretrained_model_name_or_path The path to the pre-trained tokenizer.
     * @param {PretrainedOptions} options Additional options for loading the tokenizer.
     * 
     * @throws {Error} Throws an error if the tokenizer.json or tokenizer_config.json files are not found in the `pretrained_model_name_or_path`.
     * @returns {Promise<PreTrainedTokenizer>} A new instance of the `PreTrainedTokenizer` class.
     */
    static async from_pretrained(pretrained_model_name_or_path, {
        progress_callback = null,
        config = null,
        cache_dir = null,
        local_files_only = false,
        revision = 'main',
    } = {}) {

        let info = await loadTokenizer(pretrained_model_name_or_path, {
            progress_callback,
            config,
            cache_dir,
            local_files_only,
            revision,
        })

        // @ts-ignore
        return new this(...info);
    }

    /**
     * This function can be overridden by a subclass to apply additional preprocessing
     * to a model's input data.
     * @param {Object} inputs An object containing input data as properties.
     * @returns {Object} The modified inputs object.
     */
    prepare_model_inputs(inputs) {
        return inputs;
    }

    /**
     * Encode/tokenize the given text(s).
     * @param {string|string[]} text The text to tokenize.
     * @param {Object} options An optional object containing the following properties:
     * @param {string|string[]} [options.text_pair=null] Optional second sequence to be encoded. If set, must be the same type as text.
     * @param {boolean} [options.padding=false] Whether to pad the input sequences.
     * @param {boolean} [options.truncation=null] Whether to truncate the input sequences.
     * @param {number} [options.max_length=null] Maximum length of the returned list and optionally padding length.
     * @param {boolean} [options.return_tensor=true] Whether to return the results as Tensors or arrays.
     * @returns {{ input_ids: number[]|number[][]|Tensor, attention_mask: any[]|Tensor }} Object to be passed to the model.
     */
    _call(
        // Required positional arguments
        text,

        // Optional keyword arguments
        {
            text_pair = null,
            // add_special_tokens = true, // TODO
            padding = false,
            truncation = null,
            max_length = null,
            return_tensor = true, // Different to HF
        } = {},
    ) {

        /** @type {number[]|number[][]|Tensor} */
        let tokens;

        if (Array.isArray(text)) {
            if (text.length === 0) {
                throw Error('text array must be non-empty')
            }

            if (text_pair !== null) {
                if (!Array.isArray(text_pair)) {
                    throw Error('text_pair must also be an array')

                } else if (text.length !== text_pair.length) {
                    throw Error('text and text_pair must have the same length')
                }

                tokens = text.map(
                    (t, i) => this.encode(t, text_pair[i])
                )

            } else {
                tokens = text.map(x => this.encode(x));
            }

        } else {
            if (text === null) {
                throw Error('text may not be null')
            }

            if (Array.isArray(text_pair)) {
                throw Error('When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).')
            }

            // For single input, we just wrap in an array, and then unwrap later.
            tokens = [this.encode(text, text_pair)];
        }
        // At this point, tokens is batched: [batch_size, tokens]
        // However, array may be jagged. So, we pad to max_length

        let maxLengthOfBatch = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(tokens.map(x => x.length))[0];

        // If null, we calculate max length from sequences
        if (max_length === null) {
            max_length = maxLengthOfBatch;
        }

        // Ensure it is less than model max length
        max_length = Math.min(max_length, this.model_max_length)

        /** @type {any[]|Tensor} */
        let attention_mask = [];
        if (padding || truncation) {
            // Perform padding and/or truncation
            for (let i = 0; i < tokens.length; ++i) {
                if (tokens[i].length === max_length) {
                    attention_mask.push(new Array(tokens[i].length).fill(1))
                    continue;

                } else if (tokens[i].length > max_length) {
                    // possibly truncate
                    if (truncation) {
                        tokens[i] = tokens[i].slice(0, max_length);
                    }
                    attention_mask.push(new Array(tokens[i].length).fill(1))

                } else { // t.length < max_length
                    if (padding) {
                        let diff = max_length - tokens[i].length;

                        if (this.padding_side === 'right') {
                            attention_mask.push(
                                (new Array(tokens[i].length).fill(1)).concat(new Array(diff).fill(0))
                            )
                            tokens[i].push(...new Array(diff).fill(this.pad_token_id))
                        } else { // left
                            attention_mask.push(
                                (new Array(diff).fill(0)).concat(new Array(tokens[i].length).fill(1))
                            )
                            tokens[i].unshift(...new Array(diff).fill(this.pad_token_id))
                        }

                    } else {
                        attention_mask.push(new Array(tokens[i].length).fill(1))
                    }
                }
            }
        } else {
            attention_mask = tokens.map(x => new Array(x.length).fill(1))
        }

        if (return_tensor) {
            if (!(padding && truncation)) {
                // Not, guaranteed that all items have same length, so
                // we perform additional check

                if (tokens.some(x => x.length !== tokens[0].length)) {
                    throw Error(
                        "Unable to create tensor, you should probably activate truncation and/or padding " +
                        "with 'padding=true' and 'truncation=true' to have batched tensors with the same length."
                    )
                }
            }

            // Now we actually convert to tensor
            // NOTE: In the same way as the python library, we return a batched tensor, regardless of
            // whether we have a single input or multiple inputs.
            let dims = [tokens.length, tokens[0].length];

            tokens = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor('int64',
                BigInt64Array.from(tokens.flat().map(BigInt)),
                dims
            );

            attention_mask = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
                'int64',
                BigInt64Array.from(attention_mask.flat().map(BigInt)),
                dims
            )
        } else {
            // If not returning a tensor, we match the input type
            if (!Array.isArray(text)) {
                // Input was not batched, so we unwrap
                tokens = tokens[0];
                attention_mask = attention_mask[0];
            }
        }


        // Finally, add attention mask, and possibly model-specific parameters
        let modelInputs = {
            input_ids: tokens,
            attention_mask: attention_mask
        }

        // Optional post-processing
        modelInputs = this.prepare_model_inputs(modelInputs);

        return modelInputs
    }

    /**
     * Encodes a single text using the preprocessor pipeline of the tokenizer.
     *
     * @param {string|null} text The text to encode.
     * @returns {string[]|null} The encoded tokens.
     */
    _encode_text(text) {
        if (text === null) return null;

        // Actual function which does encoding, for a single text
        // First, we take care of special tokens. Needed to avoid issues arising from
        // normalization and/or pretokenization (which may not preserve special tokens)
        const sections = text.split(this.added_tokens_regex).filter(x => x);

        let tokens = sections.map(x => {
            if (this.added_tokens.includes(x)) {
                // Ignore added tokens
                return x
            } else {
                if (this.remove_space === true) {
                    x = x.trim().split(/\s+/).join(' ');
                }

                if (this.normalizer !== null) {
                    x = this.normalizer(x);
                }

                let sectionTokens = (this.pre_tokenizer !== null) ? this.pre_tokenizer(x) : [x];

                let tokens = this.model(sectionTokens);

                return tokens;
            }
        }).flat();

        return tokens;
    }

    /**
     * Encodes a single text or a pair of texts using the model's tokenizer.
     *
     * @param {string} text The text to encode.
     * @param {string|null} text_pair The optional second text to encode.
     * @returns {number[]} An array of token IDs representing the encoded text(s).
     */
    encode(text, text_pair = null) {
        // Function called by users to encode possibly multiple texts
        let tokens = this._encode_text(text);
        let tokens2 = this._encode_text(text_pair);

        let combinedTokens = (this.post_processor !== null)
            ? this.post_processor(tokens, tokens2)
            : (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(tokens ?? [], tokens2 ?? []);

        let ids = this.model.convert_tokens_to_ids(combinedTokens);
        return ids;
    }

    /**
     * Decode a batch of tokenized sequences.
     * @param {number[][]} batch List of tokenized input sequences.
     * @param {Object} decode_args (Optional) Object with decoding arguments.
     * @returns {string[]} List of decoded sequences.
     */
    batch_decode(batch, decode_args = {}) {
        return batch.map(x => this.decode(x, decode_args));
    }

    /**
     * Decodes a sequence of token IDs back to a string.
     *
     * @param {number[]} token_ids List of token IDs to decode.
     * @param {Object} [decode_args={}]
     * @param {boolean} [decode_args.skip_special_tokens=false] If true, special tokens are removed from the output string.
     * @param {boolean} [decode_args.clean_up_tokenization_spaces=true] If true, spaces before punctuations and abbreviated forms are removed.
     *
     * @returns {string} The decoded string.
     * @throws {Error} If `token_ids` is not a non-empty array of integers.
     */
    decode(
        token_ids,
        decode_args = {},
    ) {
        if (!Array.isArray(token_ids) || token_ids.length === 0 || !(0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.isIntegralNumber)(token_ids[0])) {
            throw Error("token_ids must be a non-empty array of integers.");
        }

        return this.decode_single(token_ids, decode_args)
    }

    /**
     * Decode a single list of token ids to a string.
     * @param {number[]} token_ids List of token ids to decode
     * @param {Object} decode_args Optional arguments for decoding
     * @param {boolean} [decode_args.skip_special_tokens=false] Whether to skip special tokens during decoding
     * @param {boolean} [decode_args.clean_up_tokenization_spaces=null] Whether to clean up tokenization spaces during decoding.
     * If null, the value is set to `this.decoder.cleanup` if it exists, falling back to `this.clean_up_tokenization_spaces` if it exists, falling back to `true`.
     * @returns {string} The decoded string
     */
    decode_single(
        token_ids,
        {
            skip_special_tokens = false,
            clean_up_tokenization_spaces = null,
        }
    ) {
        let tokens = this.model.convert_ids_to_tokens(token_ids);
        if (skip_special_tokens) {
            tokens = tokens.filter(x => !this.special_tokens.includes(x));
        }

        /** @type {string} */
        let decoded = this.decoder(tokens);


        // Slight hack, but prevents having to pass `skip_special_tokens` to
        // each call to `decode`, which would lead to code duplication.
        if (this.decoder.end_of_word_suffix) {
            decoded = decoded.replaceAll(this.decoder.end_of_word_suffix, ' ');
            if (skip_special_tokens) {
                decoded = decoded.trim();
            }
        }

        if (clean_up_tokenization_spaces ?? this.clean_up_tokenization_spaces) {
            decoded = clean_up_tokenization(decoded);
        }

        return decoded;
    }

}

/**
* Helper method for adding `token_type_ids` to model inputs
* @param {Object} inputs An object containing the input ids and attention mask.
* @returns {Object} The prepared inputs object.
*/
function add_token_types(inputs) {
    // TODO ensure correctness when token pair is present
    if (inputs.input_ids instanceof _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor) {
        inputs.token_type_ids = new _utils_tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor(
            'int64',
            new BigInt64Array(inputs.input_ids.data.length),
            inputs.input_ids.dims
        )
    } else if (Array.isArray(inputs.input_ids)) {

        if (Array.isArray(inputs.input_ids[0])) {
            // This means input is batched, so we need to batch the token_type_ids as well
            inputs.token_type_ids = inputs.input_ids.map(
                x => new Array(x.length).fill(0)
            )
        } else {
            inputs.token_type_ids = new Array(inputs.input_ids.length).fill(0);
        }
    } else {
        throw new Error('Input ids must be a Tensor or an Array')
    }

    return inputs;
}

/**
 * BertTokenizer is a class used to tokenize text for BERT models.
 * @extends PreTrainedTokenizer
 */
class BertTokenizer extends PreTrainedTokenizer {
    /** @type {add_token_types} */
    prepare_model_inputs(inputs) {
        return add_token_types(inputs);
    }
}
/**
 * Albert tokenizer
 * @extends PreTrainedTokenizer
 */
class AlbertTokenizer extends PreTrainedTokenizer {
    /** @type {add_token_types} */
    prepare_model_inputs(inputs) {
        return add_token_types(inputs);
    }
}
class MobileBertTokenizer extends PreTrainedTokenizer {
    /** @type {add_token_types} */
    prepare_model_inputs(inputs) {
        return add_token_types(inputs);
    }
}
class SqueezeBertTokenizer extends PreTrainedTokenizer {
    /** @type {add_token_types} */
    prepare_model_inputs(inputs) {
        return add_token_types(inputs);
    }
}
class DistilBertTokenizer extends PreTrainedTokenizer { }
class T5Tokenizer extends PreTrainedTokenizer { }
class GPT2Tokenizer extends PreTrainedTokenizer { }
class BartTokenizer extends PreTrainedTokenizer { }
class RobertaTokenizer extends PreTrainedTokenizer { }

class BloomTokenizer extends PreTrainedTokenizer { }
class LlamaTokenizer extends PreTrainedTokenizer { }

class XLMRobertaTokenizer extends PreTrainedTokenizer { }
class MPNetTokenizer extends PreTrainedTokenizer { }

class FalconTokenizer extends PreTrainedTokenizer {
    /** @type {add_token_types} */
    prepare_model_inputs(inputs) {
        return add_token_types(inputs);
    }
}

class GPTNeoXTokenizer extends PreTrainedTokenizer { }

/**
 * The NllbTokenizer class is used to tokenize text for NLLB ("No Language Left Behind") models.
 * 
 * No Language Left Behind (NLLB) is a first-of-its-kind, AI breakthrough project
 * that open-sources models capable of delivering high-quality translations directly
 * between any pair of 200+ languages — including low-resource languages like Asturian,
 * Luganda, Urdu and more. It aims to help people communicate with anyone, anywhere,
 * regardless of their language preferences. For more information, check out their
 * [paper](https://arxiv.org/abs/2207.04672).
 * 
 * For a list of supported languages (along with their language codes),
 * @see {@link https://github.com/facebookresearch/flores/blob/main/flores200/README.md#languages-in-flores-200}
 */
class NllbTokenizer extends PreTrainedTokenizer {

    constructor(tokenizerJSON, tokenizerConfig) {
        super(tokenizerJSON, tokenizerConfig);

        this.languageRegex = /^[a-z]{3}_[A-Z][a-z]{3}$/;
        this.language_codes = this.special_tokens.filter(x => this.languageRegex.test(x));
    }

    /**
     * Helper function to build translation inputs for an `NllbTokenizer`.
     * @param {string|string[]} raw_inputs The text to tokenize.
     * @param {Object} tokenizer_options Options to be sent to the tokenizer
     * @param {Object} generate_kwargs Generation options.
     * @returns {Object} Object to be passed to the model.
     */
    _build_translation_inputs(raw_inputs, tokenizer_options, generate_kwargs) {


        // Check that the target language is valid:
        if (!this.language_codes.includes(generate_kwargs.tgt_lang)) {
            throw new Error(`Target language code "${generate_kwargs.tgt_lang}" is not valid. Must be one of: {${this.language_codes.join(', ')}}`);
        }

        // Allow `src_lang` to be optional. If not set, we'll use the tokenizer's default.
        if (generate_kwargs.src_lang !== undefined) {
            // Check that the source language is valid:
            if (!this.language_codes.includes(generate_kwargs.src_lang)) {
                throw new Error(`Source language code "${generate_kwargs.src_lang}" is not valid. Must be one of: {${this.language_codes.join(', ')}}`);
            }

            // In the same way as the Python library, we override the post-processor
            // to force the source language to be first:
            for (let item of this.post_processor.config.single) {
                if ('SpecialToken' in item && this.languageRegex.test(item.SpecialToken.id)) {
                    item.SpecialToken.id = generate_kwargs.src_lang;
                    break;
                }
            }
        }

        // Override the `forced_bos_token_id` to force the correct language
        generate_kwargs.forced_bos_token_id = this.model.convert_tokens_to_ids([generate_kwargs.tgt_lang])[0];

        return this._call(raw_inputs, tokenizer_options);
    }
}


const WHISPER_LANGUAGES = [
    ["en", "english"],
    ["zh", "chinese"],
    ["de", "german"],
    ["es", "spanish"],
    ["ru", "russian"],
    ["ko", "korean"],
    ["fr", "french"],
    ["ja", "japanese"],
    ["pt", "portuguese"],
    ["tr", "turkish"],
    ["pl", "polish"],
    ["ca", "catalan"],
    ["nl", "dutch"],
    ["ar", "arabic"],
    ["sv", "swedish"],
    ["it", "italian"],
    ["id", "indonesian"],
    ["hi", "hindi"],
    ["fi", "finnish"],
    ["vi", "vietnamese"],
    ["he", "hebrew"],
    ["uk", "ukrainian"],
    ["el", "greek"],
    ["ms", "malay"],
    ["cs", "czech"],
    ["ro", "romanian"],
    ["da", "danish"],
    ["hu", "hungarian"],
    ["ta", "tamil"],
    ["no", "norwegian"],
    ["th", "thai"],
    ["ur", "urdu"],
    ["hr", "croatian"],
    ["bg", "bulgarian"],
    ["lt", "lithuanian"],
    ["la", "latin"],
    ["mi", "maori"],
    ["ml", "malayalam"],
    ["cy", "welsh"],
    ["sk", "slovak"],
    ["te", "telugu"],
    ["fa", "persian"],
    ["lv", "latvian"],
    ["bn", "bengali"],
    ["sr", "serbian"],
    ["az", "azerbaijani"],
    ["sl", "slovenian"],
    ["kn", "kannada"],
    ["et", "estonian"],
    ["mk", "macedonian"],
    ["br", "breton"],
    ["eu", "basque"],
    ["is", "icelandic"],
    ["hy", "armenian"],
    ["ne", "nepali"],
    ["mn", "mongolian"],
    ["bs", "bosnian"],
    ["kk", "kazakh"],
    ["sq", "albanian"],
    ["sw", "swahili"],
    ["gl", "galician"],
    ["mr", "marathi"],
    ["pa", "punjabi"],
    ["si", "sinhala"],
    ["km", "khmer"],
    ["sn", "shona"],
    ["yo", "yoruba"],
    ["so", "somali"],
    ["af", "afrikaans"],
    ["oc", "occitan"],
    ["ka", "georgian"],
    ["be", "belarusian"],
    ["tg", "tajik"],
    ["sd", "sindhi"],
    ["gu", "gujarati"],
    ["am", "amharic"],
    ["yi", "yiddish"],
    ["lo", "lao"],
    ["uz", "uzbek"],
    ["fo", "faroese"],
    ["ht", "haitian creole"],
    ["ps", "pashto"],
    ["tk", "turkmen"],
    ["nn", "nynorsk"],
    ["mt", "maltese"],
    ["sa", "sanskrit"],
    ["lb", "luxembourgish"],
    ["my", "myanmar"],
    ["bo", "tibetan"],
    ["tl", "tagalog"],
    ["mg", "malagasy"],
    ["as", "assamese"],
    ["tt", "tatar"],
    ["haw", "hawaiian"],
    ["ln", "lingala"],
    ["ha", "hausa"],
    ["ba", "bashkir"],
    ["jw", "javanese"],
    ["su", "sundanese"],
]

// @ts-ignore
const WHISPER_LANGUAGE_MAPPING = new Map(WHISPER_LANGUAGES);
// @ts-ignore
const WHISPER_TO_LANGUAGE_CODE_MAPPING = new Map([
    ...WHISPER_LANGUAGES.map(([k, v]) => [v, k]),
    ...[
        ["burmese", "my"],
        ["valencian", "ca"],
        ["flemish", "nl"],
        ["haitian", "ht"],
        ["letzeburgesch", "lb"],
        ["pushto", "ps"],
        ["panjabi", "pa"],
        ["moldavian", "ro"],
        ["moldovan", "ro"],
        ["sinhalese", "si"],
        ["castilian", "es"],
    ]
]);

/**
 * WhisperTokenizer tokenizer
 * @extends PreTrainedTokenizer
 */
class WhisperTokenizer extends PreTrainedTokenizer {

    /**
     * Decodes automatic speech recognition (ASR) sequences.
     * @param {Array<{tokens: number[], token_timestamps?: number[], stride: number[]}>} sequences The sequences to decode.
     * @param {Object} options The options to use for decoding.
     * @returns {Array<string|{chunks?: undefined|Array<{language: string|null, timestamp: Array<number|null>, text: string}>}>} The decoded sequences.
     */
    _decode_asr(sequences, {
        return_timestamps = false,
        return_language = false,
        time_precision = null,
        force_full_sequences = true
    } = {}) {
        // Set force_full_sequences=false if you want streaming
        // TODO add support for `return_language`

        // Internal method meant to only be used by asr pipeline.
        // Handles all the little quirks specific to whisper to handle
        // the various options not allowed in other seq2seq models

        // =========== Overview ============
        // - iterate over all outputs
        // - all tokens within output
        // - Each token can be
        //   - language token
        //   - special token
        //   - timestamp token
        //   - text token
        // - We accumulate the text tokens.
        // - We split on end timestamps
        // - Lots of complexity comes from stride and timestamps

        if (time_precision === null) {
            throw Error("Must specify time_precision")
        }
        let last_language = null;

        const returnWordTimestamps = return_timestamps === "word";

        function new_chunk() {
            return { "language": last_language, "timestamp": [null, null], "text": "" };
        }

        // Welcome to the state machine!
        const chunks = [];
        let chunk = new_chunk();
        let time_offset = 0.0;
        const timestamp_begin = this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0] + 1;

        let previous_tokens = [];
        let previous_token_timestamps = [];

        let skip = false;
        let right_stride_start = null;


        const all_special_ids = new Set(this.all_special_ids);

        for (let output of sequences) {
            // NOTE: python version has batches, so it uses [0]
            const token_ids = output.tokens;
            const token_timestamps = returnWordTimestamps ? output.token_timestamps : null;

            // These keep track of timestamps within strides, which need
            // to be skipped and resolve all tokens in a single chunk.
            let last_timestamp = null;
            let first_timestamp = timestamp_begin;

            if ("stride" in output) {
                const [chunk_len, stride_left, stride_right] = output.stride;

                // Offset the timings to account for the other `model_outputs`.
                time_offset -= stride_left;
                right_stride_start = chunk_len - stride_right;

                // Keeping track of timestamps within strides
                // We're going to NOT split on those, and delay until we're
                // out of BOTH stride. Otherwise lots of issues occur and
                // corner cases
                if (stride_left) {
                    first_timestamp = stride_left / time_precision + timestamp_begin;
                }

                if (stride_right) {
                    for (let i = token_ids.length - 1; i >= 0; --i) {
                        const token = token_ids[i];
                        if (token >= timestamp_begin) {
                            // There can be several token in the right stride
                            // But the last one is ALWAYS going to be skipped
                            if (last_timestamp !== null && (token - timestamp_begin) * time_precision < right_stride_start) {
                                break;
                            }
                            last_timestamp = token;
                        }
                    }
                }
            }

            let current_tokens = [];
            let current_token_timestamps = [];

            // - all tokens within output
            for (let i = 0; i < token_ids.length; ++i) {
                const token = token_ids[i];
                // 4 possible states for each token
                // - 1/ Language code
                // - 2/ all other special tokens (which we ignore)
                // - 3/ Timestamp
                // - 4/ Regular text

                if (all_special_ids.has(token)) {
                    const text = this.decode([token]);
                    if (text[0] === "[" && text[text.length - 1] === "]") {
                        const language = WHISPER_LANGUAGE_MAPPING.get(text.slice(1, -1));

                        if (language !== undefined) {
                            // 1/ Indeed some language
                            // TODO Handle when language is different from the previous
                            // one, and we cannot use timestamped tokens to create chunks
                            if (last_language !== null && language !== last_language && !return_timestamps) {
                                previous_tokens.push(current_tokens);
                                const resolved_tokens = this.findLongestCommonSequence(previous_tokens)[0];
                                const resolved_text = this.decode(resolved_tokens);
                                chunk.text = resolved_text;
                                chunks.push(chunk);

                                // Flush all our temporary context
                                previous_tokens = [];
                                current_tokens = [];
                                chunk = new_chunk();
                            }

                            last_language = chunk.language = language;
                        } else {
                            // 2/ This is a regular special token, ignoring it
                        }
                    }
                } else if (token >= timestamp_begin) {
                    // 3/ Timestamp token
                    const time = (token - timestamp_begin) * time_precision + time_offset;
                    const rounded_time = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(time, 2);

                    if (last_timestamp !== null && token >= last_timestamp) {
                        // Whisper outputted a timestamp token, but it falls within
                        // our stride, so we're going to skip it for the time being
                        // and resolve this later
                        // Skip is necessary because timestamp tokens always come
                        // by pair, so we need to skip the next one too (which would mark the start of another chunk).
                        skip = true;
                    } else if (skip || (previous_tokens.length > 0 && token < first_timestamp)) {
                        skip = false;
                    } else if (chunk.timestamp[0] === null) {
                        chunk.timestamp[0] = rounded_time;
                    } else {
                        // This is the end of the timestamp chunk
                        if (rounded_time === chunk.timestamp[0]) {
                            // This is a bug in timestamp token output
                            // where we're taking the duplicate token
                            // as a stop where it should be a start.
                            // This is an issue in the underlying model output
                            // Let's just skip it so it becomes de-factor a start agin
                        } else {
                            chunk.timestamp[1] = rounded_time;

                            // Handling merges
                            previous_tokens.push(current_tokens)

                            if (returnWordTimestamps) {
                                previous_token_timestamps.push(current_token_timestamps);
                            }
                            const [resolved_tokens, resolved_token_timestamps] = this.findLongestCommonSequence(
                                previous_tokens, previous_token_timestamps
                            )

                            const resolved_text = this.decode(resolved_tokens)
                            chunk.text = resolved_text

                            if (returnWordTimestamps) {
                                chunk.words = this.collateWordTimestamps(
                                    resolved_tokens, resolved_token_timestamps, last_language,
                                )
                            }

                            chunks.push(chunk)

                            // Flush all our temporary context
                            previous_tokens = []
                            current_tokens = []
                            previous_token_timestamps = []
                            current_token_timestamps = []
                            chunk = new_chunk()
                        }
                    }

                } else {
                    // 4/ Regular token
                    // We just append to the list of all tokens so we can handle
                    // merges later and decode into text.
                    current_tokens.push(token)

                    if (returnWordTimestamps) {
                        let start_time = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(token_timestamps[i] + time_offset, 2);

                        let end_time;
                        if (i + 1 < token_timestamps.length) {
                            end_time = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(token_timestamps[i + 1] + time_offset, 2);
                        } else {
                            // should never happen
                            end_time = null;
                        }
                        current_token_timestamps.push([start_time, end_time]);
                    }

                }
            }

            if ('stride' in output) {
                const [chunk_len, stride_left, stride_right] = output.stride;
                time_offset += chunk_len - stride_right
            }

            // Leftover tokens
            if (current_tokens.length > 0) {
                previous_tokens.push(current_tokens)
                if (returnWordTimestamps) {
                    previous_token_timestamps.push(current_token_timestamps);
                }
            } else if (previous_tokens.every(p => p.length === 0)) {
                // Flushing previous tokens (END)"
                chunk = new_chunk()
                previous_tokens = []
                current_tokens = []
                previous_token_timestamps = [];
                current_token_timestamps = [];
            }

        }

        if (previous_tokens.length > 0) {
            if (force_full_sequences && return_timestamps) {
                // Last token should always be timestamps, so there shouldn't be
                // leftover
                throw new Error(
                    "Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. " +
                    "Also make sure WhisperTimeStampLogitsProcessor was used during generation."
                );
            }

            // Happens when we don't use timestamps
            const [resolved_tokens, resolved_token_timestamps] = this.findLongestCommonSequence(previous_tokens, previous_token_timestamps);

            // Flushing previous tokens (FINAL)
            const resolved_text = this.decode(resolved_tokens);
            chunk.text = resolved_text;
            if (returnWordTimestamps) {
                chunk.words = this.collateWordTimestamps(
                    resolved_tokens, resolved_token_timestamps, last_language,
                )
            }
            chunks.push(chunk);
        }

        let optional = Object.create(null);

        // Preparing and cleaning up the pipeline output
        const full_text = chunks.map(chunk => chunk.text).join('');
        if (return_timestamps || return_language) {
            for (let i = 0; i < chunks.length; ++i) {
                const chunk = chunks[i];
                if (!return_timestamps) {
                    delete chunk["timestamp"];
                }

                if (!return_language) {
                    delete chunk["language"];
                }
            }
            if (returnWordTimestamps) {
                let new_chunks = [];
                for (let chunk of chunks) {
                    for (let word of chunk.words) {
                        new_chunks.push(word);
                    }
                }
                optional = { "chunks": new_chunks };
            } else {
                optional = { "chunks": chunks };
            }
        }
        return [full_text, optional];

    }

    /**
     * Finds the longest common sequence among the provided sequences.
     * @param {number[][]} sequences An array of sequences of token ids to compare.
     * @returns {number[][]} The longest common sequence found.
     * @throws {Error} If there is a bug within the function.
     * @private
     */
    findLongestCommonSequence(sequences, token_timestamp_sequences = null) {
        // It would be much harder to do O(n) because of fault tolerance.
        // We actually have a really good property which is that the total sequence
        // MUST be those subsequences in order.
        // If token_timestamp_sequences is provided, will split those sequences in
        // exactly the same way.
        let leftSequence = sequences[0];
        let leftLength = leftSequence.length;
        let totalSequence = [];

        const use_token_timestamp_sequences = Array.isArray(token_timestamp_sequences) && token_timestamp_sequences.length > 0;
        let total_token_timestamp_sequence = use_token_timestamp_sequences ? [] : null;
        let left_token_timestamp_sequence = use_token_timestamp_sequences ? token_timestamp_sequences[0] : null;
        for (let i = 1; i < sequences.length; ++i) {
            const rightSequence = sequences[i];
            let max = 0.0;
            let maxIndices = [leftLength, leftLength, 0, 0];
            // Here we're sliding matches
            // [a, b, c, d]
            //          [c, d, f]
            // =        [c] == [d]

            // [a, b, c, d]
            //       [c, d, f]
            // =     [c, d] == [c, d]


            // [a, b, c, d]
            //    [c, d, f]

            // =  [b, c, d] == [c, d, f]

            // [a, b, c, d]
            // [c, d, f]

            // [a, b, c] == [c, d, f]

            // [a, b, c, d]
            // [d, f]

            // [a, b] == [d, f]

            // [a, b, c, d]
            // [f]

            // [a] == [f]

            const rightLength = rightSequence.length;
            for (let j = 1; j < leftLength + rightLength; ++j) {
                const eps = j / 10000.0;
                const leftStart = Math.max(0, leftLength - j);
                const leftStop = Math.min(leftLength, leftLength + rightLength - j);
                const left = leftSequence.slice(leftStart, leftStop);
                const rightStart = Math.max(0, j - leftLength);
                const rightStop = Math.min(rightLength, j);
                const right = rightSequence.slice(rightStart, rightStop);
                if (left.length !== right.length) {
                    throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");
                }
                const matches = left.filter((elem, idx) => elem === right[idx]).length;
                const matching = matches / j + eps;
                if (matches > 1 && matching > max) {
                    max = matching;
                    maxIndices = [leftStart, leftStop, rightStart, rightStop];
                }
            }
            const [leftStart, leftStop, rightStart, rightStop] = maxIndices;
            const leftMid = Math.floor((leftStop + leftStart) / 2);
            const rightMid = Math.floor((rightStop + rightStart) / 2);
            totalSequence.push(...leftSequence.slice(0, leftMid));
            leftSequence = rightSequence.slice(rightMid);
            leftLength = leftSequence.length;

            if (use_token_timestamp_sequences) {
                total_token_timestamp_sequence.push(...left_token_timestamp_sequence.slice(0, leftMid));
                left_token_timestamp_sequence = token_timestamp_sequences[i].slice(rightMid);
            }
        }
        totalSequence.push(...leftSequence);

        if (use_token_timestamp_sequences) {
            total_token_timestamp_sequence.push(...left_token_timestamp_sequence);
            return [totalSequence, total_token_timestamp_sequence];
        } else {
            return [totalSequence, []];
        }
    }

    /** @private */
    collateWordTimestamps(tokens, token_timestamps, language) {

        let [words, _, token_indices] = this.combineTokensIntoWords(tokens, language);

        let timings = [];
        for (let i = 0; i < words.length; ++i) {
            const indices = token_indices[i];
            timings.push({
                text: words[i],
                timestamp: [
                    token_timestamps[indices.at(0)][0],
                    token_timestamps[indices.at(-1)][1],
                ],
            });
        }
        return timings;
    }

    /**
     * Groups tokens by word. Returns a tuple containing a list of strings with the words,
     * and a list of `token_id` sequences with the tokens making up each word.
     * @param {number[]} tokens 
     * @param {string} [language] 
     * @param {string} prepend_punctionations 
     * @param {string} append_punctuations 
     * 
     * @private
     */
    combineTokensIntoWords(tokens, language, prepend_punctionations = "\"'“¡¿([{-", append_punctuations = "\"'.。,，!！?？:：”)]}、") {
        language = language ?? 'english';

        let words, word_tokens, token_indices;

        if (["chinese", "japanese", "thai", "lao", "myanmar"].includes(language)) {
            // These languages don't typically use spaces.

            [words, word_tokens, token_indices] = this.splitTokensOnUnicode(tokens)
        } else {
            [words, word_tokens, token_indices] = this.splitTokensOnSpaces(tokens)
        }

        return this.mergePunctuations(words, word_tokens, token_indices, prepend_punctionations, append_punctuations);
    }

    /** @type {PreTrainedTokenizer['decode']} */
    decode(
        token_ids,
        decode_args,
    ) {
        let text;
        // @ts-ignore
        if (decode_args && decode_args.decode_with_timestamps) {
            text = this.decodeWithTimestamps(token_ids, decode_args);
        } else {
            text = super.decode(token_ids, decode_args);
        }
        // TODO: implement offsets
        // if (decode_args.output_offsets) {
        //     let offsets = this.computeOffsets
        // }
        return text;
    }

    /**
     * @param {number[]} token_ids List of token IDs to decode.
     * @param {Object} decode_args Optional arguments for decoding
     * @private
     */
    decodeWithTimestamps(token_ids, decode_args) {
        const time_precision = decode_args?.time_precision ?? 0.02;

        const timestamp_begin = Array.from(this.all_special_ids).at(-1) + 1;
        /**@type {Array} */
        let outputs = [[]];
        for (let token of token_ids) {
            if (token >= timestamp_begin) {
                let timestamp = (token - timestamp_begin) * time_precision;
                timestamp = (0,_utils_maths_js__WEBPACK_IMPORTED_MODULE_2__.round)(timestamp, 2);
                outputs.push(`<|${timestamp}|>`);
                outputs.push([]);
            } else {
                outputs[outputs.length - 1].push(token);
            }
        }
        outputs = outputs.map(
            s => {
                if (typeof s === 'string') {
                    return s;
                } else {
                    return super.decode(s, decode_args);
                }
            }
        )

        return outputs.join('');
    }

    /**
     * Combine tokens into words by splitting at any position where the tokens are decoded as valid unicode points.
     * @param {number[]} tokens 
     * @returns {*}
     * @private
     */
    splitTokensOnUnicode(tokens) {
        const decoded_full = this.decode(tokens, {
            // @ts-ignore
            decode_with_timestamps: true,
        });
        const replacement_char = '\uFFFD';

        let words = []
        let word_tokens = []
        let token_indices = []
        let current_tokens = []
        let current_indices = []
        let unicode_offset = 0

        for (let token_idx = 0; token_idx < tokens.length; ++token_idx) {
            const token = tokens[token_idx];

            current_tokens.push(token);
            current_indices.push(token_idx);

            const decoded = this.decode(current_tokens, {
                // @ts-ignore
                decode_with_timestamps: true,
            });

            if (!decoded.includes(replacement_char) || decoded_full[unicode_offset + decoded.indexOf(replacement_char)] === replacement_char) {
                words.push(decoded)
                word_tokens.push(current_tokens)
                token_indices.push(current_indices)
                current_tokens = []
                current_indices = []
                unicode_offset += decoded.length;
            }

        }

        return [words, word_tokens, token_indices]
    }

    /**
     * Combine tokens into words by splitting at whitespace and punctuation tokens.
     * @param {number[]} tokens 
     * @private
     */
    splitTokensOnSpaces(tokens) {

        let [subwords, subword_tokens_list, subword_indices_list] = this.splitTokensOnUnicode(tokens);

        let words = []
        let word_tokens = []
        let token_indices = []

        const punctuationRegex = new RegExp(`[${PUNCTUATION_REGEX}]`)

        for (let i = 0; i < subwords.length; ++i) {

            const subword = subwords[i];
            const subword_tokens = subword_tokens_list[i];
            const subword_indices = subword_indices_list[i];

            // @ts-ignore
            const special = subword_tokens[0] >= this.model.tokens_to_ids.get('<|endoftext|>');
            const with_space = subword.startsWith(' ');
            const trimmed = subword.trim();
            const punctuation = punctuationRegex.test(trimmed);

            if (special || with_space || punctuation || words.length === 0) {
                words.push(subword);
                word_tokens.push(subword_tokens);
                token_indices.push(subword_indices);
            } else {
                const ix = words.length - 1;
                words[ix] += subword;
                word_tokens[ix].push(...subword_tokens);
                token_indices[ix].push(...subword_indices);
            }
        }

        return [words, word_tokens, token_indices];

    }

    /**
     * Merges punctuation tokens with neighboring words.
     * @param {string[]} words 
     * @param {number[][]} tokens 
     * @param {number[][]} indices 
     * @param {string} prepended 
     * @param {string} appended 
     * @private
     */
    mergePunctuations(words, tokens, indices, prepended, appended) {

        let newWords = structuredClone(words);
        let newTokens = structuredClone(tokens);
        let newIndices = structuredClone(indices);


        // prepend punctuations
        let i = newWords.length - 2;
        let j = newWords.length - 1;

        while (i >= 0) {
            if (newWords[i].startsWith(' ') && prepended.includes(newWords[i].trim())) {
                newWords[j] = newWords[i] + newWords[j];
                newTokens[j] = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newTokens[i], newTokens[j]);
                newIndices[j] = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newIndices[i], newIndices[j]);
                newWords[i] = '';
                newTokens[i] = [];
                newIndices[i] = [];
            } else {
                j = i;
            }
            --i;
        }

        // append punctuations
        i = 0;
        j = 1;
        while (j < newWords.length) {
            if (!newWords[i].endsWith(' ') && appended.includes(newWords[j])) {
                newWords[i] += newWords[j];
                newTokens[i] = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newTokens[i], newTokens[j]);
                newIndices[i] = (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)(newIndices[i], newIndices[j]);
                newWords[j] = '';
                newTokens[j] = [];
                newIndices[j] = [];
            } else {
                i = j;
            }
            ++j;
        }

        return [
            newWords.filter(x => x),
            newTokens.filter(x => x.length > 0),
            newIndices.filter(x => x.length > 0),
        ]
    }

    /**
     * Helper function to build translation inputs for a `WhisperTokenizer`,
     * depending on the language, task, and whether to predict timestamp tokens.
     * 
     * Used to override the prefix tokens appended to the start of the label sequence.
     * 
     * **Example: Get ids for a language**
     * ```javascript
     * // instantiate the tokenizer and set the prefix token to Spanish
     * let tokenizer = await WhisperTokenizer.from_pretrained('Xenova/whisper-tiny');
     * let forced_decoder_ids = tokenizer.get_decoder_prompt_ids({ language: 'spanish' });
     * // [(1, 50262), (2, 50363)]
     * ```
     * 
     * @param {Object} options Options to generate the decoder prompt.
     * @param {string} [options.language] The language of the transcription text.
     * The corresponding language id token is appended to the start of the sequence for multilingual
     * speech recognition and speech translation tasks, e.g. for "Spanish" the token "<|es|>" is appended
     * to the start of sequence.
     * @param {string} [options.task] Task identifier to append at the start of sequence (if any).
     * This should be used for mulitlingual fine-tuning, with "transcribe" for speech recognition and
     * "translate" for speech translation.
     * @param {boolean} [options.no_timestamps] Whether to add the <|notimestamps|> token at the start of the sequence.
     * @returns {number[][]} The decoder prompt ids.
     */
    get_decoder_prompt_ids({
        language = null,
        task = null,
        no_timestamps = true,
    } = {}) {

        // <|lang_id|> <|task|> <|notimestamps|>

        let forced_decoder_ids = [];

        if (language) {
            // User wishes to specify the language
            language = language.toLowerCase();

            // Map to code from user-friendly name (e.g., "english" -> "en")
            let language_code = WHISPER_TO_LANGUAGE_CODE_MAPPING.get(language);

            if (language_code === undefined) {
                // User provided something that is not a language name

                if (WHISPER_LANGUAGE_MAPPING.has(language)) {
                    // User provided the language code directly (e.g., "en")
                    language_code = language;

                } else {
                    // User provided something that is not a language code or name
                    const is_language_code = language.length === 2;
                    const langs = is_language_code ? WHISPER_LANGUAGE_MAPPING.keys() : WHISPER_LANGUAGE_MAPPING.values();

                    throw new Error(`Language "${language}" is not supported. Must be one of: ${JSON.stringify(langs)}`);
                }
            }

            let language_token_id = this.model.tokens_to_ids.get(`<|${language_code}|>`);
            if (language_token_id === undefined) {
                throw new Error(`Unable to find language "${language_code}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`)
            }

            forced_decoder_ids.push(language_token_id);
        } else {
            // No token will be forced, which leaves the model to predict the language
            forced_decoder_ids.push(null);
        }

        if (task) {
            task = task.toLowerCase();
            if (task !== 'transcribe' && task !== 'translate') {
                throw new Error(`Task "${task}" is not supported. Must be one of: ["transcribe", "translate"]`);
            }

            let task_token_id = this.model.tokens_to_ids.get(`<|${task}|>`);
            if (task_token_id === undefined) {
                throw new Error(`Unable to find task "${task}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`)
            }

            forced_decoder_ids.push(task_token_id);
        } else {
            // No token will be forced, which leaves the model to predict the task
            forced_decoder_ids.push(null);
        }

        if (no_timestamps) {
            let no_timestamps_id = this.model.tokens_to_ids.get(`<|notimestamps|>`);
            if (no_timestamps_id === undefined) {
                throw new Error('Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.')
            }

            forced_decoder_ids.push(no_timestamps_id);
        }

        return forced_decoder_ids.map((x, i) => [i + 1, x]).filter(x => x[1] !== null);

    }
}
class CodeGenTokenizer extends PreTrainedTokenizer { }
class CLIPTokenizer extends PreTrainedTokenizer { }


/**
 * @todo This model is not yet supported by Hugging Face's "fast" tokenizers library (https://github.com/huggingface/tokenizers).
 * Therefore, this implementation (which is based on fast tokenizers) may produce slightly inaccurate results.
 */
class MarianTokenizer extends PreTrainedTokenizer {
    /**
     * Create a new MarianTokenizer instance.
     * @param {Object} tokenizerJSON The JSON of the tokenizer.
     * @param {Object} tokenizerConfig The config of the tokenizer.
     */
    constructor(tokenizerJSON, tokenizerConfig) {
        super(tokenizerJSON, tokenizerConfig);

        this.languageRegex = /^(>>\w+<<)\s*/g;

        this.supported_language_codes = this.model.vocab.filter(
            x => this.languageRegex.test(x)
        );

        console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')
    }

    /**
     * Encodes a single text. Overriding this method is necessary since the language codes
     * must be removed before encoding with sentencepiece model.
     * @see https://github.com/huggingface/transformers/blob/12d51db243a00726a548a43cc333390ebae731e3/src/transformers/models/marian/tokenization_marian.py#L204-L213
     *
     * @param {string|null} text The text to encode.
     * @returns {Array} The encoded tokens.
     */
    _encode_text(text) {
        if (text === null) return null;

        // Check if text starts with language code:
        let [matchInfo, ...remainder] = text.trim().split(this.languageRegex);

        if (remainder.length === 0) {
            // No language code, encode normally
            return super._encode_text(matchInfo);

        } else if (remainder.length === 2) {
            // Text starts with language code, so we do not encode it with sentencepiece.
            let [language, text] = remainder;

            if (!this.supported_language_codes.includes(language)) {
                console.warn(`Unsupported language code "${language}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`)
            }
            return (0,_utils_core_js__WEBPACK_IMPORTED_MODULE_0__.mergeArrays)([language], super._encode_text(text));
        }
    }

}

/**
 * A trie structure to efficiently store and search for strings.
 */
class CharTrie {
    constructor() {
        this.root = CharTrieNode.default();
    }

    /**
     * Adds one or more `texts` to the trie.
     * @param {string[]} texts The strings to add to the trie.
     */
    extend(texts) {
        for (let text of texts) {
            this.push(text);
        }
    }

    /**
     * Adds one or more `texts` to the trie.
     * @param {*} text The strings to add to the trie.
     */
    push(text) {
        let node = this.root;
        for (let ch of text) {
            let child = node.children.get(ch);
            if (child === undefined) {
                child = CharTrieNode.default();
                node.children.set(ch, child);
            }
            node = child;
        }
        node.isLeaf = true;
    }

    /**
     * Searches the trie for all strings with a common prefix of `text`.
     * @param {string} text The common prefix to search for.
     * @yields {string} Each string in the trie that has `text` as a prefix.
     */
    *commonPrefixSearch(text) {
        let node = this.root;
        let prefix = "";
        for (let i = 0; i < text.length && node !== undefined; ++i) {
            const ch = text[i];
            prefix += ch;
            node = node.children.get(ch);
            if (node !== undefined && node.isLeaf) {
                yield prefix;
            }
        }
    }
}

/**
 * Represents a node in a character trie.
 * @param {boolean} isLeaf Whether the node is a leaf node or not.
 * @param {Map<string, CharTrieNode>} children A map containing the node's children, where the key is a character and the value is a `CharTrieNode`.
 */
class CharTrieNode {
    constructor(isLeaf, children) {
        this.isLeaf = isLeaf;
        this.children = children;
    }

    /**
     * Returns a new `CharTrieNode` instance with default values.
     * @returns {CharTrieNode} A new `CharTrieNode` instance with `isLeaf` set to `false` and an empty `children` map.
     */
    static default() {
        return new CharTrieNode(false, new Map());
    }
}

class TokenLattice {
    /**
     * Creates a new TokenLattice instance.
     *
     * @param {string} sentence The input sentence to be tokenized.
     * @param {number} bosTokenId The beginning-of-sequence token ID.
     * @param {number} eosTokenId The end-of-sequence token ID.
     */
    constructor(sentence, bosTokenId, eosTokenId) {
        this.sentence = sentence;
        this.len = sentence.length;
        this.bosTokenId = bosTokenId;
        this.eosTokenId = eosTokenId;
        this.nodes = [];
        this.beginNodes = new Array(this.len + 1);
        this.endNodes = new Array(this.len + 1);
        for (let i = 0; i < this.len + 1; ++i) {
            this.beginNodes[i] = [];
            this.endNodes[i] = [];
        }
        const bos = new TokenLatticeNode(this.bosTokenId, 0, 0, 0, 0.0);
        const eos = new TokenLatticeNode(this.eosTokenId, 1, this.len, 0, 0.0);
        this.nodes.push(bos.clone());
        this.nodes.push(eos.clone());
        this.beginNodes[this.len].push(eos);
        this.endNodes[0].push(bos);
    }

    /**
     * Inserts a new token node into the token lattice.
     *
     * @param {number} pos The starting position of the token.
     * @param {number} length The length of the token.
     * @param {number} score The score of the token.
     * @param {number} tokenId The token ID of the token.
     */
    insert(pos, length, score, tokenId) {
        const nodeId = this.nodes.length;
        const node = new TokenLatticeNode(tokenId, nodeId, pos, length, score);
        this.beginNodes[pos].push(node);
        this.endNodes[pos + length].push(node);
        this.nodes.push(node);
    }

    /**
     * Implements the Viterbi algorithm to compute the most likely sequence of tokens.
     *
     * @returns {TokenLatticeNode[]} The array of nodes representing the most likely sequence of tokens.
     */
    viterbi() {
        const len = this.len;
        let pos = 0;
        while (pos <= len) {
            if (this.beginNodes[pos].length == 0) {
                return [];
            }
            for (let rnode of this.beginNodes[pos]) {
                rnode.prev = null;
                let bestScore = 0.0;
                let bestNode = null;
                for (let lnode of this.endNodes[pos]) {
                    const score = lnode.backtraceScore + rnode.score;
                    if (bestNode === null || score > bestScore) {
                        bestNode = lnode.clone();
                        bestScore = score;
                    }
                }

                if (bestNode !== null) {
                    rnode.prev = bestNode;
                    rnode.backtraceScore = bestScore;
                } else {
                    return [];
                }
            }
            ++pos;
        }

        const results = [];
        const root = this.beginNodes[len][0];
        const prev = root.prev;
        if (prev === null) {
            return [];
        }

        let node = prev.clone();
        while (node.prev !== null) {
            results.push(node.clone());
            const n = node.clone();
            node = n.prev.clone();
        }

        results.reverse();
        return results;
    }

    /**
     * @param {TokenLatticeNode} node
     * @returns {string} The array of nodes representing the most likely sequence of tokens.
     */
    piece(node) {
        return this.sentence.slice(node.pos, node.pos + node.length);
    }

    /**
     * @returns {Array} The array of nodes representing the most likely sequence of tokens.
     */
    tokens() {
        const nodes = this.viterbi();
        return nodes.map(x => this.piece(x));
    }

    /**
     * @returns {Array} The array of nodes representing the most likely sequence of tokens.
     */
    tokenIds() {
        const nodes = this.viterbi();
        return nodes.map(x => x.tokenId);
    }
}
class TokenLatticeNode {
    /**
     * Represents a node in a token lattice for a given sentence.
     * @param {number} tokenId The ID of the token associated with this node.
     * @param {number} nodeId The ID of this node.
     * @param {number} pos The starting position of the token in the sentence.
     * @param {number} length The length of the token.
     * @param {number} score The score associated with the token.
     */
    constructor(tokenId, nodeId, pos, length, score) {
        this.tokenId = tokenId;
        this.nodeId = nodeId;
        this.pos = pos;
        this.length = length;
        this.score = score;
        this.prev = null;
        this.backtraceScore = 0.0;
    }

    /**
     * Returns a clone of this node.
     * @returns {TokenLatticeNode} A clone of this node.
     */
    clone() {
        const n = new TokenLatticeNode(this.tokenId, this.nodeId, this.pos, this.length, this.score);
        n.prev = this.prev;
        n.backtraceScore = this.backtraceScore;
        return n;
    }
}

/**
 * Helper class which is used to instantiate pretrained tokenizers with the `from_pretrained` function.
 * The chosen tokenizer class is determined by the type specified in the tokenizer config.
 * 
 * @example
 * let tokenizer = await AutoTokenizer.from_pretrained('bert-base-uncased');
 */
class AutoTokenizer {
    static TOKENIZER_CLASS_MAPPING = {
        'T5Tokenizer': T5Tokenizer,
        'DistilBertTokenizer': DistilBertTokenizer,
        'BertTokenizer': BertTokenizer,
        'MobileBertTokenizer': MobileBertTokenizer,
        'SqueezeBertTokenizer': SqueezeBertTokenizer,
        'AlbertTokenizer': AlbertTokenizer,
        'GPT2Tokenizer': GPT2Tokenizer,
        'BartTokenizer': BartTokenizer,
        'RobertaTokenizer': RobertaTokenizer,
        'WhisperTokenizer': WhisperTokenizer,
        'CodeGenTokenizer': CodeGenTokenizer,
        'CLIPTokenizer': CLIPTokenizer,
        'MarianTokenizer': MarianTokenizer,
        'BloomTokenizer': BloomTokenizer,
        'NllbTokenizer': NllbTokenizer,
        'LlamaTokenizer': LlamaTokenizer,
        'XLMRobertaTokenizer': XLMRobertaTokenizer,
        'MPNetTokenizer': MPNetTokenizer,
        'FalconTokenizer': FalconTokenizer,
        'GPTNeoXTokenizer': GPTNeoXTokenizer,

        // Base case:
        'PreTrainedTokenizer': PreTrainedTokenizer,
    }


    /**
     * Instantiate one of the tokenizer classes of the library from a pretrained model.
     * 
     * The tokenizer class to instantiate is selected based on the `tokenizer_class` property of the config object
     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)
     * 
     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:
     * - A string, the *model id* of a pretrained tokenizer hosted inside a model repo on huggingface.co.
     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a
     *   user or organization name, like `dbmdz/bert-base-german-cased`.
     * - A path to a *directory* containing tokenizer files, e.g., `./my_model_directory/`.
     * @param {PretrainedOptions} options Additional options for loading the tokenizer.
     * 
     * @returns {Promise<PreTrainedTokenizer>} A new instance of the PreTrainedTokenizer class.
     */
    static async from_pretrained(pretrained_model_name_or_path, {
        quantized = true,
        progress_callback = null,
        config = null,
        cache_dir = null,
        local_files_only = false,
        revision = 'main',
    } = {}) {

        let [tokenizerJSON, tokenizerConfig] = await loadTokenizer(pretrained_model_name_or_path, {
            quantized,
            progress_callback,
            config,
            cache_dir,
            local_files_only,
            revision,
        })

        // Some tokenizers are saved with the "Fast" suffix, so we remove that if present.
        let tokenizerName = tokenizerConfig.tokenizer_class.replace(/Fast$/, '');

        let cls = this.TOKENIZER_CLASS_MAPPING[tokenizerName];
        if (!cls) {
            console.warn(`Unknown tokenizer class "${tokenizerName}", attempting to construct from base class.`);
            cls = PreTrainedTokenizer;
        }
        return new cls(tokenizerJSON, tokenizerConfig);
    }
}


/***/ }),

/***/ "./node_modules/@xenova/transformers/src/transformers.js":
/*!***************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/transformers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AlbertForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForMaskedLM),
/* harmony export */   AlbertForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForQuestionAnswering),
/* harmony export */   AlbertForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertForSequenceClassification),
/* harmony export */   AlbertModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertModel),
/* harmony export */   AlbertPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AlbertPreTrainedModel),
/* harmony export */   AlbertTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AlbertTokenizer),
/* harmony export */   AutoConfig: () => (/* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_5__.AutoConfig),
/* harmony export */   AutoModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModel),
/* harmony export */   AutoModelForCausalLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForCausalLM),
/* harmony export */   AutoModelForImageClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageClassification),
/* harmony export */   AutoModelForImageSegmentation: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForImageSegmentation),
/* harmony export */   AutoModelForMaskGeneration: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskGeneration),
/* harmony export */   AutoModelForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForMaskedLM),
/* harmony export */   AutoModelForObjectDetection: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForObjectDetection),
/* harmony export */   AutoModelForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForQuestionAnswering),
/* harmony export */   AutoModelForSeq2SeqLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSeq2SeqLM),
/* harmony export */   AutoModelForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForSequenceClassification),
/* harmony export */   AutoModelForTokenClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForTokenClassification),
/* harmony export */   AutoModelForVision2Seq: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.AutoModelForVision2Seq),
/* harmony export */   AutoProcessor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.AutoProcessor),
/* harmony export */   AutoTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.AutoTokenizer),
/* harmony export */   AutomaticSpeechRecognitionPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.AutomaticSpeechRecognitionPipeline),
/* harmony export */   BartForConditionalGeneration: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BartForConditionalGeneration),
/* harmony export */   BartForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BartForSequenceClassification),
/* harmony export */   BartModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BartModel),
/* harmony export */   BartPretrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BartPretrainedModel),
/* harmony export */   BartTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BartTokenizer),
/* harmony export */   BaseModelOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BaseModelOutput),
/* harmony export */   BertForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForMaskedLM),
/* harmony export */   BertForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForQuestionAnswering),
/* harmony export */   BertForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForSequenceClassification),
/* harmony export */   BertForTokenClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertForTokenClassification),
/* harmony export */   BertModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertModel),
/* harmony export */   BertPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.BertPreTrainedModel),
/* harmony export */   BertTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BertTokenizer),
/* harmony export */   BloomTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.BloomTokenizer),
/* harmony export */   CLIPModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPModel),
/* harmony export */   CLIPPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPPreTrainedModel),
/* harmony export */   CLIPTextModelWithProjection: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPTextModelWithProjection),
/* harmony export */   CLIPTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CLIPTokenizer),
/* harmony export */   CLIPVisionModelWithProjection: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CLIPVisionModelWithProjection),
/* harmony export */   CausalLMOutputWithPast: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CausalLMOutputWithPast),
/* harmony export */   CodeGenForCausalLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenForCausalLM),
/* harmony export */   CodeGenModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenModel),
/* harmony export */   CodeGenPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.CodeGenPreTrainedModel),
/* harmony export */   CodeGenTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.CodeGenTokenizer),
/* harmony export */   DetrFeatureExtractor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.DetrFeatureExtractor),
/* harmony export */   DetrForObjectDetection: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForObjectDetection),
/* harmony export */   DetrForSegmentation: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrForSegmentation),
/* harmony export */   DetrObjectDetectionOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrObjectDetectionOutput),
/* harmony export */   DetrPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrPreTrainedModel),
/* harmony export */   DetrSegmentationOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DetrSegmentationOutput),
/* harmony export */   DistilBertForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForMaskedLM),
/* harmony export */   DistilBertForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForQuestionAnswering),
/* harmony export */   DistilBertForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForSequenceClassification),
/* harmony export */   DistilBertForTokenClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertForTokenClassification),
/* harmony export */   DistilBertModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertModel),
/* harmony export */   DistilBertPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.DistilBertPreTrainedModel),
/* harmony export */   DistilBertTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.DistilBertTokenizer),
/* harmony export */   FFT: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.FFT),
/* harmony export */   FalconTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.FalconTokenizer),
/* harmony export */   FeatureExtractionPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.FeatureExtractionPipeline),
/* harmony export */   FeatureExtractor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.FeatureExtractor),
/* harmony export */   FillMaskPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.FillMaskPipeline),
/* harmony export */   GPT2LMHeadModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2LMHeadModel),
/* harmony export */   GPT2Model: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2Model),
/* harmony export */   GPT2PreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPT2PreTrainedModel),
/* harmony export */   GPT2Tokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPT2Tokenizer),
/* harmony export */   GPTBigCodeForCausalLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodeForCausalLM),
/* harmony export */   GPTBigCodeModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodeModel),
/* harmony export */   GPTBigCodePreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTBigCodePreTrainedModel),
/* harmony export */   GPTNeoForCausalLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoForCausalLM),
/* harmony export */   GPTNeoModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoModel),
/* harmony export */   GPTNeoPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.GPTNeoPreTrainedModel),
/* harmony export */   GPTNeoXTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.GPTNeoXTokenizer),
/* harmony export */   ImageClassificationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageClassificationPipeline),
/* harmony export */   ImageFeatureExtractor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.ImageFeatureExtractor),
/* harmony export */   ImageSegmentationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageSegmentationPipeline),
/* harmony export */   ImageToTextPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ImageToTextPipeline),
/* harmony export */   LlamaTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.LlamaTokenizer),
/* harmony export */   M2M100ForConditionalGeneration: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100ForConditionalGeneration),
/* harmony export */   M2M100Model: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100Model),
/* harmony export */   M2M100PreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.M2M100PreTrainedModel),
/* harmony export */   MPNetForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForMaskedLM),
/* harmony export */   MPNetForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForQuestionAnswering),
/* harmony export */   MPNetForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForSequenceClassification),
/* harmony export */   MPNetForTokenClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetForTokenClassification),
/* harmony export */   MPNetModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetModel),
/* harmony export */   MPNetPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MPNetPreTrainedModel),
/* harmony export */   MPNetTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MPNetTokenizer),
/* harmony export */   MT5ForConditionalGeneration: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5ForConditionalGeneration),
/* harmony export */   MT5Model: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5Model),
/* harmony export */   MT5PreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MT5PreTrainedModel),
/* harmony export */   MarianMTModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianMTModel),
/* harmony export */   MarianModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianModel),
/* harmony export */   MarianPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MarianPreTrainedModel),
/* harmony export */   MarianTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MarianTokenizer),
/* harmony export */   MaskedLMOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MaskedLMOutput),
/* harmony export */   MobileBertForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForMaskedLM),
/* harmony export */   MobileBertForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForQuestionAnswering),
/* harmony export */   MobileBertForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertForSequenceClassification),
/* harmony export */   MobileBertModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertModel),
/* harmony export */   MobileBertPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileBertPreTrainedModel),
/* harmony export */   MobileBertTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.MobileBertTokenizer),
/* harmony export */   MobileViTFeatureExtractor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.MobileViTFeatureExtractor),
/* harmony export */   MobileViTForImageClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTForImageClassification),
/* harmony export */   MobileViTPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.MobileViTPreTrainedModel),
/* harmony export */   ModelOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.ModelOutput),
/* harmony export */   NllbTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.NllbTokenizer),
/* harmony export */   ObjectDetectionPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ObjectDetectionPipeline),
/* harmony export */   Pipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.Pipeline),
/* harmony export */   PreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.PreTrainedModel),
/* harmony export */   PreTrainedTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.PreTrainedTokenizer),
/* harmony export */   PretrainedConfig: () => (/* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_5__.PretrainedConfig),
/* harmony export */   PretrainedMixin: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.PretrainedMixin),
/* harmony export */   Processor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.Processor),
/* harmony export */   QuestionAnsweringModelOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.QuestionAnsweringModelOutput),
/* harmony export */   QuestionAnsweringPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.QuestionAnsweringPipeline),
/* harmony export */   RawImage: () => (/* reexport safe */ _utils_image_js__WEBPACK_IMPORTED_MODULE_7__.RawImage),
/* harmony export */   RobertaForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForMaskedLM),
/* harmony export */   RobertaForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForQuestionAnswering),
/* harmony export */   RobertaForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForSequenceClassification),
/* harmony export */   RobertaForTokenClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaForTokenClassification),
/* harmony export */   RobertaModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaModel),
/* harmony export */   RobertaPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.RobertaPreTrainedModel),
/* harmony export */   RobertaTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.RobertaTokenizer),
/* harmony export */   SamImageProcessor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.SamImageProcessor),
/* harmony export */   SamImageSegmentationOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SamImageSegmentationOutput),
/* harmony export */   SamModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SamModel),
/* harmony export */   SamPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SamPreTrainedModel),
/* harmony export */   SamProcessor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.SamProcessor),
/* harmony export */   Seq2SeqLMOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.Seq2SeqLMOutput),
/* harmony export */   SequenceClassifierOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SequenceClassifierOutput),
/* harmony export */   SqueezeBertForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForMaskedLM),
/* harmony export */   SqueezeBertForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForQuestionAnswering),
/* harmony export */   SqueezeBertForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertForSequenceClassification),
/* harmony export */   SqueezeBertModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertModel),
/* harmony export */   SqueezeBertPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.SqueezeBertPreTrainedModel),
/* harmony export */   SqueezeBertTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.SqueezeBertTokenizer),
/* harmony export */   SummarizationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.SummarizationPipeline),
/* harmony export */   T5ForConditionalGeneration: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.T5ForConditionalGeneration),
/* harmony export */   T5Model: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.T5Model),
/* harmony export */   T5PreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.T5PreTrainedModel),
/* harmony export */   T5Tokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.T5Tokenizer),
/* harmony export */   Tensor: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.Tensor),
/* harmony export */   Text2TextGenerationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.Text2TextGenerationPipeline),
/* harmony export */   TextClassificationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TextClassificationPipeline),
/* harmony export */   TextGenerationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TextGenerationPipeline),
/* harmony export */   TokenClassificationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TokenClassificationPipeline),
/* harmony export */   TokenClassifierOutput: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.TokenClassifierOutput),
/* harmony export */   TokenizerModel: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.TokenizerModel),
/* harmony export */   TranslationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.TranslationPipeline),
/* harmony export */   ViTFeatureExtractor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.ViTFeatureExtractor),
/* harmony export */   ViTForImageClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTForImageClassification),
/* harmony export */   ViTPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.ViTPreTrainedModel),
/* harmony export */   VisionEncoderDecoderModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.VisionEncoderDecoderModel),
/* harmony export */   WhisperFeatureExtractor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.WhisperFeatureExtractor),
/* harmony export */   WhisperForConditionalGeneration: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperForConditionalGeneration),
/* harmony export */   WhisperModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperModel),
/* harmony export */   WhisperPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.WhisperPreTrainedModel),
/* harmony export */   WhisperProcessor: () => (/* reexport safe */ _processors_js__WEBPACK_IMPORTED_MODULE_4__.WhisperProcessor),
/* harmony export */   WhisperTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.WhisperTokenizer),
/* harmony export */   XLMRobertaForMaskedLM: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForMaskedLM),
/* harmony export */   XLMRobertaForQuestionAnswering: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForQuestionAnswering),
/* harmony export */   XLMRobertaForSequenceClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForSequenceClassification),
/* harmony export */   XLMRobertaForTokenClassification: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaForTokenClassification),
/* harmony export */   XLMRobertaModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaModel),
/* harmony export */   XLMRobertaPreTrainedModel: () => (/* reexport safe */ _models_js__WEBPACK_IMPORTED_MODULE_2__.XLMRobertaPreTrainedModel),
/* harmony export */   XLMRobertaTokenizer: () => (/* reexport safe */ _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__.XLMRobertaTokenizer),
/* harmony export */   ZeroShotClassificationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ZeroShotClassificationPipeline),
/* harmony export */   ZeroShotImageClassificationPipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.ZeroShotImageClassificationPipeline),
/* harmony export */   cat: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.cat),
/* harmony export */   cos_sim: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.cos_sim),
/* harmony export */   dot: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.dot),
/* harmony export */   dynamicTimeWarping: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.dynamicTimeWarping),
/* harmony export */   env: () => (/* reexport safe */ _env_js__WEBPACK_IMPORTED_MODULE_1__.env),
/* harmony export */   getMelFilters: () => (/* reexport safe */ _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.getMelFilters),
/* harmony export */   getTopItems: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.getTopItems),
/* harmony export */   interpolate: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.interpolate),
/* harmony export */   interpolate_data: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.interpolate_data),
/* harmony export */   log_softmax: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.log_softmax),
/* harmony export */   magnitude: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.magnitude),
/* harmony export */   max: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.max),
/* harmony export */   mean: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean),
/* harmony export */   mean_pooling: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.mean_pooling),
/* harmony export */   medianFilter: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.medianFilter),
/* harmony export */   min: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.min),
/* harmony export */   pipeline: () => (/* reexport safe */ _pipelines_js__WEBPACK_IMPORTED_MODULE_0__.pipeline),
/* harmony export */   read_audio: () => (/* reexport safe */ _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__.read_audio),
/* harmony export */   rfftfreq: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.rfftfreq),
/* harmony export */   round: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.round),
/* harmony export */   softmax: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.softmax),
/* harmony export */   stack: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.stack),
/* harmony export */   std_mean: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.std_mean),
/* harmony export */   transpose: () => (/* reexport safe */ _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__.transpose),
/* harmony export */   transpose_data: () => (/* reexport safe */ _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__.transpose_data)
/* harmony export */ });
/* harmony import */ var _pipelines_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pipelines.js */ "./node_modules/@xenova/transformers/src/pipelines.js");
/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env.js */ "./node_modules/@xenova/transformers/src/env.js");
/* harmony import */ var _models_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models.js */ "./node_modules/@xenova/transformers/src/models.js");
/* harmony import */ var _tokenizers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tokenizers.js */ "./node_modules/@xenova/transformers/src/tokenizers.js");
/* harmony import */ var _processors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./processors.js */ "./node_modules/@xenova/transformers/src/processors.js");
/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./configs.js */ "./node_modules/@xenova/transformers/src/configs.js");
/* harmony import */ var _utils_audio_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/audio.js */ "./node_modules/@xenova/transformers/src/utils/audio.js");
/* harmony import */ var _utils_image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/image.js */ "./node_modules/@xenova/transformers/src/utils/image.js");
/* harmony import */ var _utils_tensor_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/tensor.js */ "./node_modules/@xenova/transformers/src/utils/tensor.js");
/* harmony import */ var _utils_maths_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/maths.js */ "./node_modules/@xenova/transformers/src/utils/maths.js");
// @ts-nocheck

/**
 * @file Entry point for the Transformers.js library. Only the exports from this file
 * are available to the end user, and are grouped as follows:
 * 
 * 1. [Pipelines](./pipelines)
 * 2. [Environment variables](./env)
 * 3. [Models](./models)
 * 4. [Tokenizers](./tokenizers)
 * 5. [Processors](./processors)
 * 
 * @module transformers
 */














/***/ }),

/***/ "./node_modules/@xenova/transformers/src/utils/audio.js":
/*!**************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/audio.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMelFilters: () => (/* binding */ getMelFilters),
/* harmony export */   read_audio: () => (/* binding */ read_audio)
/* harmony export */ });
/* harmony import */ var _hub_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hub.js */ "./node_modules/@xenova/transformers/src/utils/hub.js");
/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ "./node_modules/@xenova/transformers/src/utils/maths.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
/**
 * @file Helper module for audio processing. 
 * 
 * These functions and classes are only used internally, 
 * meaning an end-user shouldn't need to access anything here.
 * 
 * @module utils/audio
 */




/**
 * Helper function to read audio from a path/URL.
 * @param {string|URL} url The path/URL to load the audio from.
 * @param {number} sampling_rate The sampling rate to use when decoding the audio.
 * @returns {Promise<Float32Array>} The decoded audio as a `Float32Array`.
 */
async function read_audio(url, sampling_rate) {
    if (typeof AudioContext === 'undefined') {
        // Running in node or an environment without AudioContext
        throw Error(
            "Unable to load audio from path/URL since `AudioContext` is not available in your environment. " +
            "Instead, audio data should be passed directly to the pipeline/processor. " +
            "For more information and some example code, see https://huggingface.co/docs/transformers.js/tutorials/node-audio-processing."
        )
    }

    const response = await (await (0,_hub_js__WEBPACK_IMPORTED_MODULE_0__.getFile)(url)).arrayBuffer();
    const audioCTX = new AudioContext({ sampleRate: sampling_rate });
    if (typeof sampling_rate === 'undefined') {
        console.warn(`No sampling rate provided, using default of ${audioCTX.sampleRate}Hz.`)
    }
    const decoded = await audioCTX.decodeAudioData(response);
    let audio;

    // We now replicate HuggingFace's `ffmpeg_read` method:
    if (decoded.numberOfChannels === 2) {
        // When downmixing a stereo audio file to mono using the -ac 1 option in FFmpeg,
        // the audio signal is summed across both channels to create a single mono channel.
        // However, if the audio is at full scale (i.e. the highest possible volume level),
        // the summing of the two channels can cause the audio signal to clip or distort.

        // To prevent this clipping, FFmpeg applies a scaling factor of 1/sqrt(2) (~ 0.707)
        // to the audio signal before summing the two channels. This scaling factor ensures
        // that the combined audio signal will not exceed the maximum possible level, even
        // if both channels are at full scale.

        // After applying this scaling factor, the audio signal from both channels is summed
        // to create a single mono channel. It's worth noting that this scaling factor is
        // only applied when downmixing stereo audio to mono using the -ac 1 option in FFmpeg.
        // If you're using a different downmixing method, or if you're not downmixing the
        // audio at all, this scaling factor may not be needed.
        const SCALING_FACTOR = Math.sqrt(2);

        let left = decoded.getChannelData(0);
        let right = decoded.getChannelData(1);

        audio = new Float32Array(left.length);
        for (let i = 0; i < decoded.length; ++i) {
            audio[i] = SCALING_FACTOR * (left[i] + right[i]) / 2;
        }

    } else {
        // If the audio is not stereo, we can just use the first channel:
        audio = decoded.getChannelData(0);
    }

    return audio;
}

/**
 * Creates a frequency bin conversion matrix used to obtain a mel spectrogram.
 * @param {number} sr Sample rate of the audio waveform.
 * @param {number} n_fft Number of frequencies used to compute the spectrogram (should be the same as in `stft`).
 * @param {number} n_mels Number of mel filters to generate.
 * @returns {number[][]} Projection matrix to go from a spectrogram to a mel spectrogram.
 */
function getMelFilters(sr, n_fft, n_mels = 128) {
    n_mels = Math.floor(n_mels);

    // Initialize the weights
    const mel_size = Math.floor(1 + n_fft / 2);
    const weights = new Array(n_mels);

    // Center freqs of each FFT bin
    const fftfreqs = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.rfftfreq)(n_fft, 1 / sr);

    // 'Center freqs' of mel bands - uniformly spaced between limits
    const min_mel = 0.0;
    const max_mel = 45.245640471924965;
    const mel_range = max_mel - min_mel;
    const mel_scale = mel_range / (n_mels + 1);

    // Fill in the linear scale
    const f_min = 0.0;
    const f_sp = 200.0 / 3;
    const freqs = new Array(n_mels + 2);

    // And now the nonlinear scale
    const min_log_hz = 1000.0; // beginning of log region (Hz)
    const min_log_mel = (min_log_hz - f_min) / f_sp; // same (Mels)
    const logstep = Math.log(6.4) / 27.0; // step size for log region

    const ramps = new Array(freqs.length);
    for (let i = 0; i < freqs.length; ++i) {
        const mel = i * mel_scale + min_mel;
        if (mel >= min_log_mel) {
            freqs[i] = min_log_hz * Math.exp(logstep * (mel - min_log_mel));
        } else {
            freqs[i] = f_min + f_sp * mel;
        }
        ramps[i] = fftfreqs.map(k => freqs[i] - k);
    }

    const fdiffinv = freqs.slice(1).map((v, i) => 1 / (v - freqs[i]));

    for (let i = 0; i < weights.length; ++i) {
        weights[i] = new Array(mel_size);

        const a = fdiffinv[i];
        const b = fdiffinv[i + 1];
        const c = ramps[i];
        const d = ramps[i + 2];

        // Slaney-style mel is scaled to be approx constant energy per channel
        const enorm = 2.0 / (freqs[i + 2] - freqs[i]);

        for (let j = 0; j < weights[i].length; ++j) {
            // lower and upper slopes for all bins
            const lower = -c[j] * a;
            const upper = d[j] * b;
            weights[i][j] = Math.max(0, Math.min(lower, upper)) * enorm;
        }
    }

    return weights;
}


/***/ }),

/***/ "./node_modules/@xenova/transformers/src/utils/core.js":
/*!*************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/core.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Callable: () => (/* binding */ Callable),
/* harmony export */   calculateDimensions: () => (/* binding */ calculateDimensions),
/* harmony export */   dispatchCallback: () => (/* binding */ dispatchCallback),
/* harmony export */   escapeRegExp: () => (/* binding */ escapeRegExp),
/* harmony export */   exists: () => (/* binding */ exists),
/* harmony export */   isIntegralNumber: () => (/* binding */ isIntegralNumber),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isTypedArray: () => (/* binding */ isTypedArray),
/* harmony export */   mergeArrays: () => (/* binding */ mergeArrays),
/* harmony export */   pop: () => (/* binding */ pop),
/* harmony export */   reverseDictionary: () => (/* binding */ reverseDictionary)
/* harmony export */ });

/**
 * @file Core utility functions/classes for Transformers.js.
 * 
 * These are only used internally, meaning an end-user shouldn't
 * need to access anything here.
 * 
 * @module utils/core
 */

/**
 * Helper function to dispatch progress callbacks.
 *
 * @param {function} progress_callback The progress callback function to dispatch.
 * @param {any} data The data to pass to the progress callback function.
 * @returns {void}
 * @private
 */
function dispatchCallback(progress_callback, data) {
    if (progress_callback !== null) progress_callback(data);
}

/**
 * Reverses the keys and values of an object.
 *
 * @param {Object} data The object to reverse.
 * @returns {Object} The reversed object.
 * @see https://ultimatecourses.com/blog/reverse-object-keys-and-values-in-javascript
 */
function reverseDictionary(data) {
    // https://ultimatecourses.com/blog/reverse-object-keys-and-values-in-javascript
    return Object.fromEntries(Object.entries(data).map(([key, value]) => [value, key]));
}

/**
 * Escapes regular expression special characters from a string by replacing them with their escaped counterparts.
 *
 * @param {string} string The string to escape.
 * @returns {string} The escaped string.
 */
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}

/**
 * A base class for creating callable objects.
 * 
 * @type {new () => {(...args: any[]): any, _call(...args: any[]): any}}
 */
const Callable = /** @type {any} */ (class {
    /**
    * Creates a new instance of the Callable class.
    */
    constructor() {
        /**
         * Creates a closure that delegates to a private method '_call' with the given arguments.
         * @type {any}
         * @param {...any} args Zero or more arguments to pass to the '_call' method.
         * @returns {*} The result of calling the '_call' method.
         */
        let closure = function (...args) {
            return closure._call(...args)
        }
        return Object.setPrototypeOf(closure, new.target.prototype)
    }

    /**
     * This method should be implemented in subclasses to provide the
     * functionality of the callable object.
     *
     * @param {any[]} args
     * @throws {Error} If the subclass does not implement the `_call` method.
     */
    _call(...args) {
        throw Error('Must implement _call method in subclass')
    }
});


/**
 * Check if a value is a string.
 * @param {*} text The value to check.
 * @returns {boolean} True if the value is a string, false otherwise.
 */
function isString(text) {
    return typeof text === 'string' || text instanceof String
}


/**
 * Check if a value is a typed array.
 * @param {*} val The value to check.
 * @returns {boolean} True if the value is a `TypedArray`, false otherwise.
 * 
 * Adapted from https://stackoverflow.com/a/71091338/13989043
 */
function isTypedArray(val) {
    return val?.prototype?.__proto__?.constructor?.name === 'TypedArray';
}


/**
 * Check if a value is an integer.
 * @param {*} x The value to check.
 * @returns {boolean} True if the value is a string, false otherwise.
 */
function isIntegralNumber(x) {
    return Number.isInteger(x) || typeof x === 'bigint'
}

/**
 * Check if a value is exists.
 * @param {*} x The value to check.
 * @returns {boolean} True if the value exists, false otherwise.
 */
function exists(x) {
    return x !== undefined && x !== null;
}

/**
 * Calculates the dimensions of a nested array.
 *
 * @param {Array} arr The nested array to calculate dimensions for.
 * @returns {Array} An array containing the dimensions of the input array.
 */
function calculateDimensions(arr) {
    const dimensions = [];
    let current = arr;
    while (Array.isArray(current)) {
        dimensions.push(current.length);
        current = current[0];
    }
    return dimensions;
}

/**
 * Replicate python's .pop() method for objects.
 * @param {Object} obj The object to pop from.
 * @param {string} key The key to pop.
 * @param {*} defaultValue The default value to return if the key does not exist.
 * @returns {*} The value of the popped key.
 * @throws {Error} If the key does not exist and no default value is provided.
 */
function pop(obj, key, defaultValue = undefined) {
    const value = obj[key];
    if (value !== undefined) {
        delete obj[key];
        return value;
    }
    if (defaultValue === undefined) {
        throw Error(`Key ${key} does not exist in object.`)
    }
    return defaultValue;
}

/**
 * Efficiently merge arrays, creating a new copy.
 * Adapted from https://stackoverflow.com/a/6768642/13989043
 * @param  {...any} arrs Arrays to merge.
 * @returns The merged array.
 */
function mergeArrays(...arrs) {
    return Array.prototype.concat.apply([], arrs);
}


/***/ }),

/***/ "./node_modules/@xenova/transformers/src/utils/generation.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/generation.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ForceTokensLogitsProcessor: () => (/* binding */ ForceTokensLogitsProcessor),
/* harmony export */   ForcedBOSTokenLogitsProcessor: () => (/* binding */ ForcedBOSTokenLogitsProcessor),
/* harmony export */   ForcedEOSTokenLogitsProcessor: () => (/* binding */ ForcedEOSTokenLogitsProcessor),
/* harmony export */   GenerationConfig: () => (/* binding */ GenerationConfig),
/* harmony export */   LogitsProcessor: () => (/* binding */ LogitsProcessor),
/* harmony export */   LogitsProcessorList: () => (/* binding */ LogitsProcessorList),
/* harmony export */   NoRepeatNGramLogitsProcessor: () => (/* binding */ NoRepeatNGramLogitsProcessor),
/* harmony export */   RepetitionPenaltyLogitsProcessor: () => (/* binding */ RepetitionPenaltyLogitsProcessor),
/* harmony export */   Sampler: () => (/* binding */ Sampler),
/* harmony export */   SuppressTokensAtBeginLogitsProcessor: () => (/* binding */ SuppressTokensAtBeginLogitsProcessor),
/* harmony export */   WhisperTimeStampLogitsProcessor: () => (/* binding */ WhisperTimeStampLogitsProcessor)
/* harmony export */ });
/* harmony import */ var _tensor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tensor.js */ "./node_modules/@xenova/transformers/src/utils/tensor.js");
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ "./node_modules/@xenova/transformers/src/utils/core.js");
/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./maths.js */ "./node_modules/@xenova/transformers/src/utils/maths.js");

/**
 * @file Classes, functions, and utilities for generation.
 * 
 * @todo Describe how to create a custom `GenerationConfig`.
 * 
 * @module utils/generation
 */




/**
 * A class representing a list of logits processors. A logits processor is a function that modifies the logits
 * output of a language model. This class provides methods for adding new processors and applying all processors to a
 * batch of logits.
 *
 * @extends Callable
 */
class LogitsProcessorList extends _core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {
    /**
     * Constructs a new instance of `LogitsProcessorList`.
     */
    constructor() {
        super();
        this.processors = [];
    }

    /**
     * Adds a new logits processor to the list.
     *
     * @param {LogitsProcessor} item The logits processor function to add.
     */
    push(item) {
        this.processors.push(item);
    }

    /**
     * Adds multiple logits processors to the list.
     *
     * @param {LogitsProcessor[]} items The logits processor functions to add.
     */
    extend(items) {
        this.processors.push(...items);
    }

    /**
     * Applies all logits processors in the list to a batch of logits, modifying them in-place.
     *
     * @param {number[]} input_ids The input IDs for the language model.
     * @param {number[][]} batchedLogits A 2D array of logits, where each row corresponds to a single
     *                                                input sequence in the batch.
     */
    _call(input_ids, batchedLogits) {
        // NOTE: This is different from the Python code, since vanilla JS does not support vectorized operations. 
        // As a result, we apply each processor to each item in the batch.
        for (let logits of batchedLogits) {
            // Modifies logits inplace
            this.processors.forEach(
                func => func(input_ids, logits)
            )
        }
    }

    [Symbol.iterator]() {
        return this.processors.values();
    }
}

/**
 * Base class for processing logits.
 * @extends Callable
 */
class LogitsProcessor extends _core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {
    /**
     * Apply the processor to the input logits.
     *
     * @abstract
     * @param {Array} input_ids The input ids.
     * @param {Tensor} logits The logits to process.
     * @throws {Error} Throws an error if `_call` is not implemented in the subclass.
     */
    _call(input_ids, logits) {
        throw Error("`_call` should be implemented in a subclass")
    }
}

/**
 * A logits processor that forces a specific token to be generated by the decoder.
 * 
 * @extends LogitsProcessor
 */
class ForceTokensLogitsProcessor extends LogitsProcessor {
    /**
     * Constructs a new instance of `ForceTokensLogitsProcessor`.
     * 
     * @param {Array} forced_decoder_ids The ids of tokens that should be forced.
     */
    constructor(forced_decoder_ids) {
        super();
        this.force_token_map = Object.fromEntries(forced_decoder_ids ?? []);
    }

    /**
     * Apply the processor to the input logits.
     *
     * @param {Array} input_ids The input ids.
     * @param {Tensor} logits The logits to process.
     * @returns {Tensor} The processed logits.
     */
    _call(input_ids, logits) {
        let map = this.force_token_map[input_ids.length];
        if ((0,_core_js__WEBPACK_IMPORTED_MODULE_1__.exists)(map)) { // There exists a mapping
            logits.data.fill(-Infinity)
            logits.data[map] = 0;
        }
        return logits;
    }
}

/**
 * A LogitsProcessor that forces a BOS token at the beginning of the generated sequence.
 * @extends LogitsProcessor
 */
class ForcedBOSTokenLogitsProcessor extends LogitsProcessor {
    /**
     * Create a ForcedBOSTokenLogitsProcessor.
     * @param {number} bos_token_id The ID of the beginning-of-sequence token to be forced.
     */
    constructor(bos_token_id) {
        super();
        this.bos_token_id = bos_token_id;
    }

    /**
     * Apply the BOS token forcing to the logits.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The logits with BOS token forcing.
     */
    _call(input_ids, logits) {
        if (input_ids.length === 1) {
            logits.data.fill(-Infinity)
            logits.data[this.bos_token_id] = 0;
        }
        return logits;
    }
}

/**
 * A logits processor that forces end-of-sequence token probability to 1.
 * 
 * @extends LogitsProcessor
 */
class ForcedEOSTokenLogitsProcessor extends LogitsProcessor {
    /**
     * Create a ForcedEOSTokenLogitsProcessor.
     * @param {number} max_length Max length of the sequence.
     * @param {number|number[]} forced_eos_token_id The ID of the end-of-sequence token to be forced.
     */
    constructor(max_length, forced_eos_token_id) {
        super();
        this.max_length = max_length;
        this.forced_eos_token_id = forced_eos_token_id;
    }

    /**
     * Apply the processor to input_ids and logits.
     * 
     * @param {number[]} input_ids The input ids.
     * @param {Tensor} logits The logits tensor.
     */
    _call(input_ids, logits) {
        // console.log('call ForcedEOSTokenLogitsProcessor')
        // TODO
    }
}

/**
 * A LogitsProcessor that suppresses a list of tokens as soon as the `generate` function starts
 * generating using `begin_index` tokens. This should ensure that the tokens defined by
 * `begin_suppress_tokens` at not sampled at the begining of the generation.
 * @extends LogitsProcessor
 */
class SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor {
    /**
     * Create a SuppressTokensAtBeginLogitsProcessor.
     * @param {number[]} begin_suppress_tokens The IDs of the tokens to suppress.
     * @param {number} begin_index The number of tokens to generate before suppressing tokens.
     */
    constructor(begin_suppress_tokens, begin_index) {
        super();
        this.begin_suppress_tokens = begin_suppress_tokens;
        this.begin_index = begin_index;
    }

    /**
     * Apply the BOS token forcing to the logits.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The logits with BOS token forcing.
     */
    _call(input_ids, logits) {
        if (input_ids.length === this.begin_index) {
            for (let token_id of this.begin_suppress_tokens) {
                logits.data[token_id] = -Infinity;
            }
        }
        return logits;
    }
}

/**
 * A LogitsProcessor that handles adding timestamps to generated text.
 * @extends LogitsProcessor
 */
class WhisperTimeStampLogitsProcessor extends LogitsProcessor {
    /**
     * Constructs a new WhisperTimeStampLogitsProcessor.
     * @param {Object} generate_config The config object passed to the `generate()` method of a transformer model.
     * @param {number} generate_config.eos_token_id The ID of the end-of-sequence token.
     * @param {number} generate_config.no_timestamps_token_id The ID of the token used to indicate that a token should not have a timestamp.
     * @param {number[][]} [generate_config.forced_decoder_ids] An array of two-element arrays representing decoder IDs that are forced to appear in the output. The second element of each array indicates whether the token is a timestamp.
     * @param {number} [generate_config.max_initial_timestamp_index] The maximum index at which an initial timestamp can appear.
     */
    constructor(generate_config) {
        super();
        this.eos_token_id = generate_config.eos_token_id;
        this.no_timestamps_token_id = generate_config.no_timestamps_token_id;
        this.timestamp_begin = this.no_timestamps_token_id + 1;

        this.begin_index = (generate_config.forced_decoder_ids || []).length + 2;
        if (generate_config.forced_decoder_ids.slice(-1)[0][1] === this.no_timestamps_token_id) {
            this.begin_index -= 1;
        }
        this.max_initial_timestamp_index = generate_config.max_initial_timestamp_index;

    }

    /**
     * Modify the logits to handle timestamp tokens.
     * @param {Array} input_ids The input sequence of tokens.
     * @param {Tensor} logits The logits output by the model.
     * @returns {Tensor} The modified logits.
     */
    _call(input_ids, logits) {
        // suppress <|notimestamps|> which is handled by without_timestamps
        logits.data[this.no_timestamps_token_id] = -Infinity;

        if (input_ids.length === this.begin_index - 1) {
            logits.data.fill(-Infinity);
            logits.data[this.timestamp_begin] = 0;
            return logits;
        }

        // timestamps have to appear in pairs, except directly before eos_token; mask logits accordingly
        const seq = input_ids.slice(this.begin_index);
        const last_was_timestamp = seq.length >= 1 && seq[seq.length - 1] >= this.timestamp_begin;
        const penultimate_was_timestamp = seq.length < 2 || seq[seq.length - 2] >= this.timestamp_begin;

        if (last_was_timestamp) {
            if (penultimate_was_timestamp) { // has to be non-timestamp
                logits.data.subarray(this.timestamp_begin).fill(-Infinity);
            } else { // cannot be normal text tokens
                logits.data.subarray(0, this.eos_token_id).fill(-Infinity);
            }
        }

        // apply the `max_initial_timestamp` option
        if (input_ids.length === this.begin_index && this.max_initial_timestamp_index !== null) {
            const last_allowed = this.timestamp_begin + this.max_initial_timestamp_index;
            logits.data.subarray(last_allowed + 1).fill(-Infinity);
        }

        // if sum of probability over timestamps is above any other token, sample timestamp
        const logprobs = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.log_softmax)(logits.data);
        const timestamp_logprob = Math.log(logprobs.subarray(this.timestamp_begin).map(Math.exp).reduce((a, b) => a + b));
        const max_text_token_logprob = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logprobs.subarray(0, this.timestamp_begin))[0];

        if (timestamp_logprob > max_text_token_logprob) {
            logits.data.subarray(0, this.timestamp_begin).fill(-Infinity);
        }

        return logits;
    }
}

/**
 * A logits processor that disallows ngrams of a certain size to be repeated.
 * 
 * @extends LogitsProcessor
 */
class NoRepeatNGramLogitsProcessor extends LogitsProcessor {
    /**
     * Create a NoRepeatNGramLogitsProcessor.
     * @param {number} no_repeat_ngram_size The no-repeat-ngram size. All ngrams of this size can only occur once.
     */
    constructor(no_repeat_ngram_size) {
        super();
        this.no_repeat_ngram_size = no_repeat_ngram_size;
    }

    /**
     * Generate n-grams from a sequence of token ids.
     * @param {number[]} prevInputIds List of previous input ids
     * @returns {Map<string, number[]>} Map of generated n-grams
     */
    getNgrams(prevInputIds) {
        const curLen = prevInputIds.length;

        /**@type {number[][]} */
        const ngrams = [];
        for (let j = 0; j < curLen + 1 - this.no_repeat_ngram_size; ++j) {
            const ngram = [];
            for (let k = 0; k < this.no_repeat_ngram_size; ++k) {
                ngram.push(prevInputIds[j + k]);
            }
            ngrams.push(ngram);
        }

        /** @type {Map<string, number[]>} */
        const generatedNgram = new Map();
        for (const ngram of ngrams) {
            const prevNgram = ngram.slice(0, ngram.length - 1);
            const prevNgramKey = JSON.stringify(prevNgram);
            const prevNgramValue = generatedNgram.get(prevNgramKey) ?? [];
            prevNgramValue.push(ngram[ngram.length - 1]);
            generatedNgram.set(prevNgramKey, prevNgramValue);
        }
        return generatedNgram;
    }

    /**
     * Generate n-grams from a sequence of token ids.
     * @param {Map<string, number[]>} bannedNgrams Map of banned n-grams
     * @param {number[]} prevInputIds List of previous input ids
     * @returns {number[]} Map of generated n-grams
     */
    getGeneratedNgrams(bannedNgrams, prevInputIds) {
        const ngramIdx = prevInputIds.slice(prevInputIds.length + 1 - this.no_repeat_ngram_size, prevInputIds.length);
        const banned = bannedNgrams.get(JSON.stringify(ngramIdx)) ?? [];
        return banned;
    }

    /**
     * Calculate banned n-gram tokens
     * @param {number[]} prevInputIds List of previous input ids
     * @returns {number[]} Map of generated n-grams
     */
    calcBannedNgramTokens(prevInputIds) {
        const bannedTokens = [];
        if (prevInputIds.length + 1 < this.no_repeat_ngram_size) {
            // return no banned tokens if we haven't generated no_repeat_ngram_size tokens yet
            return bannedTokens;

        } else {
            const generatedNgrams = this.getNgrams(prevInputIds);
            const bannedTokens = this.getGeneratedNgrams(generatedNgrams, prevInputIds);
            return bannedTokens;
        }
    }

    /**
     * Apply the no-repeat-ngram processor to the logits.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The logits with no-repeat-ngram processing.
     */
    _call(input_ids, logits) {
        const bannedTokens = this.calcBannedNgramTokens(input_ids);

        for (const token of bannedTokens) {
            logits.data[token] = -Infinity;
        }
        return logits;
    }
}

/**
 * A logits processor that penalises repeated output tokens.
 * 
 * @extends LogitsProcessor
 */
class RepetitionPenaltyLogitsProcessor extends LogitsProcessor {
    /**
     * Create a RepetitionPenaltyLogitsProcessor.
     * @param {number} penalty The penalty to apply for repeated tokens.
     */
    constructor(penalty) {
        super();
        this.penalty = penalty;
    }

    /**
     * Apply the repetition penalty to the logits.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The logits with repetition penalty processing.
     */
    _call(input_ids, logits) {
        // Modify the logits corresponding to each element in `input_ids`.
        // As a consequence, the logits corresponding to tokens that appear
        // many times in the output will be penalised more.
        for (const input_id of input_ids) {
            if (logits.data[input_id] < 0) {
                logits.data[input_id] *= this.penalty;
            } else {
                logits.data[input_id] /= this.penalty;
            }
        }
        return logits
    }
}

/**
 * Class that holds a configuration for a generation task.
 */
class GenerationConfig {
    /**
     * Create a GenerationConfig object
     * @param {Object} [kwargs={}] The configuration parameters. If not set, the default values are used.
     * @param {number} [kwargs.max_length=20] The maximum length the generated tokens can have. Corresponds to the length of the input prompt + `max_new_tokens`. Its effect is overridden by `max_new_tokens`, if also set.
     * @param {number} [kwargs.max_new_tokens=null] The maximum numbers of tokens to generate, ignoring the number of tokens in the prompt.
     * @param {number} [kwargs.min_length=0] The minimum length of the sequence to be generated. Corresponds to the length of the input prompt + `min_new_tokens`. Its effect is overridden by `min_new_tokens`, if also set.
     * @param {number} [kwargs.min_new_tokens=null] The minimum numbers of tokens to generate, ignoring the number of tokens in the prompt.
     * @param {boolean|"never"} [kwargs.early_stopping=false] Controls the stopping condition for beam-based methods, like beam-search. It accepts the following values:
     * - `true`, where the generation stops as soon as there are `num_beams` complete candidates;
     * - `false`, where an heuristic is applied and the generation stops when is it very unlikely to find better candidates;
     * - `"never"`, where the beam search procedure only stops when there cannot be better candidates (canonical beam search algorithm).
     * @param {number} [kwargs.max_time=null] The maximum amount of time you allow the computation to run for in seconds. Generation will still finish the current pass after allocated time has been passed.
     *
     * @param {boolean} [kwargs.do_sample=false] Whether or not to use sampling; use greedy decoding otherwise.
     * @param {number} [kwargs.num_beams=1] Number of beams for beam search. 1 means no beam search.
     * @param {number} [kwargs.num_beam_groups=1] Number of groups to divide `num_beams` into in order to ensure diversity among different groups of beams. See [this paper](https://arxiv.org/pdf/1610.02424.pdf) for more details.
     * @param {number} [kwargs.penalty_alpha=null] The values balance the model confidence and the degeneration penalty in contrastive search decoding.
     * @param {boolean} [kwargs.use_cache=true] Whether or not the model should use the past last key/values attentions (if applicable to the model) to speed up decoding.
     *
     * @param {number} [kwargs.temperature=1.0] The value used to modulate the next token probabilities.
     * @param {number} [kwargs.top_k=50] The number of highest probability vocabulary tokens to keep for top-k-filtering.
     * @param {number} [kwargs.top_p=1.0] If set to float < 1, only the smallest set of most probable tokens with probabilities that add up to `top_p` or higher are kept for generation.
     * @param {number} [kwargs.typical_p=1.0] Local typicality measures how similar the conditional probability of predicting a target token next is to the expected conditional probability of predicting a random token next, given the partial text already generated. If set to float < 1, the smallest set of the most locally typical tokens with probabilities that add up to `typical_p` or higher are kept for generation. See [this paper](https://arxiv.org/pdf/2202.00666.pdf) for more details.
     * @param {number} [kwargs.epsilon_cutoff=0.0] If set to float strictly between 0 and 1, only tokens with a conditional probability greater than `epsilon_cutoff` will be sampled. In the paper, suggested values range from 3e-4 to 9e-4, depending on the size of the model. See [Truncation Sampling as Language Model Desmoothing](https://arxiv.org/abs/2210.15191) for more details.
     * @param {number} [kwargs.eta_cutoff=0.0] Eta sampling is a hybrid of locally typical sampling and epsilon sampling. If set to float strictly between 0 and 1, a token is only considered if it is greater than either `eta_cutoff` or `sqrt(eta_cutoff) * exp(-entropy(softmax(next_token_logits)))`. The latter term is intuitively the expected next token probability, scaled by `sqrt(eta_cutoff)`. In the paper, suggested values range from 3e-4 to 2e-3, depending on the size of the model. See [Truncation Sampling as Language Model Desmoothing](https://arxiv.org/abs/2210.15191) for more details.
     * @param {number} [kwargs.diversity_penalty=0.0] This value is subtracted from a beam's score if it generates a token same as any beam from other group at a particular time. Note that `diversity_penalty` is only effective if `group beam search` is enabled.
     * @param {number} [kwargs.repetition_penalty=1.0] The parameter for repetition penalty. 1.0 means no penalty. See [this paper](https://arxiv.org/pdf/1909.05858.pdf) for more details.
     * @param {number} [kwargs.encoder_repetition_penalty=1.0] The paramater for encoder_repetition_penalty. An exponential penalty on sequences that are not in the original input. 1.0 means no penalty.
     * @param {number} [kwargs.length_penalty=1.0] Exponential penalty to the length that is used with beam-based generation. It is applied as an exponent to the sequence length, which in turn is used to divide the score of the sequence. Since the score is the log likelihood of the sequence (i.e. negative), `length_penalty` > 0.0 promotes longer sequences, while `length_penalty` < 0.0 encourages shorter sequences.
     * @param {number} [kwargs.no_repeat_ngram_size=0] If set to int > 0, all ngrams of that size can only occur once.
     * @param {number[][]} [kwargs.bad_words_ids=null] List of token ids that are not allowed to be generated. In order to get the token ids of the words that should not appear in the generated text, use `(await tokenizer(bad_words, {add_prefix_space: true, add_special_tokens: false})).input_ids`.
     * @param {number[][]|number[][][]} [kwargs.force_words_ids=null] List of token ids that must be generated. If given a `number[][]`, this is treated as a simple list of words that must be included, the opposite to `bad_words_ids`. If given `number[][][]`, this triggers a [disjunctive constraint](https://github.com/huggingface/transformers/issues/14081), where one can allow different forms of each word.
     * @param {boolean} [kwargs.renormalize_logits=false] Whether to renormalize the logits after applying all the logits processors or warpers (including the custom ones). It's highly recommended to set this flag to `true` as the search algorithms suppose the score logits are normalized but some logit processors or warpers break the normalization.
     * @param {Object[]} [kwargs.constraints=null] Custom constraints that can be added to the generation to ensure that the output will contain the use of certain tokens as defined by `Constraint` objects, in the most sensible way possible.
     * 
     * @param {number} [kwargs.forced_bos_token_id=null] The id of the token to force as the first generated token after the `decoder_start_token_id`. Useful for multilingual models like mBART where the first generated token needs to be the target language token.
     * @param {number|number[]} [kwargs.forced_eos_token_id=null] The id of the token to force as the last generated token when `max_length` is reached. Optionally, use a list to set multiple *end-of-sequence* tokens.
     * @param {boolean} [kwargs.remove_invalid_values=false] Whether to remove possible *nan* and *inf* outputs of the model to prevent the generation method to crash. Note that using `remove_invalid_values` can slow down generation.
     * @param {number[]} [kwargs.exponential_decay_length_penalty=null] This Tuple adds an exponentially increasing length penalty, after a certain amount of tokens have been generated. The tuple shall consist of: `(start_index, decay_factor)` where `start_index` indicates where penalty starts and `decay_factor` represents the factor of exponential decay.
     * @param {number[]} [kwargs.suppress_tokens=null] A list of tokens that will be suppressed at generation. The `SupressTokens` logit processor will set their log probs to `-inf` so that they are not sampled.
     * @param {number[]} [kwargs.begin_suppress_tokens=null] A list of tokens that will be suppressed at the beginning of the generation. The `SupressBeginTokens` logit processor will set their log probs to `-inf` so that they are not sampled.
     * @param {number[][]} [kwargs.forced_decoder_ids=null] A list of pairs of integers which indicates a mapping from generation indices to token indices that will be forced before sampling. For example, `[[1, 123]]` means the second generated token will always be a token of index 123.
     * 
     * @param {number} [kwargs.num_return_sequences=1] The number of independently computed returned sequences for each element in the batch.
     * @param {boolean} [kwargs.output_attentions=false] Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned tensors for more details.
     * @param {boolean} [kwargs.output_hidden_states=false] Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for more details.
     * @param {boolean} [kwargs.output_scores=false] Whether or not to return the prediction scores. See `scores` under returned tensors for more details.
     * @param {boolean} [kwargs.return_dict_in_generate=false] Whether or not to return a `ModelOutput` instead of a plain tuple.
     * 
     * @param {number} [kwargs.pad_token_id=null] The id of the *padding* token.
     * @param {number} [kwargs.bos_token_id=null] The id of the *beginning-of-sequence* token.
     * @param {number|number[]} [kwargs.eos_token_id=null] The id of the *end-of-sequence* token. Optionally, use a list to set multiple *end-of-sequence* tokens.
     * 
     * @param {number} [kwargs.encoder_no_repeat_ngram_size=0] If set to int > 0, all ngrams of that size that occur in the `encoder_input_ids` cannot occur in the `decoder_input_ids`.
     * @param {number} [kwargs.decoder_start_token_id=null] If an encoder-decoder model starts decoding with a different token than *bos*, the id of that token.
     * 
     * @param {Object} [kwargs.generation_kwargs={}] Additional generation kwargs will be forwarded to the `generate` function of the model. Kwargs that are not present in `generate`'s signature will be used in the model forward pass.
     */
    constructor(kwargs = {}) {
        // Parameters that control the length of the output
        this.max_length = kwargs.max_length ?? 20;
        this.max_new_tokens = kwargs.max_new_tokens ?? null;
        this.min_length = kwargs.min_length ?? 0;
        this.min_new_tokens = kwargs.min_new_tokens ?? null;
        this.early_stopping = kwargs.early_stopping ?? false;
        this.max_time = kwargs.max_time ?? null;

        // Parameters that control the generation strategy used
        this.do_sample = kwargs.do_sample ?? false;
        this.num_beams = kwargs.num_beams ?? 1;
        this.num_beam_groups = kwargs.num_beam_groups ?? 1;
        this.penalty_alpha = kwargs.penalty_alpha ?? null;
        this.use_cache = kwargs.use_cache ?? true;

        // Parameters for manipulation of the model output logits
        this.temperature = kwargs.temperature ?? 1.0;
        this.top_k = kwargs.top_k ?? 50;
        this.top_p = kwargs.top_p ?? 1.0;
        this.typical_p = kwargs.typical_p ?? 1.0;
        this.epsilon_cutoff = kwargs.epsilon_cutoff ?? 0.0;
        this.eta_cutoff = kwargs.eta_cutoff ?? 0.0;
        this.diversity_penalty = kwargs.diversity_penalty ?? 0.0;
        this.repetition_penalty = kwargs.repetition_penalty ?? 1.0;
        this.encoder_repetition_penalty = kwargs.encoder_repetition_penalty ?? 1.0;
        this.length_penalty = kwargs.length_penalty ?? 1.0;
        this.no_repeat_ngram_size = kwargs.no_repeat_ngram_size ?? 0;
        this.bad_words_ids = kwargs.bad_words_ids ?? null;
        this.force_words_ids = kwargs.force_words_ids ?? null;
        this.renormalize_logits = kwargs.renormalize_logits ?? false;
        this.constraints = kwargs.constraints ?? null;
        this.forced_bos_token_id = kwargs.forced_bos_token_id ?? null;
        this.forced_eos_token_id = kwargs.forced_eos_token_id ?? null;
        this.remove_invalid_values = kwargs.remove_invalid_values ?? false;
        this.exponential_decay_length_penalty = kwargs.exponential_decay_length_penalty ?? null;
        this.suppress_tokens = kwargs.suppress_tokens ?? null;
        this.begin_suppress_tokens = kwargs.begin_suppress_tokens ?? null;
        this.forced_decoder_ids = kwargs.forced_decoder_ids ?? null;

        // Parameters that define the output variables of `generate`
        this.num_return_sequences = kwargs.num_return_sequences ?? 1;
        this.output_attentions = kwargs.output_attentions ?? false;
        this.output_hidden_states = kwargs.output_hidden_states ?? false;
        this.output_scores = kwargs.output_scores ?? false;
        this.return_dict_in_generate = kwargs.return_dict_in_generate ?? false;

        // Special tokens that can be used at generation time
        this.pad_token_id = kwargs.pad_token_id ?? null;
        this.bos_token_id = kwargs.bos_token_id ?? null;
        this.eos_token_id = kwargs.eos_token_id ?? null;

        // Generation parameters exclusive to encoder-decoder models
        this.encoder_no_repeat_ngram_size = kwargs.encoder_no_repeat_ngram_size ?? 0;
        this.decoder_start_token_id = kwargs.decoder_start_token_id ?? null;

        // Wild card
        this.generation_kwargs = kwargs.generation_kwargs ?? {};
    }
}


/**
 * Sampler is a base class for all sampling methods used for text generation.
 */
class Sampler extends _core_js__WEBPACK_IMPORTED_MODULE_1__.Callable {
    /**
     * Creates a new Sampler object with the specified generation config.
     * @param {GenerationConfig} generation_config The generation config.
     */
    constructor(generation_config) {
        super();
        this.generation_config = generation_config;
    }

    /**
     * Executes the sampler, using the specified logits.
     * @param {Tensor} logits
     * @param {number} index
     * @returns {void}
     */
    _call(logits, index = -1) {
        // Sample from logits, of dims [batch, sequence_length, vocab_size].
        // If index is specified, sample from [batch, index, vocab_size].
        return this.sample(logits, index);
    }

    /**
     * Abstract method for sampling the logits.
     * @param {Tensor} logits
     * @param {number} index
     * @throws {Error}
     */
    sample(logits, index) {
        throw Error("sample should be implemented in subclasses.")
    }

    /**
     * Returns the specified logits as an array, with temperature applied.
     * @param {Tensor} logits
     * @param {number} index
     * @returns {Array}
     */
    getLogits(logits, index) {
        let vocabSize = logits.dims.at(-1);

        let logs = logits.data;

        if (index === -1) {
            logs = logs.slice(-vocabSize);
        } else {
            let startIndex = index * vocabSize;
            logs = logs.slice(startIndex, startIndex + vocabSize);
        }

        // add temperature
        if (this.generation_config.temperature > 0) {
            logs = logs.map(x => x / this.generation_config.temperature)
        }
        return logs;
    }

    /**
     * Selects an item randomly based on the specified probabilities.
     * @param {Array} probabilities An array of probabilities to use for selection.
     * @returns {number} The index of the selected item.
     */
    randomSelect(probabilities) {
        // Return index of chosen item
        let sumProbabilities = probabilities.reduce((acc, curr) => acc + curr, 0);

        let r = Math.random() * sumProbabilities;
        for (let i = 0; i < probabilities.length; ++i) {
            r -= probabilities[i];
            if (r <= 0) {
                return i;
            }
        }
        return 0; // return first (most probable) as a fallback
    }

    /**
     * Returns a Sampler object based on the specified options.
     * @param {GenerationConfig} generation_config An object containing options for the sampler.
     * @returns {Sampler} A Sampler object.
     */
    static getSampler(generation_config) {
        // - *greedy decoding*: `num_beams=1` and `do_sample=False`
        // - *contrastive search*: `penalty_alpha>0` and `top_k>1`
        // - *multinomial sampling*: `num_beams=1` and `do_sample=True`
        // - *beam-search decoding*: `num_beams>1` and `do_sample=False`
        // - *beam-search multinomial sampling*: `num_beams>1` and `do_sample=True`
        // - *diverse beam-search decoding*: `num_beams>1` and `num_beam_groups>1`
        // - *constrained beam-search decoding*: `constraints!=None` or `force_words_ids!=None`

        // NOTE: beam search is implemented directly into the generation function
        if (generation_config.do_sample) {
            return new MultinomialSampler(generation_config);

        } else if (generation_config.num_beams > 1) {
            return new BeamSearchSampler(generation_config);

        } else {
            if (generation_config.num_return_sequences > 1) {
                throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${generation_config.num_return_sequences}.`)
            }
            return new GreedySampler(generation_config);
        }
    }
}

/**
 * Class representing a Greedy Sampler.
 * @extends Sampler
 */
class GreedySampler extends Sampler {
    /**
     * Sample the maximum probability of a given logits tensor.
     * @param {Tensor} logits
     * @param {number} [index=-1]
     * @returns {Array} An array with a single tuple, containing the index of the maximum value and a meaningless score (since this is a greedy search).
     */
    sample(logits, index = -1) {
        // NOTE: no need to do log_softmax here since we only take the maximum
        let logs = this.getLogits(logits, index);
        let argmax = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.max)(logs)[1];

        // Note: score is meaningless in this context, since we are performing
        // greedy search (p = 1 => log(p) = 0)
        return [
            [argmax, 0]
        ];
    }
}

/**
 * Class representing a MultinomialSampler.
 * @extends Sampler
 */
class MultinomialSampler extends Sampler {

    /**
     * Sample from the logits.
     * @param {Tensor} logits
     * @param {number} index
     * @returns {Array}
     */
    sample(logits, index = -1) {
        let k = logits.dims.at(-1); // defaults to vocab size
        if (this.generation_config.top_k > 0) {
            k = Math.min(this.generation_config.top_k, k);
        }

        // Get logits of nth token
        const logs = this.getLogits(logits, index);

        // Get top k tokens
        const topLogits = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.getTopItems)(logs, k);

        // Compute softmax over logits
        const probabilities = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(topLogits.map(x => x[1]));

        return Array.from({ length: this.generation_config.num_beams }, () => {
            const sampledIndex = this.randomSelect(probabilities);
            return [
                topLogits[sampledIndex][0], // token id
                Math.log(probabilities[sampledIndex]), // score
            ];
        });
    }
}


/**
 * Class representing a BeamSearchSampler.
 * @extends Sampler
 */
class BeamSearchSampler extends Sampler {

    /**
     * Sample from the logits.
     * @param {Tensor} logits
     * @param {number} index
     * @returns {Array}
     */
    sample(logits, index = -1) {
        let k = logits.dims.at(-1); // defaults to vocab size
        if (this.generation_config.top_k > 0) {
            k = Math.min(this.generation_config.top_k, k);
        }

        // Get logits of nth token
        const logs = this.getLogits(logits, index);

        // Get top k tokens
        const topLogits = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.getTopItems)(logs, k);

        // Compute softmax over logits
        const probabilities = (0,_maths_js__WEBPACK_IMPORTED_MODULE_2__.softmax)(topLogits.map(x => x[1]));

        return Array.from({ length: this.generation_config.num_beams }, (_, i) => {
            return [
                topLogits[i][0], // token id
                Math.log(probabilities[i]), // score
            ];
        });
    }
}


/***/ }),

/***/ "./node_modules/@xenova/transformers/src/utils/hub.js":
/*!************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/hub.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFile: () => (/* binding */ getFile),
/* harmony export */   getModelFile: () => (/* binding */ getModelFile),
/* harmony export */   getModelJSON: () => (/* binding */ getModelJSON)
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "?0a40");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "?61c2");
/* harmony import */ var stream_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream/web */ "?66bb");
/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../env.js */ "./node_modules/@xenova/transformers/src/env.js");
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core.js */ "./node_modules/@xenova/transformers/src/utils/core.js");
/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/buffer/index.js */ "./node_modules/buffer/index.js")["Buffer"];
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");

/**
 * @file Utility functions to interact with the Hugging Face Hub (https://huggingface.co/models)
 * 
 * @module utils/hub
 */








if (!globalThis.ReadableStream) {
    // @ts-ignore
    globalThis.ReadableStream = stream_web__WEBPACK_IMPORTED_MODULE_2__.ReadableStream; // ReadableStream is not a global with Node 16
}

/**
 * @typedef {Object} PretrainedOptions Options for loading a pretrained model.     
 * @property {boolean?} [options.quantized=true] Whether to load the 8-bit quantized version of the model (only applicable when loading model files).
 * @property {function} [options.progress_callback=null] If specified, this function will be called during model construction, to provide the user with progress updates.
 * @property {Object} [options.config=null] Configuration for the model to use instead of an automatically loaded configuration. Configuration can be automatically loaded when:
 * - The model is a model provided by the library (loaded with the *model id* string of a pretrained model).
 * - The model is loaded by supplying a local directory as `pretrained_model_name_or_path` and a configuration JSON file named *config.json* is found in the directory.
 * @property {string} [options.cache_dir=null] Path to a directory in which a downloaded pretrained model configuration should be cached if the standard cache should not be used.
 * @property {boolean} [options.local_files_only=false] Whether or not to only look at local files (e.g., not try downloading the model).
 * @property {string} [options.revision='main'] The specific model version to use. It can be a branch name, a tag name, or a commit id,
 * since we use a git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any identifier allowed by git.
 * NOTE: This setting is ignored for local requests.
 * @property {string} [options.model_file_name=null] If specified, load the model with this name (excluding the .onnx suffix). Currently only valid for encoder- or decoder-only models.
 */

class FileResponse {
    /**
     * Mapping from file extensions to MIME types.
     */
    _CONTENT_TYPE_MAP = {
        'txt': 'text/plain',
        'html': 'text/html',
        'css': 'text/css',
        'js': 'text/javascript',
        'json': 'application/json',
        'png': 'image/png',
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'gif': 'image/gif',
    }
    /**
     * Creates a new `FileResponse` object.
     * @param {string|URL} filePath
     */
    constructor(filePath) {
        this.filePath = filePath;
        this.headers = new Headers();

        this.exists = fs__WEBPACK_IMPORTED_MODULE_0__.existsSync(filePath);
        if (this.exists) {
            this.status = 200;
            this.statusText = 'OK';

            let stats = fs__WEBPACK_IMPORTED_MODULE_0__.statSync(filePath);
            this.headers.set('content-length', stats.size.toString());

            this.updateContentType();

            let self = this;
            this.body = new ReadableStream({
                start(controller) {
                    self.arrayBuffer().then(buffer => {
                        controller.enqueue(new Uint8Array(buffer));
                        controller.close();
                    })
                }
            });
        } else {
            this.status = 404;
            this.statusText = 'Not Found';
            this.body = null;
        }
    }

    /**
     * Updates the 'content-type' header property of the response based on the extension of
     * the file specified by the filePath property of the current object.
     * @returns {void}
     */
    updateContentType() {
        // Set content-type header based on file extension
        const extension = this.filePath.toString().split('.').pop().toLowerCase();
        this.headers.set('content-type', this._CONTENT_TYPE_MAP[extension] ?? 'application/octet-stream');
    }

    /**
     * Clone the current FileResponse object.
     * @returns {FileResponse} A new FileResponse object with the same properties as the current object.
     */
    clone() {
        let response = new FileResponse(this.filePath);
        response.exists = this.exists;
        response.status = this.status;
        response.statusText = this.statusText;
        response.headers = new Headers(this.headers);
        return response;
    }

    /**
     * Reads the contents of the file specified by the filePath property and returns a Promise that
     * resolves with an ArrayBuffer containing the file's contents.
     * @returns {Promise<ArrayBuffer>} A Promise that resolves with an ArrayBuffer containing the file's contents.
     * @throws {Error} If the file cannot be read.
     */
    async arrayBuffer() {
        const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.filePath);
        return data.buffer;
    }

    /**
     * Reads the contents of the file specified by the filePath property and returns a Promise that
     * resolves with a Blob containing the file's contents.
     * @returns {Promise<Blob>} A Promise that resolves with a Blob containing the file's contents.
     * @throws {Error} If the file cannot be read.
     */
    async blob() {
        const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.filePath);
        return new Blob([data], { type: this.headers.get('content-type') });
    }

    /**
     * Reads the contents of the file specified by the filePath property and returns a Promise that
     * resolves with a string containing the file's contents.
     * @returns {Promise<string>} A Promise that resolves with a string containing the file's contents.
     * @throws {Error} If the file cannot be read.
     */
    async text() {
        const data = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(this.filePath, 'utf8');
        return data;
    }

    /**
     * Reads the contents of the file specified by the filePath property and returns a Promise that
     * resolves with a parsed JavaScript object containing the file's contents.
     * 
     * @returns {Promise<Object>} A Promise that resolves with a parsed JavaScript object containing the file's contents.
     * @throws {Error} If the file cannot be read.
     */
    async json() {
        return JSON.parse(await this.text());
    }
}

/**
 * Determines whether the given string is a valid HTTP or HTTPS URL.
 * @param {string|URL} string The string to test for validity as an HTTP or HTTPS URL.
 * @param {string[]} [validHosts=null] A list of valid hostnames. If specified, the URL's hostname must be in this list.
 * @returns {boolean} True if the string is a valid HTTP or HTTPS URL, false otherwise.
 */
function isValidHttpUrl(string, validHosts = null) {
    // https://stackoverflow.com/a/43467144
    let url;
    try {
        url = new URL(string);
    } catch (_) {
        return false;
    }
    if (validHosts && !validHosts.includes(url.hostname)) {
        return false;
    }
    return url.protocol === "http:" || url.protocol === "https:";
}

/**
 * Helper function to get a file, using either the Fetch API or FileSystem API.
 *
 * @param {URL|string} urlOrPath The URL/path of the file to get.
 * @returns {Promise<FileResponse|Response>} A promise that resolves to a FileResponse object (if the file is retrieved using the FileSystem API), or a Response object (if the file is retrieved using the Fetch API).
 */
async function getFile(urlOrPath) {

    if (_env_js__WEBPACK_IMPORTED_MODULE_3__.env.useFS && !isValidHttpUrl(urlOrPath)) {
        return new FileResponse(urlOrPath);

    } else if (typeof process !== 'undefined' && process?.release?.name === 'node') {
        const IS_CI = !!process.env?.TESTING_REMOTELY;
        const version = _env_js__WEBPACK_IMPORTED_MODULE_3__.env.version;

        const headers = new Headers();
        headers.set('User-Agent', `transformers.js/${version}; is_ci/${IS_CI};`);

        // Check whether we are making a request to the Hugging Face Hub.
        const isHFURL = isValidHttpUrl(urlOrPath, ['huggingface.co', 'hf.co']);
        if (isHFURL) {
            // If an access token is present in the environment variables,
            // we add it to the request headers.
            const token = process.env?.HF_ACCESS_TOKEN;
            if (token) {
                headers.set('Authorization', `Bearer ${token}`);
            }
        }
        return fetch(urlOrPath, { headers });
    } else {
        // Running in a browser-environment, so we use default headers
        // NOTE: We do not allow passing authorization headers in the browser,
        // since this would require exposing the token to the client.
        return fetch(urlOrPath);
    }
}

const ERROR_MAPPING = {
    // 4xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)
    400: 'Bad request error occurred while trying to load file',
    401: 'Unauthorized access to file',
    403: 'Forbidden access to file',
    404: 'Could not locate file',
    408: 'Request timeout error occurred while trying to load file',

    // 5xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)
    500: 'Internal server error error occurred while trying to load file',
    502: 'Bad gateway error occurred while trying to load file',
    503: 'Service unavailable error occurred while trying to load file',
    504: 'Gateway timeout error occurred while trying to load file',
}
/**
 * Helper method to handle fatal errors that occur while trying to load a file from the Hugging Face Hub.
 * @param {number} status The HTTP status code of the error.
 * @param {string} remoteURL The URL of the file that could not be loaded.
 * @param {boolean} fatal Whether to raise an error if the file could not be loaded.
 * @returns {null} Returns `null` if `fatal = true`.
 * @throws {Error} If `fatal = false`.
 */
function handleError(status, remoteURL, fatal) {
    if (!fatal) {
        // File was not loaded correctly, but it is optional.
        // TODO in future, cache the response?
        return null;
    }

    const message = ERROR_MAPPING[status] ?? `Error (${status}) occurred while trying to load file`;
    throw Error(`${message}: "${remoteURL}".`);
}

class FileCache {
    /**
     * Instantiate a `FileCache` object.
     * @param {string} path 
     */
    constructor(path) {
        this.path = path;
    }

    /**
     * Checks whether the given request is in the cache.
     * @param {string} request 
     * @returns {Promise<FileResponse | undefined>}
     */
    async match(request) {

        let filePath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.path, request);
        let file = new FileResponse(filePath);

        if (file.exists) {
            return file;
        } else {
            return undefined;
        }
    }

    /**
     * Adds the given response to the cache.
     * @param {string} request 
     * @param {Response|FileResponse} response 
     * @returns {Promise<void>}
     */
    async put(request, response) {
        const buffer = Buffer.from(await response.arrayBuffer());

        let outputPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.path, request);

        try {
            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.mkdir(path__WEBPACK_IMPORTED_MODULE_1__.dirname(outputPath), { recursive: true });
            await fs__WEBPACK_IMPORTED_MODULE_0__.promises.writeFile(outputPath, buffer);

        } catch (err) {
            console.warn('An error occurred while writing the file to cache:', err)
        }
    }

    // TODO add the rest?
    // addAll(requests: RequestInfo[]): Promise<void>;
    // delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<boolean>;
    // keys(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Request>>;
    // match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response | undefined>;
    // matchAll(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Response>>;
}

/**
 * 
 * @param {FileCache|Cache} cache The cache to search
 * @param {string[]} names The names of the item to search for
 * @returns {Promise<FileResponse|Response|undefined>} The item from the cache, or undefined if not found.
 */
async function tryCache(cache, ...names) {
    for (let name of names) {
        try {
            let result = await cache.match(name);
            if (result) return result;
        } catch (e) {
            continue;
        }
    }
    return undefined;
}

/**
 * 
 * Retrieves a file from either a remote URL using the Fetch API or from the local file system using the FileSystem API.
 * If the filesystem is available and `env.useCache = true`, the file will be downloaded and cached.
 * 
 * @param {string} path_or_repo_id This can be either:
 * - a string, the *model id* of a model repo on huggingface.co.
 * - a path to a *directory* potentially containing the file.
 * @param {string} filename The name of the file to locate in `path_or_repo`.
 * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.
 * @param {PretrainedOptions} [options] An object containing optional parameters.
 * 
 * @throws Will throw an error if the file is not found and `fatal` is true.
 * @returns {Promise} A Promise that resolves with the file content as a buffer.
 */
async function getModelFile(path_or_repo_id, filename, fatal = true, options = {}) {

    if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowLocalModels) {
        // User has disabled local models, so we just make sure other settings are correct.

        if (options.local_files_only) {
            throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).")
        } else if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowRemoteModels) {
            throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")
        }
    }

    // Initiate file retrieval
    (0,_core_js__WEBPACK_IMPORTED_MODULE_4__.dispatchCallback)(options.progress_callback, {
        status: 'initiate',
        name: path_or_repo_id,
        file: filename
    })

    // First, check if the a caching backend is available
    // If no caching mechanism available, will download the file every time
    let cache;
    if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_3__.env.useBrowserCache) {
        if (typeof caches === 'undefined') {
            throw Error('Browser cache is not available in this environment.')
        }
        try {
            // In some cases, the browser cache may be visible, but not accessible due to security restrictions.
            // For example, when running an application in an iframe, if a user attempts to load the page in
            // incognito mode, the following error is thrown: `DOMException: Failed to execute 'open' on 'CacheStorage':
            // An attempt was made to break through the security policy of the user agent.`
            // So, instead of crashing, we just ignore the error and continue without using the cache.
            cache = await caches.open('transformers-cache');
        } catch (e) {
            console.warn('An error occurred while opening the browser cache:', e);
        }
    }

    if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_3__.env.useFSCache) {
        // TODO throw error if not available

        // If `cache_dir` is not specified, use the default cache directory
        cache = new FileCache(options.cache_dir ?? _env_js__WEBPACK_IMPORTED_MODULE_3__.env.cacheDir);
    }

    if (!cache && _env_js__WEBPACK_IMPORTED_MODULE_3__.env.useCustomCache) {
        // Allow the user to specify a custom cache system.
        if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.customCache) {
            throw Error('`env.useCustomCache=true`, but `env.customCache` is not defined.')
        }

        // Check that the required methods are defined:
        if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.customCache.match || !_env_js__WEBPACK_IMPORTED_MODULE_3__.env.customCache.put) {
            throw new Error(
                "`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. " +
                "For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache"
            )
        }
        cache = _env_js__WEBPACK_IMPORTED_MODULE_3__.env.customCache;
    }

    const revision = options.revision ?? 'main';

    let requestURL = pathJoin(path_or_repo_id, filename);
    let localPath = pathJoin(_env_js__WEBPACK_IMPORTED_MODULE_3__.env.localModelPath, requestURL);

    let remoteURL = pathJoin(
        _env_js__WEBPACK_IMPORTED_MODULE_3__.env.remoteHost,
        _env_js__WEBPACK_IMPORTED_MODULE_3__.env.remotePathTemplate
            .replaceAll('{model}', path_or_repo_id)
            .replaceAll('{revision}', revision),
        filename
    );

    // Choose cache key for filesystem cache
    // When using the main revision (default), we use the request URL as the cache key.
    // If a specific revision is requested, we account for this in the cache key.
    let fsCacheKey = revision === 'main' ? requestURL : pathJoin(path_or_repo_id, revision, filename);

    /** @type {string} */
    let cacheKey;
    let proposedCacheKey = cache instanceof FileCache ? fsCacheKey : remoteURL;

    /** @type {Response|undefined} */
    let responseToCache;

    /** @type {Response|FileResponse|undefined} */
    let response;

    if (cache) {
        // A caching system is available, so we try to get the file from it.
        //  1. We first try to get from cache using the local path. In some environments (like deno),
        //     non-URL cache keys are not allowed. In these cases, `response` will be undefined.
        //  2. If no response is found, we try to get from cache using the remote URL or file system cache.
        response = await tryCache(cache, localPath, proposedCacheKey);
    }

    if (response === undefined) {
        // Caching not available, or file is not cached, so we perform the request

        if (_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowLocalModels) {
            // Accessing local models is enabled, so we try to get the file locally.
            // If request is a valid HTTP URL, we skip the local file check. Otherwise, we try to get the file locally.
            const isURL = isValidHttpUrl(requestURL);
            if (!isURL) {
                try {
                    response = await getFile(localPath);
                    cacheKey = localPath; // Update the cache key to be the local path
                } catch (e) {
                    // Something went wrong while trying to get the file locally.
                    // NOTE: error handling is done in the next step (since `response` will be undefined)
                    console.warn(`Unable to load from local path "${localPath}": "${e}"`);
                }
            } else if (options.local_files_only) {
                throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${requestURL}.`);
            } else if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowRemoteModels) {
                throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${requestURL}.`);
            }
        }

        if (response === undefined || response.status === 404) {
            // File not found locally. This means either:
            // - The user has disabled local file access (`env.allowLocalModels=false`)
            // - the path is a valid HTTP url (`response === undefined`)
            // - the path is not a valid HTTP url and the file is not present on the file system or local server (`response.status === 404`)

            if (options.local_files_only || !_env_js__WEBPACK_IMPORTED_MODULE_3__.env.allowRemoteModels) {
                // User requested local files only, but the file is not found locally.
                if (fatal) {
                    throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${localPath}".`);
                } else {
                    // File not found, but this file is optional.
                    // TODO in future, cache the response?
                    return null;
                }
            }

            // File not found locally, so we try to download it from the remote server
            response = await getFile(remoteURL);

            if (response.status !== 200) {
                return handleError(response.status, remoteURL, fatal);
            }

            // Success! We use the proposed cache key from earlier
            cacheKey = proposedCacheKey;
        }


        if (cache && response instanceof Response && response.status === 200) {
            // only clone if cache available, and response is valid
            responseToCache = response.clone();
        }
    }


    // Start downloading
    (0,_core_js__WEBPACK_IMPORTED_MODULE_4__.dispatchCallback)(options.progress_callback, {
        status: 'download',
        name: path_or_repo_id,
        file: filename
    })

    const buffer = await readResponse(response, data => {
        ;(0,_core_js__WEBPACK_IMPORTED_MODULE_4__.dispatchCallback)(options.progress_callback, {
            status: 'progress',
            ...data,
            name: path_or_repo_id,
            file: filename
        })
    })


    if (
        // Only cache web responses
        // i.e., do not cache FileResponses (prevents duplication)
        responseToCache && cacheKey
        &&
        // Check again whether request is in cache. If not, we add the response to the cache
        (await cache.match(cacheKey) === undefined)
    ) {
        await cache.put(cacheKey, responseToCache)
            .catch(err => {
                // Do not crash if unable to add to cache (e.g., QuotaExceededError).
                // Rather, log a warning and proceed with execution.
                console.warn(`Unable to add response to browser cache: ${err}.`);
            });

    }

    (0,_core_js__WEBPACK_IMPORTED_MODULE_4__.dispatchCallback)(options.progress_callback, {
        status: 'done',
        name: path_or_repo_id,
        file: filename
    });

    return buffer;
}

/**
 * Fetches a JSON file from a given path and file name.
 *
 * @param {string} modelPath The path to the directory containing the file.
 * @param {string} fileName The name of the file to fetch.
 * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.
 * @param {PretrainedOptions} [options] An object containing optional parameters.
 * @returns {Promise<Object>} The JSON data parsed into a JavaScript object.
 * @throws Will throw an error if the file is not found and `fatal` is true.
 */
async function getModelJSON(modelPath, fileName, fatal = true, options = {}) {
    let buffer = await getModelFile(modelPath, fileName, fatal, options);
    if (buffer === null) {
        // Return empty object
        return {}
    }

    let decoder = new TextDecoder('utf-8');
    let jsonData = decoder.decode(buffer);

    return JSON.parse(jsonData);
}

/**
 * Read and track progress when reading a Response object
 *
 * @param {any} response The Response object to read
 * @param {function} progress_callback The function to call with progress updates
 * @returns {Promise<Uint8Array>} A Promise that resolves with the Uint8Array buffer
 */
async function readResponse(response, progress_callback) {
    // Read and track progress when reading a Response object

    const contentLength = response.headers.get('Content-Length');
    if (contentLength === null) {
        console.warn('Unable to determine content-length from response headers. Will expand buffer when needed.')
    }
    let total = parseInt(contentLength ?? '0');
    let buffer = new Uint8Array(total);
    let loaded = 0;

    const reader = response.body.getReader();
    async function read() {
        const { done, value } = await reader.read();
        if (done) return;

        let newLoaded = loaded + value.length;
        if (newLoaded > total) {
            total = newLoaded;

            // Adding the new data will overflow buffer.
            // In this case, we extend the buffer
            let newBuffer = new Uint8Array(total);

            // copy contents
            newBuffer.set(buffer);

            buffer = newBuffer;
        }
        buffer.set(value, loaded)
        loaded = newLoaded;

        const progress = (loaded / total) * 100;

        // Call your function here
        progress_callback({
            progress: progress,
            loaded: loaded,
            total: total,
        })

        return read();
    }

    // Actually read
    await read();

    return buffer;
}

/**
 * Joins multiple parts of a path into a single path, while handling leading and trailing slashes.
 *
 * @param {...string} parts Multiple parts of a path.
 * @returns {string} A string representing the joined path.
 */
function pathJoin(...parts) {
    // https://stackoverflow.com/a/55142565
    parts = parts.map((part, index) => {
        if (index) {
            part = part.replace(new RegExp('^/'), '');
        }
        if (index !== parts.length - 1) {
            part = part.replace(new RegExp('/$'), '');
        }
        return part;
    })
    return parts.join('/');
}


/***/ }),

/***/ "./node_modules/@xenova/transformers/src/utils/image.js":
/*!**************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/image.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RawImage: () => (/* binding */ RawImage)
/* harmony export */ });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "?0a40");
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ "./node_modules/@xenova/transformers/src/utils/core.js");
/* harmony import */ var _hub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hub.js */ "./node_modules/@xenova/transformers/src/utils/hub.js");
/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../env.js */ "./node_modules/@xenova/transformers/src/env.js");
/* harmony import */ var sharp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! sharp */ "?0740");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");

/**
 * @file Helper module for image processing. 
 * 
 * These functions and classes are only used internally, 
 * meaning an end-user shouldn't need to access anything here.
 * 
 * @module utils/image
 */






// Will be empty (or not used) if running in browser or web-worker


const BROWSER_ENV = typeof self !== 'undefined';

let createCanvasFunction;
let ImageDataClass;
let loadImageFunction;
if (BROWSER_ENV) {
    // Running in browser or web-worker
    createCanvasFunction = (/** @type {number} */ width, /** @type {number} */ height) => {
        if (!self.OffscreenCanvas) {
            throw new Error('OffscreenCanvas not supported by this browser.');
        }
        return new self.OffscreenCanvas(width, height)
    };
    loadImageFunction = self.createImageBitmap;
    ImageDataClass = self.ImageData;

} else if (sharp__WEBPACK_IMPORTED_MODULE_4__) {
    // Running in Node.js, electron, or other non-browser environment

    loadImageFunction = async (/**@type {sharp.Sharp}*/img) => {
        const metadata = await img.metadata();
        const rawChannels = metadata.channels;

        let { data, info } = await img.raw().toBuffer({ resolveWithObject: true });

        const newImage = new RawImage(new Uint8ClampedArray(data), info.width, info.height, info.channels);
        if (rawChannels !== undefined && rawChannels !== info.channels) {
            // Make sure the new image has the same number of channels as the input image.
            // This is necessary for grayscale images.
            newImage.convert(rawChannels);
        }
        return newImage;
    }

} else {
    throw new Error('Unable to load image processing library.');
}


// Defined here: https://github.com/python-pillow/Pillow/blob/a405e8406b83f8bfb8916e93971edc7407b8b1ff/src/libImaging/Imaging.h#L262-L268
const RESAMPLING_MAPPING = {
    0: 'nearest',
    1: 'lanczos',
    2: 'bilinear',
    3: 'bicubic',
    4: 'box',
    5: 'hamming',
}

class RawImage {

    /**
     * Mapping from file extensions to MIME types.
     */
    _CONTENT_TYPE_MAP = {
        'png': 'image/png',
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'gif': 'image/gif',
    }

    /**
     * Create a new `RawImage` object.
     * @param {Uint8ClampedArray} data The pixel data.
     * @param {number} width The width of the image.
     * @param {number} height The height of the image.
     * @param {1|2|3|4} channels The number of channels.
     */
    constructor(data, width, height, channels) {
        this._update(data, width, height, channels);
    }

    /**
     * Helper method for reading an image from a variety of input types.
     * @param {RawImage|string|URL} input 
     * @returns The image object.
     * 
     * **Example:** Read image from a URL.
     * ```javascript
     * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');
     * // test {
     * //   "data": Uint8ClampedArray [ 25, 25, 25, 19, 19, 19, ... ],
     * //   "width": 800,
     * //   "height": 533,
     * //   "channels": 3
     * // }
     * ```
     */
    static async read(input) {
        if (input instanceof RawImage) {
            return input;
        } else if ((0,_core_js__WEBPACK_IMPORTED_MODULE_1__.isString)(input) || input instanceof URL) {
            return await this.fromURL(input);
        } else {
            throw new Error(`Unsupported input type: ${typeof input}`);
        }
    }


    /**
     * Read an image from a URL or file path.
     * @param {string|URL} url The URL or file path to read the image from.
     * @returns {Promise<RawImage>} The image object.
     */
    static async fromURL(url) {
        let response = await (0,_hub_js__WEBPACK_IMPORTED_MODULE_2__.getFile)(url);
        if (response.status !== 200) {
            throw new Error(`Unable to read image from "${url}" (${response.status} ${response.statusText})`);
        }
        let blob = await response.blob();
        return this.fromBlob(blob);
    }

    /**
     * Helper method to create a new Image from a blob.
     * @param {Blob} blob The blob to read the image from.
     * @returns {Promise<RawImage>} The image object.
     */
    static async fromBlob(blob) {
        if (BROWSER_ENV) {
            // Running in environment with canvas
            let img = await loadImageFunction(blob);

            const ctx = createCanvasFunction(img.width, img.height).getContext('2d');

            // Draw image to context
            ctx.drawImage(img, 0, 0);

            return new this(ctx.getImageData(0, 0, img.width, img.height).data, img.width, img.height, 4);

        } else {
            // Use sharp.js to read (and possible resize) the image.
            let img = sharp__WEBPACK_IMPORTED_MODULE_4__(await blob.arrayBuffer());

            return await loadImageFunction(img);
        }
    }

    /**
     * Convert the image to grayscale format.
     * @returns {RawImage} `this` to support chaining.
     */
    grayscale() {
        if (this.channels === 1) {
            return this;
        }

        let newData = new Uint8ClampedArray(this.width * this.height * 1);
        switch (this.channels) {
            case 3: // rgb to grayscale
            case 4: // rgba to grayscale
                for (let i = 0, offset = 0; i < this.data.length; i += this.channels) {
                    const red = this.data[i];
                    const green = this.data[i + 1];
                    const blue = this.data[i + 2];

                    newData[offset++] = Math.round(0.2989 * red + 0.5870 * green + 0.1140 * blue);
                }
                break;
            default:
                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
        }
        return this._update(newData, this.width, this.height, 1);
    }

    /**
     * Convert the image to RGB format.
     * @returns {RawImage} `this` to support chaining.
     */
    rgb() {
        if (this.channels === 3) {
            return this;
        }

        let newData = new Uint8ClampedArray(this.width * this.height * 3);

        switch (this.channels) {
            case 1: // grayscale to rgb
                for (let i = 0, offset = 0; i < this.data.length; ++i) {
                    newData[offset++] = this.data[i];
                    newData[offset++] = this.data[i];
                    newData[offset++] = this.data[i];
                }
                break;
            case 4: // rgba to rgb
                for (let i = 0, offset = 0; i < this.data.length; i += 4) {
                    newData[offset++] = this.data[i];
                    newData[offset++] = this.data[i + 1];
                    newData[offset++] = this.data[i + 2];
                }
                break;
            default:
                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
        }
        return this._update(newData, this.width, this.height, 3);

    }

    /**
     * Convert the image to RGBA format.
     * @returns {RawImage} `this` to support chaining.
     */
    rgba() {
        if (this.channels === 4) {
            return this;
        }

        let newData = new Uint8ClampedArray(this.width * this.height * 4);

        switch (this.channels) {
            case 1: // grayscale to rgba
                for (let i = 0, offset = 0; i < this.data.length; ++i) {
                    newData[offset++] = this.data[i];
                    newData[offset++] = this.data[i];
                    newData[offset++] = this.data[i];
                    newData[offset++] = 255;
                }
                break;
            case 3: // rgb to rgba
                for (let i = 0, offset = 0; i < this.data.length; i += 3) {
                    newData[offset++] = this.data[i];
                    newData[offset++] = this.data[i + 1];
                    newData[offset++] = this.data[i + 2];
                    newData[offset++] = 255;
                }
                break;
            default:
                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
        }

        return this._update(newData, this.width, this.height, 4);
    }

    /**
     * Resize the image to the given dimensions. This method uses the canvas API to perform the resizing.
     * @param {number} width The width of the new image.
     * @param {number} height The height of the new image.
     * @param {Object} options Additional options for resizing.
     * @param {0|1|2|3|4|5|string} [options.resample] The resampling method to use.
     * @returns {Promise<RawImage>} `this` to support chaining.
     */
    async resize(width, height, {
        resample = 2,
    } = {}) {

        // Ensure resample method is a string
        let resampleMethod = RESAMPLING_MAPPING[resample] ?? resample;

        if (BROWSER_ENV) {
            // TODO use `resample` in browser environment

            // Store number of channels before resizing
            let numChannels = this.channels;

            // Create canvas object for this image
            let canvas = this.toCanvas();

            // Actually perform resizing using the canvas API
            const ctx = createCanvasFunction(width, height).getContext('2d');

            // Draw image to context, resizing in the process
            ctx.drawImage(canvas, 0, 0, width, height);

            // Create image from the resized data
            let resizedImage = new RawImage(ctx.getImageData(0, 0, width, height).data, width, height, 4);

            // Convert back so that image has the same number of channels as before
            return resizedImage.convert(numChannels);

        } else {
            // Create sharp image from raw data, and resize
            let img = this.toSharp();

            switch (resampleMethod) {
                case 'box':
                case 'hamming':
                    if (resampleMethod === 'box' || resampleMethod === 'hamming') {
                        console.warn(`Resampling method ${resampleMethod} is not yet supported. Using bilinear instead.`);
                        resampleMethod = 'bilinear';
                    }

                case 'nearest':
                case 'bilinear':
                case 'bicubic':
                    // Perform resizing using affine transform. 
                    // This matches how the python Pillow library does it.
                    img = img.affine([width / this.width, 0, 0, height / this.height], {
                        interpolator: resampleMethod
                    });
                    break;

                case 'lanczos':
                    // https://github.com/python-pillow/Pillow/discussions/5519
                    // https://github.com/lovell/sharp/blob/main/docs/api-resize.md
                    img = img.resize({
                        width, height,
                        fit: 'fill',
                        kernel: 'lanczos3', // PIL Lanczos uses a kernel size of 3 
                    });
                    break;

                default:
                    throw new Error(`Resampling method ${resampleMethod} is not supported.`);
            }

            return await loadImageFunction(img);
        }

    }

    async pad([left, right, top, bottom]) {
        left = Math.max(left, 0);
        right = Math.max(right, 0);
        top = Math.max(top, 0);
        bottom = Math.max(bottom, 0);

        if (left === 0 && right === 0 && top === 0 && bottom === 0) {
            // No padding needed
            return this;
        }

        if (BROWSER_ENV) {
            // Store number of channels before padding
            let numChannels = this.channels;

            // Create canvas object for this image
            let canvas = this.toCanvas();

            let newWidth = this.width + left + right;
            let newHeight = this.height + top + bottom;

            // Create a new canvas of the desired size.
            const ctx = createCanvasFunction(newWidth, newHeight).getContext('2d');

            // Draw image to context, padding in the process
            ctx.drawImage(canvas,
                0, 0, this.width, this.height,
                left, top, newWidth, newHeight
            );

            // Create image from the padded data
            let paddedImage = new RawImage(
                ctx.getImageData(0, 0, newWidth, newHeight).data,
                newWidth, newHeight, 4);

            // Convert back so that image has the same number of channels as before
            return paddedImage.convert(numChannels);

        } else {
            let img = this.toSharp().extend({ left, right, top, bottom });
            return await loadImageFunction(img);
        }
    }

    async center_crop(crop_width, crop_height) {
        // If the image is already the desired size, return it
        if (this.width === crop_width && this.height === crop_height) {
            return this;
        }

        // Determine bounds of the image in the new canvas
        let width_offset = (this.width - crop_width) / 2;
        let height_offset = (this.height - crop_height) / 2;


        if (BROWSER_ENV) {
            // Store number of channels before resizing
            let numChannels = this.channels;

            // Create canvas object for this image
            let canvas = this.toCanvas();

            // Create a new canvas of the desired size. This is needed since if the 
            // image is too small, we need to pad it with black pixels.
            const ctx = createCanvasFunction(crop_width, crop_height).getContext('2d');

            let sourceX = 0;
            let sourceY = 0;
            let destX = 0;
            let destY = 0;

            if (width_offset >= 0) {
                sourceX = width_offset;
            } else {
                destX = -width_offset;
            }

            if (height_offset >= 0) {
                sourceY = height_offset;
            } else {
                destY = -height_offset;
            }

            // Draw image to context, cropping in the process
            ctx.drawImage(canvas,
                sourceX, sourceY, crop_width, crop_height,
                destX, destY, crop_width, crop_height
            );

            // Create image from the resized data
            let resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);

            // Convert back so that image has the same number of channels as before
            return resizedImage.convert(numChannels);

        } else {
            // Create sharp image from raw data
            let img = this.toSharp();

            if (width_offset >= 0 && height_offset >= 0) {
                // Cropped image lies entirely within the original image
                img = img.extract({
                    left: Math.floor(width_offset),
                    top: Math.floor(height_offset),
                    width: crop_width,
                    height: crop_height,
                })
            } else if (width_offset <= 0 && height_offset <= 0) {
                // Cropped image lies entirely outside the original image,
                // so we add padding
                let top = Math.floor(-height_offset);
                let left = Math.floor(-width_offset);
                img = img.extend({
                    top: top,
                    left: left,

                    // Ensures the resulting image has the desired dimensions
                    right: crop_width - this.width - left,
                    bottom: crop_height - this.height - top,
                });
            } else {
                // Cropped image lies partially outside the original image.
                // We first pad, then crop.

                let y_padding = [0, 0];
                let y_extract = 0;
                if (height_offset < 0) {
                    y_padding[0] = Math.floor(-height_offset);
                    y_padding[1] = crop_height - this.height - y_padding[0];
                } else {
                    y_extract = Math.floor(height_offset);
                }

                let x_padding = [0, 0];
                let x_extract = 0;
                if (width_offset < 0) {
                    x_padding[0] = Math.floor(-width_offset);
                    x_padding[1] = crop_width - this.width - x_padding[0];
                } else {
                    x_extract = Math.floor(width_offset);
                }

                img = img.extend({
                    top: y_padding[0],
                    bottom: y_padding[1],
                    left: x_padding[0],
                    right: x_padding[1],
                }).extract({
                    left: x_extract,
                    top: y_extract,
                    width: crop_width,
                    height: crop_height,
                })
            }

            return await loadImageFunction(img);
        }
    }

    toCanvas() {
        if (!BROWSER_ENV) {
            throw new Error('toCanvas() is only supported in browser environments.')
        }

        // Clone, and convert data to RGBA before drawing to canvas.
        // This is because the canvas API only supports RGBA
        let cloned = this.clone().rgba();

        // Create canvas object for the cloned image
        let clonedCanvas = createCanvasFunction(cloned.width, cloned.height);

        // Draw image to context
        let data = new ImageDataClass(cloned.data, cloned.width, cloned.height);
        clonedCanvas.getContext('2d').putImageData(data, 0, 0);

        return clonedCanvas;
    }

    /**
     * Helper method to update the image data.
     * @param {Uint8ClampedArray} data The new image data.
     * @param {number} width The new width of the image.
     * @param {number} height The new height of the image.
     * @param {1|2|3|4} channels The new number of channels of the image.
     */
    _update(data, width, height, channels = null) {
        this.data = data;
        this.width = width;
        this.height = height;
        if (channels !== null) {
            this.channels = channels;
        }
        return this;
    }

    /**
     * Clone the image
     * @returns {RawImage} The cloned image
     */
    clone() {
        return new RawImage(this.data.slice(), this.width, this.height, this.channels);
    }

    /**
     * Helper method for converting image to have a certain number of channels
     * @param {number} numChannels The number of channels. Must be 1, 3, or 4.
     * @returns {RawImage} `this` to support chaining.
     */
    convert(numChannels) {
        if (this.channels === numChannels) return this; // Already correct number of channels

        switch (numChannels) {
            case 1:
                this.grayscale();
                break;
            case 3:
                this.rgb();
                break;
            case 4:
                this.rgba();
                break;
            default:
                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);
        }
        return this;
    }

    /**
     * Save the image to the given path.
     * @param {string} path The path to save the image to.
     */
    save(path) {

        if (BROWSER_ENV) {
            const extension = path.split('.').pop().toLowerCase();
            const mime = this._CONTENT_TYPE_MAP[extension] ?? 'image/png';

            // Convert image to canvas
            const canvas = this.toCanvas();

            // Convert the canvas content to a data URL
            const dataURL = canvas.toDataURL(mime);

            // Create an anchor element with the data URL as the href attribute
            const downloadLink = document.createElement('a');
            downloadLink.href = dataURL;

            // Set the download attribute to specify the desired filename for the downloaded image
            downloadLink.download = path;

            // Trigger the download
            downloadLink.click();

            // Clean up: remove the anchor element from the DOM
            downloadLink.remove();

        } else if (!_env_js__WEBPACK_IMPORTED_MODULE_3__.env.useFS) {
            throw new Error('Unable to save the image because filesystem is disabled in this environment.')

        } else {
            const img = this.toSharp();
            img.toFile(path);
        }
    }

    toSharp() {
        if (BROWSER_ENV) {
            throw new Error('toSharp() is only supported in server-side environments.')
        }

        return sharp__WEBPACK_IMPORTED_MODULE_4__(this.data, {
            raw: {
                width: this.width,
                height: this.height,
                channels: this.channels
            }
        });
    }
}


/***/ }),

/***/ "./node_modules/@xenova/transformers/src/utils/maths.js":
/*!**************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/maths.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FFT: () => (/* binding */ FFT),
/* harmony export */   cos_sim: () => (/* binding */ cos_sim),
/* harmony export */   dot: () => (/* binding */ dot),
/* harmony export */   getTopItems: () => (/* binding */ getTopItems),
/* harmony export */   interpolate_data: () => (/* binding */ interpolate_data),
/* harmony export */   log_softmax: () => (/* binding */ log_softmax),
/* harmony export */   magnitude: () => (/* binding */ magnitude),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   medianFilter: () => (/* binding */ medianFilter),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   rfftfreq: () => (/* binding */ rfftfreq),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   softmax: () => (/* binding */ softmax),
/* harmony export */   transpose_data: () => (/* binding */ transpose_data)
/* harmony export */ });

/**
 * @file Helper module for mathematical processing. 
 * 
 * These functions and classes are only used internally, 
 * meaning an end-user shouldn't need to access anything here.
 * 
 * @module utils/maths
 */

/**
 * @typedef {Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array} TypedArray
 * @typedef {BigInt64Array | BigUint64Array} BigTypedArray
 * @typedef {TypedArray | BigTypedArray} AnyTypedArray
 */

/**
 * @param {TypedArray} input
 */
function interpolate_data(input, [in_channels, in_height, in_width], [out_height, out_width], mode = 'bilinear', align_corners = false) {
    // TODO use mode and align_corners

    // Output image dimensions
    const x_scale = out_width / in_width;
    const y_scale = out_height / in_height;

    // Output image
    // @ts-ignore
    const out_img = new input.constructor(out_height * out_width * in_channels);

    // Pre-calculate strides
    const inStride = in_height * in_width;
    const outStride = out_height * out_width;

    for (let i = 0; i < out_height; ++i) {
        for (let j = 0; j < out_width; ++j) {
            // Calculate output offset
            const outOffset = i * out_width + j;

            // Calculate input pixel coordinates
            const x = (j + 0.5) / x_scale - 0.5;
            const y = (i + 0.5) / y_scale - 0.5;

            // Calculate the four nearest input pixels
            // We also check if the input pixel coordinates are within the image bounds
            let x1 = Math.floor(x);
            let y1 = Math.floor(y);
            const x2 = Math.min(x1 + 1, in_width - 1);
            const y2 = Math.min(y1 + 1, in_height - 1);

            x1 = Math.max(x1, 0);
            y1 = Math.max(y1, 0);


            // Calculate the fractional distances between the input pixel and the four nearest pixels
            const s = x - x1;
            const t = y - y1;

            // Perform bilinear interpolation
            const w1 = (1 - s) * (1 - t);
            const w2 = s * (1 - t);
            const w3 = (1 - s) * t;
            const w4 = s * t;

            // Calculate the four nearest input pixel indices
            const yStride = y1 * in_width;
            const xStride = y2 * in_width;
            const idx1 = yStride + x1;
            const idx2 = yStride + x2;
            const idx3 = xStride + x1;
            const idx4 = xStride + x2;

            for (let k = 0; k < in_channels; ++k) {
                // Calculate channel offset
                const cOffset = k * inStride;

                out_img[k * outStride + outOffset] =
                    w1 * input[cOffset + idx1] +
                    w2 * input[cOffset + idx2] +
                    w3 * input[cOffset + idx3] +
                    w4 * input[cOffset + idx4];
            }
        }
    }

    return out_img;
}


/**
 * Helper method to transpose a `AnyTypedArray` directly
 * @param {T} array 
 * @template {AnyTypedArray} T 
 * @param {number[]} dims 
 * @param {number[]} axes 
 * @returns {[T, number[]]} The transposed array and the new shape.
 */
function transpose_data(array, dims, axes) {
    // Calculate the new shape of the transposed array
    // and the stride of the original array
    const shape = new Array(axes.length);
    const stride = new Array(axes.length);

    for (let i = axes.length - 1, s = 1; i >= 0; --i) {
        stride[i] = s;
        shape[i] = dims[axes[i]];
        s *= shape[i];
    }

    // Precompute inverse mapping of stride
    const invStride = axes.map((_, i) => stride[axes.indexOf(i)]);

    // Create the transposed array with the new shape
    // @ts-ignore
    const transposedData = new array.constructor(array.length);

    // Transpose the original array to the new array
    for (let i = 0; i < array.length; ++i) {
        let newIndex = 0;
        for (let j = dims.length - 1, k = i; j >= 0; --j) {
            newIndex += (k % dims[j]) * invStride[j];
            k = Math.floor(k / dims[j]);
        }
        transposedData[newIndex] = array[i];
    }

    return [transposedData, shape];
}


/**
 * Compute the softmax of an array of numbers.
 *
 * @param {number[]} arr The array of numbers to compute the softmax of.
 * @returns {number[]} The softmax array.
 */
function softmax(arr) {
    // Compute the maximum value in the array
    const maxVal = max(arr)[0];

    // Compute the exponentials of the array values
    const exps = arr.map(x => Math.exp(x - maxVal));

    // Compute the sum of the exponentials
    const sumExps = exps.reduce((acc, val) => acc + val, 0);

    // Compute the softmax values
    const softmaxArr = exps.map(x => x / sumExps);

    return softmaxArr;
}

/**
 * Calculates the logarithm of the softmax function for the input array.
 * @param {number[]} arr The input array to calculate the log_softmax function for.
 * @returns {any} The resulting log_softmax array.
 */
function log_softmax(arr) {
    // Compute the softmax values
    const softmaxArr = softmax(arr);

    // Apply log formula to each element
    const logSoftmaxArr = softmaxArr.map(x => Math.log(x));

    return logSoftmaxArr;
}

/**
 * Calculates the dot product of two arrays.
 * @param {number[]} arr1 The first array.
 * @param {number[]} arr2 The second array.
 * @returns {number} The dot product of arr1 and arr2.
 */
function dot(arr1, arr2) {
    return arr1.reduce((acc, val, i) => acc + val * arr2[i], 0);
}


/**
 * Get the top k items from an iterable, sorted by descending order
 *
 * @param {Array} items The items to be sorted
 * @param {number} [top_k=0] The number of top items to return (default: 0 = return all)
 * @returns {Array} The top k items, sorted by descending order
 */
function getTopItems(items, top_k = 0) {
    // if top == 0, return all

    items = Array.from(items)
        .map((x, i) => [i, x])            // Get indices ([index, score])
        .sort((a, b) => b[1] - a[1])      // Sort by log probabilities

    if (top_k > 0) {
        items = items.slice(0, top_k);    // Get top k items
    }

    return items
}

/**
 * Computes the cosine similarity between two arrays.
 *
 * @param {number[]} arr1 The first array.
 * @param {number[]} arr2 The second array.
 * @returns {number} The cosine similarity between the two arrays.
 */
function cos_sim(arr1, arr2) {
    // Calculate dot product of the two arrays
    const dotProduct = dot(arr1, arr2);

    // Calculate the magnitude of the first array
    const magnitudeA = magnitude(arr1);

    // Calculate the magnitude of the second array
    const magnitudeB = magnitude(arr2);

    // Calculate the cosine similarity
    const cosineSimilarity = dotProduct / (magnitudeA * magnitudeB);

    return cosineSimilarity;
}

/**
 * Calculates the magnitude of a given array.
 * @param {number[]} arr The array to calculate the magnitude of.
 * @returns {number} The magnitude of the array.
 */
function magnitude(arr) {
    return Math.sqrt(arr.reduce((acc, val) => acc + val * val, 0));
}


/**
 * Returns the value and index of the minimum element in an array.
 * @param {number[]} arr array of numbers.
 * @returns {number[]} the value and index of the minimum element, of the form: [valueOfMin, indexOfMin]
 * @throws {Error} If array is empty.
 */
function min(arr) {
    if (arr.length === 0) throw Error('Array must not be empty');
    let min = arr[0];
    let indexOfMin = 0;
    for (let i = 1; i < arr.length; ++i) {
        if (arr[i] < min) {
            min = arr[i];
            indexOfMin = i;
        }
    }
    return [min, indexOfMin];
}


/**
 * Returns the value and index of the maximum element in an array.
 * @param {number[]} arr array of numbers.
 * @returns {number[]} the value and index of the maximum element, of the form: [valueOfMax, indexOfMax]
 * @throws {Error} If array is empty.
 */
function max(arr) {
    if (arr.length === 0) throw Error('Array must not be empty');
    let max = arr[0];
    let indexOfMax = 0;
    for (let i = 1; i < arr.length; ++i) {
        if (arr[i] > max) {
            max = arr[i];
            indexOfMax = i;
        }
    }
    return [max, indexOfMax];
}

/**
 * Return the Discrete Fourier Transform sample frequencies.
 * 
 * Code adapted from https://github.com/numpy/numpy/blob/25908cacd19915bf3ddd659c28be28a41bd97a54/numpy/fft/helper.py#L173-L221
 * Original Python doc: https://numpy.org/doc/stable/reference/generated/numpy.fft.rfftfreq.html
 * @example
 * rfftfreq(400, 1 / 16000) // (201) [0, 40, 80, 120, 160, 200, ..., 8000]
 * @param {number} n Window length
 * @param {number} [d = 1.0] Sample spacing (inverse of the sampling rate). Defaults to 1.
 * @throws {TypeError} If n is not an integer.
 * @returns {number[]} Array of length `Math.floor(n / 2) + 1;` containing the sample frequencies.
 */
function rfftfreq(n, d = 1.0) {
    if (!Number.isInteger(n)) {
        throw new TypeError(`n should be an integer, but ${n} given.`);
    }
    const val = 1.0 / (n * d);
    const len = Math.floor(n / 2) + 1;
    const results = new Array(len);
    for (let i = 0; i < len; ++i) {
        results[i] = i * val;
    }
    return results;
}

/**
 * FFT class provides functionality for performing Fast Fourier Transform on arrays
 * Code adapted from https://www.npmjs.com/package/fft.js
 */
class FFT {
    /**
     * @param {number} size The size of the input array. Must be a power of two and bigger than 1.
     * @throws {Error} FFT size must be a power of two and bigger than 1.
     */
    constructor(size) {
        this.size = size | 0; // convert to a 32-bit signed integer
        if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)
            throw new Error('FFT size must be a power of two and bigger than 1');

        this._csize = size << 1;

        this.table = new Float32Array(this.size * 2);
        for (let i = 0; i < this.table.length; i += 2) {
            const angle = Math.PI * i / this.size;
            this.table[i] = Math.cos(angle);
            this.table[i + 1] = -Math.sin(angle);
        }

        // Find size's power of two
        let power = 0;
        for (let t = 1; this.size > t; t <<= 1)
            ++power;

        // Calculate initial step's width:
        //   * If we are full radix-4, it is 2x smaller to give inital len=8
        //   * Otherwise it is the same as `power` to give len=4
        this._width = power % 2 === 0 ? power - 1 : power;

        // Pre-compute bit-reversal patterns
        this._bitrev = new Int32Array(1 << this._width);
        for (let j = 0; j < this._bitrev.length; ++j) {
            this._bitrev[j] = 0;
            for (let shift = 0; shift < this._width; shift += 2) {
                const revShift = this._width - shift - 2;
                this._bitrev[j] |= ((j >>> shift) & 3) << revShift;
            }
        }
    }

    /**
     * Create a complex number array with size `2 * size`
     *
     * @returns {Float32Array} A complex number array with size `2 * size`
     */
    createComplexArray() {
        return new Float32Array(this._csize);
    }

    /**
     * Converts a complex number representation stored in a Float32Array to an array of real numbers.
     * 
     * @param {Float32Array} complex The complex number representation to be converted.
     * @param {number[]} [storage] An optional array to store the result in.
     * @returns {number[]} An array of real numbers representing the input complex number representation.
     */
    fromComplexArray(complex, storage) {
        const res = storage || new Array(complex.length >>> 1);
        for (let i = 0; i < complex.length; i += 2)
            res[i >>> 1] = complex[i];
        return res;
    }

    /**
     * Convert a real-valued input array to a complex-valued output array.
     * @param {Float32Array} input The real-valued input array.
     * @param {Float32Array} [storage] Optional buffer to store the output array.
     * @returns {Float32Array} The complex-valued output array.
     */
    toComplexArray(input, storage) {
        const res = storage || this.createComplexArray();
        for (let i = 0; i < res.length; i += 2) {
            res[i] = input[i >>> 1];
            res[i + 1] = 0;
        }
        return res;
    }

    /**
     * Completes the spectrum by adding its mirrored negative frequency components.
     * @param {Float32Array} spectrum The input spectrum.
     * @returns {void}
     */
    completeSpectrum(spectrum) {
        const size = this._csize;
        const half = size >>> 1;
        for (let i = 2; i < half; i += 2) {
            spectrum[size - i] = spectrum[i];
            spectrum[size - i + 1] = -spectrum[i + 1];
        }
    }

    /**
     * Performs a Fast Fourier Transform (FFT) on the given input data and stores the result in the output buffer.
     * 
     * @param {Float32Array} out The output buffer to store the result.
     * @param {Float32Array} data The input data to transform.
     * 
     * @throws {Error} Input and output buffers must be different.
     * 
     * @returns {void}
     */
    transform(out, data) {
        if (out === data)
            throw new Error('Input and output buffers must be different');

        this._transform4(out, data, 1 /* DONE */);
    }

    /**
     * Performs a real-valued forward FFT on the given input buffer and stores the result in the given output buffer.
     * The input buffer must contain real values only, while the output buffer will contain complex values. The input and
     * output buffers must be different.
     *
     * @param {Float32Array} out The output buffer.
     * @param {Float32Array} data The input buffer containing real values.
     *
     * @throws {Error} If the input and output buffers are the same.
     */
    realTransform(out, data) {
        if (out === data)
            throw new Error('Input and output buffers must be different');

        this._realTransform4(out, data, 1 /* DONE */);
    }

    /**
     * Performs an inverse FFT transformation on the given `data` array, and stores the result in `out`.
     * The `out` array must be a different buffer than the `data` array. The `out` array will contain the
     * result of the transformation. The `data` array will not be modified.
     * 
     * @param {Float32Array} out The output buffer for the transformed data.
     * @param {Float32Array} data The input data to transform.
     * @throws {Error} If `out` and `data` refer to the same buffer.
     * @returns {void}
     */
    inverseTransform(out, data) {
        if (out === data)
            throw new Error('Input and output buffers must be different');

        this._transform4(out, data, -1 /* DONE */);
        for (let i = 0; i < out.length; ++i)
            out[i] /= this.size;
    }

    /**
     * Performs a radix-4 implementation of a discrete Fourier transform on a given set of data.
     *
     * @param {Float32Array} out The output buffer for the transformed data.
     * @param {Float32Array} data The input buffer of data to be transformed.
     * @param {number} inv A scaling factor to apply to the transform.
     * @returns {void}
     */
    _transform4(out, data, inv) {
        // radix-4 implementation

        const size = this._csize;

        // Initial step (permute and transform)
        const width = this._width;
        let step = 1 << width;
        let len = (size / step) << 1;

        let outOff;
        let t;
        let bitrev = this._bitrev;
        if (len === 4) {
            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {
                const off = bitrev[t];
                this._singleTransform2(data, out, outOff, off, step);
            }
        } else {
            // len === 8
            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {
                const off = bitrev[t];
                this._singleTransform4(data, out, outOff, off, step, inv);
            }
        }

        // Loop through steps in decreasing order
        for (step >>= 2; step >= 2; step >>= 2) {
            len = (size / step) << 1;
            let quarterLen = len >>> 2;

            // Loop through offsets in the data
            for (outOff = 0; outOff < size; outOff += len) {
                // Full case
                let limit = outOff + quarterLen;
                for (let i = outOff, k = 0; i < limit; i += 2, k += step) {
                    const A = i;
                    const B = A + quarterLen;
                    const C = B + quarterLen;
                    const D = C + quarterLen;

                    // Original values
                    const Ar = out[A];
                    const Ai = out[A + 1];
                    const Br = out[B];
                    const Bi = out[B + 1];
                    const Cr = out[C];
                    const Ci = out[C + 1];
                    const Dr = out[D];
                    const Di = out[D + 1];

                    const tableBr = this.table[k];
                    const tableBi = inv * this.table[k + 1];
                    const MBr = Br * tableBr - Bi * tableBi;
                    const MBi = Br * tableBi + Bi * tableBr;

                    const tableCr = this.table[2 * k];
                    const tableCi = inv * this.table[2 * k + 1];
                    const MCr = Cr * tableCr - Ci * tableCi;
                    const MCi = Cr * tableCi + Ci * tableCr;

                    const tableDr = this.table[3 * k];
                    const tableDi = inv * this.table[3 * k + 1];
                    const MDr = Dr * tableDr - Di * tableDi;
                    const MDi = Dr * tableDi + Di * tableDr;

                    // Pre-Final values
                    const T0r = Ar + MCr;
                    const T0i = Ai + MCi;
                    const T1r = Ar - MCr;
                    const T1i = Ai - MCi;
                    const T2r = MBr + MDr;
                    const T2i = MBi + MDi;
                    const T3r = inv * (MBr - MDr);
                    const T3i = inv * (MBi - MDi);

                    // Final values
                    out[A] = T0r + T2r;
                    out[A + 1] = T0i + T2i;
                    out[B] = T1r + T3i;
                    out[B + 1] = T1i - T3r;
                    out[C] = T0r - T2r;
                    out[C + 1] = T0i - T2i;
                    out[D] = T1r - T3i;
                    out[D + 1] = T1i + T3r;
                }
            }
        }
    }

    /**
     * Performs a radix-2 implementation of a discrete Fourier transform on a given set of data.
     *
     * @param {Float32Array} data The input buffer of data to be transformed.
     * @param {Float32Array} out The output buffer for the transformed data.
     * @param {number} outOff The offset at which to write the output data.
     * @param {number} off The offset at which to begin reading the input data.
     * @param {number} step The step size for indexing the input data.
     * @returns {void}
     */
    _singleTransform2(data, out, outOff, off, step) {
        // radix-2 implementation
        // NOTE: Only called for len=4

        const evenR = data[off];
        const evenI = data[off + 1];
        const oddR = data[off + step];
        const oddI = data[off + step + 1];

        out[outOff] = evenR + oddR;
        out[outOff + 1] = evenI + oddI;
        out[outOff + 2] = evenR - oddR;
        out[outOff + 3] = evenI - oddI;
    }

    /**
     * Performs radix-4 transformation on input data of length 8
     *
     * @param {Float32Array} data Input data array of length 8
     * @param {Float32Array} out Output data array of length 8
     * @param {number} outOff Index of output array to start writing from
     * @param {number} off Index of input array to start reading from
     * @param {number} step Step size between elements in input array
     * @param {number} inv Scaling factor for inverse transform
     * 
     * @returns {void}
     */
    _singleTransform4(data, out, outOff, off, step, inv) {
        // radix-4
        // NOTE: Only called for len=8
        const step2 = step * 2;
        const step3 = step * 3;

        // Original values
        const Ar = data[off];
        const Ai = data[off + 1];
        const Br = data[off + step];
        const Bi = data[off + step + 1];
        const Cr = data[off + step2];
        const Ci = data[off + step2 + 1];
        const Dr = data[off + step3];
        const Di = data[off + step3 + 1];

        // Pre-Final values
        const T0r = Ar + Cr;
        const T0i = Ai + Ci;
        const T1r = Ar - Cr;
        const T1i = Ai - Ci;
        const T2r = Br + Dr;
        const T2i = Bi + Di;
        const T3r = inv * (Br - Dr);
        const T3i = inv * (Bi - Di);

        // Final values
        out[outOff] = T0r + T2r;
        out[outOff + 1] = T0i + T2i;
        out[outOff + 2] = T1r + T3i;
        out[outOff + 3] = T1i - T3r;
        out[outOff + 4] = T0r - T2r;
        out[outOff + 5] = T0i - T2i;
        out[outOff + 6] = T1r - T3i;
        out[outOff + 7] = T1i + T3r;
    }

    /**
     * Real input radix-4 implementation
     * @param {Float32Array} out Output array for the transformed data
     * @param {Float32Array} data Input array of real data to be transformed
     * @param {number} inv The scale factor used to normalize the inverse transform
     */
    _realTransform4(out, data, inv) {
        // Real input radix-4 implementation
        const size = this._csize;

        // Initial step (permute and transform)
        const width = this._width;
        let step = 1 << width;
        let len = (size / step) << 1;

        var outOff;
        var t;
        var bitrev = this._bitrev;
        if (len === 4) {
            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {
                const off = bitrev[t];
                this._singleRealTransform2(data, out, outOff, off >>> 1, step >>> 1);
            }
        } else {
            // len === 8
            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {
                const off = bitrev[t];
                this._singleRealTransform4(data, out, outOff, off >>> 1, step >>> 1, inv);
            }
        }

        // Loop through steps in decreasing order
        for (step >>= 2; step >= 2; step >>= 2) {
            len = (size / step) << 1;
            const halfLen = len >>> 1;
            const quarterLen = halfLen >>> 1;
            const hquarterLen = quarterLen >>> 1;

            // Loop through offsets in the data
            for (outOff = 0; outOff < size; outOff += len) {
                for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {
                    const A = outOff + i;
                    const B = A + quarterLen;
                    const C = B + quarterLen;
                    const D = C + quarterLen;

                    // Original values
                    const Ar = out[A];
                    const Ai = out[A + 1];
                    const Br = out[B];
                    const Bi = out[B + 1];
                    const Cr = out[C];
                    const Ci = out[C + 1];
                    const Dr = out[D];
                    const Di = out[D + 1];

                    const tableBr = this.table[k];
                    const tableBi = inv * this.table[k + 1];
                    const MBr = Br * tableBr - Bi * tableBi;
                    const MBi = Br * tableBi + Bi * tableBr;

                    const tableCr = this.table[2 * k];
                    const tableCi = inv * this.table[2 * k + 1];
                    const MCr = Cr * tableCr - Ci * tableCi;
                    const MCi = Cr * tableCi + Ci * tableCr;

                    const tableDr = this.table[3 * k];
                    const tableDi = inv * this.table[3 * k + 1];
                    const MDr = Dr * tableDr - Di * tableDi;
                    const MDi = Dr * tableDi + Di * tableDr;

                    // Pre-Final values
                    const T0r = Ar + MCr;
                    const T0i = Ai + MCi;
                    const T1r = Ar - MCr;
                    const T1i = Ai - MCi;
                    const T2r = MBr + MDr;
                    const T2i = MBi + MDi;
                    const T3r = inv * (MBr - MDr);
                    const T3i = inv * (MBi - MDi);

                    // Final values
                    out[A] = T0r + T2r;
                    out[A + 1] = T0i + T2i;
                    out[B] = T1r + T3i;
                    out[B + 1] = T1i - T3r;

                    // Output final middle point
                    if (i === 0) {
                        out[C] = T0r - T2r;
                        out[C + 1] = T0i - T2i;
                        continue;
                    }

                    // Do not overwrite ourselves
                    if (i === hquarterLen)
                        continue;

                    const SA = outOff + quarterLen - i;
                    const SB = outOff + halfLen - i;

                    out[SA] = T1r + -inv * T3i;
                    out[SA + 1] = -T1i - inv * T3r;
                    out[SB] = T0r + -inv * T2r;
                    out[SB + 1] = -T0i + inv * T2i;
                }
            }
        }
    }

    /**
     * Performs a single real input radix-2 transformation on the provided data
     * 
     * @param {Float32Array} data The input data array
     * @param {Float32Array} out The output data array
     * @param {number} outOff The output offset
     * @param {number} off The input offset
     * @param {number} step The step
     * 
     * @returns {void}
     */
    _singleRealTransform2(data, out, outOff, off, step) {
        // radix-2 implementation
        // NOTE: Only called for len=4

        const evenR = data[off];
        const oddR = data[off + step];

        out[outOff] = evenR + oddR;
        out[outOff + 1] = 0;
        out[outOff + 2] = evenR - oddR;
        out[outOff + 3] = 0;
    }

    /**
     * Computes a single real-valued transform using radix-4 algorithm.
     * This method is only called for len=8.
     *
     * @param {Float32Array} data The input data array.
     * @param {Float32Array} out The output data array.
     * @param {number} outOff The offset into the output array.
     * @param {number} off The offset into the input array.
     * @param {number} step The step size for the input array.
     * @param {number} inv The value of inverse.
     */
    _singleRealTransform4(data, out, outOff, off, step, inv) {
        // radix-4
        // NOTE: Only called for len=8
        const step2 = step * 2;
        const step3 = step * 3;

        // Original values
        const Ar = data[off];
        const Br = data[off + step];
        const Cr = data[off + step2];
        const Dr = data[off + step3];

        // Pre-Final values
        const T0r = Ar + Cr;
        const T1r = Ar - Cr;
        const T2r = Br + Dr;
        const T3r = inv * (Br - Dr);

        // Final values
        out[outOff] = T0r + T2r;
        out[outOff + 1] = 0;
        out[outOff + 2] = T1r;
        out[outOff + 3] = -T3r;
        out[outOff + 4] = T0r - T2r;
        out[outOff + 5] = 0;
        out[outOff + 6] = T1r;
        out[outOff + 7] = T3r;
    }
}

/**
 * Performs median filter on the provided data. Padding is done by mirroring the data.
 * @param {AnyTypedArray} data The input array
 * @param {number} windowSize The window size
 */
function medianFilter(data, windowSize) {

    if (windowSize % 2 === 0 || windowSize <= 0) {
        throw new Error('Window size must be a positive odd number');
    }

    // @ts-ignore
    const outputArray = new data.constructor(data.length);

    // @ts-ignore
    const buffer = new data.constructor(windowSize); // Reusable array for storing values

    const halfWindowSize = Math.floor(windowSize / 2);

    for (let i = 0; i < data.length; ++i) {
        let valuesIndex = 0;

        for (let j = -halfWindowSize; j <= halfWindowSize; ++j) {
            let index = i + j;
            if (index < 0) {
                index = Math.abs(index);
            } else if (index >= data.length) {
                index = 2 * (data.length - 1) - index;
            }

            buffer[valuesIndex++] = data[index];
        }

        buffer.sort();
        outputArray[i] = buffer[halfWindowSize];
    }

    return outputArray;
}

/**
 * Helper function to round a number to a given number of decimals
 * @param {number} num The number to round
 * @param {number} decimals The number of decimals
 * @returns {number} The rounded number
 */
function round(num, decimals) {
    const pow = Math.pow(10, decimals);
    return Math.round(num * pow) / pow;
}


/***/ }),

/***/ "./node_modules/@xenova/transformers/src/utils/tensor.js":
/*!***************************************************************!*\
  !*** ./node_modules/@xenova/transformers/src/utils/tensor.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Tensor: () => (/* binding */ Tensor),
/* harmony export */   cat: () => (/* binding */ cat),
/* harmony export */   dynamicTimeWarping: () => (/* binding */ dynamicTimeWarping),
/* harmony export */   interpolate: () => (/* binding */ interpolate),
/* harmony export */   mean: () => (/* binding */ mean),
/* harmony export */   mean_pooling: () => (/* binding */ mean_pooling),
/* harmony export */   stack: () => (/* binding */ stack),
/* harmony export */   std_mean: () => (/* binding */ std_mean),
/* harmony export */   transpose: () => (/* binding */ transpose)
/* harmony export */ });
/* harmony import */ var _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../backends/onnx.js */ "./node_modules/@xenova/transformers/src/backends/onnx.js");
/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ "./node_modules/@xenova/transformers/src/utils/maths.js");
/**
 * @file Helper module for `Tensor` processing.
 * 
 * These functions and classes are only used internally, 
 * meaning an end-user shouldn't need to access anything here.
 * 
 * @module utils/tensor
 */






/**
 * @typedef {import('./maths.js').AnyTypedArray} AnyTypedArray
 */

/** @type {Object} */
const ONNXTensor = _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__.ONNX.Tensor;

class Tensor extends ONNXTensor {
    /**
     * Create a new Tensor or copy an existing Tensor.
     * @param {[string, Array|AnyTypedArray, number[]]|[ONNXTensor]} args
     */
    constructor(...args) {
        if (args[0] instanceof _backends_onnx_js__WEBPACK_IMPORTED_MODULE_0__.ONNX.Tensor) {
            // Create shallow copy
            super(args[0].type, args[0].data, args[0].dims);

        } else {
            // Create new
            super(...args);
        }

        return new Proxy(this, {
            get: (obj, key) => {
                if (typeof key === 'string') {
                    let index = Number(key);
                    if (Number.isInteger(index)) {
                        // key is an integer (i.e., index)
                        return obj._getitem(index);
                    }
                }
                // @ts-ignore
                return obj[key];
            },
            set: (obj, key, value) => {
                // TODO allow setting of data

                // @ts-ignore
                return obj[key] = value;
            }
        });
    }

    /**
     * Returns an iterator object for iterating over the tensor data in row-major order.
     * If the tensor has more than one dimension, the iterator will yield subarrays.
     * @returns {Iterator} An iterator object for iterating over the tensor data in row-major order.
     */
    *[Symbol.iterator]() {
        const [iterLength, ...iterDims] = this.dims;

        if (iterDims.length > 0) {
            const iterSize = iterDims.reduce((a, b) => a * b);
            for (let i = 0; i < iterLength; ++i) {
                yield this._subarray(i, iterSize, iterDims);
            }
        } else {
            yield* this.data
        }

    }

    /**
     * Index into a Tensor object.
     * @param {number} index The index to access.
     * @returns {Tensor} The data at the specified index.
     */
    _getitem(index) {
        const [iterLength, ...iterDims] = this.dims;

        index = safeIndex(index, iterLength);

        if (iterDims.length > 0) {
            const iterSize = iterDims.reduce((a, b) => a * b);
            return this._subarray(index, iterSize, iterDims);
        } else {
            return new Tensor(this.type, [this.data[index]], iterDims);
        }
    }

    /**
     * @param {number|bigint} item The item to search for in the tensor
     * @returns {number} The index of the first occurrence of item in the tensor data.
     */
    indexOf(item) {
        for (let index = 0; index < this.data.length; ++index) {
            // Note: == instead of === so we can match Ints with BigInts
            if (this.data[index] == item) {
                return index;
            }
        }
        return -1;
    }

    /**
     * @param {number} index 
     * @param {number} iterSize 
     * @param {any} iterDims 
     * @returns {Tensor}
     */
    _subarray(index, iterSize, iterDims) {
        let data = this.data.subarray(index * iterSize, (index + 1) * iterSize);
        return new Tensor(this.type, data, iterDims);
    }

    /**
     * Returns the value of this tensor as a standard JavaScript Number. This only works
     * for tensors with one element. For other cases, see `Tensor.tolist()`.
     * @returns {number} The value of this tensor as a standard JavaScript Number.
     * @throws {Error} If the tensor has more than one element.
     */
    item() {
        if (this.data.length !== 1) {
            throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);
        }
        return this.data[0];
    }

    /**
     * Convert tensor data to a n-dimensional JS list
     * @returns {Array}
     */
    tolist() {
        return reshape(this.data, this.dims)
    }

    /**
     * Return a new Tensor with the sigmoid function applied to each element.
     * @returns {Tensor} The tensor with the sigmoid function applied.
     */
    sigmoid() {
        return this.clone().sigmoid_();
    }

    /**
     * Applies the sigmoid function to the tensor in place.
     * @returns {Tensor} Returns `this`.
     */
    sigmoid_() {
        for (let i = 0; i < this.data.length; ++i) {
            this.data[i] = 1 / (1 + Math.exp(-this.data[i]));
        }
        return this;
    }

    clone() {
        return new Tensor(this.type, this.data.slice(), this.dims.slice());
    }

    slice(...slices) {
        // This allows for slicing with ranges and numbers
        let newTensorDims = [];
        let newOffsets = [];

        // slices is an array of numbers or arrays of numbers
        // e.g., slices = [0, [1, 3], null, [0, 3]]
        for (let sliceIndex = 0; sliceIndex < this.dims.length; ++sliceIndex) {
            let slice = slices[sliceIndex];

            if (slice === null || slice === undefined) {
                // null or undefined means take the whole dimension
                newOffsets.push([0, this.dims[sliceIndex]]);
                newTensorDims.push(this.dims[sliceIndex]);

            } else if (typeof slice === 'number') {
                slice = safeIndex(slice, this.dims[sliceIndex], sliceIndex);

                // A number means take a single element
                newOffsets.push([slice, slice + 1]);

            } else if (Array.isArray(slice) && slice.length === 2) {
                // An array of length 2 means take a range of elements

                if (slice[0] > slice[1]) {
                    throw new Error(`Invalid slice: ${slice}`);
                }

                let offsets = [
                    Math.max(slice[0], 0),
                    Math.min(slice[1], this.dims[sliceIndex])
                ];

                newOffsets.push(offsets);
                newTensorDims.push(offsets[1] - offsets[0]);

            } else {
                throw new Error(`Invalid slice: ${slice}`);
            }
        }

        let newDims = newOffsets.map(([start, end]) => end - start);
        let newBufferSize = newDims.reduce((a, b) => a * b);

        // Allocate memory
        let data = new this.data.constructor(newBufferSize);

        // Precompute strides
        const stride = this.stride();

        for (let i = 0; i < newBufferSize; ++i) {
            let originalIndex = 0;
            for (let j = newDims.length - 1, num = i; j >= 0; --j) {
                const size = newDims[j];
                originalIndex += ((num % size) + newOffsets[j][0]) * stride[j];
                num = Math.floor(num / size);
            }
            data[i] = this.data[originalIndex];
        }
        return new Tensor(this.type, data, newTensorDims);

    }

    /**
     * Return a transposed version of this Tensor, according to the provided dimensions.
     * @param  {...number} dims Dimensions to transpose.
     * @returns {Tensor} The transposed tensor.
     */
    transpose(...dims) {
        return transpose(this, dims);
    }

    // TODO: rename transpose to permute
    // TODO: implement transpose

    // TODO add .max() and .min() methods

    /**
     * Returns the sum of each row of the input tensor in the given dimension dim.
     * 
     * @param {number} [dim=null] The dimension or dimensions to reduce. If `null`, all dimensions are reduced.
     * @param {boolean} keepdim Whether the output tensor has `dim` retained or not.
     * @returns The summed tensor
     */
    sum(dim = null, keepdim = false) {
        return this.norm(1, dim, keepdim);
    }

    /**
     * Returns the matrix norm or vector norm of a given tensor.
     * @param {number|string} [p='fro'] The order of norm
     * @param {number} [dim=null] Specifies which dimension of the tensor to calculate the norm across.
     * If dim is None, the norm will be calculated across all dimensions of input.
     * @param {boolean} [keepdim=false] Whether the output tensors have dim retained or not.
     * @returns {Tensor} The norm of the tensor.
     */
    norm(p = 'fro', dim = null, keepdim = false) {
        if (p === 'fro') {
            // NOTE: Since we only support integer dims, Frobenius norm produces the same result as p=2.
            p = 2;
        } else if (typeof p === 'string') {
            throw Error(`Unsupported norm: ${p}`);
        }

        if (dim === null) {
            // @ts-ignore
            let val = this.data.reduce((a, b) => a + (b ** p), 0) ** (1 / p);
            return new Tensor(this.type, [val], []);
        }

        // Negative indexing
        dim = safeIndex(dim, this.dims.length);

        // Calculate the shape of the resulting array after summation
        const resultDims = this.dims.slice(); // Copy the original dimensions
        resultDims[dim] = 1; // Remove the specified axis

        // Create a new array to store the accumulated values
        const result = new this.data.constructor(this.data.length / this.dims[dim]);

        // Iterate over the data array
        for (let i = 0; i < this.data.length; ++i) {

            // Calculate the index in the resulting array
            let resultIndex = 0;

            for (let j = this.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
                const size = this.dims[j];
                if (j !== dim) {
                    const index = num % size;
                    resultIndex += index * resultMultiplier;
                    resultMultiplier *= resultDims[j];
                }
                num = Math.floor(num / size);
            }

            // Accumulate the value at the current index
            result[resultIndex] += (this.data[i]) ** p;
        }

        if (p !== 1) {
            for (let i = 0; i < result.length; ++i) {
                result[i] = result[i] ** (1 / p);
            }
        }

        if (!keepdim) {
            resultDims.splice(dim, 1);
        }

        return new Tensor(this.type, result, resultDims);
    }

    /**
     * Performs `L_p` normalization of inputs over specified dimension. Operates in place.
     * @param {number} [p=2] The exponent value in the norm formulation
     * @param {number} [dim=1] The dimension to reduce
     * @returns {Tensor} `this` for operation chaining.
     */
    normalize_(p = 2.0, dim = 1) {
        dim = safeIndex(dim, this.dims.length);

        const norm = this.norm(p, dim, true);

        for (let i = 0; i < this.data.length; ++i) {

            // Calculate the index in the resulting array
            let resultIndex = 0;

            for (let j = this.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
                const size = this.dims[j];
                if (j !== dim) {
                    const index = num % size;
                    resultIndex += index * resultMultiplier;
                    resultMultiplier *= this.dims[j];
                }
                num = Math.floor(num / size);
            }

            // Divide by normalized value
            this.data[i] /= norm.data[resultIndex];
        }

        return this;
    }

    /**
     * Performs `L_p` normalization of inputs over specified dimension.
     * @param {number} [p=2] The exponent value in the norm formulation
     * @param {number} [dim=1] The dimension to reduce
     * @returns {Tensor} The normalized tensor.
     */
    normalize(p = 2.0, dim = 1) {
        return this.clone().normalize_(p, dim);
    }

    /**
     * Compute and return the stride of this tensor.
     * Stride is the jump necessary to go from one element to the next one in the specified dimension dim.
     * @returns {number[]} The stride of this tensor.
     */
    stride() {
        return dimsToStride(this.dims);
    }

    /**
     * Returns a tensor with all specified dimensions of input of size 1 removed.
     * 
     * NOTE: The returned tensor shares the storage with the input tensor, so changing the contents of one will change the contents of the other.
     * If you would like a copy, use `tensor.clone()` before squeezing.
     * 
     * @param {number} [dim=null] If given, the input will be squeezed only in the specified dimensions.
     * @returns The squeezed tensor
     */
    squeeze(dim = null) {
        return new Tensor(
            this.type,
            this.data,
            calc_squeeze_dims(this.dims, dim)
        )
    }

    /**
     * In-place version of @see {@link Tensor.squeeze}
     */
    squeeze_(dim = null) {
        this.dims = calc_squeeze_dims(this.dims, dim);
        return this;
    }

    /**
     * Returns a new tensor with a dimension of size one inserted at the specified position.
     * 
     * NOTE: The returned tensor shares the same underlying data with this tensor.
     * 
     * @param {number} dim The index at which to insert the singleton dimension
     * @returns The unsqueezed tensor
     */
    unsqueeze(dim = null) {
        return new Tensor(
            this.type,
            this.data,
            calc_unsqueeze_dims(this.dims, dim)
        );
    }

    /**
     * In-place version of @see {@link Tensor.unsqueeze}
     */
    unsqueeze_(dim = null) {
        this.dims = calc_unsqueeze_dims(this.dims, dim);
        return this;
    }

    /**
     * In-place version of @see {@link Tensor.flatten}
     */
    flatten_(start_dim = 0, end_dim = -1) {
        // TODO validate inputs
        end_dim = (end_dim + this.dims.length) % this.dims.length;

        let dimsToKeepBefore = this.dims.slice(0, start_dim);
        let dimsToFlatten = this.dims.slice(start_dim, end_dim + 1);
        let dimsToKeepAfter = this.dims.slice(end_dim + 1);

        this.dims = [...dimsToKeepBefore, dimsToFlatten.reduce((a, b) => a * b, 1), ...dimsToKeepAfter]
        return this;
    }

    /**
     * Flattens input by reshaping it into a one-dimensional tensor.
     * If `start_dim` or `end_dim` are passed, only dimensions starting with `start_dim`
     * and ending with `end_dim` are flattened. The order of elements in input is unchanged.
     * @param {number} start_dim the first dim to flatten
     * @param {number} end_dim the last dim to flatten
     * @returns The flattened tensor.
     */
    flatten(start_dim = 0, end_dim = -1) {
        return this.clone().flatten_(start_dim, end_dim);
    }

    /**
     * Returns a new tensor with the same data as the `self` tensor but of a different `shape`.
     * @param  {...number} dims the desired size
     * @returns {Tensor} The tensor with the same data but different shape
     */
    view(...dims) {
        // TODO: validate dims
        let inferredIndex = -1;
        for (let i = 0; i < dims.length; ++i) {
            if (dims[i] === -1) {
                if (inferredIndex !== -1) {
                    throw new Error("Only one dimension can be inferred");
                }
                inferredIndex = i;
            }
        }

        if (inferredIndex !== -1) {
            // Some dimension must be inferred
            const productOther = dims.reduce((product, curr, index) => {
                return index !== inferredIndex ? product * curr : product
            }, 1);

            dims[inferredIndex] = this.data.length / productOther;
        }
        return new Tensor(this.type, this.data, dims); // NOTE: uses same underlying storage
    }

    neg_() {
        for (let i = 0; i < this.data.length; ++i) {
            this.data[i] = -this.data[i];
        }
        return this;
    }
    neg() {
        return this.clone().neg_();
    }
}

/**
 * This creates a nested array of a given type and depth (see examples).
 * 
 * @example
 *   NestArray<string, 1>; // string[]
 * @example
 *   NestArray<number, 2>; // number[][]
 * @example
 *   NestArray<string, 3>; // string[][][] etc.
 * @template T
 * @template {number} Depth
 * @template {never[]} [Acc=[]]
 * @typedef {Acc['length'] extends Depth ? T : NestArray<T[], Depth, [...Acc, never]>} NestArray
 */

/**
 * Reshapes a 1-dimensional array into an n-dimensional array, according to the provided dimensions.
 *
 * @example
 *   reshape([10                    ], [1      ]); // Type: number[]      Value: [10]
 *   reshape([1, 2, 3, 4            ], [2, 2   ]); // Type: number[][]    Value: [[1, 2], [3, 4]]
 *   reshape([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 2]); // Type: number[][][]  Value: [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
 *   reshape([1, 2, 3, 4, 5, 6, 7, 8], [4, 2   ]); // Type: number[][]    Value: [[1, 2], [3, 4], [5, 6], [7, 8]]
 * @param {T[]} data The input array to reshape.
 * @param {DIM} dimensions The target shape/dimensions.
 * @template T
 * @template {[number]|[number, number]|[number, number, number]|[number, number, number, number]} DIM
 * @returns {NestArray<T, DIM["length"]>} The reshaped array.
 */
function reshape(data, dimensions) {

    const totalElements = data.length;
    const dimensionSize = dimensions.reduce((a, b) => a * b);

    if (totalElements !== dimensionSize) {
        throw Error(`cannot reshape array of size ${totalElements} into shape (${dimensions})`);
    }

    /** @type {any} */
    let reshapedArray = data;

    for (let i = dimensions.length - 1; i >= 0; i--) {
        reshapedArray = reshapedArray.reduce((acc, val) => {
            let lastArray = acc[acc.length - 1];

            if (lastArray.length < dimensions[i]) {
                lastArray.push(val);
            } else {
                acc.push([val]);
            }

            return acc;
        }, [[]]);
    }

    return reshapedArray[0];
}

/**
 * Transposes a tensor according to the provided axes.
 * @param {any} tensor The input tensor to transpose.
 * @param {Array} axes The axes to transpose the tensor along.
 * @returns {Tensor} The transposed tensor.
 */
function transpose(tensor, axes) {
    const [transposedData, shape] = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.transpose_data)(tensor.data, tensor.dims, axes);
    return new Tensor(tensor.type, transposedData, shape);
}


/**
 * Interpolates an Tensor to the given size.
 * @param {Tensor} input The input tensor to interpolate. Data must be channel-first (i.e., [c, h, w])
 * @param {number[]} size The output size of the image
 * @param {string} mode The interpolation mode
 * @param {boolean} align_corners Whether to align corners.
 * @returns {Tensor} The interpolated tensor.
 */
function interpolate(input, [out_height, out_width], mode = 'bilinear', align_corners = false) {

    // Input image dimensions
    const in_channels = input.dims.at(-3) ?? 1;
    const in_height = input.dims.at(-2);
    const in_width = input.dims.at(-1);

    let output = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.interpolate_data)(
        input.data,
        [in_channels, in_height, in_width],
        [out_height, out_width],
        mode,
        align_corners
    );
    return new Tensor(input.type, output, [in_channels, out_height, out_width]);
}

/**
 * Perform mean pooling of the last hidden state followed by a normalization step.
 * @param {Tensor} last_hidden_state Tensor of shape [batchSize, seqLength, embedDim]
 * @param {Tensor} attention_mask Tensor of shape [batchSize, seqLength]
 * @returns {Tensor} Returns a new Tensor of shape [batchSize, embedDim].
 */
function mean_pooling(last_hidden_state, attention_mask) {
    // last_hidden_state: [batchSize, seqLength, embedDim]
    // attention_mask:    [batchSize, seqLength]

    let shape = [last_hidden_state.dims[0], last_hidden_state.dims[2]];
    let returnedData = new last_hidden_state.data.constructor(shape[0] * shape[1]);
    let [batchSize, seqLength, embedDim] = last_hidden_state.dims;

    let outIndex = 0;
    for (let i = 0; i < batchSize; ++i) {
        let offset = i * embedDim * seqLength;

        for (let k = 0; k < embedDim; ++k) {
            let sum = 0;
            let count = 0;

            let attnMaskOffset = i * seqLength;
            let offset2 = offset + k;
            // Pool over all words in sequence
            for (let j = 0; j < seqLength; ++j) {
                // index into attention mask
                let attn = Number(attention_mask.data[attnMaskOffset + j]);

                count += attn;
                sum += last_hidden_state.data[offset2 + j * embedDim] * attn;
            }

            let avg = sum / count;
            returnedData[outIndex++] = avg;
        }
    }

    return new Tensor(
        last_hidden_state.type,
        returnedData,
        shape
    )
}

/**
 * Helper function to calculate new dimensions when performing a squeeze operation.
 * @param {number[]} dims The dimensions of the tensor.
 * @param {number|number[]|null} dim The dimension(s) to squeeze.
 * @returns The new dimensions.
 * @private
 */
function calc_squeeze_dims(dims, dim) {
    dims = dims.slice();
    if (dim === null) {
        dims = dims.filter((d) => d !== 1);
    } else if (typeof dim === 'number') {
        if (dims[dim] === 1) {
            dims.splice(dim, 1);
        }
    } else if (Array.isArray(dim)) {
        dims = dims.filter((x, i) => {
            return x !== 1 || !dim.includes(i);
        });
    }
    return dims;
}

/**
 * Helper function to calculate new dimensions when performing an unsqueeze operation.
 * @param {number[]} dims The dimensions of the tensor.
 * @param {number} dim The dimension to unsqueeze.
 * @returns The new dimensions.
 * @private
 */
function calc_unsqueeze_dims(dims, dim) {
    // Dimension out of range (e.g., "expected to be in range of [-4, 3], but got 4")
    // + 1 since we allow inserting at the end (i.e. dim = -1)
    dim = safeIndex(dim, dims.length + 1);
    dims = dims.slice();
    // Insert 1 into specified dimension
    dims.splice(dim, 0, 1);
    return dims;
}

/**
 * Safely calculate the index for an array of a given size, allowing negative indexing.
 * @param {number} index The index that will be used.
 * @param {number} size The size of the array.
 * @param {number} [dimension=null] The dimension that the index is for (optional).
 * @returns {number} The index, guaranteed to be non-negative and less than `arrayLength`.
 * 
 * @throws {Error} If the index is out of range.
 * @private
 */
function safeIndex(index, size, dimension = null) {
    if (index < -size || index >= size) {
        throw new Error(`IndexError: index ${index} is out of bounds for dimension${dimension === null ? '' : ' ' + dimension} with size ${size}`);
    }

    if (index < 0) {
        // Negative indexing, ensuring positive index
        index = ((index % size) + size) % size;
    }
    return index;
}

/**
 * Concatenates an array of tensors along a specified dimension.
 * @param {Tensor[]} tensors The array of tensors to concatenate.
 * @param {number} dim The dimension to concatenate along.
 * @returns {Tensor} The concatenated tensor.
 */
function cat(tensors, dim = 0) {
    dim = safeIndex(dim, tensors[0].dims.length);

    // TODO do validation of shapes

    const resultDims = tensors[0].dims.slice();
    resultDims[dim] = tensors.reduce((a, b) => a + b.dims[dim], 0);

    // Create a new array to store the accumulated values
    const resultSize = resultDims.reduce((a, b) => a * b, 1);
    const result = new tensors[0].data.constructor(resultSize);

    // Create output tensor of same type as first
    const resultType = tensors[0].type;

    if (dim === 0) {
        // Handle special case for performance reasons

        let offset = 0;
        for (let t of tensors) {
            result.set(t.data, offset);
            offset += t.data.length;
        }

    } else {

        let currentDim = 0;

        for (let t = 0; t < tensors.length; ++t) {
            let tensor = tensors[t];

            // Iterate over the data array
            for (let i = 0; i < tensor.data.length; ++i) {
                // Calculate the index in the resulting array
                let resultIndex = 0;

                for (let j = tensor.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
                    const size = tensor.dims[j];
                    let index = num % size;
                    if (j === dim) {
                        index += currentDim;
                    }
                    resultIndex += index * resultMultiplier;
                    resultMultiplier *= resultDims[j];
                    num = Math.floor(num / size);
                }
                // Accumulate the value at the current index
                result[resultIndex] = tensor.data[i];
            }

            currentDim += tensor.dims[dim];
        }
    }
    return new Tensor(resultType, result, resultDims);
}

/**
 * Stack an array of tensors along a specified dimension.
 * @param {Tensor[]} tensors The array of tensors to stack.
 * @param {number} dim The dimension to stack along.
 * @returns {Tensor} The stacked tensor.
 */
function stack(tensors, dim = 0) {
    // TODO do validation of shapes
    // NOTE: stack expects each tensor to be equal size
    return cat(tensors.map(t => t.unsqueeze(dim)), dim);
}


/**
 * Calculates the standard deviation and mean over the dimensions specified by dim. dim can be a single dimension or `null` to reduce over all dimensions.
 * @param {Tensor} input the input tenso
 * @param {number|null} dim the dimension to reduce. If None, all dimensions are reduced.
 * @param {number} correction difference between the sample size and sample degrees of freedom. Defaults to Bessel's correction, correction=1.
 * @param {boolean} keepdim whether the output tensor has dim retained or not.
 * @returns {Tensor[]} A tuple of (std, mean) tensors.
 */
function std_mean(input, dim = null, correction = 1, keepdim = false) {

    if (dim === null) {
        // None to reduce over all dimensions.
        const sum = input.data.reduce((a, b) => a + b, 0);
        const mean = sum / input.data.length;
        const std = Math.sqrt(input.data.reduce((a, b) => a + (b - mean) ** 2, 0) / (input.data.length - correction));

        const meanTensor = new Tensor(input.type, [mean], [/* scalar */]);
        const stdTensor = new Tensor(input.type, [std], [/* scalar */]);

        return [stdTensor, meanTensor];
    }

    // Negative indexing
    dim = safeIndex(dim, input.dims.length);

    const meanTensor = mean(input, dim, keepdim);

    // Calculate the shape of the resulting array after summation
    const resultDims = input.dims.slice(); // Copy the original dimensions
    resultDims[dim] = 1; // Remove the specified axis

    // Create a new array to store the accumulated values
    const result = new input.data.constructor(input.data.length / input.dims[dim]);

    // Iterate over the data array
    for (let i = 0; i < input.data.length; ++i) {

        // Calculate the index in the resulting array
        let resultIndex = 0;

        for (let j = input.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
            const size = input.dims[j];
            if (j !== dim) {
                const index = num % size;
                resultIndex += index * resultMultiplier;
                resultMultiplier *= resultDims[j];
            }
            num = Math.floor(num / size);
        }

        // Accumulate the value at the current index
        result[resultIndex] += (input.data[i] - meanTensor.data[resultIndex]) ** 2;
    }

    for (let i = 0; i < result.length; ++i) {
        result[i] = Math.sqrt(result[i] / (input.dims[dim] - correction));
    }

    if (!keepdim) {
        resultDims.splice(dim, 1);
    }

    const stdTensor = new Tensor(input.type, result, resultDims);

    return [stdTensor, meanTensor];
}


/**
 * Returns the mean value of each row of the input tensor in the given dimension dim.
 * @param {Tensor} input the input tensor.
 * @param {number|null} dim the dimension to reduce.
 * @param {boolean} keepdim whether the output tensor has dim retained or not.
 * @returns A new tensor with means taken along the specified dimension.
 */
function mean(input, dim = null, keepdim = false) {

    if (dim === null) {
        // None to reduce over all dimensions.
        let val = input.data.reduce((a, b) => a + b, 0);
        return new Tensor(input.type, [val / input.data.length], [/* scalar */]);
    }

    // Negative indexing
    dim = safeIndex(dim, input.dims.length);

    // Calculate the shape of the resulting array after summation
    const resultDims = input.dims.slice(); // Copy the original dimensions
    resultDims[dim] = 1; // Remove the specified axis

    // Create a new array to store the accumulated values
    const result = new input.data.constructor(input.data.length / input.dims[dim]);

    // Iterate over the data array
    for (let i = 0; i < input.data.length; ++i) {

        // Calculate the index in the resulting array
        let resultIndex = 0;

        for (let j = input.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
            const size = input.dims[j];
            if (j !== dim) {
                const index = num % size;
                resultIndex += index * resultMultiplier;
                resultMultiplier *= resultDims[j];
            }
            num = Math.floor(num / size);
        }

        // Accumulate the value at the current index
        result[resultIndex] += input.data[i];
    }

    if (input.dims[dim] !== 1) {
        for (let i = 0; i < result.length; ++i) {
            result[i] = result[i] / input.dims[dim];
        }
    }

    if (!keepdim) {
        resultDims.splice(dim, 1);
    }

    return new Tensor(input.type, result, resultDims);
}


/**
 *
 * Measures similarity between two temporal sequences (e.g., input audio and output tokens
 * to generate token-level timestamps).
 * @param {Tensor} matrix 
 * @returns {number[][]}
 */
function dynamicTimeWarping(matrix) {
    const [output_length, input_length] = matrix.dims;

    const outputShape = [output_length + 1, input_length + 1];

    const cost = new Tensor(
        'float32',
        new Float32Array(outputShape[0] * outputShape[1]).fill(Infinity),
        outputShape
    );

    const trace = new Tensor(
        'float32',
        new Float32Array(outputShape[0] * outputShape[1]).fill(-1),
        outputShape
    )

    // same as `cost[0][0] = 0`;
    cost[0].data[0] = 0;

    for (let j = 1; j < input_length + 1; ++j) {
        for (let i = 1; i < output_length + 1; ++i) {

            const c0 = cost[i - 1][j - 1].item();
            const c1 = cost[i - 1][j].item();
            const c2 = cost[i][j - 1].item();

            let c, t;
            if (c0 < c1 && c0 < c2) {
                c = c0;
                t = 0;
            } else if (c1 < c0 && c1 < c2) {
                c = c1;
                t = 1;
            } else {
                c = c2;
                t = 2;
            }

            cost[i].data[j] = matrix[i - 1][j - 1].item() + c;
            trace[i].data[j] = t;
        }
    }

    // backtrace
    let i = output_length;
    let j = input_length;

    trace.data.fill(2, 0, outputShape[1]) // trace[0, :] = 2
    for (let i = 0; i < outputShape[0]; ++i) { // trace[:, 0] = 1
        trace[i].data[0] = 1;
    }

    let text_indices = [];
    let time_indices = [];

    while (i > 0 || j > 0) {
        text_indices.push(i - 1);
        time_indices.push(j - 1);

        const t = trace[i][j].item();
        switch (t) {
            case 0:
                --i; --j;
                break;
            case 1:
                --i;
                break;
            case 2:
                --j;
                break;
            default:
                throw new Error(
                    `Internal error in dynamic time warping. Unexpected trace[${i}, ${j}]. Please file a bug report.`
                )
        }
    }

    text_indices.reverse();
    time_indices.reverse();

    return [text_indices, time_indices];

}

function dimsToStride(dims) {
    const stride = new Array(dims.length);
    for (let i = dims.length - 1, s2 = 1; i >= 0; --i) {
        stride[i] = s2;
        s2 *= dims[i];
    }
    return stride;
}


/***/ }),

/***/ "./src/serviceworkers/background.js":
/*!******************************************!*\
  !*** ./src/serviceworkers/background.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils.js */ "./src/utils/utils.js");
/* harmony import */ var _semantic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./semantic.js */ "./src/serviceworkers/semantic.js");
// background.js - Handles requests from the UI, runs the model, then sends back a response




////////////////////// 1. Context Menus //////////////////////
//
// Add a listener to create the initial context menu items,
// context menu items only need to be created at runtime.onInstalled
// chrome.runtime.onInstalled.addListener(function () {
// Register a context menu item that will only show up for selection text.
// chrome.contextMenus.create({
//     id: 'classify-selection',
//     title: 'Classify "%s"',
//     contexts: ['selection'],
// });
// });
//
// Perform inference when the user clicks a context menu
// chrome.contextMenus.onClicked.addListener(async (info, tab) => {
// Ignore context menu clicks that are not for classifications (or when there is no input)
// if (info.menuItemId !== 'classify-selection' || !info.selectionText) return;
//
// Perform classification on the selected text
// let result = await classify(info.selectionText);
//
// Do something with the result
// chrome.scripting.executeScript(
//
//     {
//     target: { tabId: tab.id },    // Run in the tab that the user clicked in
//     args: [result],               // The arguments to pass to the function
//     function: (result) => {       // The function to run
//         // NOTE: This function is run in the context of the web page, meaning that `document` is available.
//         console.log('result', result)
//         console.log('document', document)
//     },
// }
// );
// });
//////////////////////////////////////////////////////////////

////////////////////// 2. Message Events /////////////////////
//
// Listen for messages from the UI, process it, and send the result back.

// TODO: body text is not persistent
let bodyText = [];
let inputText = "";

let liveProcess = 0;
let currSite = "";

chrome.runtime.onMessage.addListener(async function (request, sender, sendResponse) {
    if (request.type === "tabUpdated") {
        if (request.text.length > 0) {
            bodyText = request.text;
            currSite = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.getSiteID)(request.currentURL);
        }
    } else if (request.type === "inputText") {
        inputText = request.text;
    } else {return; }
    if (!bodyText || !inputText) {
        return;
    }

    liveProcess++;
    const processId = liveProcess;

    await processQuery(inputText, bodyText, processId);
});


async function processQuery(query, bodyText, processId) {
    if (bodyText.length === 0) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.prettyLog)("Error", "no content found. please reload this page if this is unexpected", "red");
        chrome.runtime.sendMessage({type: "error", reason: "No content detected. Reloading may help."});
        return;  // Exit early if no bodyText
    }

    await (0,_semantic_js__WEBPACK_IMPORTED_MODULE_1__.loadEmbeddings)(currSite);
    (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.prettyLog)("starting process " + processId, bodyText.length + " items", "orange");

    let results = [];
    const k = 10;

    let i = 0;
    for (let text of bodyText) {
        if (processId !== liveProcess) { return;}
        let sim = await (0,_semantic_js__WEBPACK_IMPORTED_MODULE_1__.similarity)(query, text);

        if (sim > 0.15) {
            results.push({sim: sim, text: text});
            results.sort((a, b) => b.sim - a.sim);
            results.length = Math.min(results.length, k);

            if (processId !== liveProcess) { return;}
            chrome.runtime.sendMessage({
                type: "results", progress: 100 * (i / bodyText.length),
                text: results
            });
        }
        i += 1;
    }
    chrome.runtime.sendMessage({type: "results", progress: 100});
    await (0,_semantic_js__WEBPACK_IMPORTED_MODULE_1__.storeEmbeddings)();
}

//////////////////////////////////////////////////////////////



/***/ }),

/***/ "./src/serviceworkers/semantic.js":
/*!****************************************!*\
  !*** ./src/serviceworkers/semantic.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadEmbeddings: () => (/* binding */ loadEmbeddings),
/* harmony export */   similarity: () => (/* binding */ similarity),
/* harmony export */   storeEmbeddings: () => (/* binding */ storeEmbeddings)
/* harmony export */ });
/* harmony import */ var _utils_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cache.js */ "./src/utils/cache.js");
/* harmony import */ var _xenova_transformers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @xenova/transformers */ "./node_modules/@xenova/transformers/src/transformers.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils.js */ "./src/utils/utils.js");
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
// Define caching parameters




_xenova_transformers__WEBPACK_IMPORTED_MODULE_1__.env.useBrowserCache = false;
_xenova_transformers__WEBPACK_IMPORTED_MODULE_1__.env.useCustomCache = true;
_xenova_transformers__WEBPACK_IMPORTED_MODULE_1__.env.customCache = new _utils_cache_js__WEBPACK_IMPORTED_MODULE_0__.CustomCache('transformers-cache');
_xenova_transformers__WEBPACK_IMPORTED_MODULE_1__.env.allowLocalModels = false;


// Due to a bug in onnxruntime-web, we must disable multithreading for now.
// See https://github.com/microsoft/onnxruntime/issues/14445 for more information.
_xenova_transformers__WEBPACK_IMPORTED_MODULE_1__.env.backends.onnx.wasm.numThreads = 1;

// these should go in EmbedPipeline prob
let embeddingsDict = {};
let currID = "";

class EmbedPipeline {
    static task = 'feature-extraction';
    static model = 'Xenova/distiluse-base-multilingual-cased-v2';
    static instance = null;

    static async getInstance() {
        if (this.instance === null) { // no await?
            this.instance = await (0,_xenova_transformers__WEBPACK_IMPORTED_MODULE_1__.pipeline)(this.task, this.model,
                {
                    progress_callback: async data => {
                        await chrome.runtime.sendMessage({type: "download", data: data});
                    }
                }
            );
        }
        await chrome.runtime.sendMessage({type: "download", data: {status: "complete"}})

        return this.instance;
    }
}

// Important: Return true to indicate that the response is asynchronous.
chrome.runtime.onMessage.addListener(async (request, sender, sendResponse) => {
    switch (request.type) {
        case "load":
            await load();
            break;
        case "clearLocalStorage":
            chrome.storage.local.clear(() => {
            });
            break;
        case "pruneEmbeddings":
            await pruneStoredEmbeddings(10);
            break;
    }
});


async function load() {
    await EmbedPipeline.getInstance();
}

async function embed(text, use_dict = true) {
    if (use_dict && text in embeddingsDict) {
        return embeddingsDict[text];
    }

    let embedder = await EmbedPipeline.getInstance();
    let e0 = await embedder(text, {pooling: 'mean', normalize: true});
    if (use_dict) {
        embeddingsDict[text] = e0["data"];
    }
    return e0["data"];
}


// do on clean-up / unmount
async function pruneStoredEmbeddings(k) {
    return new Promise((resolve) => {
        chrome.storage.local.get(null, function (allData) {
            let embeddingKeys = Object.keys(allData).filter(key => allData[key].is_embeddings === true);

            console.log("All embedding keys found:", embeddingKeys);  // This logs all the embedding keys

            // Sort these embedding keys based on frecency scores
            let sortedKeys = embeddingKeys.sort((a, b) => allData[b].frecency_score - allData[a].frecency_score);

            let topKKeys = sortedKeys.slice(0, k);
            let keysToRemove = sortedKeys.filter(key => !topKKeys.includes(key));
            console.log(`Removing the following keys: ${keysToRemove}`);

            // Remove the non-top k embeddings from storage.
            if (keysToRemove.length > 0) {
                chrome.storage.local.remove(keysToRemove, () => {
                    console.log(`Successfully removed ${keysToRemove.length} keys.`);
                    resolve();
                });
            } else {
                resolve();
            }
        });
    });
}



async function storeEmbeddings() {
    const buffer = new TextEncoder().encode(JSON.stringify(embeddingsDict));

    const body = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = e => reject(e.target.error);
        reader.readAsDataURL(new Blob([buffer], {type: 'application/json'}));
    });

    try {
        await chrome.storage.local.set({
            [currID]: {
                _body: body,
                frecency_score: computeFrecencyScore(currID),
                is_embeddings: true,
                model_name: EmbedPipeline.model
            }
        });
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_2__.prettyLog)("stored " + currID, Object.keys(embeddingsDict).length + " items");

    } catch (err) {
        console.warn('An error occurred while writing the embeddings to cache:', err)
    }
}

async function verifyLoad() {
    for (let text in embeddingsDict) {
        let e0 = await embed(text, true);
        let e1 = await embed(text, false);
        let sim = cosineSimilarity(e0, e1);
        if (sim <  0.99) {
            (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_2__.prettyLog)("load differs", sim, "red");
        }
    }
}

async function loadEmbeddings(ID) {
    if (Object.keys(embeddingsDict).length !== 0 && ID === currID) {
        return;
    }
    currID = ID;
    const data = await chrome.storage.local.get([currID]);
    if (data[ID] && data[ID].is_embeddings) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_2__.prettyLog)("attempting load", ID);
        if (!data[ID].model_name || data[ID].model_name !== EmbedPipeline.model) { return; }
        const body = data[ID]._body;

        const jsonString = await new Promise((resolve, reject) => {
            const byteCharacters = atob(body.split(',')[1]);
            const byteNumbers = Array.from(byteCharacters).map(char => char.charCodeAt(0));
            const byteArray = new Uint8Array(byteNumbers);
            const blob = new Blob([byteArray], {type: 'application/json'});
            const reader = new FileReader();
            reader.onload = (event) => resolve(event.target.result);
            reader.onerror = (error) => reject(error);
            reader.readAsText(blob);
        });

        const parsedData = JSON.parse(jsonString);

        // Convert the object-with-integer-keys representation into Float32Array
        for (let textKey in parsedData) {
            if (parsedData.hasOwnProperty(textKey)) {
                let arrayData = Object.values(parsedData[textKey]);
                embeddingsDict[textKey] = new Float32Array(arrayData);
            }
        }

        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_2__.prettyLog)("loaded " + ID, Object.keys(embeddingsDict).length + " items");
        // await verifyLoad();
    }
}


// todo: implement & move to utils
function computeFrecencyScore(ID) {
    return 4; // lol!
}


async function similarity(text1, text2) {
    let e0 = await embed(text1);
    let e1 = await embed(text2);

    return cosineSimilarity(e0, e1);
}

function cosineSimilarity(v1, v2) {
    if (v1.length !== v2.length) {
        return -1;
    }
    let dotProduct = 0;
    let v1_mag = 0;
    let v2_mag = 0;
    for (let i = 0; i < v1.length; i++) {
        dotProduct += v1[i] * v2[i];
        v1_mag += v1[i] ** 2;
        v2_mag += v2[i] ** 2;
    }
    return dotProduct / (Math.sqrt(v1_mag) * Math.sqrt(v2_mag));
}


/***/ }),

/***/ "./src/utils/cache.js":
/*!****************************!*\
  !*** ./src/utils/cache.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CustomCache: () => (/* binding */ CustomCache)
/* harmony export */ });
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
// Author: Xenova
// Design a caching API to be used by the extension which implements the same interface as
// the browser's native Cache API (https://developer.mozilla.org/en-US/docs/Web/API/Cache)
// but uses the browser's local storage API (https://developer.chrome.com/docs/extensions/reference/storage/).
//
// Since the local storage API requires all data to be stored as JSON (which doesn't allow some ASCII chars),
// one of the better approaches is to store the response body as a base64-encoded string. This is not ideal,
// as it increases the size of the response body by ~33%, but it's the best we can do with the local storage API.
// See https://stackoverflow.com/a/1443240/13989043 for more information about this.
//
// For serialization (arraybuffer -> string) and unserialization (string -> arraybuffer),
// use the `FileReader` and `Blob` APIs. Although other options are also possible, this approach
// is considered to be better for larger files (like models).
//
// Other references:
//  - https://developer.chrome.com/docs/extensions/reference/storage/#property-local
//  - https://stackoverflow.com/questions/6965107/converting-between-strings-and-arraybuffers

class CustomCache {
    /**
     * Instantiate a `CustomCache` object.
     * @param {string} path
     */
    constructor(cacheName) {
        this.cacheName = cacheName;
    }

    /**
     * Checks whether the given request is in the cache.
     * @param {Request|string} request
     * @returns {Promise<Response | undefined>}
     */
    async match(request) {
        const url = request instanceof Request ? request.url : request;
        const cached = await chrome.storage.local.get([url]);

        if (cached[url]) {
            let model =  await fetch(cached[url]._body);
            // console.log("model: ", model);
            return model;
        } else {
            return undefined;
        }
    }

    /**
     * Adds the given response to the cache.
     * @param {Request|string} request
     * @param {Response} response
     * @returns {Promise<void>}
     */
    async put(request, response) {
        const url = request instanceof Request ? request.url : request;
        const buffer = await response.arrayBuffer();

        const body = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.onerror = e => reject(e.target.error);
            reader.readAsDataURL(new Blob([buffer], { type: 'application/octet-stream' }));
        });

        try {
            await chrome.storage.local.set({
                [url]: {
                    _body: body,

                    // Save original response in case
                    status: response.status,
                    statusText: response.statusText,
                    headers: Object.fromEntries(response.headers.entries()),
                    url: response.url,
                    redirected: response.redirected,
                    type: response.type,
                    ok: response.ok,
                }
            });

        } catch (err) {
            console.warn('An error occurred while writing the file to cache:', err)
        }
    }
}


/***/ }),

/***/ "./src/utils/utils.js":
/*!****************************!*\
  !*** ./src/utils/utils.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSiteID: () => (/* binding */ getSiteID),
/* harmony export */   prettyLog: () => (/* binding */ prettyLog),
/* harmony export */   splitReadableContent: () => (/* binding */ splitReadableContent)
/* harmony export */ });
/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ "./node_modules/console-browserify/index.js");
function prettyLog(label, message, labelColor = 'blue', messageColor = 'black') {
    console.log("%c" + label + ": %c" + message,
        "font-weight: bold; color: " + labelColor + ";",
        "font-weight: normal; color: " + messageColor + ";");
}


/*  Looks for a sentence ending after numChars.  */
function splitByChars(text, numChars) {
    let chunks = [];
    let currChunk = '';
    const sentenceEndings = ['.', '?', '!', ';', ':', '\n', '–'];

    for (let i = 0; i < text.length; i++) {
        currChunk += text[i];

        let isEndingPunctuation = sentenceEndings.includes(text[i]);

        // Special case: if the punctuation is a period and the next character is a quote
        if (text[i] === '.' && text[i + 1] === '"') {
            currChunk += text[++i];
            isEndingPunctuation = true;
        }

        if (currChunk.trim().length >= numChars && isEndingPunctuation) {
            chunks.push(currChunk.trim());
            currChunk = '';
        }
    }

    if (currChunk.trim()) {
        chunks.push(currChunk.trim());
    }

    return chunks;
}


function getSiteID(url) {
    let urlObj = new URL(url);
    return urlObj.hostname + urlObj.pathname;
}


function splitReadableContent(readableContent) {
    return splitByChars(readableContent, 50);
}


function collectTextNodes(element, texts = []) {
    if (element.nodeType === Node.ELEMENT_NODE && element.tagName.toLowerCase() === 'p') {
        let sentences = tokenizer.tokenize(element.textContent); // Tokenize the text content into sentences
        for (let sentence of sentences) {
            sentence = sentence.trim();  // Remove leading/trailing white spaces
            if (sentence !== "") {
                texts.push(sentence);
            }
        }
    } else {
        for (let child of element.childNodes) {
            collectTextNodes(child, texts);
        }
    }
    return texts;
}




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("./src/serviceworkers/background.js");
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/serviceworkers/semantic.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2dyb3VuZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYix3QkFBd0IsMkVBQTJFLGtDQUFrQyx3QkFBd0IsT0FBTyxrQ0FBa0MsbUlBQW1JOztBQUV6VSxrREFBa0QsMENBQTBDOztBQUU1RixlQUFlLG1CQUFPLENBQUMseUVBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQU8sQ0FBQyx5R0FBbUM7O0FBRWhFLGdCQUFnQixtQkFBTyxDQUFDLDBDQUFPO0FBQy9COztBQUVBLHFCQUFxQix1RUFBc0I7QUFDM0M7QUFDQTs7QUFFQSxtREFBbUQsa0dBQW1DO0FBQ3RGLHVDQUF1QyxtQkFBTyxDQUFDLG9EQUFXO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLDZGQUE2Qjs7QUFFeEQ7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyxlQUFlLE9BQU8sZUFBZSxPQUFPLFdBQVcsT0FBTztBQUN0RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQSxzRUFBc0UsYUFBYTtBQUNuRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCOztBQUVoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUEsU0FBUyxrQkFBa0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQix3QkFBd0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EscUJBQXFCLFdBQVcsR0FBRyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsZ0JBQWdCLFdBQVcsR0FBRyxJQUFJLEtBQUssYUFBYTtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixLQUFLLG1EQUFtRCxjQUFjO0FBQ3pGLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLGFBQWEsU0FBUztBQUN0RDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QixjQUFjLG9CQUFvQixFQUFFLElBQUk7QUFDeEM7QUFDQSxZQUFZLGdCQUFnQixFQUFFLElBQUk7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUcsU0FBUyxHQUFHLEtBQUsscUJBQXFCLEVBQUUsRUFBRTtBQUNwRSxRQUFRO0FBQ1IseUJBQXlCLEdBQUcsS0FBSyx5QkFBeUIsRUFBRSxFQUFFO0FBQzlELG1CQUFtQix5QkFBeUIsRUFBRSxFQUFFO0FBQ2hEO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixJQUFJLEVBQUUsR0FBRyxTQUFTLElBQUksRUFBRSxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxjQUFjLFNBQVMsT0FBTztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUMsb0RBQVc7O0FBRWxDO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxHQUFHO0FBQ0gsZ0RBQWdEO0FBQ2hELEdBQUc7QUFDSCxzREFBc0Q7QUFDdEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8s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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNi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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Es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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIs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RTtXQUN2RztXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDekJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztVRU5BO1VBQ0E7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYnVpbGQvYXNzZXJ0LmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2Fzc2VydC9idWlsZC9pbnRlcm5hbC9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2J1aWxkL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9jb25zb2xlLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvZGVmaW5lLXByb3BlcnRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvZXM2LW9iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvZ29wZC9pbmRleC5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9oYXMtcHJvcGVydHktZGVzY3JpcHRvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvaGFzLXByb3RvL2luZGV4LmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2hhcy10b3N0cmluZ3RhZy9zaGFtcy5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9pcy1hcmd1bWVudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvaXMtY2FsbGFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uL2luZGV4LmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9pcy1uYW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvaXMtbmFuL3BvbHlmaWxsLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2lzLW5hbi9zaGltLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L2luZGV4LmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbXBsZW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9vYmplY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWlzL3BvbHlmaWxsLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL29iamVjdC1pcy9zaGltLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2luZGV4LmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL29iamVjdC1rZXlzL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9iYWNrZW5kLWltcGwuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL2JhY2tlbmQuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL2Vudi1pbXBsLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9lbnYuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL2luZGV4LmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvb25ueC12YWx1ZS5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9saWIvdGVuc29yLWltcGwuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvbGliL3RlbnNvci5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQtd2ViLm1pbi5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL3doaWNoLXR5cGVkLWFycmF5L2luZGV4LmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyL2lnbm9yZWR8L21udC9jL1VzZXJzL2RvbWUvRG93bmxvYWRzL1NlbWFudGljRmluZGVyL2V4dGVuc2lvbi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL2JhY2tlbmRzfG9ubnhydW50aW1lLW5vZGUiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvaWdub3JlZHwvbW50L2MvVXNlcnMvZG9tZS9Eb3dubG9hZHMvU2VtYW50aWNGaW5kZXIvZXh0ZW5zaW9uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHN8ZnMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvaWdub3JlZHwvbW50L2MvVXNlcnMvZG9tZS9Eb3dubG9hZHMvU2VtYW50aWNGaW5kZXIvZXh0ZW5zaW9uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHN8cGF0aCIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci9pZ25vcmVkfC9tbnQvYy9Vc2Vycy9kb21lL0Rvd25sb2Fkcy9TZW1hbnRpY0ZpbmRlci9leHRlbnNpb24vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy91dGlsc3xzaGFycCIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci9pZ25vcmVkfC9tbnQvYy9Vc2Vycy9kb21lL0Rvd25sb2Fkcy9TZW1hbnRpY0ZpbmRlci9leHRlbnNpb24vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy91dGlsc3xzdHJlYW0vd2ViIiwid2VicGFjazovL1NlbWFudGljRmluZGVyL2lnbm9yZWR8L21udC9jL1VzZXJzL2RvbWUvRG93bmxvYWRzL1NlbWFudGljRmluZGVyL2V4dGVuc2lvbi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjfGZzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyL2lnbm9yZWR8L21udC9jL1VzZXJzL2RvbWUvRG93bmxvYWRzL1NlbWFudGljRmluZGVyL2V4dGVuc2lvbi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjfHBhdGgiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvaWdub3JlZHwvbW50L2MvVXNlcnMvZG9tZS9Eb3dubG9hZHMvU2VtYW50aWNGaW5kZXIvZXh0ZW5zaW9uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmN8dXJsIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL2JhY2tlbmRzL29ubnguanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL2NvbmZpZ3MuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL2Vudi5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvbW9kZWxzLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy9waXBlbGluZXMuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3Byb2Nlc3NvcnMuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3Rva2VuaXplcnMuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3RyYW5zZm9ybWVycy5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvYXVkaW8uanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL2NvcmUuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL2dlbmVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL2h1Yi5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL25vZGVfbW9kdWxlcy9AeGVub3ZhL3RyYW5zZm9ybWVycy9zcmMvdXRpbHMvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9ub2RlX21vZHVsZXMvQHhlbm92YS90cmFuc2Zvcm1lcnMvc3JjL3V0aWxzL21hdGhzLmpzIiwid2VicGFjazovL1NlbWFudGljRmluZGVyLy4vbm9kZV9tb2R1bGVzL0B4ZW5vdmEvdHJhbnNmb3JtZXJzL3NyYy91dGlscy90ZW5zb3IuanMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvLi9zcmMvc2VydmljZXdvcmtlcnMvYmFja2dyb3VuZC5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL3NyYy9zZXJ2aWNld29ya2Vycy9zZW1hbnRpYy5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL3NyYy91dGlscy9jYWNoZS5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci8uL3NyYy91dGlscy91dGlscy5qcyIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci93ZWJwYWNrL3J1bnRpbWUvY3JlYXRlIGZha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL1NlbWFudGljRmluZGVyL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9TZW1hbnRpY0ZpbmRlci93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vU2VtYW50aWNGaW5kZXIvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvYXNzZXJ0LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzJhNTFhZTQyNGE1MTNlYzlhNmFhMzQ2NmJhYTBjYzFkNTVkZDRmM2Jcbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9lcnJvcnMnKSxcbiAgICBfcmVxdWlyZSRjb2RlcyA9IF9yZXF1aXJlLmNvZGVzLFxuICAgIEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfQU1CSUdVT1VTX0FSR1VNRU5ULFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX0lOVkFMSURfQVJHX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1ZBTFVFLFxuICAgIEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUztcblxudmFyIEFzc2VydGlvbkVycm9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hc3NlcnQvYXNzZXJ0aW9uX2Vycm9yJyk7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsLycpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gcmVxdWlyZSgndXRpbC8nKS50eXBlcyxcbiAgICBpc1Byb21pc2UgPSBfcmVxdWlyZSR0eXBlcy5pc1Byb21pc2UsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cDtcblxudmFyIG9iamVjdEFzc2lnbiA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduIDogcmVxdWlyZSgnZXM2LW9iamVjdC1hc3NpZ24nKS5hc3NpZ247XG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiByZXF1aXJlKCdvYmplY3QtaXMnKTtcbnZhciBlcnJvckNhY2hlID0gbmV3IE1hcCgpO1xudmFyIGlzRGVlcEVxdWFsO1xudmFyIGlzRGVlcFN0cmljdEVxdWFsO1xudmFyIHBhcnNlRXhwcmVzc2lvbkF0O1xudmFyIGZpbmROb2RlQXJvdW5kO1xudmFyIGRlY29kZXI7XG5cbmZ1bmN0aW9uIGxhenlMb2FkQ29tcGFyaXNvbigpIHtcbiAgdmFyIGNvbXBhcmlzb24gPSByZXF1aXJlKCcuL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMnKTtcblxuICBpc0RlZXBFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwRXF1YWw7XG4gIGlzRGVlcFN0cmljdEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBTdHJpY3RFcXVhbDtcbn0gLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycyBidXQgbm90IFxcbiBhbmQgXFx0IHRvIGtlZXAgdGhlIGxpbmUgYnJlYWtzIGFuZFxuLy8gaW5kZW50YXRpb24gaW50YWN0LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXG52YXIgZXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZl0vZztcbnZhciBtZXRhID0gW1wiXFxcXHUwMDAwXCIsIFwiXFxcXHUwMDAxXCIsIFwiXFxcXHUwMDAyXCIsIFwiXFxcXHUwMDAzXCIsIFwiXFxcXHUwMDA0XCIsIFwiXFxcXHUwMDA1XCIsIFwiXFxcXHUwMDA2XCIsIFwiXFxcXHUwMDA3XCIsICdcXFxcYicsICcnLCAnJywgXCJcXFxcdTAwMGJcIiwgJ1xcXFxmJywgJycsIFwiXFxcXHUwMDBlXCIsIFwiXFxcXHUwMDBmXCIsIFwiXFxcXHUwMDEwXCIsIFwiXFxcXHUwMDExXCIsIFwiXFxcXHUwMDEyXCIsIFwiXFxcXHUwMDEzXCIsIFwiXFxcXHUwMDE0XCIsIFwiXFxcXHUwMDE1XCIsIFwiXFxcXHUwMDE2XCIsIFwiXFxcXHUwMDE3XCIsIFwiXFxcXHUwMDE4XCIsIFwiXFxcXHUwMDE5XCIsIFwiXFxcXHUwMDFhXCIsIFwiXFxcXHUwMDFiXCIsIFwiXFxcXHUwMDFjXCIsIFwiXFxcXHUwMDFkXCIsIFwiXFxcXHUwMDFlXCIsIFwiXFxcXHUwMDFmXCJdO1xuXG52YXIgZXNjYXBlRm4gPSBmdW5jdGlvbiBlc2NhcGVGbihzdHIpIHtcbiAgcmV0dXJuIG1ldGFbc3RyLmNoYXJDb2RlQXQoMCldO1xufTtcblxudmFyIHdhcm5lZCA9IGZhbHNlOyAvLyBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG52YXIgTk9fRVhDRVBUSU9OX1NFTlRJTkVMID0ge307IC8vIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gaW5uZXJGYWlsKG9iaikge1xuICBpZiAob2JqLm1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihvYmopO1xufVxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0Rm4pIHtcbiAgdmFyIGFyZ3NMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW50ZXJuYWxNZXNzYWdlO1xuXG4gIGlmIChhcmdzTGVuID09PSAwKSB7XG4gICAgaW50ZXJuYWxNZXNzYWdlID0gJ0ZhaWxlZCc7XG4gIH0gZWxzZSBpZiAoYXJnc0xlbiA9PT0gMSkge1xuICAgIG1lc3NhZ2UgPSBhY3R1YWw7XG4gICAgYWN0dWFsID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIGlmICh3YXJuZWQgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgdmFyIHdhcm4gPSBwcm9jZXNzLmVtaXRXYXJuaW5nID8gcHJvY2Vzcy5lbWl0V2FybmluZyA6IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICAgICAgd2FybignYXNzZXJ0LmZhaWwoKSB3aXRoIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgaXMgZGVwcmVjYXRlZC4gJyArICdQbGVhc2UgdXNlIGFzc2VydC5zdHJpY3RFcXVhbCgpIGluc3RlYWQgb3Igb25seSBwYXNzIGEgbWVzc2FnZS4nLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgJ0RFUDAwOTQnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJnc0xlbiA9PT0gMikgb3BlcmF0b3IgPSAnIT0nO1xuICB9XG5cbiAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgbWVzc2FnZTtcbiAgdmFyIGVyckFyZ3MgPSB7XG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvciA9PT0gdW5kZWZpbmVkID8gJ2ZhaWwnIDogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm4gfHwgZmFpbFxuICB9O1xuXG4gIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlcnJBcmdzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG5cbiAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcihlcnJBcmdzKTtcblxuICBpZiAoaW50ZXJuYWxNZXNzYWdlKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBpbnRlcm5hbE1lc3NhZ2U7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG5cbiAgdGhyb3cgZXJyO1xufVxuXG5hc3NlcnQuZmFpbCA9IGZhaWw7IC8vIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGludGVybmFsL2Vycm9yLlxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcblxuZnVuY3Rpb24gaW5uZXJPayhmbiwgYXJnTGVuLCB2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdmFyIGdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcblxuICAgIGlmIChhcmdMZW4gPT09IDApIHtcbiAgICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICAgICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCc7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICBhY3R1YWw6IHZhbHVlLFxuICAgICAgZXhwZWN0ZWQ6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gICAgZXJyLmdlbmVyYXRlZE1lc3NhZ2UgPSBnZW5lcmF0ZWRNZXNzYWdlO1xuICAgIHRocm93IGVycjtcbiAgfVxufSAvLyBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIXZhbHVlLlxuXG5cbmZ1bmN0aW9uIG9rKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtvaywgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5vayA9IG9rOyAvLyBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGggPT0uXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllcyAqL1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cblxuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnPT0nLFxuICAgICAgc3RhY2tTdGFydEZuOiBlcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90XG4vLyBlcXVhbCB3aXRoICE9LlxuXG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICchPScsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuXG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59OyAvLyBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cblxuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuXG4gIGlmIChpc0RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IG5vdERlZXBFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKCFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IGRlZXBTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuXG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn1cblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoIW9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnc3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChvYmplY3RJcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90U3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIENvbXBhcmlzb24gPSBmdW5jdGlvbiBDb21wYXJpc29uKG9iaiwga2V5cywgYWN0dWFsKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBhcmlzb24pO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChhY3R1YWwgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKG9ialtrZXldKSAmJiBvYmpba2V5XS50ZXN0KGFjdHVhbFtrZXldKSkge1xuICAgICAgICBfdGhpc1trZXldID0gYWN0dWFsW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpc1trZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmVFeGNlcHRpb25LZXkoYWN0dWFsLCBleHBlY3RlZCwga2V5LCBtZXNzYWdlLCBrZXlzLCBmbikge1xuICBpZiAoIShrZXkgaW4gYWN0dWFsKSB8fCAhaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsW2tleV0sIGV4cGVjdGVkW2tleV0pKSB7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXIgb2JqZWN0cyB0byBjcmVhdGUgYSBuaWNlIG91dHB1dC5cbiAgICAgIHZhciBhID0gbmV3IENvbXBhcmlzb24oYWN0dWFsLCBrZXlzKTtcbiAgICAgIHZhciBiID0gbmV3IENvbXBhcmlzb24oZXhwZWN0ZWQsIGtleXMsIGFjdHVhbCk7XG4gICAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgYWN0dWFsOiBhLFxuICAgICAgICBleHBlY3RlZDogYixcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5hY3R1YWwgPSBhY3R1YWw7XG4gICAgICBlcnIuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiBmbi5uYW1lLFxuICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG1zZywgZm4pIHtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChpc1JlZ0V4cChleHBlY3RlZCkpIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7IC8vIGFzc2VydC5kb2VzTm90VGhyb3cgZG9lcyBub3QgYWNjZXB0IG9iamVjdHMuXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdleHBlY3RlZCcsIFsnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGV4cGVjdGVkKTtcbiAgICB9IC8vIEhhbmRsZSBwcmltaXRpdmVzIHByb3Blcmx5LlxuXG5cbiAgICBpZiAoX3R5cGVvZihhY3R1YWwpICE9PSAnb2JqZWN0JyB8fCBhY3R1YWwgPT09IG51bGwpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgICAgc3RhY2tTdGFydEZuOiBmblxuICAgICAgfSk7XG4gICAgICBlcnIub3BlcmF0b3IgPSBmbi5uYW1lO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBTcGVjaWFsIGhhbmRsZSBlcnJvcnMgdG8gbWFrZSBzdXJlIHRoZSBuYW1lIGFuZCB0aGUgbWVzc2FnZSBhcmUgY29tcGFyZWRcbiAgICAvLyBhcyB3ZWxsLlxuXG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGtleXMucHVzaCgnbmFtZScsICdtZXNzYWdlJyk7XG4gICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRSgnZXJyb3InLCBleHBlY3RlZCwgJ21heSBub3QgYmUgYW4gZW1wdHkgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVlcEVxdWFsID09PSB1bmRlZmluZWQpIGxhenlMb2FkQ29tcGFyaXNvbigpO1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGFjdHVhbFtrZXldID09PSAnc3RyaW5nJyAmJiBpc1JlZ0V4cChleHBlY3RlZFtrZXldKSAmJiBleHBlY3RlZFtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1zZywga2V5cywgZm4pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEd1YXJkIGluc3RhbmNlb2YgYWdhaW5zdCBhcnJvdyBmdW5jdGlvbnMgYXMgdGhleSBkb24ndCBoYXZlIGEgcHJvdG90eXBlLlxuXG5cbiAgaWYgKGV4cGVjdGVkLnByb3RvdHlwZSAhPT0gdW5kZWZpbmVkICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0dWFsKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgJ0Z1bmN0aW9uJywgZm4pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBmbigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzUHJvbWlzZShvYmopIHtcbiAgLy8gQWNjZXB0IG5hdGl2ZSBFUzYgcHJvbWlzZXMgYW5kIHByb21pc2VzIHRoYXQgYXJlIGltcGxlbWVudGVkIGluIGEgc2ltaWxhclxuICAvLyB3YXkuIERvIG5vdCBhY2NlcHQgdGhlbmFibGVzIHRoYXQgdXNlIGEgZnVuY3Rpb24gYXMgYG9iamAgYW5kIHRoYXQgaGF2ZSBub1xuICAvLyBgY2F0Y2hgIGhhbmRsZXIuXG4gIC8vIFRPRE86IHRoZW5hYmxlcyBhcmUgY2hlY2tlZCB1cCB1bnRpbCB0aGV5IGhhdmUgdGhlIGNvcnJlY3QgbWV0aG9kcyxcbiAgLy8gYnV0IGFjY29yZGluZyB0byBkb2N1bWVudGF0aW9uLCB0aGUgYHRoZW5gIG1ldGhvZCBzaG91bGQgcmVjZWl2ZVxuICAvLyB0aGUgYGZ1bGZpbGxgIGFuZCBgcmVqZWN0YCBhcmd1bWVudHMgYXMgd2VsbCBvciBpdCBtYXkgYmUgbmV2ZXIgcmVzb2x2ZWQuXG4gIHJldHVybiBpc1Byb21pc2Uob2JqKSB8fCBvYmogIT09IG51bGwgJiYgX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5jYXRjaCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHRQcm9taXNlO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9taXNlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFJldHVybiBhIHJlamVjdGVkIHByb21pc2UgaWYgYHByb21pc2VGbmAgdGhyb3dzIHN5bmNocm9ub3VzbHkuXG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuKCk7IC8vIEZhaWwgaW4gY2FzZSBubyBwcm9taXNlIGlzIHJldHVybmVkLlxuXG4gICAgICBpZiAoIWNoZWNrSXNQcm9taXNlKHJlc3VsdFByb21pc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUoJ2luc3RhbmNlIG9mIFByb21pc2UnLCAncHJvbWlzZUZuJywgcmVzdWx0UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGVja0lzUHJvbWlzZShwcm9taXNlRm4pKSB7XG4gICAgICByZXN1bHRQcm9taXNlID0gcHJvbWlzZUZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ3Byb21pc2VGbicsIFsnRnVuY3Rpb24nLCAnUHJvbWlzZSddLCBwcm9taXNlRm4pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXN1bHRQcm9taXNlO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE5PX0VYQ0VQVElPTl9TRU5USU5FTDtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBleHBlY3RzRXJyb3Ioc3RhY2tTdGFydEZuLCBhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGFjdHVhbC5tZXNzYWdlID09PSBlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIG1lc3NhZ2UgXFxcIlwiLmNvbmNhdChhY3R1YWwubWVzc2FnZSwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSBlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVSUl9BTUJJR1VPVVNfQVJHVU1FTlQoJ2Vycm9yL21lc3NhZ2UnLCBcIlRoZSBlcnJvciBcXFwiXCIuY29uY2F0KGFjdHVhbCwgXCJcXFwiIGlzIGlkZW50aWNhbCB0byB0aGUgbWVzc2FnZS5cIikpO1xuICAgIH1cblxuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmIChlcnJvciAhPSBudWxsICYmIF90eXBlb2YoZXJyb3IpICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2Vycm9yJywgWydPYmplY3QnLCAnRXJyb3InLCAnRnVuY3Rpb24nLCAnUmVnRXhwJ10sIGVycm9yKTtcbiAgfVxuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTl9TRU5USU5FTCkge1xuICAgIHZhciBkZXRhaWxzID0gJyc7XG5cbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSkge1xuICAgICAgZGV0YWlscyArPSBcIiAoXCIuY29uY2F0KGVycm9yLm5hbWUsIFwiKVwiKTtcbiAgICB9XG5cbiAgICBkZXRhaWxzICs9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ3JlamVjdHMnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIk1pc3NpbmcgZXhwZWN0ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChlcnJvciAmJiAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvciwgbWVzc2FnZSwgc3RhY2tTdGFydEZuKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBlY3RzTm9FcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSByZXR1cm47XG5cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXJyb3I7XG4gICAgZXJyb3IgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIWVycm9yIHx8IGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgdmFyIGRldGFpbHMgPSBtZXNzYWdlID8gXCI6IFwiLmNvbmNhdChtZXNzYWdlKSA6ICcuJztcbiAgICB2YXIgZm5UeXBlID0gc3RhY2tTdGFydEZuLm5hbWUgPT09ICdkb2VzTm90UmVqZWN0JyA/ICdyZWplY3Rpb24nIDogJ2V4Y2VwdGlvbic7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6IHN0YWNrU3RhcnRGbi5uYW1lLFxuICAgICAgbWVzc2FnZTogXCJHb3QgdW53YW50ZWQgXCIuY29uY2F0KGZuVHlwZSkuY29uY2F0KGRldGFpbHMsIFwiXFxuXCIpICsgXCJBY3R1YWwgbWVzc2FnZTogXFxcIlwiLmNvbmNhdChhY3R1YWwgJiYgYWN0dWFsLm1lc3NhZ2UsIFwiXFxcIlwiKSxcbiAgICAgIHN0YWNrU3RhcnRGbjogc3RhY2tTdGFydEZuXG4gICAgfSk7XG4gIH1cblxuICB0aHJvdyBhY3R1YWw7XG59XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiB0aHJvd3MocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFt0aHJvd3MsIGdldEFjdHVhbChwcm9taXNlRm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LnJlamVjdHMgPSBmdW5jdGlvbiByZWplY3RzKHByb21pc2VGbikge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICByZXR1cm4gd2FpdEZvckFjdHVhbChwcm9taXNlRm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzRXJyb3IuYXBwbHkodm9pZCAwLCBbcmVqZWN0cywgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiBkb2VzTm90VGhyb3coZm4pIHtcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFRocm93LCBnZXRBY3R1YWwoZm4pXS5jb25jYXQoYXJncykpO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RSZWplY3QgPSBmdW5jdGlvbiBkb2VzTm90UmVqZWN0KGZuKSB7XG4gIGZvciAodmFyIF9sZW41ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNSA+IDEgPyBfbGVuNSAtIDEgOiAwKSwgX2tleTUgPSAxOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgYXJnc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKGZuKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gZXhwZWN0c05vRXJyb3IuYXBwbHkodm9pZCAwLCBbZG9lc05vdFJlamVjdCwgcmVzdWx0XS5jb25jYXQoYXJncykpO1xuICB9KTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24gaWZFcnJvcihlcnIpIHtcbiAgaWYgKGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBtZXNzYWdlID0gJ2lmRXJyb3IgZ290IHVud2FudGVkIGV4Y2VwdGlvbjogJztcblxuICAgIGlmIChfdHlwZW9mKGVycikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZS5sZW5ndGggPT09IDAgJiYgZXJyLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlICs9IGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlICs9IGluc3BlY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3RXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogZXJyLFxuICAgICAgZXhwZWN0ZWQ6IG51bGwsXG4gICAgICBvcGVyYXRvcjogJ2lmRXJyb3InLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIHN0YWNrU3RhcnRGbjogaWZFcnJvclxuICAgIH0pOyAvLyBNYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHN0YWNrIHRyYWNlIVxuXG4gICAgdmFyIG9yaWdTdGFjayA9IGVyci5zdGFjaztcblxuICAgIGlmICh0eXBlb2Ygb3JpZ1N0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHJlbW92ZSBhbnkgZHVwbGljYXRlZCBmcmFtZXMgZnJvbSB0aGUgZXJyb3IgZnJhbWVzIHRha2VuXG4gICAgICAvLyBmcm9tIHdpdGhpbiBgaWZFcnJvcmAgYW5kIGFkZCB0aGUgb3JpZ2luYWwgZXJyb3IgZnJhbWVzIHRvIHRoZSBuZXdseVxuICAgICAgLy8gY3JlYXRlZCBvbmVzLlxuICAgICAgdmFyIHRtcDIgPSBvcmlnU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdG1wMi5zaGlmdCgpOyAvLyBGaWx0ZXIgYWxsIGZyYW1lcyBleGlzdGluZyBpbiBlcnIuc3RhY2suXG5cbiAgICAgIHZhciB0bXAxID0gbmV3RXJyLnN0YWNrLnNwbGl0KCdcXG4nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bXAyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIGZyYW1lLlxuICAgICAgICB2YXIgcG9zID0gdG1wMS5pbmRleE9mKHRtcDJbaV0pO1xuXG4gICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgLy8gT25seSBrZWVwIG5ldyBmcmFtZXMuXG4gICAgICAgICAgdG1wMSA9IHRtcDEuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdFcnIuc3RhY2sgPSBcIlwiLmNvbmNhdCh0bXAxLmpvaW4oJ1xcbicpLCBcIlxcblwiKS5jb25jYXQodG1wMi5qb2luKCdcXG4nKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3RXJyO1xuICB9XG59OyAvLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuXG5cbmZ1bmN0aW9uIHN0cmljdCgpIHtcbiAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42KSwgX2tleTYgPSAwOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICB9XG5cbiAgaW5uZXJPay5hcHBseSh2b2lkIDAsIFtzdHJpY3QsIGFyZ3MubGVuZ3RoXS5jb25jYXQoYXJncykpO1xufVxuXG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Fzc2VydC9hc3NlcnRpb25fZXJyb3IuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMDgxNzg0MGY3NzUwMzIxNjlkZGQ3MGM4NWFjMDU5ZjE4ZmZjYzgxY1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0OyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgndXRpbC8nKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUuaW5zcGVjdDtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUyLmNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gIGlmIChzdHIubGVuZ3RoID09IDAgfHwgY291bnQgPT0gMCkgcmV0dXJuICcnO1xuICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnQ7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSk7XG5cbiAgd2hpbGUgKGNvdW50KSB7XG4gICAgc3RyICs9IHN0cjtcbiAgICBjb3VudC0tO1xuICB9XG5cbiAgc3RyICs9IHN0ci5zdWJzdHJpbmcoMCwgbWF4Q291bnQgLSBzdHIubGVuZ3RoKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIGJsdWUgPSAnJztcbnZhciBncmVlbiA9ICcnO1xudmFyIHJlZCA9ICcnO1xudmFyIHdoaXRlID0gJyc7XG52YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XG4gIGRlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsOicsXG4gIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gIHN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIGRlZXBFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWw6JyxcbiAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonLFxuICBub3RJZGVudGljYWw6ICdWYWx1ZXMgaWRlbnRpY2FsIGJ1dCBub3QgcmVmZXJlbmNlLWVxdWFsOidcbn07IC8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXG4vLyBkaWZmLlxuXG52YXIga01heFNob3J0TGVuZ3RoID0gMTA7XG5cbmZ1bmN0aW9uIGNvcHlFcnJvcihzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdtZXNzYWdlJywge1xuICAgIHZhbHVlOiBzb3VyY2UubWVzc2FnZVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFZhbHVlKHZhbCkge1xuICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgLy8gZXJyb3IgbWVzc2FnZXMgY29udGFpbiB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIG5ldmVydGhlbGVzcy5cbiAgcmV0dXJuIGluc3BlY3QodmFsLCB7XG4gICAgY29tcGFjdDogZmFsc2UsXG4gICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgZGVwdGg6IDEwMDAsXG4gICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBjb21wYXJlcyBvbmx5IGVudW1lcmFibGUgcHJvcGVydGllcyAod2l0aCBhIGZldyBleGNlcHRpb25zKS5cbiAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXG4gICAgLy8gY29tcGFyaXNvbiBmb3Igbm93LlxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBgYnJlYWtMZW5ndGhgIHNob3VsZCBiZSBsaW1pdGVkIGFzIHNvb24gYXMgc29vbiBhcyB3ZVxuICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcbiAgICAvLyBpbiB3aGF0IGxpbmUgdGhlIHByb3BlcnR5IHN0YXJ0cyBhbmQgZW5kcykuXG4gICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXG4gICAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgICBzb3J0ZWQ6IHRydWUsXG4gICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxuICAgIGdldHRlcnM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpIHtcbiAgdmFyIG90aGVyID0gJyc7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgZW5kID0gJyc7XG4gIHZhciBza2lwcGVkID0gZmFsc2U7XG4gIHZhciBhY3R1YWxJbnNwZWN0ZWQgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcbiAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGV4cGVjdGVkTGluZXMgPSBpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgaW5kaWNhdG9yID0gJyc7IC8vIEluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMgZXhwbGljaXRseSBtYXJrIHRoZW0gYXMgbm90IHJlZmVyZW5jZSBlcXVhbFxuICAvLyBmb3IgdGhlIGBzdHJpY3RFcXVhbGAgb3BlcmF0b3IuXG5cbiAgaWYgKG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgIG9wZXJhdG9yID0gJ3N0cmljdEVxdWFsT2JqZWN0JztcbiAgfSAvLyBJZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgZml0IG9uIGEgc2luZ2xlIGxpbmUgYW5kIHRoZXkgYXJlIG5vdCBzdHJpY3RseVxuICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxuXG5cbiAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBhY3R1YWxMaW5lc1swXSAhPT0gZXhwZWN0ZWRMaW5lc1swXSkge1xuICAgIHZhciBpbnB1dExlbmd0aCA9IGFjdHVhbExpbmVzWzBdLmxlbmd0aCArIGV4cGVjdGVkTGluZXNbMF0ubGVuZ3RoOyAvLyBJZiB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgdG9nZXRoZXIgaXMgbGVzcyB0aGFuXG4gICAgLy8ga01heFNob3J0TGVuZ3RoIGFuZCBpZiBuZWl0aGVyIGlzIGFuIG9iamVjdCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaXNcbiAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxuXG4gICAgaWYgKGlucHV0TGVuZ3RoIDw9IGtNYXhTaG9ydExlbmd0aCkge1xuICAgICAgaWYgKChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkgJiYgKF90eXBlb2YoZXhwZWN0ZWQpICE9PSAnb2JqZWN0JyB8fCBleHBlY3RlZCA9PT0gbnVsbCkgJiYgKGFjdHVhbCAhPT0gMCB8fCBleHBlY3RlZCAhPT0gMCkpIHtcbiAgICAgICAgLy8gLTAgPT09ICswXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpICsgXCJcIi5jb25jYXQoYWN0dWFsTGluZXNbMF0sIFwiICE9PSBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbMF0sIFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09ICdzdHJpY3RFcXVhbE9iamVjdCcpIHtcbiAgICAgIC8vIElmIHRoZSBzdGRlcnIgaXMgYSB0dHkgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudFxuICAgICAgLy8gY29sdW1ucyBwZXIgbGluZSwgYWRkIGEgbWlzbWF0Y2ggaW5kaWNhdG9yIGJlbG93IHRoZSBvdXRwdXQuIElmIGl0IGlzXG4gICAgICAvLyBub3QgYSB0dHksIHVzZSBhIGRlZmF1bHQgdmFsdWUgb2YgODAgY2hhcmFjdGVycy5cbiAgICAgIHZhciBtYXhMZW5ndGggPSBwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSA/IHByb2Nlc3Muc3RkZXJyLmNvbHVtbnMgOiA4MDtcblxuICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChhY3R1YWxMaW5lc1swXVtpXSA9PT0gZXhwZWN0ZWRMaW5lc1swXVtpXSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSAvLyBJZ25vcmUgdGhlIGZpcnN0IGNoYXJhY3RlcnMuXG5cblxuICAgICAgICBpZiAoaSA+IDIpIHtcbiAgICAgICAgICAvLyBBZGQgcG9zaXRpb24gaW5kaWNhdG9yIGZvciB0aGUgZmlyc3QgbWlzbWF0Y2ggaW4gY2FzZSBpdCBpcyBhXG4gICAgICAgICAgLy8gc2luZ2xlIGxpbmUgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBjb2x1bW4gbGVuZ3RoLlxuICAgICAgICAgIGluZGljYXRvciA9IFwiXFxuICBcIi5jb25jYXQocmVwZWF0KCcgJywgaSksIFwiXlwiKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxuICAvLyByZWFkYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIHRvdGFsIGNoYW5nZWQgbGluZXMpLlxuXG5cbiAgdmFyIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgdmFyIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG5cbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBpZiAoaSsrIDwgMikge1xuICAgICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChhKS5jb25jYXQoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBhO1xuICAgIH1cblxuICAgIGFjdHVhbExpbmVzLnBvcCgpO1xuICAgIGV4cGVjdGVkTGluZXMucG9wKCk7XG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICAgIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKTsgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXG4gIC8vIEUuZy4sIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoeyBhOiBTeW1ib2woKSB9LCB7IGE6IFN5bWJvbCgpIH0pXG5cbiAgaWYgKG1heExpbmVzID09PSAwKSB7XG4gICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHJlc3VsdCBhZ2Fpbi4gVGhlIGxpbmVzIHdlcmUgYWxsIHJlbW92ZWQgYmVmb3JlLlxuICAgIHZhciBfYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpOyAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcbiAgICAgIF9hY3R1YWxMaW5lc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICB3aGlsZSAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgIF9hY3R1YWxMaW5lcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Iubm90SWRlbnRpY2FsLCBcIlxcblxcblwiKS5jb25jYXQoX2FjdHVhbExpbmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKTtcbiAgfVxuXG4gIGlmIChpID4gMykge1xuICAgIGVuZCA9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZCk7XG4gICAgc2tpcHBlZCA9IHRydWU7XG4gIH1cblxuICBpZiAob3RoZXIgIT09ICcnKSB7XG4gICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCk7XG4gICAgb3RoZXIgPSAnJztcbiAgfVxuXG4gIHZhciBwcmludGVkTGluZXMgPSAwO1xuICB2YXIgbXNnID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdICsgXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiKyBhY3R1YWxcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KHJlZCwgXCItIGV4cGVjdGVkXCIpLmNvbmNhdCh3aGl0ZSk7XG4gIHZhciBza2lwcGVkTXNnID0gXCIgXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSwgXCIgTGluZXMgc2tpcHBlZFwiKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4TGluZXM7IGkrKykge1xuICAgIC8vIE9ubHkgZXh0cmEgZXhwZWN0ZWQgbGluZXMgZXhpc3RcbiAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3M7XG5cbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgZXhwZWN0ZWQgbGluZSB0byB0aGUgY2FjaGUuXG5cbiAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBPbmx5IGV4dHJhIGFjdHVhbCBsaW5lcyBleGlzdFxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gTGluZXMgZGl2ZXJnZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhwZWN0ZWRMaW5lID0gZXhwZWN0ZWRMaW5lc1tpXTtcbiAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV07IC8vIElmIHRoZSBsaW5lcyBkaXZlcmdlLCBzcGVjaWZpY2FsbHkgY2hlY2sgZm9yIGxpbmVzIHRoYXQgb25seSBkaXZlcmdlIGJ5XG4gICAgICAvLyBhIHRyYWlsaW5nIGNvbW1hLiBJbiB0aGF0IGNhc2UgaXQgaXMgYWN0dWFsbHkgaWRlbnRpY2FsIGFuZCB3ZSBzaG91bGRcbiAgICAgIC8vIG1hcmsgaXQgYXMgc3VjaC5cblxuICAgICAgdmFyIGRpdmVyZ2luZ0xpbmVzID0gYWN0dWFsTGluZSAhPT0gZXhwZWN0ZWRMaW5lICYmICghZW5kc1dpdGgoYWN0dWFsTGluZSwgJywnKSB8fCBhY3R1YWxMaW5lLnNsaWNlKDAsIC0xKSAhPT0gZXhwZWN0ZWRMaW5lKTsgLy8gSWYgdGhlIGV4cGVjdGVkIGxpbmUgaGFzIGEgdHJhaWxpbmcgY29tbWEgYnV0IGlzIG90aGVyd2lzZSBpZGVudGljYWwsXG4gICAgICAvLyBhZGQgYSBjb21tYSBhdCB0aGUgZW5kIG9mIHRoZSBhY3R1YWwgbGluZS4gT3RoZXJ3aXNlIHRoZSBvdXRwdXQgY291bGRcbiAgICAgIC8vIGxvb2sgd2VpcmQgYXMgaW46XG4gICAgICAvL1xuICAgICAgLy8gICBbXG4gICAgICAvLyAgICAgMSAgICAgICAgIC8vIE5vIGNvbW1hIGF0IHRoZSBlbmQhXG4gICAgICAvLyArICAgMlxuICAgICAgLy8gICBdXG4gICAgICAvL1xuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMgJiYgZW5kc1dpdGgoZXhwZWN0ZWRMaW5lLCAnLCcpICYmIGV4cGVjdGVkTGluZS5zbGljZSgwLCAtMSkgPT09IGFjdHVhbExpbmUpIHtcbiAgICAgICAgZGl2ZXJnaW5nTGluZXMgPSBmYWxzZTtcbiAgICAgICAgYWN0dWFsTGluZSArPSAnLCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcykge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQgYW5kIGNhY2hlIHRoZSBleHBlY3RlZCBkaXZlcmdpbmdcbiAgICAgICAgLy8gbGluZSBzbyBjb25zZWN1dGl2ZSBkaXZlcmdpbmcgbGluZXMgc2hvdyB1cCBhcyArKystLS0gYW5kIG5vdCArLSstKy0uXG5cbiAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lKTtcbiAgICAgICAgcHJpbnRlZExpbmVzICs9IDI7IC8vIExpbmVzIGFyZSBpZGVudGljYWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhbGwgY2FjaGVkIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgYmVmb3JlIGFkZGluZyBvdGhlciB0aGluZ3NcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBjYWNoZS5cbiAgICAgICAgcmVzICs9IG90aGVyO1xuICAgICAgICBvdGhlciA9ICcnOyAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBleGFjdGx5IG9uZSBsaW5lIGFib3ZlIG9yIGlmIGl0IGlzIHRoZVxuICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICAgIGlmIChjdXIgPT09IDEgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBJbnNwZWN0ZWQgb2JqZWN0IHRvIGJpZyAoU2hvdyB+MjAgcm93cyBtYXgpXG5cblxuICAgIGlmIChwcmludGVkTGluZXMgPiAyMCAmJiBpIDwgbWF4TGluZXMgLSAyKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZE1zZywgXCJcXG5cIikuY29uY2F0KHJlcywgXCJcXG5cIikuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KG90aGVyLCBcIlxcblwiKSArIFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsIFwiXFxuXCIpLmNvbmNhdChyZXMpLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCkuY29uY2F0KGluZGljYXRvcik7XG59XG5cbnZhciBBc3NlcnRpb25FcnJvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFzc2VydGlvbkVycm9yKTtcblxuICAgIGlmIChfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcbiAgICAgICAgc3RhY2tTdGFydEZuID0gb3B0aW9ucy5zdGFja1N0YXJ0Rm47XG4gICAgdmFyIGFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG5cbiAgICBpZiAobWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBTdHJpbmcobWVzc2FnZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIC8vIFJlc2V0IG9uIGVhY2ggY2FsbCB0byBtYWtlIHN1cmUgd2UgaGFuZGxlIGR5bmFtaWNhbGx5IHNldCBlbnZpcm9ubWVudFxuICAgICAgICAvLyB2YXJpYWJsZXMgY29ycmVjdC5cbiAgICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGggJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCgpICE9PSAxKSB7XG4gICAgICAgICAgYmx1ZSA9IFwiXFx4MUJbMzRtXCI7XG4gICAgICAgICAgZ3JlZW4gPSBcIlxceDFCWzMybVwiO1xuICAgICAgICAgIHdoaXRlID0gXCJcXHgxQlszOW1cIjtcbiAgICAgICAgICByZWQgPSBcIlxceDFCWzMxbVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsdWUgPSAnJztcbiAgICAgICAgICBncmVlbiA9ICcnO1xuICAgICAgICAgIHdoaXRlID0gJyc7XG4gICAgICAgICAgcmVkID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJldmVudCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBiZWluZyB2aXNpYmxlIGJ5IGR1cGxpY2F0aW5nIHRoZSBlcnJvclxuICAgICAgLy8gaW4gYSB2ZXJ5IGNsb3NlIHdheSB0byB0aGUgb3JpZ2luYWwgaW4gY2FzZSBib3RoIHNpZGVzIGFyZSBhY3R1YWxseVxuICAgICAgLy8gaW5zdGFuY2VzIG9mIEVycm9yLlxuXG5cbiAgICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWQgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBhY3R1YWwgJiYgYWN0dWFsIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3N0YWNrJyBpbiBleHBlY3RlZCAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGFjdHVhbCA9IGNvcHlFcnJvcihhY3R1YWwpO1xuICAgICAgICBleHBlY3RlZCA9IGNvcHlFcnJvcihleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikpKTtcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGJ1dCB0aGUgb3BlcmF0b3IgcmVxdWlyZXMgdW5lcXVhbCwgc2hvd1xuICAgICAgICAvLyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBzYXkgQSBlcXVhbHMgQlxuICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcbiAgICAgICAgdmFyIHJlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpLnNwbGl0KCdcXG4nKTsgLy8gSW4gY2FzZSBcImFjdHVhbFwiIGlzIGFuIG9iamVjdCwgaXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2UgZXF1YWwuXG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yLm5vdFN0cmljdEVxdWFsT2JqZWN0O1xuICAgICAgICB9IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgcmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE9ubHkgcHJpbnQgYSBzaW5nbGUgaW5wdXQuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiIFwiKS5jb25jYXQocmVzWzBdKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXFxuXCIpLmNvbmNhdChyZXMuam9pbignXFxuJyksIFwiXFxuXCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG5cbiAgICAgICAgdmFyIG90aGVyID0gJyc7XG4gICAgICAgIHZhciBrbm93bk9wZXJhdG9ycyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90RXF1YWwnKSB7XG4gICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KGluc3BlY3RWYWx1ZShleHBlY3RlZCkpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXIubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KG90aGVyLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrbm93bk9wZXJhdG9ycywgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMsIFwiXFxuXFxuc2hvdWxkIGVxdWFsXFxuXFxuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiIFwiLmNvbmNhdChvcGVyYXRvciwgXCIgXCIpLmNvbmNhdChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoX3JlcykuY29uY2F0KG90aGVyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICduYW1lJywge1xuICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF90aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgX3RoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc3RhY2tTdGFydEZuKTtcbiAgICB9IC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZSBpbiB0aGUgbmFtZS5cblxuXG4gICAgX3RoaXMuc3RhY2s7IC8vIFJlc2V0IHRoZSBuYW1lLlxuXG4gICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBc3NlcnRpb25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIiBbXCIpLmNvbmNhdCh0aGlzLmNvZGUsIFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogaW5zcGVjdC5jdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXG4gICAgICAvLyB0aGUgbWluaW11bSBkZXB0aC4gT3RoZXJ3aXNlIHRob3NlIHZhbHVlcyB3b3VsZCBiZSB0b28gdmVyYm9zZSBjb21wYXJlZFxuICAgICAgLy8gdG8gdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlIHdoaWNoIGNvbnRhaW5zIGEgY29tYmluZWQgdmlldyBvZiB0aGVzZSB0d29cbiAgICAgIC8vIGlucHV0IHZhbHVlcy5cbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIGN0eCwge1xuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjsiLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL2Vycm9ycy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8zYjA0NDk2MmM0OGZlMzEzOTA1ODc3YTk2YjVkMDg5NGE1NDA0ZjZmXG5cbi8qIGVzbGludCBub2RlLWNvcmUvZG9jdW1lbnRlZC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2FscGhhYmV0aXplLWVycm9yczogXCJlcnJvclwiICovXG5cbi8qIGVzbGludCBub2RlLWNvcmUvcHJlZmVyLXV0aWwtZm9ybWF0LWVycm9yczogXCJlcnJvclwiICovXG4ndXNlIHN0cmljdCc7IC8vIFRoZSB3aG9sZSBwb2ludCBiZWhpbmQgdGhpcyBpbnRlcm5hbCBtb2R1bGUgaXMgdG8gYWxsb3cgTm9kZS5qcyB0byBub1xuLy8gbG9uZ2VyIGJlIGZvcmNlZCB0byB0cmVhdCBldmVyeSBlcnJvciBtZXNzYWdlIGNoYW5nZSBhcyBhIHNlbXZlci1tYWpvclxuLy8gY2hhbmdlLiBUaGUgTm9kZUVycm9yIGNsYXNzZXMgaGVyZSBhbGwgZXhwb3NlIGEgYGNvZGVgIHByb3BlcnR5IHdob3NlXG4vLyB2YWx1ZSBzdGF0aWNhbGx5IGFuZCBwZXJtYW5lbnRseSBpZGVudGlmaWVzIHRoZSBlcnJvci4gV2hpbGUgdGhlIGVycm9yXG4vLyBtZXNzYWdlIG1heSBjaGFuZ2UsIHRoZSBjb2RlIHNob3VsZCBub3QuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIGNvZGVzID0ge307IC8vIExhenkgbG9hZGVkXG5cbnZhciBhc3NlcnQ7XG52YXIgdXRpbDtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0cyhOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlRXJyb3IpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihOb2RlRXJyb3IpLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkpO1xuICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0FNQklHVU9VU19BUkdVTUVOVCcsICdUaGUgXCIlc1wiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gJXMnLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vYXNzZXJ0Jyk7XG4gIGFzc2VydCh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsIFwiJ25hbWUnIG11c3QgYmUgYSBzdHJpbmdcIik7IC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG5cbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gLy8gVE9ETyhCcmlkZ2VBUik6IEltcHJvdmUgdGhlIG91dHB1dCBieSBzaG93aW5nIGBudWxsYCBhbmQgc2ltaWxhci5cblxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQoX3R5cGVvZihhY3R1YWwpKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnaXMgaW52YWxpZCc7XG4gIGlmICh1dGlsID09PSB1bmRlZmluZWQpIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xuICB2YXIgaW5zcGVjdGVkID0gdXRpbC5pbnNwZWN0KHZhbHVlKTtcblxuICBpZiAoaW5zcGVjdGVkLmxlbmd0aCA+IDEyOCkge1xuICAgIGluc3BlY3RlZCA9IFwiXCIuY29uY2F0KGluc3BlY3RlZC5zbGljZSgwLCAxMjgpLCBcIi4uLlwiKTtcbiAgfVxuXG4gIHJldHVybiBcIlRoZSBhcmd1bWVudCAnXCIuY29uY2F0KG5hbWUsIFwiJyBcIikuY29uY2F0KHJlYXNvbiwgXCIuIFJlY2VpdmVkIFwiKS5jb25jYXQoaW5zcGVjdGVkKTtcbn0sIFR5cGVFcnJvciwgUmFuZ2VFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX1JFVFVSTl9WQUxVRScsIGZ1bmN0aW9uIChpbnB1dCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR5cGU7XG5cbiAgaWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICB0eXBlID0gXCJpbnN0YW5jZSBvZiBcIi5jb25jYXQodmFsdWUuY29uc3RydWN0b3IubmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IFwidHlwZSBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIuY29uY2F0KGlucHV0LCBcIiB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBcXFwiXCIpLmNvbmNhdChuYW1lLCBcIlxcXCJcIikgKyBcIiBmdW5jdGlvbiBidXQgZ290IFwiLmNvbmNhdCh0eXBlLCBcIi5cIik7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUlTU0lOR19BUkdTJywgZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSBhc3NlcnQgPSByZXF1aXJlKCcuLi9hc3NlcnQnKTtcbiAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gIHZhciBtc2cgPSAnVGhlICc7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdChhLCBcIlxcXCJcIik7XG4gIH0pO1xuXG4gIHN3aXRjaCAobGVuKSB7XG4gICAgY2FzZSAxOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFyZ3VtZW50XCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBtc2cgKz0gXCJcIi5jb25jYXQoYXJnc1swXSwgXCIgYW5kIFwiKS5jb25jYXQoYXJnc1sxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbXNnICs9IGFyZ3Muc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKTtcbiAgICAgIG1zZyArPSBcIiwgYW5kIFwiLmNvbmNhdChhcmdzW2xlbiAtIDFdLCBcIiBhcmd1bWVudHNcIik7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBcIlwiLmNvbmNhdChtc2csIFwiIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xufSwgVHlwZUVycm9yKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL2NvbXBhcmlzb25zLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciByZWdleEZsYWdzU3VwcG9ydGVkID0gL2EvZy5mbGFncyAhPT0gdW5kZWZpbmVkO1xuXG52YXIgYXJyYXlGcm9tU2V0ID0gZnVuY3Rpb24gYXJyYXlGcm9tU2V0KHNldCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2godmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIGFycmF5RnJvbU1hcCA9IGZ1bmN0aW9uIGFycmF5RnJvbU1hcChtYXApIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIGFycmF5LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IHJlcXVpcmUoJ29iamVjdC1pcycpO1xudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW107XG59O1xudmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOID8gTnVtYmVyLmlzTmFOIDogcmVxdWlyZSgnaXMtbmFuJyk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUpO1xudmFyIG9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IHJlcXVpcmUoJ3V0aWwvJykudHlwZXMsXG4gICAgaXNBbnlBcnJheUJ1ZmZlciA9IF9yZXF1aXJlJHR5cGVzLmlzQW55QXJyYXlCdWZmZXIsXG4gICAgaXNBcnJheUJ1ZmZlclZpZXcgPSBfcmVxdWlyZSR0eXBlcy5pc0FycmF5QnVmZmVyVmlldyxcbiAgICBpc0RhdGUgPSBfcmVxdWlyZSR0eXBlcy5pc0RhdGUsXG4gICAgaXNNYXAgPSBfcmVxdWlyZSR0eXBlcy5pc01hcCxcbiAgICBpc1JlZ0V4cCA9IF9yZXF1aXJlJHR5cGVzLmlzUmVnRXhwLFxuICAgIGlzU2V0ID0gX3JlcXVpcmUkdHlwZXMuaXNTZXQsXG4gICAgaXNOYXRpdmVFcnJvciA9IF9yZXF1aXJlJHR5cGVzLmlzTmF0aXZlRXJyb3IsXG4gICAgaXNCb3hlZFByaW1pdGl2ZSA9IF9yZXF1aXJlJHR5cGVzLmlzQm94ZWRQcmltaXRpdmUsXG4gICAgaXNOdW1iZXJPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc051bWJlck9iamVjdCxcbiAgICBpc1N0cmluZ09iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3RyaW5nT2JqZWN0LFxuICAgIGlzQm9vbGVhbk9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQm9vbGVhbk9iamVjdCxcbiAgICBpc0JpZ0ludE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzQmlnSW50T2JqZWN0LFxuICAgIGlzU3ltYm9sT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNTeW1ib2xPYmplY3QsXG4gICAgaXNGbG9hdDMyQXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0MzJBcnJheSxcbiAgICBpc0Zsb2F0NjRBcnJheSA9IF9yZXF1aXJlJHR5cGVzLmlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc05vbkluZGV4KGtleSkge1xuICBpZiAoa2V5Lmxlbmd0aCA9PT0gMCB8fCBrZXkubGVuZ3RoID4gMTApIHJldHVybiB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvZGUgPSBrZXkuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1NykgcmV0dXJuIHRydWU7XG4gIH0gLy8gVGhlIG1heGltdW0gc2l6ZSBmb3IgYW4gYXJyYXkgaXMgMiAqKiAzMiAtMS5cblxuXG4gIHJldHVybiBrZXkubGVuZ3RoID09PSAxMCAmJiBrZXkgPj0gTWF0aC5wb3coMiwgMzIpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoaXNOb25JbmRleCkuY29uY2F0KG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkuZmlsdGVyKE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYmluZCh2YWx1ZSkpKTtcbn0gLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxudmFyIE9OTFlfRU5VTUVSQUJMRSA9IHVuZGVmaW5lZDtcbnZhciBrU3RyaWN0ID0gdHJ1ZTtcbnZhciBrTG9vc2UgPSBmYWxzZTtcbnZhciBrTm9JdGVyYXRvciA9IDA7XG52YXIga0lzQXJyYXkgPSAxO1xudmFyIGtJc1NldCA9IDI7XG52YXIga0lzTWFwID0gMzsgLy8gQ2hlY2sgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHNvdXJjZSBhbmQgZmxhZ3NcblxuZnVuY3Rpb24gYXJlU2ltaWxhclJlZ0V4cHMoYSwgYikge1xuICByZXR1cm4gcmVnZXhGbGFnc1N1cHBvcnRlZCA/IGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzIDogUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJGbG9hdEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGEuYnl0ZUxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICBpZiAoYVtvZmZzZXRdICE9PSBiW29mZnNldF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYXJlU2ltaWxhclR5cGVkQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKSwgbmV3IFVpbnQ4QXJyYXkoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGFyZUVxdWFsQXJyYXlCdWZmZXJzKGJ1ZjEsIGJ1ZjIpIHtcbiAgcmV0dXJuIGJ1ZjEuYnl0ZUxlbmd0aCA9PT0gYnVmMi5ieXRlTGVuZ3RoICYmIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYnVmMSksIG5ldyBVaW50OEFycmF5KGJ1ZjIpKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpIHtcbiAgaWYgKGlzTnVtYmVyT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyT2JqZWN0KHZhbDIpICYmIG9iamVjdElzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpLCBOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKSk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmdPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNTdHJpbmdPYmplY3QodmFsMikgJiYgU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc0Jvb2xlYW5PYmplY3QodmFsMikgJiYgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG4gIH1cblxuICBpZiAoaXNCaWdJbnRPYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCaWdJbnRPYmplY3QodmFsMikgJiYgQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMSkgPT09IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3ltYm9sT2JqZWN0KHZhbDIpICYmIFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbn0gLy8gTm90ZXM6IFR5cGUgdGFncyBhcmUgaGlzdG9yaWNhbCBbW0NsYXNzXV0gcHJvcGVydGllcyB0aGF0IGNhbiBiZSBzZXQgYnlcbi8vIEZ1bmN0aW9uVGVtcGxhdGU6OlNldENsYXNzTmFtZSgpIGluIEMrKyBvciBTeW1ib2wudG9TdHJpbmdUYWcgaW4gSlNcbi8vIGFuZCByZXRyaWV2ZWQgdXNpbmcgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgaW4gSlNcbi8vIFNlZSBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG4vLyBmb3IgYSBsaXN0IG9mIHRhZ3MgcHJlLWRlZmluZWQgaW4gdGhlIHNwZWMuXG4vLyBUaGVyZSBhcmUgc29tZSB1bnNwZWNpZmllZCB0YWdzIGluIHRoZSB3aWxkIHRvbyAoZS5nLiB0eXBlZCBhcnJheSB0YWdzKS5cbi8vIFNpbmNlIHRhZ3MgY2FuIGJlIGFsdGVyZWQsIHRoZXkgb25seSBzZXJ2ZSBmYXN0IGZhaWx1cmVzXG4vL1xuLy8gVHlwZWQgYXJyYXlzIGFuZCBidWZmZXJzIGFyZSBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGUgY29udGVudCBpbiB0aGVpclxuLy8gdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhhdCBpdCdzXG4vLyByZWFzb25hYmxlIHRvIGludGVycHJldCB0aGVpciB1bmRlcmx5aW5nIG1lbW9yeSBpbiB0aGUgc2FtZSB3YXksXG4vLyB3aGljaCBpcyBjaGVja2VkIGJ5IGNvbXBhcmluZyB0aGVpciB0eXBlIHRhZ3MuXG4vLyAoZS5nLiBhIFVpbnQ4QXJyYXkgYW5kIGEgVWludDE2QXJyYXkgd2l0aCB0aGUgc2FtZSBtZW1vcnkgY29udGVudFxuLy8gY291bGQgc3RpbGwgYmUgZGlmZmVyZW50IGJlY2F1c2UgdGhleSB3aWxsIGJlIGludGVycHJldGVkIGRpZmZlcmVudGx5KS5cbi8vXG4vLyBGb3Igc3RyaWN0IGNvbXBhcmlzb24sIG9iamVjdHMgc2hvdWxkIGhhdmVcbi8vIGEpIFRoZSBzYW1lIGJ1aWx0LWluIHR5cGUgdGFnc1xuLy8gYikgVGhlIHNhbWUgcHJvdG90eXBlcy5cblxuXG5mdW5jdGlvbiBpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKHZhbDEgPT09IHZhbDIpIHtcbiAgICBpZiAodmFsMSAhPT0gMCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHN0cmljdCA/IG9iamVjdElzKHZhbDEsIHZhbDIpIDogdHJ1ZTtcbiAgfSAvLyBDaGVjayBtb3JlIGNsb3NlbHkgaWYgdmFsMSBhbmQgdmFsMiBhcmUgZXF1YWwuXG5cblxuICBpZiAoc3RyaWN0KSB7XG4gICAgaWYgKF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbDEgPT09ICdudW1iZXInICYmIG51bWJlcklzTmFOKHZhbDEpICYmIG51bWJlcklzTmFOKHZhbDIpO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0JyB8fCB2YWwxID09PSBudWxsIHx8IHZhbDIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbDEgPT09IG51bGwgfHwgX3R5cGVvZih2YWwxKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgcmV0dXJuIHZhbDEgPT0gdmFsMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh2YWwyID09PSBudWxsIHx8IF90eXBlb2YodmFsMikgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbDFUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwxKTtcbiAgdmFyIHZhbDJUYWcgPSBvYmplY3RUb1N0cmluZyh2YWwyKTtcblxuICBpZiAodmFsMVRhZyAhPT0gdmFsMlRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbDEpKSB7XG4gICAgLy8gQ2hlY2sgZm9yIHNwYXJzZSBhcnJheXMgYW5kIGdlbmVyYWwgZmFzdCBwYXRoXG4gICAgaWYgKHZhbDEubGVuZ3RoICE9PSB2YWwyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBrZXlzMSA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuICAgIHZhciBrZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc0FycmF5LCBrZXlzMSk7XG4gIH0gLy8gW2Jyb3dzZXJpZnldIFRoaXMgdHJpZ2dlcnMgb24gY2VydGFpbiB0eXBlcyBpbiBJRSAoTWFwL1NldCkgc28gd2UgZG9uJ3RcbiAgLy8gd2FuJ3QgdG8gZWFybHkgcmV0dXJuIG91dCBvZiB0aGUgcmVzdCBvZiB0aGUgY2hlY2tzLiBIb3dldmVyIHdlIGNhbiBjaGVja1xuICAvLyBpZiB0aGUgc2Vjb25kIHZhbHVlIGlzIG9uZSBvZiB0aGVzZSB2YWx1ZXMgYW5kIHRoZSBmaXJzdCBpc24ndC5cblxuXG4gIGlmICh2YWwxVGFnID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIC8vIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG4gICAgaWYgKCFpc01hcCh2YWwxKSAmJiBpc01hcCh2YWwyKSB8fCAhaXNTZXQodmFsMSkgJiYgaXNTZXQodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNEYXRlKHZhbDEpKSB7XG4gICAgaWYgKCFpc0RhdGUodmFsMikgfHwgRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDEpICE9PSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAodmFsMSkpIHtcbiAgICBpZiAoIWlzUmVnRXhwKHZhbDIpIHx8ICFhcmVTaW1pbGFyUmVnRXhwcyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc05hdGl2ZUVycm9yKHZhbDEpIHx8IHZhbDEgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIERvIG5vdCBjb21wYXJlIHRoZSBzdGFjayBhcyBpdCBtaWdodCBkaWZmZXIgZXZlbiB0aG91Z2ggdGhlIGVycm9yIGl0c2VsZlxuICAgIC8vIGlzIG90aGVyd2lzZSBpZGVudGljYWwuXG4gICAgaWYgKHZhbDEubWVzc2FnZSAhPT0gdmFsMi5tZXNzYWdlIHx8IHZhbDEubmFtZSAhPT0gdmFsMi5uYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHZhbDEpKSB7XG4gICAgaWYgKCFzdHJpY3QgJiYgKGlzRmxvYXQzMkFycmF5KHZhbDEpIHx8IGlzRmxvYXQ2NEFycmF5KHZhbDEpKSkge1xuICAgICAgaWYgKCFhcmVTaW1pbGFyRmxvYXRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFyZVNpbWlsYXJUeXBlZEFycmF5cyh2YWwxLCB2YWwyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQnVmZmVyLmNvbXBhcmUgcmV0dXJucyB0cnVlLCBzbyB2YWwxLmxlbmd0aCA9PT0gdmFsMi5sZW5ndGguIElmIHRoZXkgYm90aFxuICAgIC8vIG9ubHkgY29udGFpbiBudW1lcmljIGtleXMsIHdlIGRvbid0IG5lZWQgdG8gZXhhbSBmdXJ0aGVyIHRoYW4gY2hlY2tpbmdcbiAgICAvLyB0aGUgc3ltYm9scy5cblxuXG4gICAgdmFyIF9rZXlzID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDEsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICB2YXIgX2tleXMyID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbDIsIE9OTFlfRU5VTUVSQUJMRSk7XG5cbiAgICBpZiAoX2tleXMubGVuZ3RoICE9PSBfa2V5czIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yLCBfa2V5cyk7XG4gIH0gZWxzZSBpZiAoaXNTZXQodmFsMSkpIHtcbiAgICBpZiAoIWlzU2V0KHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc1NldCk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsMSkpIHtcbiAgICBpZiAoIWlzTWFwKHZhbDIpIHx8IHZhbDEuc2l6ZSAhPT0gdmFsMi5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtJc01hcCk7XG4gIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWwxKSkge1xuICAgIGlmICghYXJlRXF1YWxBcnJheUJ1ZmZlcnModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNCb3hlZFByaW1pdGl2ZSh2YWwxKSAmJiAhaXNFcXVhbEJveGVkUHJpbWl0aXZlKHZhbDEsIHZhbDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGtOb0l0ZXJhdG9yKTtcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZXModmFsLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwsIGspO1xuICB9KTtcbn1cblxuZnVuY3Rpb24ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywgaXRlcmF0aW9uVHlwZSwgYUtleXMpIHtcbiAgLy8gRm9yIGFsbCByZW1haW5pbmcgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXksIG9iamVjdHMgYW5kIE1hcHMsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgaGF2aW5nOlxuICAvLyBhKSBUaGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gIC8vIGIpIFRoZSBzYW1lIHNldCBvZiBrZXlzL2luZGV4ZXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlcilcbiAgLy8gYykgRXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5L2luZGV4XG4gIC8vIGQpIEZvciBTZXRzIGFuZCBNYXBzLCBlcXVhbCBjb250ZW50c1xuICAvLyBOb3RlOiB0aGlzIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIGFLZXlzID0gT2JqZWN0LmtleXModmFsMSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXModmFsMik7IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcy5cblxuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBDaGVhcCBrZXkgdGVzdFxuXG5cbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgYUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KHZhbDIsIGFLZXlzW2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHJpY3QgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIHZhciBzeW1ib2xLZXlzQSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwxKTtcblxuICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzeW1ib2xLZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gc3ltYm9sS2V5c0FbaV07XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDEsIGtleSkpIHtcbiAgICAgICAgICBpZiAoIXByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbDIsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKHN5bWJvbEtleXNBLmxlbmd0aCAhPT0gc3ltYm9sS2V5c0IubGVuZ3RoICYmIGdldEVudW1lcmFibGVzKHZhbDIsIHN5bWJvbEtleXNCKS5sZW5ndGggIT09IGNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9zeW1ib2xLZXlzQiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWwyKTtcblxuICAgICAgaWYgKF9zeW1ib2xLZXlzQi5sZW5ndGggIT09IDAgJiYgZ2V0RW51bWVyYWJsZXModmFsMiwgX3N5bWJvbEtleXNCKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhS2V5cy5sZW5ndGggPT09IDAgJiYgKGl0ZXJhdGlvblR5cGUgPT09IGtOb0l0ZXJhdG9yIHx8IGl0ZXJhdGlvblR5cGUgPT09IGtJc0FycmF5ICYmIHZhbDEubGVuZ3RoID09PSAwIHx8IHZhbDEuc2l6ZSA9PT0gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBVc2UgbWVtb3MgdG8gaGFuZGxlIGN5Y2xlcy5cblxuXG4gIGlmIChtZW1vcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWVtb3MgPSB7XG4gICAgICB2YWwxOiBuZXcgTWFwKCksXG4gICAgICB2YWwyOiBuZXcgTWFwKCksXG4gICAgICBwb3NpdGlvbjogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgcHJldmVudCB1cCB0byB0d28gbWFwLmhhcyh4KSBjYWxscyBieSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZVxuICAgIC8vIGFuZCBjaGVja2luZyBmb3IgdW5kZWZpbmVkLiBUaGUgbWFwIGNhbiBvbmx5IGNvbnRhaW4gbnVtYmVycywgc28gaXQgaXNcbiAgICAvLyBzYWZlIHRvIGNoZWNrIGZvciB1bmRlZmluZWQgb25seS5cbiAgICB2YXIgdmFsMk1lbW9BID0gbWVtb3MudmFsMS5nZXQodmFsMSk7XG5cbiAgICBpZiAodmFsMk1lbW9BICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB2YWwyTWVtb0IgPSBtZW1vcy52YWwyLmdldCh2YWwyKTtcblxuICAgICAgaWYgKHZhbDJNZW1vQiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWwyTWVtb0EgPT09IHZhbDJNZW1vQjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5wb3NpdGlvbisrO1xuICB9XG5cbiAgbWVtb3MudmFsMS5zZXQodmFsMSwgbWVtb3MucG9zaXRpb24pO1xuICBtZW1vcy52YWwyLnNldCh2YWwyLCBtZW1vcy5wb3NpdGlvbik7XG4gIHZhciBhcmVFcSA9IG9iakVxdWl2KHZhbDEsIHZhbDIsIHN0cmljdCwgYUtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKTtcbiAgbWVtb3MudmFsMS5kZWxldGUodmFsMSk7XG4gIG1lbW9zLnZhbDIuZGVsZXRlKHZhbDIpO1xuICByZXR1cm4gYXJlRXE7XG59XG5cbmZ1bmN0aW9uIHNldEhhc0VxdWFsRWxlbWVudChzZXQsIHZhbDEsIHN0cmljdCwgbWVtbykge1xuICAvLyBHbyBsb29raW5nLlxuICB2YXIgc2V0VmFsdWVzID0gYXJyYXlGcm9tU2V0KHNldCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsMiA9IHNldFZhbHVlc1tpXTtcblxuICAgIGlmIChpbm5lckRlZXBFcXVhbCh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIG1hdGNoaW5nIGVsZW1lbnQgdG8gbWFrZSBzdXJlIHdlIGRvIG5vdCBjaGVjayB0aGF0IGFnYWluLlxuICAgICAgc2V0LmRlbGV0ZSh2YWwyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRXF1YWxpdHlfY29tcGFyaXNvbnNfYW5kX3NhbWVuZXNzI0xvb3NlX2VxdWFsaXR5X3VzaW5nXG4vLyBTYWRseSBpdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGNvcnJlc3BvbmRpbmcgdmFsdWVzIHByb3Blcmx5IGluIGNhc2UgdGhlXG4vLyB0eXBlIGlzIGEgc3RyaW5nLCBudW1iZXIsIGJpZ2ludCBvciBib29sZWFuLiBUaGUgcmVhc29uIGlzIHRoYXQgdGhvc2UgdmFsdWVzXG4vLyBjYW4gbWF0Y2ggbG90cyBvZiBkaWZmZXJlbnQgc3RyaW5nIHZhbHVlcyAoZS5nLiwgMW4gPT0gJyswMDAwMScpLlxuXG5cbmZ1bmN0aW9uIGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKSB7XG4gIHN3aXRjaCAoX3R5cGVvZihwcmltKSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAvLyBPbmx5IHBhc3MgaW4gbnVsbCBhcyBvYmplY3QhXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBwcmltID0gK3ByaW07XG4gICAgLy8gTG9vc2UgZXF1YWwgZW50cmllcyBleGlzdCBvbmx5IGlmIHRoZSBzdHJpbmcgaXMgcG9zc2libGUgdG8gY29udmVydCB0b1xuICAgIC8vIGEgcmVndWxhciBudW1iZXIgYW5kIG5vdCBOYU4uXG4gICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKG51bWJlcklzTmFOKHByaW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCBwcmltKSB7XG4gIHZhciBhbHRWYWx1ZSA9IGZpbmRMb29zZU1hdGNoaW5nUHJpbWl0aXZlcyhwcmltKTtcbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHJldHVybiBhbHRWYWx1ZTtcbiAgcmV0dXJuIGIuaGFzKGFsdFZhbHVlKSAmJiAhYS5oYXMoYWx0VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSwgaXRlbSwgbWVtbykge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG5cbiAgaWYgKGFsdFZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gYWx0VmFsdWU7XG4gIH1cblxuICB2YXIgY3VyQiA9IGIuZ2V0KGFsdFZhbHVlKTtcblxuICBpZiAoY3VyQiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhhbHRWYWx1ZSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhYS5oYXMoYWx0VmFsdWUpICYmIGlubmVyRGVlcEVxdWFsKGl0ZW0sIGN1ckIsIGZhbHNlLCBtZW1vKTtcbn1cblxuZnVuY3Rpb24gc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRoaXMgaXMgYSBsYXppbHkgaW5pdGlhdGVkIFNldCBvZiBlbnRyaWVzIHdoaWNoIGhhdmUgdG8gYmUgY29tcGFyZWRcbiAgLy8gcGFpcndpc2UuXG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYVZhbHVlcyA9IGFycmF5RnJvbVNldChhKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYVZhbHVlc1tpXTsgLy8gTm90ZTogQ2hlY2tpbmcgZm9yIHRoZSBvYmplY3RzIGZpcnN0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSBmb3Igb2JqZWN0XG4gICAgLy8gaGVhdnkgc2V0cyBidXQgaXQgaXMgYSBtaW5vciBzbG93IGRvd24gZm9yIHByaW1pdGl2ZXMuIEFzIHRoZXkgYXJlIGZhc3RcbiAgICAvLyB0byBjaGVjayB0aGlzIGltcHJvdmVzIHRoZSB3b3JzdCBjYXNlIHNjZW5hcmlvIGluc3RlYWQuXG5cbiAgICBpZiAoX3R5cGVvZih2YWwpID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfSAvLyBJZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNlY29uZCBzZXQgaXRzIGFuIG5vdCBudWxsXG4gICAgICAvLyBvYmplY3QgKG9yIG5vbiBzdHJpY3Qgb25seTogYSBub3QgbWF0Y2hpbmcgcHJpbWl0aXZlKSB3ZSdsbCBuZWVkIHRvIGdvXG4gICAgICAvLyBodW50aW5nIGZvciBzb21ldGhpbmcgdGhhdHMgZGVlcC0oc3RyaWN0LSllcXVhbCB0byBpdC4gVG8gbWFrZSB0aGlzXG4gICAgICAvLyBPKG4gbG9nIG4pIGNvbXBsZXhpdHkgd2UgaGF2ZSB0byBjb3B5IHRoZXNlIHZhbHVlcyBpbiBhIG5ldyBzZXQgZmlyc3QuXG5cblxuICAgICAgc2V0LmFkZCh2YWwpO1xuICAgIH0gZWxzZSBpZiAoIWIuaGFzKHZhbCkpIHtcbiAgICAgIGlmIChzdHJpY3QpIHJldHVybiBmYWxzZTsgLy8gRmFzdCBwYXRoIHRvIGRldGVjdCBtaXNzaW5nIHN0cmluZywgc3ltYm9sLCB1bmRlZmluZWQgYW5kIG51bGwgdmFsdWVzLlxuXG4gICAgICBpZiAoIXNldE1pZ2h0SGF2ZUxvb3NlUHJpbShhLCBiLCB2YWwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJWYWx1ZXMgPSBhcnJheUZyb21TZXQoYik7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYlZhbHVlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfdmFsID0gYlZhbHVlc1tfaV07IC8vIFdlIGhhdmUgdG8gY2hlY2sgaWYgYSBwcmltaXRpdmUgdmFsdWUgaXMgYWxyZWFkeVxuICAgICAgLy8gbWF0Y2hpbmcgYW5kIG9ubHkgaWYgaXQncyBub3QsIGdvIGh1bnRpbmcgZm9yIGl0LlxuXG4gICAgICBpZiAoX3R5cGVvZihfdmFsKSA9PT0gJ29iamVjdCcgJiYgX3ZhbCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAhYS5oYXMoX3ZhbCkgJiYgIXNldEhhc0VxdWFsRWxlbWVudChzZXQsIF92YWwsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXBIYXNFcXVhbEVudHJ5KHNldCwgbWFwLCBrZXkxLCBpdGVtMSwgc3RyaWN0LCBtZW1vKSB7XG4gIC8vIFRvIGJlIGFibGUgdG8gaGFuZGxlIGNhc2VzIGxpa2U6XG4gIC8vICAgTWFwKFtbe30sICdhJ10sIFt7fSwgJ2InXV0pIHZzIE1hcChbW3t9LCAnYiddLCBbe30sICdhJ11dKVxuICAvLyAuLi4gd2UgbmVlZCB0byBjb25zaWRlciAqYWxsKiBtYXRjaGluZyBrZXlzLCBub3QganVzdCB0aGUgZmlyc3Qgd2UgZmluZC5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleTIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwoa2V5MSwga2V5Miwgc3RyaWN0LCBtZW1vKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtMSwgbWFwLmdldChrZXkyKSwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgc2V0LmRlbGV0ZShrZXkyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vKSB7XG4gIHZhciBzZXQgPSBudWxsO1xuICB2YXIgYUVudHJpZXMgPSBhcnJheUZyb21NYXAoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfYUVudHJpZXMkaSA9IF9zbGljZWRUb0FycmF5KGFFbnRyaWVzW2ldLCAyKSxcbiAgICAgICAga2V5ID0gX2FFbnRyaWVzJGlbMF0sXG4gICAgICAgIGl0ZW0xID0gX2FFbnRyaWVzJGlbMV07XG5cbiAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJ5IGRpcmVjdGx5IHJldHJpZXZpbmcgdGhlIHZhbHVlIHdlIHByZXZlbnQgYW5vdGhlciBiLmhhcyhrZXkpIGNoZWNrIGluXG4gICAgICAvLyBhbG1vc3QgYWxsIHBvc3NpYmxlIGNhc2VzLlxuICAgICAgdmFyIGl0ZW0yID0gYi5nZXQoa2V5KTtcblxuICAgICAgaWYgKGl0ZW0yID09PSB1bmRlZmluZWQgJiYgIWIuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGl0ZW0xLCBpdGVtMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsXG4gICAgICAgIC8vIGtleXMuXG5cbiAgICAgICAgaWYgKCFtYXBNaWdodEhhdmVMb29zZVByaW0oYSwgYiwga2V5LCBpdGVtMSwgbWVtbykpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZXQgIT09IG51bGwpIHtcbiAgICB2YXIgYkVudHJpZXMgPSBhcnJheUZyb21NYXAoYik7XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBiRW50cmllcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2JFbnRyaWVzJF9pID0gX3NsaWNlZFRvQXJyYXkoYkVudHJpZXNbX2kyXSwgMiksXG4gICAgICAgICAga2V5ID0gX2JFbnRyaWVzJF9pWzBdLFxuICAgICAgICAgIGl0ZW0gPSBfYkVudHJpZXMkX2lbMV07XG5cbiAgICAgIGlmIChfdHlwZW9mKGtleSkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIHN0cmljdCwgbWVtbykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiAoIWEuaGFzKGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGEuZ2V0KGtleSksIGl0ZW0sIGZhbHNlLCBtZW1vKSkgJiYgIW1hcEhhc0VxdWFsRW50cnkoc2V0LCBhLCBrZXksIGl0ZW0sIGZhbHNlLCBtZW1vKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldC5zaXplID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwga2V5cywgbWVtb3MsIGl0ZXJhdGlvblR5cGUpIHtcbiAgLy8gU2V0cyBhbmQgbWFwcyBkb24ndCBoYXZlIHRoZWlyIGVudHJpZXMgYWNjZXNzaWJsZSB2aWEgbm9ybWFsIG9iamVjdFxuICAvLyBwcm9wZXJ0aWVzLlxuICB2YXIgaSA9IDA7XG5cbiAgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc1NldCkge1xuICAgIGlmICghc2V0RXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzTWFwKSB7XG4gICAgaWYgKCFtYXBFcXVpdihhLCBiLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSkge1xuICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KGEsIGkpKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwgaSkgfHwgIWlubmVyRGVlcEVxdWFsKGFbaV0sIGJbaV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGIsIGkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFycmF5IGlzIHNwYXJzZS5cbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG5cbiAgICAgICAgZm9yICg7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzQVtpXTtcblxuICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkoYiwga2V5KSB8fCAhaW5uZXJEZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleXNBLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZSBwYWlyIG11c3QgaGF2ZSBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXkuXG4gIC8vIFBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3Q6XG5cblxuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfa2V5ID0ga2V5c1tpXTtcblxuICAgIGlmICghaW5uZXJEZWVwRXF1YWwoYVtfa2V5XSwgYltfa2V5XSwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwRXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga0xvb3NlKTtcbn1cblxuZnVuY3Rpb24gaXNEZWVwU3RyaWN0RXF1YWwodmFsMSwgdmFsMikge1xuICByZXR1cm4gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwga1N0cmljdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0RlZXBFcXVhbDogaXNEZWVwRXF1YWwsXG4gIGlzRGVlcFN0cmljdEVxdWFsOiBpc0RlZXBTdHJpY3RFcXVhbFxufTsiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuY29uc3QgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoXG4gIGxldCB5ID0gYi5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGNvbnN0IG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIGxldCBzdHIgPSAnJ1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIiwiLypnbG9iYWwgd2luZG93LCBnbG9iYWwqL1xudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKVxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIilcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIH1cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG52YXIgY29uc29sZVxudmFyIHRpbWVzID0ge31cblxuaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxufSBlbHNlIHtcbiAgICBjb25zb2xlID0ge31cbn1cblxudmFyIGZ1bmN0aW9ucyA9IFtcbiAgICBbbG9nLCBcImxvZ1wiXSxcbiAgICBbaW5mbywgXCJpbmZvXCJdLFxuICAgIFt3YXJuLCBcIndhcm5cIl0sXG4gICAgW2Vycm9yLCBcImVycm9yXCJdLFxuICAgIFt0aW1lLCBcInRpbWVcIl0sXG4gICAgW3RpbWVFbmQsIFwidGltZUVuZFwiXSxcbiAgICBbdHJhY2UsIFwidHJhY2VcIl0sXG4gICAgW2RpciwgXCJkaXJcIl0sXG4gICAgW2NvbnNvbGVBc3NlcnQsIFwiYXNzZXJ0XCJdXG5dXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gZnVuY3Rpb25zW2ldXG4gICAgdmFyIGYgPSB0dXBsZVswXVxuICAgIHZhciBuYW1lID0gdHVwbGVbMV1cblxuICAgIGlmICghY29uc29sZVtuYW1lXSkge1xuICAgICAgICBjb25zb2xlW25hbWVdID0gZlxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlXG5cbmZ1bmN0aW9uIGxvZygpIHt9XG5cbmZ1bmN0aW9uIGluZm8oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgIHRpbWVzW2xhYmVsXSA9IG5vdygpXG59XG5cbmZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICB2YXIgdGltZSA9IHRpbWVzW2xhYmVsXVxuICAgIGlmICghdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsOiBcIiArIGxhYmVsKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aW1lc1tsYWJlbF1cbiAgICB2YXIgZHVyYXRpb24gPSBub3coKSAtIHRpbWVcbiAgICBjb25zb2xlLmxvZyhsYWJlbCArIFwiOiBcIiArIGR1cmF0aW9uICsgXCJtc1wiKVxufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKClcbiAgICBlcnIubmFtZSA9IFwiVHJhY2VcIlxuICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxufVxuXG5mdW5jdGlvbiBkaXIob2JqZWN0KSB7XG4gICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyBcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBjb25zb2xlQXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJ29iamVjdC1rZXlzJyk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgb3JpZ0RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSByZXF1aXJlKCdoYXMtcHJvcGVydHktZGVzY3JpcHRvcnMnKSgpO1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IG9yaWdEZWZpbmVQcm9wZXJ0eSAmJiBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCB2YWx1ZSwgcHJlZGljYXRlKSB7XG5cdGlmIChuYW1lIGluIG9iamVjdCkge1xuXHRcdGlmIChwcmVkaWNhdGUgPT09IHRydWUpIHtcblx0XHRcdGlmIChvYmplY3RbbmFtZV0gPT09IHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCFpc0Z1bmN0aW9uKHByZWRpY2F0ZSkgfHwgIXByZWRpY2F0ZSgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cdGlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG5cdFx0b3JpZ0RlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG9iamVjdFtuYW1lXSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG5cdH1cbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwKSB7XG5cdHZhciBwcmVkaWNhdGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB7fTtcblx0dmFyIHByb3BzID0ga2V5cyhtYXApO1xuXHRpZiAoaGFzU3ltYm9scykge1xuXHRcdHByb3BzID0gY29uY2F0LmNhbGwocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWFwKSk7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcHNbaV0sIG1hcFtwcm9wc1tpXV0sIHByZWRpY2F0ZXNbcHJvcHNbaV1dKTtcblx0fVxufTtcblxuZGVmaW5lUHJvcGVydGllcy5zdXBwb3J0c0Rlc2NyaXB0b3JzID0gISFzdXBwb3J0c0Rlc2NyaXB0b3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnRpZXM7XG4iLCIvKipcbiAqIENvZGUgcmVmYWN0b3JlZCBmcm9tIE1vemlsbGEgRGV2ZWxvcGVyIE5ldHdvcms6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBmaXJzdFNvdXJjZSkge1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgZmlyc3QgYXJndW1lbnQgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAobmV4dFNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpO1xuICAgIGZvciAodmFyIG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7IG5leHRJbmRleCA8IGxlbjsgbmV4dEluZGV4KyspIHtcbiAgICAgIHZhciBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIGlmICghT2JqZWN0LmFzc2lnbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsICdhc3NpZ24nLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGFzc2lnblxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NpZ246IGFzc2lnbixcbiAgcG9seWZpbGw6IHBvbHlmaWxsXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJ2lzLWNhbGxhYmxlJyk7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm9yRWFjaEFycmF5ID0gZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGkpKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaFN0cmluZyA9IGZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaXRlcmF0b3Ioc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaE9iamVjdCA9IGZ1bmN0aW9uIGZvckVhY2hPYmplY3Qob2JqZWN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBrIGluIG9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGspKSB7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrXSwgaywgb2JqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgb2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGxpc3QsIGl0ZXJhdG9yLCB0aGlzQXJnKSB7XG4gICAgaWYgKCFpc0NhbGxhYmxlKGl0ZXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgcmVjZWl2ZXI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xuICAgICAgICByZWNlaXZlciA9IHRoaXNBcmc7XG4gICAgfVxuXG4gICAgaWYgKHRvU3RyLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgZm9yRWFjaEFycmF5KGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yRWFjaFN0cmluZyhsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvckVhY2hPYmplY3QobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG52YXIgaGFzUHJvdG8gPSByZXF1aXJlKCdoYXMtcHJvdG8nKSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgKFxuXHRoYXNQcm90b1xuXHRcdD8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblx0XHQ6IG51bGxcbik7XG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJpZ0ludDY0QXJyYXklJzogdHlwZW9mIEJpZ0ludDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50NjRBcnJheSxcblx0JyVCaWdVaW50NjRBcnJheSUnOiB0eXBlb2YgQmlnVWludDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnVWludDY0QXJyYXksXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiBFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiBFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiBSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbmlmIChnZXRQcm90bykge1xuXHR0cnkge1xuXHRcdG51bGwuZXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zaGFkb3dyZWFsbS9wdWxsLzM4NCNpc3N1ZWNvbW1lbnQtMTM2NDI2NDIyOVxuXHRcdHZhciBlcnJvclByb3RvID0gZ2V0UHJvdG8oZ2V0UHJvdG8oZSkpO1xuXHRcdElOVFJJTlNJQ1NbJyVFcnJvci5wcm90b3R5cGUlJ10gPSBlcnJvclByb3RvO1xuXHR9XG59XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4gJiYgZ2V0UHJvdG8pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclQm9vbGVhblByb3RvdHlwZSUnOiBbJ0Jvb2xlYW4nLCAncHJvdG90eXBlJ10sXG5cdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcblx0JyVFcnJvclByb3RvdHlwZSUnOiBbJ0Vycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQ2NEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXG5cdCclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXG5cdCclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG5cdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG5cdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXG59O1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXMnKTtcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG52YXIgJGV4ZWMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgUmVnRXhwLnByb3RvdHlwZS5leGVjKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHRpZiAoJGV4ZWMoL14lP1teJV0qJT8kLywgbmFtZSkgPT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdgJWAgbWF5IG5vdCBiZSBwcmVzZW50IGFueXdoZXJlIGJ1dCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGludHJpbnNpYyBuYW1lJyk7XG5cdH1cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG5cbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0JGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGdPUEQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpIHtcblx0aWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHRyeSB7XG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbmhhc1Byb3BlcnR5RGVzY3JpcHRvcnMuaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcgPSBmdW5jdGlvbiBoYXNBcnJheUxlbmd0aERlZmluZUJ1ZygpIHtcblx0Ly8gbm9kZSB2MC42IGhhcyBhIGJ1ZyB3aGVyZSBhcnJheSBsZW5ndGhzIGNhbiBiZSBTZXQgYnV0IG5vdCBEZWZpbmVkXG5cdGlmICghaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gJGRlZmluZVByb3BlcnR5KFtdLCAnbGVuZ3RoJywgeyB2YWx1ZTogMSB9KS5sZW5ndGggIT09IDE7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJbiBGaXJlZm94IDQtMjIsIGRlZmluaW5nIGxlbmd0aCBvbiBhbiBhcnJheSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvcnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0ZXN0ID0ge1xuXHRmb286IHt9XG59O1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNQcm90bygpIHtcblx0cmV0dXJuIHsgX19wcm90b19fOiB0ZXN0IH0uZm9vID09PSB0ZXN0LmZvbyAmJiAhKHsgX19wcm90b19fOiBudWxsIH0gaW5zdGFuY2VvZiAkT2JqZWN0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scy9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1RvU3RyaW5nVGFnU2hhbXMoKSB7XG5cdHJldHVybiBoYXNTeW1ib2xzKCkgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgcmVmbGVjdEFwcGx5ID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QgIT09IG51bGwgJiYgUmVmbGVjdC5hcHBseTtcbnZhciBiYWRBcnJheUxpa2U7XG52YXIgaXNDYWxsYWJsZU1hcmtlcjtcbmlmICh0eXBlb2YgcmVmbGVjdEFwcGx5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcblx0dHJ5IHtcblx0XHRiYWRBcnJheUxpa2UgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdsZW5ndGgnLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhyb3cgaXNDYWxsYWJsZU1hcmtlcjtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRpc0NhbGxhYmxlTWFya2VyID0ge307XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcblx0XHRyZWZsZWN0QXBwbHkoZnVuY3Rpb24gKCkgeyB0aHJvdyA0MjsgfSwgbnVsbCwgYmFkQXJyYXlMaWtlKTtcblx0fSBjYXRjaCAoXykge1xuXHRcdGlmIChfICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7XG5cdFx0XHRyZWZsZWN0QXBwbHkgPSBudWxsO1xuXHRcdH1cblx0fVxufSBlbHNlIHtcblx0cmVmbGVjdEFwcGx5ID0gbnVsbDtcbn1cblxudmFyIGNvbnN0cnVjdG9yUmVnZXggPSAvXlxccypjbGFzc1xcYi87XG52YXIgaXNFUzZDbGFzc0ZuID0gZnVuY3Rpb24gaXNFUzZDbGFzc0Z1bmN0aW9uKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0dmFyIGZuU3RyID0gZm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gY29uc3RydWN0b3JSZWdleC50ZXN0KGZuU3RyKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTsgLy8gbm90IGEgZnVuY3Rpb25cblx0fVxufTtcblxudmFyIHRyeUZ1bmN0aW9uT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RnVuY3Rpb25Ub1N0cih2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGlmIChpc0VTNkNsYXNzRm4odmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZuVG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG9iamVjdENsYXNzID0gJ1tvYmplY3QgT2JqZWN0XSc7XG52YXIgZm5DbGFzcyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG52YXIgZ2VuQ2xhc3MgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xudmFyIGRkYUNsYXNzID0gJ1tvYmplY3QgSFRNTEFsbENvbGxlY3Rpb25dJzsgLy8gSUUgMTFcbnZhciBkZGFDbGFzczIgPSAnW29iamVjdCBIVE1MIGRvY3VtZW50LmFsbCBjbGFzc10nO1xudmFyIGRkYUNsYXNzMyA9ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXSc7IC8vIElFIDktMTBcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7IC8vIGJldHRlcjogdXNlIGBoYXMtdG9zdHJpbmd0YWdgXG5cbnZhciBpc0lFNjggPSAhKDAgaW4gWyxdKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zcGFyc2UtYXJyYXlzLCBjb21tYS1zcGFjaW5nXG5cbnZhciBpc0REQSA9IGZ1bmN0aW9uIGlzRG9jdW1lbnREb3RBbGwoKSB7IHJldHVybiBmYWxzZTsgfTtcbmlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnKSB7XG5cdC8vIEZpcmVmb3ggMyBjYW5vbmljYWxpemVzIEREQSB0byB1bmRlZmluZWQgd2hlbiBpdCdzIG5vdCBhY2Nlc3NlZCBkaXJlY3RseVxuXHR2YXIgYWxsID0gZG9jdW1lbnQuYWxsO1xuXHRpZiAodG9TdHIuY2FsbChhbGwpID09PSB0b1N0ci5jYWxsKGRvY3VtZW50LmFsbCkpIHtcblx0XHRpc0REQSA9IGZ1bmN0aW9uIGlzRG9jdW1lbnREb3RBbGwodmFsdWUpIHtcblx0XHRcdC8qIGdsb2JhbHMgZG9jdW1lbnQ6IGZhbHNlICovXG5cdFx0XHQvLyBpbiBJRSA2LTgsIHR5cGVvZiBkb2N1bWVudC5hbGwgaXMgXCJvYmplY3RcIiBhbmQgaXQncyB0cnV0aHlcblx0XHRcdGlmICgoaXNJRTY4IHx8ICF2YWx1ZSkgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdHN0ciA9PT0gZGRhQ2xhc3Ncblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gZGRhQ2xhc3MyXG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IGRkYUNsYXNzMyAvLyBvcGVyYSAxMi4xNlxuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBvYmplY3RDbGFzcyAvLyBJRSA2LThcblx0XHRcdFx0XHQpICYmIHZhbHVlKCcnKSA9PSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuXHRcdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWZsZWN0QXBwbHlcblx0PyBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdFx0aWYgKGlzRERBKHZhbHVlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHRyeSB7XG5cdFx0XHRyZWZsZWN0QXBwbHkodmFsdWUsIG51bGwsIGJhZEFycmF5TGlrZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKGUgIT09IGlzQ2FsbGFibGVNYXJrZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0fVxuXHRcdHJldHVybiAhaXNFUzZDbGFzc0ZuKHZhbHVlKSAmJiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7XG5cdH1cblx0OiBmdW5jdGlvbiBpc0NhbGxhYmxlKHZhbHVlKSB7XG5cdFx0aWYgKGlzRERBKHZhbHVlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmIChoYXNUb1N0cmluZ1RhZykgeyByZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpOyB9XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIHN0ckNsYXNzID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdFx0aWYgKHN0ckNsYXNzICE9PSBmbkNsYXNzICYmIHN0ckNsYXNzICE9PSBnZW5DbGFzcyAmJiAhKC9eXFxbb2JqZWN0IEhUTUwvKS50ZXN0KHN0ckNsYXNzKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRyZXR1cm4gdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpO1xuXHR9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGblJlZ2V4ID0gL15cXHMqKD86ZnVuY3Rpb24pP1xcKi87XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIGdldEdlbmVyYXRvckZ1bmMgPSBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uKigpIHt9JykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG59O1xudmFyIEdlbmVyYXRvckZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24oZm4pIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAoaXNGblJlZ2V4LnRlc3QoZm5Ub1N0ci5jYWxsKGZuKSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0dmFyIHN0ciA9IHRvU3RyLmNhbGwoZm4pO1xuXHRcdHJldHVybiBzdHIgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cdH1cblx0aWYgKCFnZXRQcm90bykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAodHlwZW9mIEdlbmVyYXRvckZ1bmN0aW9uID09PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciBnZW5lcmF0b3JGdW5jID0gZ2V0R2VuZXJhdG9yRnVuYygpO1xuXHRcdEdlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuYyA/IGdldFByb3RvKGdlbmVyYXRvckZ1bmMpIDogZmFsc2U7XG5cdH1cblx0cmV0dXJuIGdldFByb3RvKGZuKSA9PT0gR2VuZXJhdG9yRnVuY3Rpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcbnZhciBnZXRQb2x5ZmlsbCA9IHJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnZhciBzaGltID0gcmVxdWlyZSgnLi9zaGltJyk7XG5cbnZhciBwb2x5ZmlsbCA9IGNhbGxCaW5kKGdldFBvbHlmaWxsKCksIE51bWJlcik7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxuZGVmaW5lKHBvbHlmaWxsLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoTnVtYmVyLmlzTmFOICYmIE51bWJlci5pc05hTihOYU4pICYmICFOdW1iZXIuaXNOYU4oJ2EnKSkge1xuXHRcdHJldHVybiBOdW1iZXIuaXNOYU47XG5cdH1cblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltTnVtYmVySXNOYU4oKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShOdW1iZXIsIHsgaXNOYU46IHBvbHlmaWxsIH0sIHtcblx0XHRpc05hTjogZnVuY3Rpb24gdGVzdElzTmFOKCkge1xuXHRcdFx0cmV0dXJuIE51bWJlci5pc05hTiAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHdoaWNoVHlwZWRBcnJheSA9IHJlcXVpcmUoJ3doaWNoLXR5cGVkLWFycmF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG5cdHJldHVybiAhIXdoaWNoVHlwZWRBcnJheSh2YWx1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbnVtYmVySXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXMoYSwgYikge1xuXHRpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7XG5cdFx0cmV0dXJuIDEgLyBhID09PSAxIC8gYjtcblx0fVxuXHRpZiAoYSA9PT0gYikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmIChudW1iZXJJc05hTihhKSAmJiBudW1iZXJJc05hTihiKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCdjYWxsLWJpbmQnKTtcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIHNoaW0gPSByZXF1aXJlKCcuL3NoaW0nKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgT2JqZWN0KTtcblxuZGVmaW5lKHBvbHlmaWxsLCB7XG5cdGdldFBvbHlmaWxsOiBnZXRQb2x5ZmlsbCxcblx0aW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uLFxuXHRzaGltOiBzaGltXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXR1cm4gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGltcGxlbWVudGF0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFBvbHlmaWxsID0gcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJ2RlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU9iamVjdElzKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoT2JqZWN0LCB7IGlzOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXM6IGZ1bmN0aW9uIHRlc3RPYmplY3RJcygpIHtcblx0XHRcdHJldHVybiBPYmplY3QuaXMgIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZXlzU2hpbTtcbmlmICghT2JqZWN0LmtleXMpIHtcblx0Ly8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ2xvYmFsLXJlcXVpcmVcblx0dmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cdHZhciBoYXNEb250RW51bUJ1ZyA9ICFpc0VudW1lcmFibGUuY2FsbCh7IHRvU3RyaW5nOiBudWxsIH0sICd0b1N0cmluZycpO1xuXHR2YXIgaGFzUHJvdG9FbnVtQnVnID0gaXNFbnVtZXJhYmxlLmNhbGwoZnVuY3Rpb24gKCkge30sICdwcm90b3R5cGUnKTtcblx0dmFyIGRvbnRFbnVtcyA9IFtcblx0XHQndG9TdHJpbmcnLFxuXHRcdCd0b0xvY2FsZVN0cmluZycsXG5cdFx0J3ZhbHVlT2YnLFxuXHRcdCdoYXNPd25Qcm9wZXJ0eScsXG5cdFx0J2lzUHJvdG90eXBlT2YnLFxuXHRcdCdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG5cdFx0J2NvbnN0cnVjdG9yJ1xuXHRdO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUgPSBmdW5jdGlvbiAobykge1xuXHRcdHZhciBjdG9yID0gby5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gbztcblx0fTtcblx0dmFyIGV4Y2x1ZGVkS2V5cyA9IHtcblx0XHQkYXBwbGljYXRpb25DYWNoZTogdHJ1ZSxcblx0XHQkY29uc29sZTogdHJ1ZSxcblx0XHQkZXh0ZXJuYWw6IHRydWUsXG5cdFx0JGZyYW1lOiB0cnVlLFxuXHRcdCRmcmFtZUVsZW1lbnQ6IHRydWUsXG5cdFx0JGZyYW1lczogdHJ1ZSxcblx0XHQkaW5uZXJIZWlnaHQ6IHRydWUsXG5cdFx0JGlubmVyV2lkdGg6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmNoYW5nZTogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuZXJyb3I6IHRydWUsXG5cdFx0JG91dGVySGVpZ2h0OiB0cnVlLFxuXHRcdCRvdXRlcldpZHRoOiB0cnVlLFxuXHRcdCRwYWdlWE9mZnNldDogdHJ1ZSxcblx0XHQkcGFnZVlPZmZzZXQ6IHRydWUsXG5cdFx0JHBhcmVudDogdHJ1ZSxcblx0XHQkc2Nyb2xsTGVmdDogdHJ1ZSxcblx0XHQkc2Nyb2xsVG9wOiB0cnVlLFxuXHRcdCRzY3JvbGxYOiB0cnVlLFxuXHRcdCRzY3JvbGxZOiB0cnVlLFxuXHRcdCRzZWxmOiB0cnVlLFxuXHRcdCR3ZWJraXRJbmRleGVkREI6IHRydWUsXG5cdFx0JHdlYmtpdFN0b3JhZ2VJbmZvOiB0cnVlLFxuXHRcdCR3aW5kb3c6IHRydWVcblx0fTtcblx0dmFyIGhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRmb3IgKHZhciBrIGluIHdpbmRvdykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCFleGNsdWRlZEtleXNbJyQnICsga10gJiYgaGFzLmNhbGwod2luZG93LCBrKSAmJiB3aW5kb3dba10gIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvd1trXSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0ZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUod2luZG93W2tdKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSgpKTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0LyogZ2xvYmFsIHdpbmRvdyAqL1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnKSB7XG5cdFx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGUobyk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHRrZXlzU2hpbSA9IGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG5cdFx0dmFyIGlzT2JqZWN0ID0gb2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xuXHRcdHZhciBpc0Z1bmN0aW9uID0gdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHRcdHZhciBpc0FyZ3VtZW50cyA9IGlzQXJncyhvYmplY3QpO1xuXHRcdHZhciBpc1N0cmluZyA9IGlzT2JqZWN0ICYmIHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cdFx0dmFyIHRoZUtleXMgPSBbXTtcblxuXHRcdGlmICghaXNPYmplY3QgJiYgIWlzRnVuY3Rpb24gJiYgIWlzQXJndW1lbnRzKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiBpc0Z1bmN0aW9uO1xuXHRcdGlmIChpc1N0cmluZyAmJiBvYmplY3QubGVuZ3RoID4gMCAmJiAhaGFzLmNhbGwob2JqZWN0LCAwKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhpKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzQXJndW1lbnRzICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdC5sZW5ndGg7ICsraikge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGopKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09ICdwcm90b3R5cGUnKSAmJiBoYXMuY2FsbChvYmplY3QsIG5hbWUpKSB7XG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhuYW1lKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaGFzRG9udEVudW1CdWcpIHtcblx0XHRcdHZhciBza2lwQ29uc3RydWN0b3IgPSBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kob2JqZWN0KTtcblxuXHRcdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBkb250RW51bXMubGVuZ3RoOyArK2spIHtcblx0XHRcdFx0aWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtc1trXSA9PT0gJ2NvbnN0cnVjdG9yJykgJiYgaGFzLmNhbGwob2JqZWN0LCBkb250RW51bXNba10pKSB7XG5cdFx0XHRcdFx0dGhlS2V5cy5wdXNoKGRvbnRFbnVtc1trXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoZUtleXM7XG5cdH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaXNBcmdzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpO1xuXG52YXIgb3JpZ0tleXMgPSBPYmplY3Qua2V5cztcbnZhciBrZXlzU2hpbSA9IG9yaWdLZXlzID8gZnVuY3Rpb24ga2V5cyhvKSB7IHJldHVybiBvcmlnS2V5cyhvKTsgfSA6IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxudmFyIG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzO1xuXG5rZXlzU2hpbS5zaGltID0gZnVuY3Rpb24gc2hpbU9iamVjdEtleXMoKSB7XG5cdGlmIChPYmplY3Qua2V5cykge1xuXHRcdHZhciBrZXlzV29ya3NXaXRoQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFNhZmFyaSA1LjAgYnVnXG5cdFx0XHR2YXIgYXJncyA9IE9iamVjdC5rZXlzKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gYXJncyAmJiBhcmdzLmxlbmd0aCA9PT0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHR9KDEsIDIpKTtcblx0XHRpZiAoIWtleXNXb3Jrc1dpdGhBcmd1bWVudHMpIHtcblx0XHRcdE9iamVjdC5rZXlzID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcblx0XHRcdFx0aWYgKGlzQXJncyhvYmplY3QpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhzbGljZS5jYWxsKG9iamVjdCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvcmlnaW5hbEtleXMob2JqZWN0KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdE9iamVjdC5rZXlzID0ga2V5c1NoaW07XG5cdH1cblx0cmV0dXJuIE9iamVjdC5rZXlzIHx8IGtleXNTaGltO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHR2YXIgc3RyID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG5cdHZhciBpc0FyZ3MgPSBzdHIgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXHRpZiAoIWlzQXJncykge1xuXHRcdGlzQXJncyA9IHN0ciAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0dG9TdHIuY2FsbCh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBpc0FyZ3M7XG59O1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5jb25zdCBiYWNrZW5kcyA9IHt9O1xuY29uc3QgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5ID0gW107XG4vKipcbiAqIFJlZ2lzdGVyIGEgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIGFzIGEga2V5IHRvIGxvb2t1cCBhcyBhbiBleGVjdXRpb24gcHJvdmlkZXIuXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBiYWNrZW5kIG9iamVjdC5cbiAqIEBwYXJhbSBwcmlvcml0eSAtIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgcHJpb3JpdHkgb2YgdGhlIGJhY2tlbmQuIEhpZ2hlciBudW1iZXIgbWVhbnMgaGlnaGVyIHByaW9yaXR5LiBpZiBwcmlvcml0eVxuICogPCAwLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYSAnYmV0YScgdmVyc2lvbiBhbmQgd2lsbCBub3QgYmUgdXNlZCBhcyBhIGZhbGxiYWNrIGJhY2tlbmQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyQmFja2VuZCA9IChuYW1lLCBiYWNrZW5kLCBwcmlvcml0eSkgPT4ge1xuICAgIGlmIChiYWNrZW5kICYmIHR5cGVvZiBiYWNrZW5kLmluaXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGJhY2tlbmQuY3JlYXRlU2Vzc2lvbkhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEJhY2tlbmQgPSBiYWNrZW5kc1tuYW1lXTtcbiAgICAgICAgaWYgKGN1cnJlbnRCYWNrZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJhY2tlbmRzW25hbWVdID0geyBiYWNrZW5kLCBwcmlvcml0eSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRCYWNrZW5kLnByaW9yaXR5ID4gcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIC8vIHNhbWUgbmFtZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgd2l0aCBhIGhpZ2hlciBwcmlvcml0eS4gc2tpcCByZWdpc3RlcmF0aW9uLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRCYWNrZW5kLnByaW9yaXR5ID09PSBwcmlvcml0eSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRCYWNrZW5kLmJhY2tlbmQgIT09IGJhY2tlbmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtuYW1lfVwiIHVzaW5nIHByaW9yaXR5ICR7cHJpb3JpdHl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yaXR5ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChiYWNrZW5kc1tiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHlbaV1dLnByaW9yaXR5IDw9IHByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIHZhbGlkIGJhY2tlbmQnKTtcbn07XG4vKipcbiAqIFJlc29sdmUgYmFja2VuZCBieSBzcGVjaWZpZWQgaGludHMuXG4gKlxuICogQHBhcmFtIGJhY2tlbmRIaW50cyAtIGEgbGlzdCBvZiBleGVjdXRpb24gcHJvdmlkZXIgbmFtZXMgdG8gbG9va3VwLiBJZiBvbWl0dGVkIHVzZSByZWdpc3RlcmVkIGJhY2tlbmRzIGFzIGxpc3QuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgYmFja2VuZC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVCYWNrZW5kID0gYXN5bmMgKGJhY2tlbmRIaW50cykgPT4ge1xuICAgIGNvbnN0IGJhY2tlbmROYW1lcyA9IGJhY2tlbmRIaW50cy5sZW5ndGggPT09IDAgPyBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkgOiBiYWNrZW5kSGludHM7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcbiAgICAgICAgY29uc3QgYmFja2VuZEluZm8gPSBiYWNrZW5kc1tiYWNrZW5kTmFtZV07XG4gICAgICAgIGlmIChiYWNrZW5kSW5mbykge1xuICAgICAgICAgICAgaWYgKGJhY2tlbmRJbmZvLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmJhY2tlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiYWNrZW5kSW5mby5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIGN1cnJlbnQgYmFja2VuZCBpcyB1bmF2YWlsYWJsZTsgdHJ5IG5leHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzSW5pdGlhbGl6aW5nID0gISFiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5pbml0UHJvbWlzZSA9IGJhY2tlbmRJbmZvLmJhY2tlbmQuaW5pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmJhY2tlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBuYW1lOiBiYWNrZW5kTmFtZSwgZXJyOiBlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7ZXJyb3JzLm1hcChlID0+IGBbJHtlLm5hbWV9XSAke2UuZXJyfWApLmpvaW4oJywgJyl9YCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja2VuZC1pbXBsLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuZXhwb3J0IHsgcmVnaXN0ZXJCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLWltcGwnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja2VuZC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmV4cG9ydCBjbGFzcyBFbnZJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy53YXNtID0ge307XG4gICAgICAgIHRoaXMud2ViZ2wgPSB7fTtcbiAgICAgICAgdGhpcy5sb2dMZXZlbEludGVybmFsID0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICAvLyBUT0RPIHN0YW5kYWRpemUgdGhlIGdldHRlciBhbmQgc2V0dGVyIGNvbnZlbnRpb24gaW4gZW52IGZvciBvdGhlciBmaWVsZHMuXG4gICAgc2V0IGxvZ0xldmVsKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgWyd2ZXJib3NlJywgJ2luZm8nLCAnd2FybmluZycsICdlcnJvcicsICdmYXRhbCddLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nTGV2ZWxJbnRlcm5hbCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgbG9nTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0xldmVsSW50ZXJuYWw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52LWltcGwuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyBFbnZJbXBsIH0gZnJvbSAnLi9lbnYtaW1wbCc7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBhcyBhIGdsb2JhbCBzaW5nbGV0b24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnYgPSBuZXcgRW52SW1wbCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuLyoqXG4gKiAjIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSVxuICpcbiAqIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSSBpcyBhIHVuaWZpZWQgQVBJIGZvciBhbGwgSmF2YVNjcmlwdCB1c2FnZXMsIGluY2x1ZGluZyB0aGUgZm9sbG93aW5nIE5QTSBwYWNrYWdlczpcbiAqXG4gKiAtIFtvbm54cnVudGltZS1ub2RlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1ub2RlKVxuICogLSBbb25ueHJ1bnRpbWUtd2ViXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS13ZWIpXG4gKiAtIFtvbm54cnVudGltZS1yZWFjdC1uYXRpdmVdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZSlcbiAqXG4gKiBTZWUgYWxzbzpcbiAqIC0gW0dldCBTdGFydGVkXShodHRwczovL29ubnhydW50aW1lLmFpL2RvY3MvZ2V0LXN0YXJ0ZWQvd2l0aC1qYXZhc2NyaXB0Lmh0bWwpXG4gKiAtIFtJbmZlcmVuY2UgZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUtaW5mZXJlbmNlLWV4YW1wbGVzL3RyZWUvbWFpbi9qcylcbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuZXhwb3J0ICogZnJvbSAnLi9iYWNrZW5kJztcbmV4cG9ydCAqIGZyb20gJy4vZW52JztcbmV4cG9ydCAqIGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24nO1xuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3InO1xuZXhwb3J0ICogZnJvbSAnLi9vbm54LXZhbHVlJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuaW1wb3J0IHsgcmVzb2x2ZUJhY2tlbmQgfSBmcm9tICcuL2JhY2tlbmQtaW1wbCc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvcic7XG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoaGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICBhc3luYyBydW4oZmVlZHMsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgZmV0Y2hlcyA9IHt9O1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgICAgICAvLyBjaGVjayBpbnB1dHNcbiAgICAgICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZlZWRzXFwnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggb3ZlcnJpZGUgaXMgYmVpbmcgdXNlZFxuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhIFRlbnNvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gb3V0cHV0IG5hbWVzXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke25hbWV9LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgICAgICAgICAgLy8gaWYgYW55IG91dHB1dCBuYW1lIGlzIHByZXNlbnQgYW5kIGl0cyB2YWx1ZSBpcyB2YWxpZCBPbm54VmFsdWUsIHdlIGNvbnNpZGVyIGl0IGZldGNoZXNcbiAgICAgICAgICAgICAgICBsZXQgaXNGZXRjaGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5vdXRwdXROYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBhcmcxW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT09IG51bGwgfHwgdiBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaGVzW25hbWVdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNGZXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlIFxcJ2ZldGNoZXNcXCcgb3IgXFwnb3B0aW9uc1xcJy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmlucHV0TmFtZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmVlZHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtuYW1lfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vIGZldGNoZXMgaXMgc3BlY2lmaWVkLCB3ZSB1c2UgdGhlIGZ1bGwgb3V0cHV0IG5hbWVzIGxpc3RcbiAgICAgICAgaWYgKGlzRmV0Y2hlc0VtcHR5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5vdXRwdXROYW1lcykge1xuICAgICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zIGFyZSBwcmVwYXJlZFxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1bihmZWVkcywgZmV0Y2hlcywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0c1trZXldLnR5cGUsIHJlc3VsdHNba2V5XS5kYXRhLCByZXN1bHRzW2tleV0uZGltcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgLy8gZWl0aGVyIGxvYWQgZnJvbSBhIGZpbGUgb3IgYnVmZmVyXG4gICAgICAgIGxldCBmaWxlUGF0aE9yVWludDhBcnJheTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBhcmcwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBhcmcwIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhcmcwO1xuICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSBhcmcxO1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2J5dGVPZmZzZXRcXCcgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYnl0ZU9mZnNldCA+PSBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHtidWZmZXIuYnl0ZUxlbmd0aH0pLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieXRlTGVuZ3RoID0gYXJnMC5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggPSBhcmcyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnYnl0ZUxlbmd0aFxcJyBtdXN0IGJlIGFuIGludGVnZXIuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtidWZmZXIuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXR9XS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzMgPT09ICdvYmplY3QnICYmIGFyZzMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmczO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmczICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnYnl0ZUxlbmd0aFxcJyBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlIFxcJ3BhdGhcXCcgb3IgXFwnYnVmZmVyXFwnLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBiYWNrZW5kIGhpbnRzXG4gICAgICAgIGNvbnN0IGVwcyA9IG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzIHx8IFtdO1xuICAgICAgICBjb25zdCBiYWNrZW5kSGludHMgPSBlcHMubWFwKGkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSk7XG4gICAgICAgIGNvbnN0IGJhY2tlbmQgPSBhd2FpdCByZXNvbHZlQmFja2VuZChiYWNrZW5kSGludHMpO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gYXdhaXQgYmFja2VuZC5jcmVhdGVTZXNzaW9uSGFuZGxlcihmaWxlUGF0aE9yVWludDhBcnJheSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5mZXJlbmNlU2Vzc2lvbihoYW5kbGVyKTtcbiAgICB9XG4gICAgc3RhcnRQcm9maWxpbmcoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpO1xuICAgIH1cbiAgICBlbmRQcm9maWxpbmcoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKTtcbiAgICB9XG4gICAgZ2V0IGlucHV0TmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lcztcbiAgICB9XG4gICAgZ2V0IG91dHB1dE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmVyZW5jZS1zZXNzaW9uLWltcGwuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb25JbXBsIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBJbmZlcmVuY2VTZXNzaW9uID0gSW5mZXJlbmNlU2Vzc2lvbkltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZlcmVuY2Utc2Vzc2lvbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ubngtdmFsdWUuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5jb25zdCBpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnSW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEJpZ0ludDY0QXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnVWludDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBCaWdVaW50NjRBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nO1xuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAgPSBuZXcgTWFwKFtcbiAgICBbJ2Zsb2F0MzInLCBGbG9hdDMyQXJyYXldLFxuICAgIFsndWludDgnLCBVaW50OEFycmF5XSxcbiAgICBbJ2ludDgnLCBJbnQ4QXJyYXldLFxuICAgIFsndWludDE2JywgVWludDE2QXJyYXldLFxuICAgIFsnaW50MTYnLCBJbnQxNkFycmF5XSxcbiAgICBbJ2ludDMyJywgSW50MzJBcnJheV0sXG4gICAgWydib29sJywgVWludDhBcnJheV0sXG4gICAgWydmbG9hdDY0JywgRmxvYXQ2NEFycmF5XSxcbiAgICBbJ3VpbnQzMicsIFVpbnQzMkFycmF5XSxcbl0pO1xuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAgPSBuZXcgTWFwKFtcbiAgICBbRmxvYXQzMkFycmF5LCAnZmxvYXQzMiddLFxuICAgIFtVaW50OEFycmF5LCAndWludDgnXSxcbiAgICBbSW50OEFycmF5LCAnaW50OCddLFxuICAgIFtVaW50MTZBcnJheSwgJ3VpbnQxNiddLFxuICAgIFtJbnQxNkFycmF5LCAnaW50MTYnXSxcbiAgICBbSW50MzJBcnJheSwgJ2ludDMyJ10sXG4gICAgW0Zsb2F0NjRBcnJheSwgJ2Zsb2F0NjQnXSxcbiAgICBbVWludDMyQXJyYXksICd1aW50MzInXSxcbl0pO1xuaWYgKGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdpbnQ2NCcsIEJpZ0ludDY0QXJyYXkpO1xuICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEJpZ0ludDY0QXJyYXksICdpbnQ2NCcpO1xufVxuaWYgKGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgndWludDY0JywgQmlnVWludDY0QXJyYXkpO1xuICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEJpZ1VpbnQ2NEFycmF5LCAndWludDY0Jyk7XG59XG4vKipcbiAqIGNhbGN1bGF0ZSBzaXplIGZyb20gZGltcy5cbiAqXG4gKiBAcGFyYW0gZGltcyB0aGUgZGltcyBhcnJheS4gTWF5IGJlIGFuIGlsbGVnYWwgaW5wdXQuXG4gKi9cbmNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltcykgPT4ge1xuICAgIGxldCBzaXplID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGltID0gZGltc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBkaW0gIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7aX1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke2RpbX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xuICAgICAgICB9XG4gICAgICAgIHNpemUgKj0gZGltO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn07XG5leHBvcnQgY2xhc3MgVGVuc29yIHtcbiAgICBjb25zdHJ1Y3RvcihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGxldCB0eXBlO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgbGV0IGRpbXM7XG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXJnMCBpcyB0eXBlIG9yIGRhdGFcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3Rvcih0eXBlLCBkYXRhLCAuLi4pXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdHlwZSA9IGFyZzA7XG4gICAgICAgICAgICBkaW1zID0gYXJnMjtcbiAgICAgICAgICAgIGlmIChhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIHN0cmluZyB0ZW5zb3JcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBzdHJpbmcgdGVuc29yXFwncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGNoZWNrIHdoZXRoZXIgZXZlcnkgZWxlbWVudCBpbiB0aGUgYXJyYXkgaXMgc3RyaW5nOyB0aGlzIGlzIHRvbyBzbG93LiB3ZSBhc3N1bWUgaXQncyBjb3JyZWN0IGFuZFxuICAgICAgICAgICAgICAgIC8vIGVycm9yIHdpbGwgYmUgcG9wdWxhdGVkIGF0IGluZmVyZW5jZVxuICAgICAgICAgICAgICAgIGRhdGEgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbnVtZXJpYyB0ZW5zb3JcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldChhcmcwKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZWRBcnJheUNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7YXJnMH0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSAnYXMgYW55JyBoZXJlIGJlY2F1c2UgVHlwZVNjcmlwdCdzIGNoZWNrIG9uIHR5cGUgb2YgJ1N1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMuZnJvbSgpJyBwcm9kdWNlc1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmNvcnJlY3QgcmVzdWx0cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gJ3R5cGVkQXJyYXlDb25zdHJ1Y3Rvcicgc2hvdWxkIGJlIG9uZSBvZiB0aGUgdHlwZWQgYXJyYXkgcHJvdG90eXBlIG9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlZEFycmF5Q29uc3RydWN0b3IuZnJvbShhcmcxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnMSBpbnN0YW5jZW9mIHR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgJHt0eXBlfSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiAke3R5cGVkQXJyYXlDb25zdHJ1Y3Rvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKGRhdGEsIC4uLilcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBkaW1zID0gYXJnMTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBib29sZWFuW10gYW5kIHN0cmluZ1tdIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIGlmIChhcmcwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUZW5zb3IgdHlwZSBjYW5ub3QgYmUgaW5mZXJyZWQgZnJvbSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RFbGVtZW50VHlwZSA9IHR5cGVvZiBhcmcwWzBdO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhcmcwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdib29sJztcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2FyZzAnIGlzIG9mIHR5cGUgJ2Jvb2xlYW5bXScuIFVpbnQ4QXJyYXkuZnJvbShib29sZWFuW10pIGFjdHVhbGx5IHdvcmtzLCBidXQgdHlwZXNjcmlwdCB0aGlua3MgdGhpcyBpc1xuICAgICAgICAgICAgICAgICAgICAvLyB3cm9uZyB0eXBlLiBXZSB1c2UgJ2FzIGFueScgdG8gbWFrZSBpdCBoYXBweS5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShhcmcwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7Zmlyc3RFbGVtZW50VHlwZX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRlbnNvciB0eXBlIGZyb20gVHlwZWRBcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBlZFR5cGUgPSBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLmdldChhcmcwLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgZm9yIHRlbnNvciBkYXRhOiAke2FyZzAuY29uc3RydWN0b3J9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eXBlID0gbWFwcGVkVHlwZTtcbiAgICAgICAgICAgICAgICBkYXRhID0gYXJnMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0eXBlIGFuZCBkYXRhIGlzIHByb2Nlc3NlZCwgbm93IHByb2Nlc3NpbmcgZGltc1xuICAgICAgICBpZiAoZGltcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBhc3N1bWUgMS1EIHRlbnNvciBpZiBkaW1zIG9taXR0ZWRcbiAgICAgICAgICAgIGRpbXMgPSBbZGF0YS5sZW5ndGhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGRpbXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHRlbnNvclxcJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybSBjaGVja1xuICAgICAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlU2l6ZShkaW1zKTtcbiAgICAgICAgaWYgKHNpemUgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHtzaXplfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHtkYXRhLmxlbmd0aH0pLmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGltcyA9IGRpbXM7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIGltYWdlIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1ZmZlciAtIEV4dHJhY3RlZCBpbWFnZSBidWZmZXIgZGF0YSAtIGFzc3VtaW5nIFJHQkEgZm9ybWF0XG4gICAgICogQHBhcmFtIGltYWdlRm9ybWF0IC0gaW5wdXQgaW1hZ2UgY29uZmlndXJhdGlvbiAtIHJlcXVpcmVkIGNvbmZpZ3VyYXRpb25zIGhlaWdodCwgd2lkdGgsIGZvcm1hdFxuICAgICAqIEBwYXJhbSB0ZW5zb3JGb3JtYXQgLSBvdXRwdXQgdGVuc29yIGNvbmZpZ3VyYXRpb24gLSBEZWZhdWx0IGlzIFJHQiBmb3JtYXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYnVmZmVyVG9UZW5zb3IoYnVmZmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBidWZmZXIgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBub3JtID0gb3B0aW9ucy5ub3JtO1xuICAgICAgICBsZXQgbm9ybU1lYW47XG4gICAgICAgIGxldCBub3JtQmlhcztcbiAgICAgICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybU1lYW4gPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3JtTWVhbiA9IG5vcm0ubWVhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3JtQmlhcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3JtQmlhcyA9IG5vcm0uYmlhcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMuYml0bWFwRm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJpdG1hcEZvcm1hdCA6ICdSR0JBJztcbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZSBpcyBSR0JBIHNpbmNlIGltYWdlZGF0YSBhbmQgSFRNTEltYWdlRWxlbWVudCB1c2VzIGl0XG4gICAgICAgIGNvbnN0IG91dHB1dGZvcm1hdCA9IG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgKG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRlbnNvckZvcm1hdCA6ICdSR0InKSA6XG4gICAgICAgICAgICAnUkdCJztcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgICAgIGNvbnN0IGZsb2F0MzJEYXRhID0gb3V0cHV0Zm9ybWF0ID09PSAnUkdCQScgPyBuZXcgRmxvYXQzMkFycmF5KG9mZnNldCAqIDQpIDogbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKiAzKTtcbiAgICAgICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gICAgICAgIGxldCBzdGVwID0gNCwgckltYWdlUG9pbnRlciA9IDAsIGdJbWFnZVBvaW50ZXIgPSAxLCBiSW1hZ2VQb2ludGVyID0gMiwgYUltYWdlUG9pbnRlciA9IDM7XG4gICAgICAgIGxldCByVGVuc29yUG9pbnRlciA9IDAsIGdUZW5zb3JQb2ludGVyID0gb2Zmc2V0LCBiVGVuc29yUG9pbnRlciA9IG9mZnNldCAqIDIsIGFUZW5zb3JQb2ludGVyID0gLTE7XG4gICAgICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICAgICAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgICAgICAgICAgc3RlcCA9IDM7XG4gICAgICAgICAgICBySW1hZ2VQb2ludGVyID0gMDtcbiAgICAgICAgICAgIGdJbWFnZVBvaW50ZXIgPSAxO1xuICAgICAgICAgICAgYkltYWdlUG9pbnRlciA9IDI7XG4gICAgICAgICAgICBhSW1hZ2VQb2ludGVyID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIG91dHB1dCB0ZW5zb3IgZm9ybWF0XG4gICAgICAgIGlmIChvdXRwdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgICAgICAgYVRlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICAgICAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gb2Zmc2V0O1xuICAgICAgICAgICAgZ1RlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ0JHUicpIHtcbiAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgICAgICAgIGdUZW5zb3JQb2ludGVyID0gb2Zmc2V0O1xuICAgICAgICAgICAgclRlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2Zmc2V0OyBpKyssIHJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGFJbWFnZVBvaW50ZXIgKz0gc3RlcCkge1xuICAgICAgICAgICAgZmxvYXQzMkRhdGFbclRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW3JJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXMpIC8gbm9ybU1lYW47XG4gICAgICAgICAgICBmbG9hdDMyRGF0YVtnVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbZ0ltYWdlUG9pbnRlcl0gKyBub3JtQmlhcykgLyBub3JtTWVhbjtcbiAgICAgICAgICAgIGZsb2F0MzJEYXRhW2JUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltiSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzKSAvIG5vcm1NZWFuO1xuICAgICAgICAgICAgaWYgKGFUZW5zb3JQb2ludGVyICE9PSAtMSAmJiBhSW1hZ2VQb2ludGVyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZsb2F0MzJEYXRhW2FUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlclthSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzKSAvIG5vcm1NZWFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZsb2F0MzJBcnJheSAtPiBvcnQuVGVuc29yXG4gICAgICAgIGNvbnN0IG91dHB1dFRlbnNvciA9IG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnID8gbmV3IFRlbnNvcignZmxvYXQzMicsIGZsb2F0MzJEYXRhLCBbMSwgNCwgaGVpZ2h0LCB3aWR0aF0pIDpcbiAgICAgICAgICAgIG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDMsIGhlaWdodCwgd2lkdGhdKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dFRlbnNvcjtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGZyb21JbWFnZShpbWFnZSwgb3B0aW9ucykge1xuICAgICAgICAvLyBjaGVja2luZyB0aGUgdHlwZSBvZiBpbWFnZSBvYmplY3RcbiAgICAgICAgY29uc3QgaXNIVE1MSW1hZ2VFbGUgPSB0eXBlb2YgKEhUTUxJbWFnZUVsZW1lbnQpICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGlzSW1hZ2VEYXRhRWxlID0gdHlwZW9mIChJbWFnZURhdGEpICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlRGF0YTtcbiAgICAgICAgY29uc3QgaXNJbWFnZUJpdG1hcCA9IHR5cGVvZiAoSW1hZ2VCaXRtYXApICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwO1xuICAgICAgICBjb25zdCBpc1VSTCA9IHR5cGVvZiAoU3RyaW5nKSAhPT0gJ3VuZGVmaW5lZCcgJiYgKGltYWdlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgbGV0IHRlbnNvckNvbmZpZyA9IHt9O1xuICAgICAgICAvLyBmaWxsaW5nIGFuZCBjaGVja2luZyBpbWFnZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgICAgaWYgKGlzSFRNTEltYWdlRWxlKSB7XG4gICAgICAgICAgICAvLyBIVE1MSW1hZ2VFbGVtZW50IC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IGlzIFJHQkEgYnkgZGVmYXVsdFxuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IGltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5yZXNpemVkSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBIVE1MSW1hZ2VFbGVtZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGhlaWdodCBkb2VzblxcJ3QgbWF0Y2ggSFRNTEltYWdlRWxlbWVudCBoZWlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgd2lkdGggZG9lc25cXCd0IG1hdGNoIEhUTUxJbWFnZUVsZW1lbnQgd2lkdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBwaXhlbHMyRENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJbWFnZURhdGFFbGUpIHtcbiAgICAgICAgICAgIC8vIEltYWdlRGF0YSAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBpcyBSR0JBIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgICAgIGxldCBoZWlnaHQ7XG4gICAgICAgICAgICBsZXQgd2lkdGg7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLnJlc2l6ZWRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBvcHRpb25zLnJlc2l6ZWRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYml0bWFwRm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5iaXRtYXBGb3JtYXQgIT09IGZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBJbWFnZURhdGEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy5iaXRtYXBGb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLmJpdG1hcEZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbnNvckNvbmZpZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0ZW5zb3JDb25maWcud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzMkRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gaW1hZ2UuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0ltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICAvLyBJbWFnZUJpdG1hcCAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBtdXN0IGJlIHByb3ZpZGVkIGJ5IHVzZXJcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGltYWdlIGNvbmZpZyB3aXRoIGZvcm1hdCBmb3IgSW1hZ2ViaXRtYXAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJpdG1hcEZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgZGVmaW5lZCBmb3IgSW1hZ2VCaXRtYXAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICBwaXhlbHMyRENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgc3F1YXJlIGJyYWNrZXRzIHRvIGF2b2lkIFRTIGVycm9yIC0gdHlwZSAnbmV2ZXInXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGhlaWdodCBkb2VzblxcJ3QgbWF0Y2ggSW1hZ2VCaXRtYXAgaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIHNxdWFyZSBicmFja2V0cyB0byBhdm9pZCBUUyBlcnJvciAtIHR5cGUgJ25ldmVyJ1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyB3aWR0aCBkb2VzblxcJ3QgbWF0Y2ggSW1hZ2VCaXRtYXAgd2lkdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRlbnNvci5idWZmZXJUb1RlbnNvcihkYXRhLCB0ZW5zb3JDb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNVUkwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGlmICghaW1hZ2UgfHwgIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIG5ld0ltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICAgICAgICAgICAgbmV3SW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgbmV3SW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBuZXdJbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IG5ld0ltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UobmV3SW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIHNxdWFyZSBicmFja2V0cyB0byBhdm9pZCBUUyBlcnJvciAtIHR5cGUgJ25ldmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oZWlnaHQgIT09IGNhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyBoZWlnaHQgZG9lc25cXCd0IG1hdGNoIEltYWdlQml0bWFwIGhlaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yQ29uZmlnLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBzcXVhcmUgYnJhY2tldHMgdG8gYXZvaWQgVFMgZXJyb3IgLSB0eXBlICduZXZlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy53aWR0aCAhPT0gY2FudmFzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgd2lkdGggZG9lc25cXCd0IG1hdGNoIEltYWdlQml0bWFwIHdpZHRoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zb3JDb25maWcuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNvckNvbmZpZy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFRlbnNvci5idWZmZXJUb1RlbnNvcihpbWcuZGF0YSwgdGVuc29yQ29uZmlnKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBUZW5zb3IuYnVmZmVyVG9UZW5zb3IoZGF0YSwgdGVuc29yQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0ltYWdlRGF0YShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGxldCBpbWFnZTtcbiAgICAgICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmRpbXNbM107XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmRpbXNbMl07XG4gICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IHRoaXMuZGltc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0InKSA6ICdSR0InO1xuICAgICAgICAgICAgY29uc3Qgbm9ybU1lYW4gPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyAoKChfYSA9IG9wdGlvbnMubm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lYW4pICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5vcm0ubWVhbiA6IDI1NSkgOiAyNTU7XG4gICAgICAgICAgICBjb25zdCBub3JtQmlhcyA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/ICgoKF9iID0gb3B0aW9ucy5ub3JtKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmlhcykgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubm9ybS5iaWFzIDogMCkgOiAwO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIG91dHB1dCBjb25maWcgaGVpZ2h0IGRvZXNuXFwndCBtYXRjaCB0ZW5zb3IgaGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy53aWR0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBvdXRwdXQgY29uZmlnIHdpZHRoIGRvZXNuXFwndCBtYXRjaCB0ZW5zb3Igd2lkdGgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgKGNoYW5uZWxzID09PSA0ICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCQScpIHx8XG4gICAgICAgICAgICAgICAgICAgIChjaGFubmVscyA9PT0gMyAmJiAob3B0aW9ucy5mb3JtYXQgIT09ICdSR0InICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnQkdSJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIGZvcm1hdCBkb2VzblxcJ3QgbWF0Y2ggaW5wdXQgdGVuc29yIGRpbXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSA0O1xuICAgICAgICAgICAgbGV0IHJJbWFnZVBvaW50ZXIgPSAwLCBnSW1hZ2VQb2ludGVyID0gMSwgYkltYWdlUG9pbnRlciA9IDIsIGFJbWFnZVBvaW50ZXIgPSAzO1xuICAgICAgICAgICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCwgZ1RlbnNvclBvaW50ZXIgPSBvZmZzZXQsIGJUZW5zb3JQb2ludGVyID0gb2Zmc2V0ICogMiwgYVRlbnNvclBvaW50ZXIgPSAtMTtcbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICAgICAgICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgICAgICAgICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgIGdUZW5zb3JQb2ludGVyID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gb2Zmc2V0ICogMjtcbiAgICAgICAgICAgICAgICBhVGVuc29yUG9pbnRlciA9IG9mZnNldCAqIDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgICAgICAgICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICAgICAgICAgICAgZ1RlbnNvclBvaW50ZXIgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgYlRlbnNvclBvaW50ZXIgPSBvZmZzZXQgKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICAgICAgICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGdUZW5zb3JQb2ludGVyID0gb2Zmc2V0ICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltYWdlID0gcGl4ZWxzMkRDb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0ICogd2lkdGg7IHJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgZ0ltYWdlUG9pbnRlciArPSBzdGVwLCBiSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGFJbWFnZVBvaW50ZXIgKz0gc3RlcCwgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UuZGF0YVtySW1hZ2VQb2ludGVyXSA9ICh0aGlzLmRhdGFbclRlbnNvclBvaW50ZXIrK10gLSBub3JtQmlhcykgKiBub3JtTWVhbjsgLy8gUiB2YWx1ZVxuICAgICAgICAgICAgICAgIGltYWdlLmRhdGFbZ0ltYWdlUG9pbnRlcl0gPSAodGhpcy5kYXRhW2dUZW5zb3JQb2ludGVyKytdIC0gbm9ybUJpYXMpICogbm9ybU1lYW47IC8vIEcgdmFsdWVcbiAgICAgICAgICAgICAgICBpbWFnZS5kYXRhW2JJbWFnZVBvaW50ZXJdID0gKHRoaXMuZGF0YVtiVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzKSAqIG5vcm1NZWFuOyAvLyBCIHZhbHVlXG4gICAgICAgICAgICAgICAgaW1hZ2UuZGF0YVthSW1hZ2VQb2ludGVyXSA9XG4gICAgICAgICAgICAgICAgICAgIGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICh0aGlzLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gLSBub3JtQmlhcykgKiBub3JtTWVhbjsgLy8gQSB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI3JlZ2lvbiB0ZW5zb3IgdXRpbGl0aWVzXG4gICAgcmVzaGFwZShkaW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKHRoaXMudHlwZSwgdGhpcy5kYXRhLCBkaW1zKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW5zb3ItaW1wbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbXBsIH0gZnJvbSAnLi90ZW5zb3ItaW1wbCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVGVuc29yID0gVGVuc29ySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbnNvci5qcy5tYXAiLCIvKiFcbiogT05OWCBSdW50aW1lIFdlYiB2MS4xNC4wXG4qIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuIWZ1bmN0aW9uKHQsZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZShyZXF1aXJlKFwib25ueHJ1bnRpbWUtY29tbW9uXCIpKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgbj1cIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9lKHJlcXVpcmUoXCJvbm54cnVudGltZS1jb21tb25cIikpOmUodC5vcnQpO2Zvcih2YXIgciBpbiBuKShcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzOnQpW3JdPW5bcl19fShzZWxmLChfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNjcwX189PigoKT0+e3ZhciBfX3dlYnBhY2tfbW9kdWxlc19fPXszNDc0Oih0LGUsbik9Pnt2YXIgX3NjcmlwdERpcixyPShfc2NyaXB0RGlyPShfc2NyaXB0RGlyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDApfHxcIi9pbmRleC5qc1wiLGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gJC5idWZmZXIhPUMmJkgoJC5idWZmZXIpLEZ9ZnVuY3Rpb24gcigpe3JldHVybiAkLmJ1ZmZlciE9QyYmSCgkLmJ1ZmZlciksTn1mdW5jdGlvbiBpKCl7cmV0dXJuICQuYnVmZmVyIT1DJiZIKCQuYnVmZmVyKSxMfWZ1bmN0aW9uIG8oKXtyZXR1cm4gJC5idWZmZXIhPUMmJkgoJC5idWZmZXIpLFJ9ZnVuY3Rpb24gYSgpe3JldHVybiAkLmJ1ZmZlciE9QyYmSCgkLmJ1ZmZlciksan12YXIgcyx1LGM7dD10fHx7fSxzfHwocz12b2lkIDAhPT10P3Q6e30pLHMucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7dT10LGM9ZX0pKTt2YXIgbCxwLGYsZCxoLGcsYj1PYmplY3QuYXNzaWduKHt9LHMpLG09XCIuL3RoaXMucHJvZ3JhbVwiLHk9KHQsZSk9Pnt0aHJvdyBlfSxfPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3csdj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLHc9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLHg9cy5FTlZJUk9OTUVOVF9JU19QVEhSRUFEfHwhMSxUPVwiXCI7ZnVuY3Rpb24gUyh0KXtyZXR1cm4gcy5sb2NhdGVGaWxlP3MubG9jYXRlRmlsZSh0LFQpOlQrdH1pZih3KXtsZXQgZTtUPXY/big5MDgpLmRpcm5hbWUoVCkrXCIvXCI6XCIvL1wiLGc9KCk9PntofHwoZD1uKDEzODQpLGg9big5MDgpKX0sbD1mdW5jdGlvbih0LGUpe3JldHVybiBnKCksdD1oLm5vcm1hbGl6ZSh0KSxkLnJlYWRGaWxlU3luYyh0LGU/dm9pZCAwOlwidXRmOFwiKX0sZj10PT4oKHQ9bCh0LCEwKSkuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksdCkscD0odCxlLG4pPT57ZygpLHQ9aC5ub3JtYWxpemUodCksZC5yZWFkRmlsZSh0LChmdW5jdGlvbih0LHIpe3Q/bih0KTplKHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYobT1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLChmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiB1dCkpdGhyb3cgdH0pKSxwcm9jZXNzLm9uKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsKGZ1bmN0aW9uKHQpe3Rocm93IHR9KSkseT0odCxlKT0+e2lmKEooKSl0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPXQsZTtlIGluc3RhbmNlb2YgdXR8fFAoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK2UpLHByb2Nlc3MuZXhpdCh0KX0scy5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifTt0cnl7ZT1uKDk5MjUpfWNhdGNoKHQpe3Rocm93IGNvbnNvbGUuZXJyb3IoJ1RoZSBcIndvcmtlcl90aHJlYWRzXCIgbW9kdWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBub2RlLmpzIGJ1aWxkIC0gcGVyaGFwcyBhIG5ld2VyIHZlcnNpb24gaXMgbmVlZGVkPycpLHR9bi5nLldvcmtlcj1lLldvcmtlcn1lbHNlKF98fHYpJiYodj9UPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihUPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYoVD1fc2NyaXB0RGlyKSxUPTAhPT1ULmluZGV4T2YoXCJibG9iOlwiKT9ULnN1YnN0cigwLFQucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIix3fHwobD10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnNlbmQobnVsbCksZS5yZXNwb25zZVRleHR9LHYmJihmPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixlLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoZS5yZXNwb25zZSl9KSxwPSh0LGUsbik9Pnt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKFwiR0VUXCIsdCwhMCksci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHIub25sb2FkPSgpPT57MjAwPT1yLnN0YXR1c3x8MD09ci5zdGF0dXMmJnIucmVzcG9uc2U/ZShyLnJlc3BvbnNlKTpuKCl9LHIub25lcnJvcj1uLHIuc2VuZChudWxsKX0pKTt3JiZcInVuZGVmaW5lZFwiPT10eXBlb2YgcGVyZm9ybWFuY2UmJihuLmcucGVyZm9ybWFuY2U9big2OTUzKS5wZXJmb3JtYW5jZSk7dmFyIE89Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxBPWNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO3cmJihnKCksTz10PT5kLndyaXRlU3luYygxLHQrXCJcXG5cIiksQT10PT5kLndyaXRlU3luYygyLHQrXCJcXG5cIikpO3ZhciBFLEk9cy5wcmludHx8TyxQPXMucHJpbnRFcnJ8fEE7T2JqZWN0LmFzc2lnbihzLGIpLGI9bnVsbCxzLnRoaXNQcm9ncmFtJiYobT1zLnRoaXNQcm9ncmFtKSxzLnF1aXQmJih5PXMucXVpdCkscy53YXNtQmluYXJ5JiYoRT1zLndhc21CaW5hcnkpO3ZhciBEPXMubm9FeGl0UnVudGltZXx8ITE7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZpdChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyICQsayxDLEYsTixMLFIsaixNPSExLFU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwO2Z1bmN0aW9uIFYodCxlLG4pe3ZhciByPShlPj4+PTApK247Zm9yKG49ZTt0W25dJiYhKG4+PXIpOykrK247aWYoMTY8bi1lJiZ0LmJ1ZmZlciYmVSlyZXR1cm4gVS5kZWNvZGUodC5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcj90LnNsaWNlKGUsbik6dC5zdWJhcnJheShlLG4pKTtmb3Iocj1cIlwiO2U8bjspe3ZhciBpPXRbZSsrXTtpZigxMjgmaSl7dmFyIG89NjMmdFtlKytdO2lmKDE5Mj09KDIyNCZpKSlyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZpKTw8NnxvKTtlbHNle3ZhciBhPTYzJnRbZSsrXTs2NTUzNj4oaT0yMjQ9PSgyNDAmaSk/KDE1JmkpPDwxMnxvPDw2fGE6KDcmaSk8PDE4fG88PDEyfGE8PDZ8NjMmdFtlKytdKT9yKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpOihpLT02NTUzNixyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGk+PjEwLDU2MzIwfDEwMjMmaSkpfX1lbHNlIHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoaSl9cmV0dXJuIHJ9ZnVuY3Rpb24gQih0LGUpe3JldHVybih0Pj4+PTApP1YocigpLHQsZSk6XCJcIn1mdW5jdGlvbiB6KHQsZSxuLHIpe2lmKCEoMDxyKSlyZXR1cm4gMDt2YXIgaT1uPj4+PTA7cj1uK3ItMTtmb3IodmFyIG89MDtvPHQubGVuZ3RoOysrbyl7dmFyIGE9dC5jaGFyQ29kZUF0KG8pO2lmKDU1Mjk2PD1hJiY1NzM0Mz49YSYmKGE9NjU1MzYrKCgxMDIzJmEpPDwxMCl8MTAyMyZ0LmNoYXJDb2RlQXQoKytvKSksMTI3Pj1hKXtpZihuPj1yKWJyZWFrO2VbbisrPj4+MF09YX1lbHNle2lmKDIwNDc+PWEpe2lmKG4rMT49cilicmVhaztlW24rKz4+PjBdPTE5MnxhPj42fWVsc2V7aWYoNjU1MzU+PWEpe2lmKG4rMj49cilicmVhaztlW24rKz4+PjBdPTIyNHxhPj4xMn1lbHNle2lmKG4rMz49cilicmVhaztlW24rKz4+PjBdPTI0MHxhPj4xOCxlW24rKz4+PjBdPTEyOHxhPj4xMiY2M31lW24rKz4+PjBdPTEyOHxhPj42JjYzfWVbbisrPj4+MF09MTI4fDYzJmF9fXJldHVybiBlW24+Pj4wXT0wLG4taX1mdW5jdGlvbiBHKHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIHI9dC5jaGFyQ29kZUF0KG4pOzEyNz49cj9lKys6MjA0Nz49cj9lKz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8oZSs9NCwrK24pOmUrPTN9cmV0dXJuIGV9ZnVuY3Rpb24gSCh0KXtDPXQscy5IRUFQOD1GPW5ldyBJbnQ4QXJyYXkodCkscy5IRUFQMTY9bmV3IEludDE2QXJyYXkodCkscy5IRUFQMzI9TD1uZXcgSW50MzJBcnJheSh0KSxzLkhFQVBVOD1OPW5ldyBVaW50OEFycmF5KHQpLHMuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkodCkscy5IRUFQVTMyPVI9bmV3IFVpbnQzMkFycmF5KHQpLHMuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KHQpLHMuSEVBUEY2ND1qPW5ldyBGbG9hdDY0QXJyYXkodCl9eCYmKEM9cy5idWZmZXIpO3ZhciBXPXMuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2lmKHgpJD1zLndhc21NZW1vcnksQz1zLmJ1ZmZlcjtlbHNlIGlmKHMud2FzbU1lbW9yeSkkPXMud2FzbU1lbW9yeTtlbHNlIGlmKCEoKCQ9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpXLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSkpLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBQKFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLHcmJmNvbnNvbGUubG9nKFwiKG9uIG5vZGUgeW91IG1heSBuZWVkOiAtLWV4cGVyaW1lbnRhbC13YXNtLXRocmVhZHMgLS1leHBlcmltZW50YWwtd2FzbS1idWxrLW1lbW9yeSBhbmQgYWxzbyB1c2UgYSByZWNlbnQgdmVyc2lvbilcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpOyQmJihDPSQuYnVmZmVyKSxXPUMuYnl0ZUxlbmd0aCxIKEMpO3ZhciBxLFg9W10sWT1bXSxLPVtdLFo9W107ZnVuY3Rpb24gSigpe3JldHVybiBEfHwhMX1mdW5jdGlvbiBRKCl7dmFyIHQ9cy5wcmVSdW4uc2hpZnQoKTtYLnVuc2hpZnQodCl9dmFyIHR0LGV0PTAsbnQ9bnVsbCxydD1udWxsO2Z1bmN0aW9uIGl0KHQpe3Rocm93IHg/cG9zdE1lc3NhZ2Uoe2NtZDpcIm9uQWJvcnRcIixhcmc6dH0pOnMub25BYm9ydCYmcy5vbkFib3J0KHQpLFAodD1cIkFib3J0ZWQoXCIrdCtcIilcIiksTT0hMCx0PW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IodCtcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksYyh0KSx0fWZ1bmN0aW9uIG90KCl7cmV0dXJuIHR0LnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfWZ1bmN0aW9uIGF0KCl7dmFyIHQ9dHQ7dHJ5e2lmKHQ9PXR0JiZFKXJldHVybiBuZXcgVWludDhBcnJheShFKTtpZihmKXJldHVybiBmKHQpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKHQpe2l0KHQpfX10dD1cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIixvdCgpfHwodHQ9Uyh0dCkpO3ZhciBzdD17fTtmdW5jdGlvbiB1dCh0KXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIit0K1wiKVwiLHRoaXMuc3RhdHVzPXR9ZnVuY3Rpb24gY3QodCl7KHQ9ZHQuVmJbdF0pfHxpdCgpLGR0Lm1jKHQpfWZ1bmN0aW9uIGx0KHQpe3ZhciBlPWR0LkNjKCk7aWYoIWUpcmV0dXJuIDY7ZHQuYWMucHVzaChlKSxkdC5WYlt0LlViXT1lLGUuVWI9dC5VYjt2YXIgbj17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTp0LkljLGFyZzp0LnpjLHB0aHJlYWRfcHRyOnQuVWJ9O3JldHVybiBlLiRiPSgpPT57bi50aW1lPXBlcmZvcm1hbmNlLm5vdygpLGUucG9zdE1lc3NhZ2Uobix0Lk5jKX0sZS5sb2FkZWQmJihlLiRiKCksZGVsZXRlIGUuJGIpLDB9ZnVuY3Rpb24gcHQodCl7aWYoeClyZXR1cm4gcXQoMSwxLHQpO0ooKXx8KGR0Lm9jKCkscy5vbkV4aXQmJnMub25FeGl0KHQpLE09ITApLHkodCxuZXcgdXQodCkpfWZ1bmN0aW9uIGZ0KHQsZSl7aWYoIWUmJngpdGhyb3cgYnQodCksXCJ1bndpbmRcIjtKKCl8fHh8fChtZSgpLGh0KEspLGJlKDApLHJlWzFdLmxlbmd0aCYmaWUoMSwxMCkscmVbMl0ubGVuZ3RoJiZpZSgyLDEwKSxkdC5vYygpKSxwdCh0KX12YXIgZHQ9e1liOltdLGFjOltdLHFjOltdLFZiOnt9LGZjOmZ1bmN0aW9uKCl7eCYmZHQuRWMoKX0sUGM6ZnVuY3Rpb24oKXt9LEVjOmZ1bmN0aW9uKCl7ZHQucmVjZWl2ZU9iamVjdFRyYW5zZmVyPWR0LkdjLGR0LnRocmVhZEluaXRUTFM9ZHQucGMsZHQuc2V0RXhpdFN0YXR1cz1kdC5uYyxEPSExfSxuYzpmdW5jdGlvbigpe30sb2M6ZnVuY3Rpb24oKXtmb3IodmFyIHQgb2YgT2JqZWN0LnZhbHVlcyhkdC5WYikpZHQubWModCk7Zm9yKHQgb2YgZHQuWWIpdC50ZXJtaW5hdGUoKTtkdC5ZYj1bXX0sbWM6ZnVuY3Rpb24odCl7dmFyIGU9dC5VYjtkZWxldGUgZHQuVmJbZV0sZHQuWWIucHVzaCh0KSxkdC5hYy5zcGxpY2UoZHQuYWMuaW5kZXhPZih0KSwxKSx0LlViPTAseGUoZSl9LEdjOmZ1bmN0aW9uKCl7fSxwYzpmdW5jdGlvbigpe2R0LnFjLmZvckVhY2goKHQ9PnQoKSkpfSxGYzpmdW5jdGlvbih0LGUpe3Qub25tZXNzYWdlPW49Pnt2YXIgcj0obj1uLmRhdGEpLmNtZDtpZih0LlViJiYoZHQuQmM9dC5VYiksbi50YXJnZXRUaHJlYWQmJm4udGFyZ2V0VGhyZWFkIT1kZSgpKXt2YXIgaT1kdC5WYltuLlFjXTtpP2kucG9zdE1lc3NhZ2UobixuLnRyYW5zZmVyTGlzdCk6UCgnSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIicrcisnXCIgdG8gdGFyZ2V0IHB0aHJlYWQgJytuLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfWVsc2VcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCI9PT1yP1Z0KG4ucXVldWUpOlwic3Bhd25UaHJlYWRcIj09PXI/bHQobik6XCJjbGVhbnVwVGhyZWFkXCI9PT1yP2N0KG4udGhyZWFkKTpcImtpbGxUaHJlYWRcIj09PXI/KG49bi50aHJlYWQscj1kdC5WYltuXSxkZWxldGUgZHQuVmJbbl0sci50ZXJtaW5hdGUoKSx4ZShuKSxkdC5hYy5zcGxpY2UoZHQuYWMuaW5kZXhPZihyKSwxKSxyLlViPTApOlwiY2FuY2VsVGhyZWFkXCI9PT1yP2R0LlZiW24udGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTpcImxvYWRlZFwiPT09cj8odC5sb2FkZWQ9ITAsZSYmZSh0KSx0LiRiJiYodC4kYigpLGRlbGV0ZSB0LiRiKSk6XCJwcmludFwiPT09cj9JKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJwcmludEVyclwiPT09cj9QKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJhbGVydFwiPT09cj9hbGVydChcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwic2V0aW1tZWRpYXRlXCI9PT1uLnRhcmdldD90LnBvc3RNZXNzYWdlKG4pOlwib25BYm9ydFwiPT09cj9zLm9uQWJvcnQmJnMub25BYm9ydChuLmFyZyk6ciYmUChcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIityKTtkdC5CYz12b2lkIDB9LHQub25lcnJvcj10PT57dGhyb3cgUChcIndvcmtlciBzZW50IGFuIGVycm9yISBcIit0LmZpbGVuYW1lK1wiOlwiK3QubGluZW5vK1wiOiBcIit0Lm1lc3NhZ2UpLHR9LHcmJih0Lm9uKFwibWVzc2FnZVwiLChmdW5jdGlvbihlKXt0Lm9ubWVzc2FnZSh7ZGF0YTplfSl9KSksdC5vbihcImVycm9yXCIsKGZ1bmN0aW9uKGUpe3Qub25lcnJvcihlKX0pKSx0Lm9uKFwiZGV0YWNoZWRFeGl0XCIsKGZ1bmN0aW9uKCl7fSkpKSx0LnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsdXJsT3JCbG9iOnMubWFpblNjcmlwdFVybE9yQmxvYnx8X3NjcmlwdERpcix3YXNtTWVtb3J5OiQsd2FzbU1vZHVsZTprfSl9LHljOmZ1bmN0aW9uKCl7dmFyIHQ9UyhcIm9ydC13YXNtLXRocmVhZGVkLndvcmtlci5qc1wiKTtkdC5ZYi5wdXNoKG5ldyBXb3JrZXIodCkpfSxDYzpmdW5jdGlvbigpe3JldHVybiAwPT1kdC5ZYi5sZW5ndGgmJihkdC55YygpLGR0LkZjKGR0LlliWzBdKSksZHQuWWIucG9wKCl9fTtmdW5jdGlvbiBodCh0KXtmb3IoOzA8dC5sZW5ndGg7KXQuc2hpZnQoKShzKX1mdW5jdGlvbiBndCh0KXt2YXIgZT1BZSgpO3JldHVybiB0PXQoKSxFZShlKSx0fWZ1bmN0aW9uIGJ0KHQpe2lmKHgpcmV0dXJuIHF0KDIsMCx0KTt0cnl7ZnQodCl9Y2F0Y2godCl7dCBpbnN0YW5jZW9mIHV0fHxcInVud2luZFwiPT10fHx5KDEsdCl9fXMuUFRocmVhZD1kdCxzLmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgdD1kZSgpLGU9aSgpW3QrNDQ+PjI+Pj4wXTt0PWkoKVt0KzQ4Pj4yPj4+MF0sT2UoZSxlLXQpLEVlKGUpfTt2YXIgbXQ9W107ZnVuY3Rpb24geXQodCl7dmFyIGU9bXRbdF07cmV0dXJuIGV8fCh0Pj1tdC5sZW5ndGgmJihtdC5sZW5ndGg9dCsxKSxtdFt0XT1lPXEuZ2V0KHQpKSxlfXMuaW52b2tlRW50cnlQb2ludD1mdW5jdGlvbih0LGUpe3Q9eXQodCkoZSksSigpP2R0Lm5jKHQpOlRlKHQpfTt2YXIgX3QsdnQsd3Q9W10seHQ9MCxUdD0wO2Z1bmN0aW9uIFN0KHQpe3RoaXMuWmI9dCx0aGlzLlNiPXQtMjQsdGhpcy54Yz1mdW5jdGlvbih0KXtvKClbdGhpcy5TYis0Pj4yPj4+MF09dH0sdGhpcy5iYz1mdW5jdGlvbigpe3JldHVybiBvKClbdGhpcy5TYis0Pj4yPj4+MF19LHRoaXMud2M9ZnVuY3Rpb24odCl7bygpW3RoaXMuU2IrOD4+Mj4+PjBdPXR9LHRoaXMuRGM9ZnVuY3Rpb24oKXtyZXR1cm4gbygpW3RoaXMuU2IrOD4+Mj4+PjBdfSx0aGlzLnJjPWZ1bmN0aW9uKCl7aSgpW3RoaXMuU2I+PjI+Pj4wXT0wfSx0aGlzLmhjPWZ1bmN0aW9uKHQpe3Q9dD8xOjAsZSgpW3RoaXMuU2IrMTI+PjA+Pj4wXT10fSx0aGlzLnVjPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPWUoKVt0aGlzLlNiKzEyPj4wPj4+MF19LHRoaXMuaWM9ZnVuY3Rpb24odCl7dD10PzE6MCxlKClbdGhpcy5TYisxMz4+MD4+PjBdPXR9LHRoaXMua2M9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9ZSgpW3RoaXMuU2IrMTM+PjA+Pj4wXX0sdGhpcy5mYz1mdW5jdGlvbih0LGUpe3RoaXMuY2MoMCksdGhpcy54Yyh0KSx0aGlzLndjKGUpLHRoaXMucmMoKSx0aGlzLmhjKCExKSx0aGlzLmljKCExKX0sdGhpcy5zYz1mdW5jdGlvbigpe0F0b21pY3MuYWRkKGkoKSx0aGlzLlNiPj4yLDEpfSx0aGlzLkhjPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1BdG9taWNzLnN1YihpKCksdGhpcy5TYj4+MiwxKX0sdGhpcy5jYz1mdW5jdGlvbih0KXtvKClbdGhpcy5TYisxNj4+Mj4+PjBdPXR9LHRoaXMudGM9ZnVuY3Rpb24oKXtyZXR1cm4gbygpW3RoaXMuU2IrMTY+PjI+Pj4wXX0sdGhpcy52Yz1mdW5jdGlvbigpe2lmKERlKHRoaXMuYmMoKSkpcmV0dXJuIG8oKVt0aGlzLlpiPj4yPj4+MF07dmFyIHQ9dGhpcy50YygpO3JldHVybiAwIT09dD90OnRoaXMuWmJ9fWZ1bmN0aW9uIE90KHQpe3JldHVybiBnZShuZXcgU3QodCkuU2IpfWZ1bmN0aW9uIEF0KHQsZSxuLHIpe3JldHVybiB4P3F0KDMsMSx0LGUsbixyKTpFdCh0LGUsbixyKX1mdW5jdGlvbiBFdCh0LGUsbixyKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIpcmV0dXJuIFAoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBpPVtdO3JldHVybiB4JiYwPT09aS5sZW5ndGg/QXQodCxlLG4scik6KHQ9e0ljOm4sVWI6dCx6YzpyLE5jOml9LHg/KHQuT2M9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHQsaSksMCk6bHQodCkpfWZ1bmN0aW9uIEl0KHQsZSxuKXtyZXR1cm4geD9xdCg0LDEsdCxlLG4pOjB9ZnVuY3Rpb24gUHQodCxlKXtpZih4KXJldHVybiBxdCg1LDEsdCxlKX1mdW5jdGlvbiBEdCh0LGUpe2lmKHgpcmV0dXJuIHF0KDYsMSx0LGUpfWZ1bmN0aW9uICR0KHQsZSxuKXtpZih4KXJldHVybiBxdCg3LDEsdCxlLG4pfWZ1bmN0aW9uIGt0KHQsZSxuKXtyZXR1cm4geD9xdCg4LDEsdCxlLG4pOjB9ZnVuY3Rpb24gQ3QodCxlKXtpZih4KXJldHVybiBxdCg5LDEsdCxlKX1mdW5jdGlvbiBGdCh0LGUsbil7aWYoeClyZXR1cm4gcXQoMTAsMSx0LGUsbil9ZnVuY3Rpb24gTnQodCxlLG4scil7aWYoeClyZXR1cm4gcXQoMTEsMSx0LGUsbixyKX1mdW5jdGlvbiBMdCh0LGUsbixyKXtpZih4KXJldHVybiBxdCgxMiwxLHQsZSxuLHIpfWZ1bmN0aW9uIFJ0KHQsZSxuLHIpe2lmKHgpcmV0dXJuIHF0KDEzLDEsdCxlLG4scil9ZnVuY3Rpb24ganQodCl7aWYoeClyZXR1cm4gcXQoMTQsMSx0KX1mdW5jdGlvbiBNdCh0LGUpe2lmKHgpcmV0dXJuIHF0KDE1LDEsdCxlKX1mdW5jdGlvbiBVdCh0LGUsbil7aWYoeClyZXR1cm4gcXQoMTYsMSx0LGUsbil9ZnVuY3Rpb24gVnQodCl7QXRvbWljcy5zdG9yZShpKCksdD4+MiwxKSxkZSgpJiZ3ZSh0KSxBdG9taWNzLmNvbXBhcmVFeGNoYW5nZShpKCksdD4+MiwxLDApfWZ1bmN0aW9uIEJ0KHQpe3JldHVybiBvKClbdD4+PjJdKzQyOTQ5NjcyOTYqaSgpW3QrND4+PjJdfWZ1bmN0aW9uIHp0KHQsZSxuLHIsaSxvKXtyZXR1cm4geD9xdCgxNywxLHQsZSxuLHIsaSxvKTotNTJ9ZnVuY3Rpb24gR3QodCxlLG4scixpLG8pe2lmKHgpcmV0dXJuIHF0KDE4LDEsdCxlLG4scixpLG8pfWZ1bmN0aW9uIEh0KHQpe3ZhciBuPUcodCkrMSxyPWhlKG4pO3JldHVybiByJiZ6KHQsZSgpLHIsbikscn1mdW5jdGlvbiBXdCh0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP3RbMV06XCJHTVRcIn1pZih4KXJldHVybiBxdCgxOSwxLHQsZSxuKTt2YXIgYT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCkscz1uZXcgRGF0ZShhLDAsMSksdT1uZXcgRGF0ZShhLDYsMSk7YT1zLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGM9dS5nZXRUaW1lem9uZU9mZnNldCgpLGw9TWF0aC5tYXgoYSxjKTtpKClbdD4+Mj4+PjBdPTYwKmwsaSgpW2U+PjI+Pj4wXT1OdW1iZXIoYSE9YyksdD1yKHMpLGU9cih1KSx0PUh0KHQpLGU9SHQoZSksYzxhPyhvKClbbj4+Mj4+PjBdPXQsbygpW24rND4+Mj4+PjBdPWUpOihvKClbbj4+Mj4+PjBdPWUsbygpW24rND4+Mj4+PjBdPXQpfWZ1bmN0aW9uIHF0KHQsZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aC0yLHI9YXJndW1lbnRzO3JldHVybiBndCgoKCk9Pntmb3IodmFyIGk9SWUoOCpuKSxvPWk+PjMscz0wO3M8bjtzKyspe3ZhciB1PXJbMitzXTthKClbbytzPj4+MF09dX1yZXR1cm4gdmUodCxuLGksZSl9KSl9cy5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlPVZ0LHZ0PXc/KCk9Pnt2YXIgdD1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxZTMqdFswXSt0WzFdLzFlNn06eD8oKT0+cGVyZm9ybWFuY2Uubm93KCktcy5fX3BlcmZvcm1hbmNlX25vd19jbG9ja19kcmlmdDooKT0+cGVyZm9ybWFuY2Uubm93KCk7dmFyIFh0LFl0PVtdLEt0PXt9O2Z1bmN0aW9uIFp0KCl7aWYoIVh0KXt2YXIgdCxlPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOm18fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHQgaW4gS3Qpdm9pZCAwPT09S3RbdF0/ZGVsZXRlIGVbdF06ZVt0XT1LdFt0XTt2YXIgbj1bXTtmb3IodCBpbiBlKW4ucHVzaCh0K1wiPVwiK2VbdF0pO1h0PW59cmV0dXJuIFh0fWZ1bmN0aW9uIEp0KHQsbil7aWYoeClyZXR1cm4gcXQoMjAsMSx0LG4pO3ZhciByPTA7cmV0dXJuIFp0KCkuZm9yRWFjaCgoZnVuY3Rpb24oaSxhKXt2YXIgcz1uK3I7Zm9yKGE9bygpW3QrNCphPj4yPj4+MF09cyxzPTA7czxpLmxlbmd0aDsrK3MpZSgpW2ErKz4+MD4+PjBdPWkuY2hhckNvZGVBdChzKTtlKClbYT4+MD4+PjBdPTAscis9aS5sZW5ndGgrMX0pKSwwfWZ1bmN0aW9uIFF0KHQsZSl7aWYoeClyZXR1cm4gcXQoMjEsMSx0LGUpO3ZhciBuPVp0KCk7bygpW3Q+PjI+Pj4wXT1uLmxlbmd0aDt2YXIgcj0wO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3IrPXQubGVuZ3RoKzF9KSksbygpW2U+PjI+Pj4wXT1yLDB9ZnVuY3Rpb24gdGUodCl7cmV0dXJuIHg/cXQoMjIsMSx0KTo1Mn1mdW5jdGlvbiBlZSh0LGUsbixyKXtyZXR1cm4geD9xdCgyMywxLHQsZSxuLHIpOjUyfWZ1bmN0aW9uIG5lKHQsZSxuLHIsaSl7cmV0dXJuIHg/cXQoMjQsMSx0LGUsbixyLGkpOjcwfXZhciByZT1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gaWUodCxlKXt2YXIgbj1yZVt0XTswPT09ZXx8MTA9PT1lPygoMT09PXQ/STpQKShWKG4sMCkpLG4ubGVuZ3RoPTApOm4ucHVzaChlKX1mdW5jdGlvbiBvZSh0LGUsbixpKXtpZih4KXJldHVybiBxdCgyNSwxLHQsZSxuLGkpO2Zvcih2YXIgYT0wLHM9MDtzPG47cysrKXt2YXIgdT1vKClbZT4+Mj4+PjBdLGM9bygpW2UrND4+Mj4+PjBdO2UrPTg7Zm9yKHZhciBsPTA7bDxjO2wrKylpZSh0LHIoKVt1K2w+Pj4wXSk7YSs9Y31yZXR1cm4gbygpW2k+PjI+Pj4wXT1hLDB9dmFyIGFlPTA7ZnVuY3Rpb24gc2UodCl7cmV0dXJuIDA9PXQlNCYmKDAhPXQlMTAwfHwwPT10JTQwMCl9dmFyIHVlPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sY2U9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBsZSh0LG4scixvKXtmdW5jdGlvbiBhKHQsZSxuKXtmb3IodD1cIm51bWJlclwiPT10eXBlb2YgdD90LnRvU3RyaW5nKCk6dHx8XCJcIjt0Lmxlbmd0aDxlOyl0PW5bMF0rdDtyZXR1cm4gdH1mdW5jdGlvbiBzKHQsZSl7cmV0dXJuIGEodCxlLFwiMFwiKX1mdW5jdGlvbiB1KHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gMD50Py0xOjA8dD8xOjB9dmFyIHI7cmV0dXJuIDA9PT0ocj1uKHQuZ2V0RnVsbFllYXIoKS1lLmdldEZ1bGxZZWFyKCkpKSYmMD09PShyPW4odC5nZXRNb250aCgpLWUuZ2V0TW9udGgoKSkpJiYocj1uKHQuZ2V0RGF0ZSgpLWUuZ2V0RGF0ZSgpKSkscn1mdW5jdGlvbiBjKHQpe3N3aXRjaCh0LmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIGwodCl7dmFyIGU9dC5XYjtmb3IodD1uZXcgRGF0ZShuZXcgRGF0ZSh0LlhiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZTspe3ZhciBuPXQuZ2V0TW9udGgoKSxyPShzZSh0LmdldEZ1bGxZZWFyKCkpP3VlOmNlKVtuXTtpZighKGU+ci10LmdldERhdGUoKSkpe3Quc2V0RGF0ZSh0LmdldERhdGUoKStlKTticmVha31lLT1yLXQuZ2V0RGF0ZSgpKzEsdC5zZXREYXRlKDEpLDExPm4/dC5zZXRNb250aChuKzEpOih0LnNldE1vbnRoKDApLHQuc2V0RnVsbFllYXIodC5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gbj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCkrMSwwLDQpLGU9YyhuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCw0KSksbj1jKG4pLDA+PXUoZSx0KT8wPj11KG4sdCk/dC5nZXRGdWxsWWVhcigpKzE6dC5nZXRGdWxsWWVhcigpOnQuZ2V0RnVsbFllYXIoKS0xfXZhciBwPWkoKVtvKzQwPj4yPj4+MF07Zm9yKHZhciBmIGluIG89e0xjOmkoKVtvPj4yPj4+MF0sS2M6aSgpW28rND4+Mj4+PjBdLGRjOmkoKVtvKzg+PjI+Pj4wXSxqYzppKClbbysxMj4+Mj4+PjBdLGVjOmkoKVtvKzE2Pj4yPj4+MF0sWGI6aSgpW28rMjA+PjI+Pj4wXSxUYjppKClbbysyND4+Mj4+PjBdLFdiOmkoKVtvKzI4Pj4yPj4+MF0sUmM6aSgpW28rMzI+PjI+Pj4wXSxKYzppKClbbyszNj4+Mj4+PjBdLE1jOnA/QihwKTpcIlwifSxyPUIocikscD17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9KXI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoZixcImdcIikscFtmXSk7dmFyIGQ9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxoPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoZiBpbiBwPXtcIiVhXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGRbdC5UYl0uc3Vic3RyaW5nKDAsMyl9LFwiJUFcIjpmdW5jdGlvbih0KXtyZXR1cm4gZFt0LlRiXX0sXCIlYlwiOmZ1bmN0aW9uKHQpe3JldHVybiBoW3QuZWNdLnN1YnN0cmluZygwLDMpfSxcIiVCXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGhbdC5lY119LFwiJUNcIjpmdW5jdGlvbih0KXtyZXR1cm4gcygodC5YYisxOTAwKS8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuamMsMil9LFwiJWVcIjpmdW5jdGlvbih0KXtyZXR1cm4gYSh0LmpjLDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGwodCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbih0KXtyZXR1cm4gbCh0KX0sXCIlSFwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuZGMsMil9LFwiJUlcIjpmdW5jdGlvbih0KXtyZXR1cm4gMD09KHQ9dC5kYyk/dD0xMjoxMjx0JiYodC09MTIpLHModCwyKX0sXCIlalwiOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49MDtuPD10LmVjLTE7ZSs9KHNlKHQuWGIrMTkwMCk/dWU6Y2UpW24rK10pO3JldHVybiBzKHQuamMrZSwzKX0sXCIlbVwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuZWMrMSwyKX0sXCIlTVwiOmZ1bmN0aW9uKHQpe3JldHVybiBzKHQuS2MsMil9LFwiJW5cIjpmdW5jdGlvbigpe3JldHVyblwiXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbih0KXtyZXR1cm4gMDw9dC5kYyYmMTI+dC5kYz9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHModC5MYywyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifHw3fSxcIiVVXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHMoTWF0aC5mbG9vcigodC5XYis3LXQuVGIpLzcpLDIpfSxcIiVWXCI6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpO2lmKDI+PSh0LlRiKzM3MS10LldiLTIpJTcmJmUrKyxlKTUzPT1lJiYoND09KG49KHQuVGIrMzcxLXQuV2IpJTcpfHwzPT1uJiZzZSh0LlhiKXx8KGU9MSkpO2Vsc2V7ZT01Mjt2YXIgbj0odC5UYis3LXQuV2ItMSklNzsoND09bnx8NT09biYmc2UodC5YYiU0MDAtMSkpJiZlKyt9cmV0dXJuIHMoZSwyKX0sXCIld1wiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlRifSxcIiVXXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHMoTWF0aC5mbG9vcigodC5XYis3LSh0LlRiKzYpJTcpLzcpLDIpfSxcIiV5XCI6ZnVuY3Rpb24odCl7cmV0dXJuKHQuWGIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5YYisxOTAwfSxcIiV6XCI6ZnVuY3Rpb24odCl7dmFyIGU9MDw9KHQ9dC5KYyk7cmV0dXJuIHQ9TWF0aC5hYnModCkvNjAsKGU/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisodC82MCoxMDArdCU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmZ1bmN0aW9uKHQpe3JldHVybiB0Lk1jfSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19LHI9ci5yZXBsYWNlKC8lJS9nLFwiXFwwXFwwXCIpLHApci5pbmNsdWRlcyhmKSYmKHI9ci5yZXBsYWNlKG5ldyBSZWdFeHAoZixcImdcIikscFtmXShvKSkpO3JldHVybiBmPWZ1bmN0aW9uKHQpe3ZhciBlPUFycmF5KEcodCkrMSk7cmV0dXJuIHoodCxlLDAsZS5sZW5ndGgpLGV9KHI9ci5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIikpLGYubGVuZ3RoPm4/MDooZnVuY3Rpb24odCxuKXtlKCkuc2V0KHQsbj4+PjApfShmLHQpLGYubGVuZ3RoLTEpfWR0LmZjKCk7dmFyIHBlPVtudWxsLHB0LGJ0LEF0LEl0LFB0LER0LCR0LGt0LEN0LEZ0LE50LEx0LFJ0LGp0LE10LFV0LHp0LEd0LFd0LEp0LFF0LHRlLGVlLG5lLG9lXSxmZT17YjpmdW5jdGlvbih0KXtyZXR1cm4gaGUodCsyNCkrMjR9LG46ZnVuY3Rpb24odCl7cmV0dXJuKHQ9bmV3IFN0KHQpKS51YygpfHwodC5oYyghMCkseHQtLSksdC5pYyghMSksd3QucHVzaCh0KSx0LnNjKCksdC52YygpfSxtYTpmdW5jdGlvbih0KXt0aHJvdyBQKFwiVW5leHBlY3RlZCBleGNlcHRpb24gdGhyb3duLCB0aGlzIGlzIG5vdCBwcm9wZXJseSBzdXBwb3J0ZWQgLSBhYm9ydGluZ1wiKSxNPSEwLHR9LHg6ZnVuY3Rpb24oKXtTZSgwKTt2YXIgdD13dC5wb3AoKTtpZih0LkhjKCkmJiF0LmtjKCkpe3ZhciBlPXQuRGMoKTtlJiZ5dChlKSh0LlpiKSxPdCh0LlpiKX1UdD0wfSxlOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSxsOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSxoOmZ1bmN0aW9uKCl7dmFyIHQ9VHQ7aWYoIXQpcmV0dXJuIGFlPTA7dmFyIGU9bmV3IFN0KHQpO2UuY2ModCk7dmFyIG49ZS5iYygpO2lmKCFuKXJldHVybiBhZT0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbz1yW2ldO2lmKDA9PT1vfHxvPT09bilicmVhaztpZihQZShvLG4sZS5TYisxNikpcmV0dXJuIGFlPW8sdH1yZXR1cm4gYWU9bix0fSx0Ok90LE06ZnVuY3Rpb24oKXt2YXIgdD13dC5wb3AoKTt0fHxpdChcIm5vIGV4Y2VwdGlvbiB0byB0aHJvd1wiKTt2YXIgZT10LlpiO3Rocm93IHQua2MoKXx8KHd0LnB1c2godCksdC5pYyghMCksdC5oYyghMSkseHQrKyksVHQ9ZSxlfSxjOmZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgU3QodCkuZmMoZSxuKSxUdD10LHh0KyssdH0scGE6ZnVuY3Rpb24oKXtyZXR1cm4geHR9LEZhOmZ1bmN0aW9uKHQpe3llKHQsIXYsMSwhXyksZHQucGMoKX0sVDpmdW5jdGlvbih0KXt4P3Bvc3RNZXNzYWdlKHtjbWQ6XCJjbGVhbnVwVGhyZWFkXCIsdGhyZWFkOnR9KTpjdCh0KX0seGE6RXQsajpmdW5jdGlvbih0KXt0aHJvdyBUdHx8KFR0PXQpLHR9LEg6SXQsTWE6UHQsdWE6RHQsd2E6JHQsb2E6a3QsS2E6Q3QsQ2E6RnQsSmE6TnQsVjpMdCx2YTpSdCxzYTpqdCxMYTpNdCx0YTpVdCxUYTpmdW5jdGlvbigpe30sWDpmdW5jdGlvbigpe2l0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LFVhOmZ1bmN0aW9uKCl7aXQoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sVzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSx5YTpmdW5jdGlvbigpe3JldHVybiAyMDk3MTUyfSxPYTpmdW5jdGlvbigpe3JldHVybiEwfSx6YTpmdW5jdGlvbih0LGUsbixyKXtpZih0PT1lKXNldFRpbWVvdXQoKCgpPT5WdChyKSkpO2Vsc2UgaWYoeClwb3N0TWVzc2FnZSh7dGFyZ2V0VGhyZWFkOnQsY21kOlwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIixxdWV1ZTpyfSk7ZWxzZXtpZighKHQ9ZHQuVmJbdF0pKXJldHVybjt0LnBvc3RNZXNzYWdlKHtjbWQ6XCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiLHF1ZXVlOnJ9KX1yZXR1cm4gMX0sRWE6ZnVuY3Rpb24oKXtyZXR1cm4tMX0sUGE6ZnVuY3Rpb24odCxlKXt0PW5ldyBEYXRlKDFlMypCdCh0KSksaSgpW2U+PjI+Pj4wXT10LmdldFVUQ1NlY29uZHMoKSxpKClbZSs0Pj4yPj4+MF09dC5nZXRVVENNaW51dGVzKCksaSgpW2UrOD4+Mj4+PjBdPXQuZ2V0VVRDSG91cnMoKSxpKClbZSsxMj4+Mj4+PjBdPXQuZ2V0VVRDRGF0ZSgpLGkoKVtlKzE2Pj4yPj4+MF09dC5nZXRVVENNb250aCgpLGkoKVtlKzIwPj4yPj4+MF09dC5nZXRVVENGdWxsWWVhcigpLTE5MDAsaSgpW2UrMjQ+PjI+Pj4wXT10LmdldFVUQ0RheSgpLHQ9KHQuZ2V0VGltZSgpLURhdGUuVVRDKHQuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsaSgpW2UrMjg+PjI+Pj4wXT10fSxRYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKkJ0KHQpKSxpKClbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLGkoKVtlKzQ+PjI+Pj4wXT10LmdldE1pbnV0ZXMoKSxpKClbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLGkoKVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksaSgpW2UrMTY+PjI+Pj4wXT10LmdldE1vbnRoKCksaSgpW2UrMjA+PjI+Pj4wXT10LmdldEZ1bGxZZWFyKCktMTkwMCxpKClbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSkscj0odC5nZXRUaW1lKCktbi5nZXRUaW1lKCkpLzg2NGU1fDA7aSgpW2UrMjg+PjI+Pj4wXT1yLGkoKVtlKzM2Pj4yPj4+MF09LTYwKnQuZ2V0VGltZXpvbmVPZmZzZXQoKSxyPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCksdD0wfChyIT0obj1uLmdldFRpbWV6b25lT2Zmc2V0KCkpJiZ0LmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4scikpLGkoKVtlKzMyPj4yPj4+MF09dH0sUmE6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IERhdGUoaSgpW3QrMjA+PjI+Pj4wXSsxOTAwLGkoKVt0KzE2Pj4yPj4+MF0saSgpW3QrMTI+PjI+Pj4wXSxpKClbdCs4Pj4yPj4+MF0saSgpW3QrND4+Mj4+PjBdLGkoKVt0Pj4yPj4+MF0sMCksbj1pKClbdCszMj4+Mj4+PjBdLHI9ZS5nZXRUaW1lem9uZU9mZnNldCgpLG89bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSksYT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLHM9by5nZXRUaW1lem9uZU9mZnNldCgpLHU9TWF0aC5taW4ocyxhKTtyZXR1cm4gMD5uP2koKVt0KzMyPj4yPj4+MF09TnVtYmVyKGEhPXMmJnU9PXIpOjA8biE9KHU9PXIpJiYoYT1NYXRoLm1heChzLGEpLGUuc2V0VGltZShlLmdldFRpbWUoKSs2ZTQqKCgwPG4/dTphKS1yKSkpLGkoKVt0KzI0Pj4yPj4+MF09ZS5nZXREYXkoKSxuPShlLmdldFRpbWUoKS1vLmdldFRpbWUoKSkvODY0ZTV8MCxpKClbdCsyOD4+Mj4+PjBdPW4saSgpW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxpKClbdCs0Pj4yPj4+MF09ZS5nZXRNaW51dGVzKCksaSgpW3QrOD4+Mj4+PjBdPWUuZ2V0SG91cnMoKSxpKClbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLGkoKVt0KzE2Pj4yPj4+MF09ZS5nZXRNb250aCgpLGUuZ2V0VGltZSgpLzFlM3wwfSxBYTp6dCxCYTpHdCxTYTpmdW5jdGlvbiB0KGUsbixyKXt0LkFjfHwodC5BYz0hMCxXdChlLG4scikpfSx5OmZ1bmN0aW9uKCl7aXQoXCJcIil9LFU6ZnVuY3Rpb24oKXtpZighdyYmIXYpe3ZhciB0PVwiQmxvY2tpbmcgb24gdGhlIG1haW4gdGhyZWFkIGlzIHZlcnkgZGFuZ2Vyb3VzLCBzZWUgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL3BvcnRpbmcvcHRocmVhZHMuaHRtbCNibG9ja2luZy1vbi10aGUtbWFpbi1icm93c2VyLXRocmVhZFwiO190fHwoX3Q9e30pLF90W3RdfHwoX3RbdF09MSx3JiYodD1cIndhcm5pbmc6IFwiK3QpLFAodCkpfX0scmE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sQjp2dCxJYTpmdW5jdGlvbih0LGUsbil7cigpLmNvcHlXaXRoaW4odD4+PjAsZT4+PjAsZStuPj4+MCl9LEY6ZnVuY3Rpb24oKXtyZXR1cm4gdz9uKDM5OTMpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LERhOmZ1bmN0aW9uKHQsZSxuKXtZdC5sZW5ndGg9ZSxuPj49Mztmb3IodmFyIHI9MDtyPGU7cisrKVl0W3JdPWEoKVtuK3I+Pj4wXTtyZXR1cm4oMD50P3N0Wy10LTFdOnBlW3RdKS5hcHBseShudWxsLFl0KX0scWE6ZnVuY3Rpb24odCl7dmFyIGU9cigpLmxlbmd0aDtpZigodD4+Pj0wKTw9ZXx8NDI5NDkwMTc2MDx0KXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIGk9ZSooMSsuMi9uKTtpPU1hdGgubWluKGksdCsxMDA2NjMyOTYpO3ZhciBvPU1hdGg7aT1NYXRoLm1heCh0LGkpLG89by5taW4uY2FsbChvLDQyOTQ5MDE3NjAsaSsoNjU1MzYtaSU2NTUzNiklNjU1MzYpO3Q6e3RyeXskLmdyb3coby1DLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksSCgkLmJ1ZmZlcik7dmFyIGE9MTticmVhayB0fWNhdGNoKHQpe31hPXZvaWQgMH1pZihhKXJldHVybiEwfXJldHVybiExfSxOYTpmdW5jdGlvbigpe3Rocm93XCJ1bndpbmRcIn0sR2E6SnQsSGE6UXQsSjpmdCxJOnRlLFM6ZWUsZ2E6bmUsUjpvZSxkOmZ1bmN0aW9uKCl7cmV0dXJuIGFlfSxuYTpmdW5jdGlvbiB0KHIsaSl7dC5sY3x8KHQubGM9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYodyl0cnl7dmFyIGU9bihPYmplY3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ2NyeXB0bydcIik7dGhyb3cgdC5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLHR9KCkpKTtyZXR1cm4oKT0+ZS5yYW5kb21CeXRlcygxKVswXX1jYXRjaCh0KXt9cmV0dXJuKCk9Pml0KFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIG89MDtvPGk7bysrKWUoKVtyK28+PjA+Pj4wXT10LmxjKCk7cmV0dXJuIDB9LGlhOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGphOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEs6ZnVuY3Rpb24odCl7dmFyIGU9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKCl9Y2F0Y2godCl7aWYoRWUoZSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxmOmZ1bmN0aW9uKHQsZSl7dmFyIG49QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUpfWNhdGNoKHQpe2lmKEVlKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sUDpmdW5jdGlvbih0LGUsbil7dmFyIHI9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbil9Y2F0Y2godCl7aWYoRWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxROmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGs6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4pfWNhdGNoKHQpe2lmKEVlKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scDpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1BZSgpO3RyeXtyZXR1cm4geXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKEVlKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scTpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpKX1jYXRjaCh0KXtpZihFZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LE46ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpLG8pfWNhdGNoKHQpe2lmKEVlKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sczpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyl9Y2F0Y2godCl7aWYoRWUoYSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSx3OmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzPUFlKCk7dHJ5e3JldHVybiB5dCh0KShlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoRWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxMOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sRTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMsdSxjLGwscCl7dmFyIGY9QWUoKTt0cnl7cmV0dXJuIHl0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoRWUoZiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxhYTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PUFlKCk7dHJ5e3JldHVybiBNZSh0LGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sXzpmdW5jdGlvbih0LGUsbixyLGksbyxhKXt2YXIgcz1BZSgpO3RyeXtyZXR1cm4ga2UodCxlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoRWUocyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxaOmZ1bmN0aW9uKHQsZSxuLHIsaSl7dmFyIG89QWUoKTt0cnl7cmV0dXJuIFVlKHQsZSxuLHIsaSl9Y2F0Y2godCl7aWYoRWUobyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxjYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1BZSgpO3RyeXtyZXR1cm4gUmUodCxlLG4scil9Y2F0Y2godCl7aWYoRWUoaSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSwkOmZ1bmN0aW9uKHQpe3ZhciBlPUFlKCk7dHJ5e3JldHVybiAkZSh0KX1jYXRjaCh0KXtpZihFZShlKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGJhOmZ1bmN0aW9uKHQsZSl7dmFyIG49QWUoKTt0cnl7cmV0dXJuIGplKHQsZSl9Y2F0Y2godCl7aWYoRWUobiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxZOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BZSgpO3RyeXtyZXR1cm4gQ2UodCxlLG4pfWNhdGNoKHQpe2lmKEVlKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZzpmdW5jdGlvbih0KXt2YXIgZT1BZSgpO3RyeXt5dCh0KSgpfWNhdGNoKHQpe2lmKEVlKGUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0scjpmdW5jdGlvbih0LGUpe3ZhciBuPUFlKCk7dHJ5e3l0KHQpKGUpfWNhdGNoKHQpe2lmKEVlKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0saTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QWUoKTt0cnl7eXQodCkoZSxuKX1jYXRjaCh0KXtpZihFZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGhhOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPUFlKCk7dHJ5e3l0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihFZShpKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LG06ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9QWUoKTt0cnl7eXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKEVlKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdjpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGkpfWNhdGNoKHQpe2lmKEVlKG8pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihFZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LE86ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvLGEpfWNhdGNoKHQpe2lmKEVlKHMpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sQTpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKEVlKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sa2E6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUpe3ZhciBjPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMsdSl9Y2F0Y2godCl7aWYoRWUoYyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxDOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCl7dmFyIHA9QWUoKTt0cnl7eXQodCkoZSxuLHIsaSxvLGEscyx1LGMsbCl9Y2F0Y2godCl7aWYoRWUocCksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxEOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwLGYsZCxoLGcpe3ZhciBiPUFlKCk7dHJ5e3l0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCxmLGQsaCxnKX1jYXRjaCh0KXtpZihFZShiKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGZhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9QWUoKTt0cnl7RmUodCxlLG4scixpLG8sYSxzKX1jYXRjaCh0KXtpZihFZSh1KSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGRhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwKXt2YXIgZj1BZSgpO3RyeXtMZSh0LGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoRWUoZiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxlYTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9QWUoKTt0cnl7TmUodCxlLG4scixpLG8pfWNhdGNoKHQpe2lmKEVlKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sbzpmdW5jdGlvbih0KXtyZXR1cm4gdH0sYTokfHxzLndhc21NZW1vcnksRzpmdW5jdGlvbih0KXthZT10fSxsYTpsZSx6OmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBsZSh0LGUsbixyKX19OyFmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtzLmFzbT10LmV4cG9ydHMsZHQucWMucHVzaChzLmFzbS5zYikscT1zLmFzbS51YixZLnVuc2hpZnQocy5hc20uVmEpLGs9ZSx4fHwoZXQtLSxzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhldCksMD09ZXQmJihudWxsIT09bnQmJihjbGVhckludGVydmFsKG50KSxudD1udWxsKSxydCYmKHQ9cnQscnQ9bnVsbCx0KCkpKSl9ZnVuY3Rpb24gZShlKXt0KGUuaW5zdGFuY2UsZS5tb2R1bGUpfWZ1bmN0aW9uIG4odCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIUUmJihffHx2KSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJiF0dC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2godHQse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIit0dCtcIidcIjtyZXR1cm4gdC5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBhdCgpfSkpO2lmKHApcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe3AodHQsKGZ1bmN0aW9uKGUpe3QobmV3IFVpbnQ4QXJyYXkoZSkpfSksZSl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIGF0KCl9KSl9KCkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHQscil9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSkudGhlbih0LChmdW5jdGlvbih0KXtQKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrdCksaXQodCl9KSl9dmFyIHI9e2E6ZmV9O2lmKHh8fChldCsrLHMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmcy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGV0KSkscy5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBzLmluc3RhbnRpYXRlV2FzbShyLHQpfWNhdGNoKHQpe3JldHVybiBQKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrdCksITF9KEV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxvdCgpfHx0dC5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8d3x8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/bihlKTpmZXRjaCh0dCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHQscikudGhlbihlLChmdW5jdGlvbih0KXtyZXR1cm4gUChcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIit0KSxQKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksbihlKX0pKX0pKSkuY2F0Y2goYyl9KCkscy5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fX193YXNtX2NhbGxfY3RvcnM9cy5hc20uVmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRJbml0PXMuYXNtLldhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXMuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPXMuYXNtLllhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9cy5hc20uWmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1zLmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydENyZWF0ZVNlc3Npb249cy5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0UmVsZWFzZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0UmVsZWFzZVNlc3Npb249cy5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0SW5wdXRDb3VudD1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRJbnB1dENvdW50PXMuYXNtLmJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEdldE91dHB1dENvdW50PXMuYXNtLmNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldElucHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRJbnB1dE5hbWU9cy5hc20uZGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0R2V0T3V0cHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihzLl9PcnRHZXRPdXRwdXROYW1lPXMuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0RnJlZT1zLmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0Q3JlYXRlVGVuc29yPXMuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4ocy5fT3J0R2V0VGVuc29yRGF0YT1zLmFzbS5oYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzLl9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VUZW5zb3I9cy5hc20uaWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybihzLl9PcnRDcmVhdGVSdW5PcHRpb25zPXMuYXNtLmpiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXMuYXNtLmtiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydFJlbGVhc2VSdW5PcHRpb25zPXMuYXNtLmxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHMuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybihzLl9PcnRSdW49cy5hc20ubWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scy5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX09ydEVuZFByb2ZpbGluZz1zLmFzbS5uYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgZGU9cy5fcHRocmVhZF9zZWxmPWZ1bmN0aW9uKCl7cmV0dXJuKGRlPXMuX3B0aHJlYWRfc2VsZj1zLmFzbS5vYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxoZT1zLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oaGU9cy5fbWFsbG9jPXMuYXNtLnBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGdlPXMuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oZ2U9cy5fZnJlZT1zLmFzbS5xYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxiZT1zLl9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4oYmU9cy5fZmZsdXNoPXMuYXNtLnJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3MuX19lbXNjcmlwdGVuX3Rsc19pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3Rsc19pbml0PXMuYXNtLnNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtZT1zLl9fX2Z1bmNzX29uX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4obWU9cy5fX19mdW5jc19vbl9leGl0PXMuYXNtLnRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHllPXMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHllPXMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PXMuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3MuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPWZ1bmN0aW9uKCl7cmV0dXJuKHMuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPXMuYXNtLndiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZSx2ZT1zLl9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPWZ1bmN0aW9uKCl7cmV0dXJuKHZlPXMuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9cy5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sd2U9cy5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPWZ1bmN0aW9uKCl7cmV0dXJuKHdlPXMuX19lbXNjcmlwdGVuX3Byb3h5X2V4ZWN1dGVfdGFza19xdWV1ZT1zLmFzbS55YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx4ZT1zLl9fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKHhlPXMuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9cy5hc20uemIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVGU9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4oVGU9cy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9cy5hc20uQWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU2U9cy5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oU2U9cy5fc2V0VGhyZXc9cy5hc20uQmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT2U9cy5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPWZ1bmN0aW9uKCl7cmV0dXJuKE9lPXMuX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cz1zLmFzbS5DYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBZT1zLnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybihBZT1zLnN0YWNrU2F2ZT1zLmFzbS5EYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFZT1zLnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihFZT1zLnN0YWNrUmVzdG9yZT1zLmFzbS5FYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxJZT1zLnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oSWU9cy5zdGFja0FsbG9jPXMuYXNtLkZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFBlPXMuX19fY3hhX2Nhbl9jYXRjaD1mdW5jdGlvbigpe3JldHVybihQZT1zLl9fX2N4YV9jYW5fY2F0Y2g9cy5hc20uR2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRGU9cy5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuKERlPXMuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1zLmFzbS5IYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSwkZT1zLmR5bkNhbGxfaj1mdW5jdGlvbigpe3JldHVybigkZT1zLmR5bkNhbGxfaj1zLmFzbS5JYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrZT1zLmR5bkNhbGxfaWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKGtlPXMuZHluQ2FsbF9paWlpaWo9cy5hc20uSmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ2U9cy5keW5DYWxsX2ppaT1mdW5jdGlvbigpe3JldHVybihDZT1zLmR5bkNhbGxfamlpPXMuYXNtLktiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZlPXMuZHluQ2FsbF92aWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEZlPXMuZHluQ2FsbF92aWlpaWlqPXMuYXNtLkxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE5lPXMuZHluQ2FsbF92amppPWZ1bmN0aW9uKCl7cmV0dXJuKE5lPXMuZHluQ2FsbF92amppPXMuYXNtLk1iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LExlPXMuZHluQ2FsbF92aWlpampqaWk9ZnVuY3Rpb24oKXtyZXR1cm4oTGU9cy5keW5DYWxsX3ZpaWlqamppaT1zLmFzbS5OYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxSZT1zLmR5bkNhbGxfaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKFJlPXMuZHluQ2FsbF9paWo9cy5hc20uT2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0samU9cy5keW5DYWxsX2ppPWZ1bmN0aW9uKCl7cmV0dXJuKGplPXMuZHluQ2FsbF9qaT1zLmFzbS5QYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxNZT1zLmR5bkNhbGxfaWlpaWlpaj1mdW5jdGlvbigpe3JldHVybihNZT1zLmR5bkNhbGxfaWlpaWlpaj1zLmFzbS5RYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxVZT1zLmR5bkNhbGxfaWlpaj1mdW5jdGlvbigpe3JldHVybihVZT1zLmR5bkNhbGxfaWlpaj1zLmFzbS5SYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBWZSgpe2Z1bmN0aW9uIHQoKXtpZighX2UmJihfZT0hMCxzLmNhbGxlZFJ1bj0hMCwhTSkmJih4fHxodChZKSx1KHMpLHMub25SdW50aW1lSW5pdGlhbGl6ZWQmJnMub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwheCkpe2lmKHMucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2Ygcy5wb3N0UnVuJiYocy5wb3N0UnVuPVtzLnBvc3RSdW5dKTtzLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9cy5wb3N0UnVuLnNoaWZ0KCk7Wi51bnNoaWZ0KHQpfWh0KFopfX1pZighKDA8ZXQpKWlmKHgpdShzKSx4fHxodChZKSxwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtlbHNle2lmKHMucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBzLnByZVJ1biYmKHMucHJlUnVuPVtzLnByZVJ1bl0pO3MucHJlUnVuLmxlbmd0aDspUSgpO2h0KFgpLDA8ZXR8fChzLnNldFN0YXR1cz8ocy5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtzLnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZihzLlVURjhUb1N0cmluZz1CLHMuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4geih0LHIoKSxlLG4pfSxzLmxlbmd0aEJ5dGVzVVRGOD1HLHMua2VlcFJ1bnRpbWVBbGl2ZT1KLHMud2FzbU1lbW9yeT0kLHMuc3RhY2tTYXZlPUFlLHMuc3RhY2tSZXN0b3JlPUVlLHMuc3RhY2tBbGxvYz1JZSxzLkV4aXRTdGF0dXM9dXQscy5QVGhyZWFkPWR0LHJ0PWZ1bmN0aW9uIHQoKXtfZXx8VmUoKSxfZXx8KHJ0PXQpfSxzLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHMucHJlSW5pdCYmKHMucHJlSW5pdD1bcy5wcmVJbml0XSk7MDxzLnByZUluaXQubGVuZ3RoOylzLnByZUluaXQucG9wKCkoKTtyZXR1cm4gVmUoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDkzMjoodCxlLG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8XCIvaW5kZXguanNcIixmdW5jdGlvbih0KXt2YXIgZSxyLGk7dD10fHx7fSxlfHwoZT12b2lkIDAhPT10P3Q6e30pLGUucmVhZHk9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7cj10LGk9ZX0pKTt2YXIgbyxhLHMsdSxjLGwscD1PYmplY3QuYXNzaWduKHt9LGUpLGY9XCIuL3RoaXMucHJvZ3JhbVwiLGQ9KHQsZSk9Pnt0aHJvdyBlfSxoPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3csZz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLGI9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLG09XCJcIjtiPyhtPWc/big5MDgpLmRpcm5hbWUobSkrXCIvXCI6XCIvL1wiLGw9KCk9PntjfHwodT1uKDEzODQpLGM9big5MDgpKX0sbz1mdW5jdGlvbih0LGUpe3JldHVybiBsKCksdD1jLm5vcm1hbGl6ZSh0KSx1LnJlYWRGaWxlU3luYyh0LGU/dm9pZCAwOlwidXRmOFwiKX0scz10PT4oKHQ9byh0LCEwKSkuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksdCksYT0odCxlLG4pPT57bCgpLHQ9Yy5ub3JtYWxpemUodCksdS5yZWFkRmlsZSh0LChmdW5jdGlvbih0LHIpe3Q/bih0KTplKHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoZj1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLChmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBLKSl0aHJvdyB0fSkpLHByb2Nlc3Mub24oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIiwoZnVuY3Rpb24odCl7dGhyb3cgdH0pKSxkPSh0LGUpPT57aWYod3x8MDxVKXRocm93IHByb2Nlc3MuZXhpdENvZGU9dCxlO2UgaW5zdGFuY2VvZiBLfHx2KFwiZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiBcIitlKSxwcm9jZXNzLmV4aXQodCl9LGUuaW5zcGVjdD1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn0pOihofHxnKSYmKGc/bT1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYobT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKG09X3NjcmlwdERpciksbT0wIT09bS5pbmRleE9mKFwiYmxvYjpcIik/bS5zdWJzdHIoMCxtLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIsbz10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnNlbmQobnVsbCksZS5yZXNwb25zZVRleHR9LGcmJihzPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixlLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoZS5yZXNwb25zZSl9KSxhPSh0LGUsbik9Pnt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKFwiR0VUXCIsdCwhMCksci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHIub25sb2FkPSgpPT57MjAwPT1yLnN0YXR1c3x8MD09ci5zdGF0dXMmJnIucmVzcG9uc2U/ZShyLnJlc3BvbnNlKTpuKCl9LHIub25lcnJvcj1uLHIuc2VuZChudWxsKX0pO3ZhciB5LF89ZS5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSx2PWUucHJpbnRFcnJ8fGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24oZSxwKSxwPW51bGwsZS50aGlzUHJvZ3JhbSYmKGY9ZS50aGlzUHJvZ3JhbSksZS5xdWl0JiYoZD1lLnF1aXQpLGUud2FzbUJpbmFyeSYmKHk9ZS53YXNtQmluYXJ5KTt2YXIgdz1lLm5vRXhpdFJ1bnRpbWV8fCExO1wib2JqZWN0XCIhPXR5cGVvZiBXZWJBc3NlbWJseSYmVyhcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIHgsVCxTLE8sQSxFLEk9ITEsUD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDA7ZnVuY3Rpb24gRCh0LGUsbil7dmFyIHI9KGU+Pj49MCkrbjtmb3Iobj1lO3Rbbl0mJiEobj49cik7KSsrbjtpZigxNjxuLWUmJnQuYnVmZmVyJiZQKXJldHVybiBQLmRlY29kZSh0LnN1YmFycmF5KGUsbikpO2ZvcihyPVwiXCI7ZTxuOyl7dmFyIGk9dFtlKytdO2lmKDEyOCZpKXt2YXIgbz02MyZ0W2UrK107aWYoMTkyPT0oMjI0JmkpKXIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJmkpPDw2fG8pO2Vsc2V7dmFyIGE9NjMmdFtlKytdOzY1NTM2PihpPTIyND09KDI0MCZpKT8oMTUmaSk8PDEyfG88PDZ8YTooNyZpKTw8MTh8bzw8MTJ8YTw8Nnw2MyZ0W2UrK10pP3IrPVN0cmluZy5mcm9tQ2hhckNvZGUoaSk6KGktPTY1NTM2LHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8aT4+MTAsNTYzMjB8MTAyMyZpKSl9fWVsc2Ugcis9U3RyaW5nLmZyb21DaGFyQ29kZShpKX1yZXR1cm4gcn1mdW5jdGlvbiAkKHQsZSl7cmV0dXJuKHQ+Pj49MCk/RChPLHQsZSk6XCJcIn1mdW5jdGlvbiBrKHQsZSxuLHIpe2lmKCEoMDxyKSlyZXR1cm4gMDt2YXIgaT1uPj4+PTA7cj1uK3ItMTtmb3IodmFyIG89MDtvPHQubGVuZ3RoOysrbyl7dmFyIGE9dC5jaGFyQ29kZUF0KG8pO2lmKDU1Mjk2PD1hJiY1NzM0Mz49YSYmKGE9NjU1MzYrKCgxMDIzJmEpPDwxMCl8MTAyMyZ0LmNoYXJDb2RlQXQoKytvKSksMTI3Pj1hKXtpZihuPj1yKWJyZWFrO2VbbisrPj4+MF09YX1lbHNle2lmKDIwNDc+PWEpe2lmKG4rMT49cilicmVhaztlW24rKz4+PjBdPTE5MnxhPj42fWVsc2V7aWYoNjU1MzU+PWEpe2lmKG4rMj49cilicmVhaztlW24rKz4+PjBdPTIyNHxhPj4xMn1lbHNle2lmKG4rMz49cilicmVhaztlW24rKz4+PjBdPTI0MHxhPj4xOCxlW24rKz4+PjBdPTEyOHxhPj4xMiY2M31lW24rKz4+PjBdPTEyOHxhPj42JjYzfWVbbisrPj4+MF09MTI4fDYzJmF9fXJldHVybiBlW24+Pj4wXT0wLG4taX1mdW5jdGlvbiBDKHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIHI9dC5jaGFyQ29kZUF0KG4pOzEyNz49cj9lKys6MjA0Nz49cj9lKz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8oZSs9NCwrK24pOmUrPTN9cmV0dXJuIGV9ZnVuY3Rpb24gRigpe3ZhciB0PXguYnVmZmVyO1Q9dCxlLkhFQVA4PVM9bmV3IEludDhBcnJheSh0KSxlLkhFQVAxNj1uZXcgSW50MTZBcnJheSh0KSxlLkhFQVAzMj1BPW5ldyBJbnQzMkFycmF5KHQpLGUuSEVBUFU4PU89bmV3IFVpbnQ4QXJyYXkodCksZS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheSh0KSxlLkhFQVBVMzI9RT1uZXcgVWludDMyQXJyYXkodCksZS5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkodCksZS5IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkodCl9dmFyIE4sTD1bXSxSPVtdLGo9W10sTT1bXSxVPTA7ZnVuY3Rpb24gVigpe3ZhciB0PWUucHJlUnVuLnNoaWZ0KCk7TC51bnNoaWZ0KHQpfXZhciBCLHo9MCxHPW51bGwsSD1udWxsO2Z1bmN0aW9uIFcodCl7dGhyb3cgZS5vbkFib3J0JiZlLm9uQWJvcnQodCksdih0PVwiQWJvcnRlZChcIit0K1wiKVwiKSxJPSEwLHQ9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih0K1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxpKHQpLHR9ZnVuY3Rpb24gcSgpe3JldHVybiBCLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfWlmKEI9XCJvcnQtd2FzbS53YXNtXCIsIXEoKSl7dmFyIFg9QjtCPWUubG9jYXRlRmlsZT9lLmxvY2F0ZUZpbGUoWCxtKTptK1h9ZnVuY3Rpb24gWSgpe3ZhciB0PUI7dHJ5e2lmKHQ9PUImJnkpcmV0dXJuIG5ldyBVaW50OEFycmF5KHkpO2lmKHMpcmV0dXJuIHModCk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2godCl7Vyh0KX19ZnVuY3Rpb24gSyh0KXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIit0K1wiKVwiLHRoaXMuc3RhdHVzPXR9ZnVuY3Rpb24gWih0KXtmb3IoOzA8dC5sZW5ndGg7KXQuc2hpZnQoKShlKX12YXIgSj1bXSxRPTAsdHQ9MDtmdW5jdGlvbiBldCh0KXt0aGlzLkRiPXQsdGhpcy56Yj10LTI0LHRoaXMuVWI9ZnVuY3Rpb24odCl7RVt0aGlzLnpiKzQ+PjI+Pj4wXT10fSx0aGlzLkViPWZ1bmN0aW9uKCl7cmV0dXJuIEVbdGhpcy56Yis0Pj4yPj4+MF19LHRoaXMuU2I9ZnVuY3Rpb24odCl7RVt0aGlzLnpiKzg+PjI+Pj4wXT10fSx0aGlzLldiPWZ1bmN0aW9uKCl7cmV0dXJuIEVbdGhpcy56Yis4Pj4yPj4+MF19LHRoaXMuVGI9ZnVuY3Rpb24oKXtBW3RoaXMuemI+PjI+Pj4wXT0wfSx0aGlzLkliPWZ1bmN0aW9uKHQpe1NbdGhpcy56YisxMj4+MD4+PjBdPXQ/MTowfSx0aGlzLlBiPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPVNbdGhpcy56YisxMj4+MD4+PjBdfSx0aGlzLkpiPWZ1bmN0aW9uKHQpe1NbdGhpcy56YisxMz4+MD4+PjBdPXQ/MTowfSx0aGlzLkxiPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPVNbdGhpcy56YisxMz4+MD4+PjBdfSx0aGlzLlJiPWZ1bmN0aW9uKHQsZSl7dGhpcy5GYigwKSx0aGlzLlViKHQpLHRoaXMuU2IoZSksdGhpcy5UYigpLHRoaXMuSWIoITEpLHRoaXMuSmIoITEpfSx0aGlzLk5iPWZ1bmN0aW9uKCl7QVt0aGlzLnpiPj4yPj4+MF0rPTF9LHRoaXMuWGI9ZnVuY3Rpb24oKXt2YXIgdD1BW3RoaXMuemI+PjI+Pj4wXTtyZXR1cm4gQVt0aGlzLnpiPj4yPj4+MF09dC0xLDE9PT10fSx0aGlzLkZiPWZ1bmN0aW9uKHQpe0VbdGhpcy56YisxNj4+Mj4+PjBdPXR9LHRoaXMuT2I9ZnVuY3Rpb24oKXtyZXR1cm4gRVt0aGlzLnpiKzE2Pj4yPj4+MF19LHRoaXMuUWI9ZnVuY3Rpb24oKXtpZihFdCh0aGlzLkViKCkpKXJldHVybiBFW3RoaXMuRGI+PjI+Pj4wXTt2YXIgdD10aGlzLk9iKCk7cmV0dXJuIDAhPT10P3Q6dGhpcy5EYn19ZnVuY3Rpb24gbnQodCl7cmV0dXJuIF90KG5ldyBldCh0KS56Yil9dmFyIHJ0PVtdO2Z1bmN0aW9uIGl0KHQpe3ZhciBlPXJ0W3RdO3JldHVybiBlfHwodD49cnQubGVuZ3RoJiYocnQubGVuZ3RoPXQrMSkscnRbdF09ZT1OLmdldCh0KSksZX1mdW5jdGlvbiBvdCh0KXt2YXIgZT1DKHQpKzEsbj15dChlKTtyZXR1cm4gbiYmayh0LFMsbixlKSxufXZhciBhdD17fTtmdW5jdGlvbiBzdCgpe2lmKCF1dCl7dmFyIHQsZT17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzooXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpmfHxcIi4vdGhpcy5wcm9ncmFtXCJ9O2Zvcih0IGluIGF0KXZvaWQgMD09PWF0W3RdP2RlbGV0ZSBlW3RdOmVbdF09YXRbdF07dmFyIG49W107Zm9yKHQgaW4gZSluLnB1c2godCtcIj1cIitlW3RdKTt1dD1ufXJldHVybiB1dH12YXIgdXQsY3Q9W251bGwsW10sW11dO2Z1bmN0aW9uIGx0KHQsZSl7dmFyIG49Y3RbdF07MD09PWV8fDEwPT09ZT8oKDE9PT10P186dikoRChuLDApKSxuLmxlbmd0aD0wKTpuLnB1c2goZSl9dmFyIHB0PTA7ZnVuY3Rpb24gZnQodCl7cmV0dXJuIDA9PXQlNCYmKDAhPXQlMTAwfHwwPT10JTQwMCl9dmFyIGR0PVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0saHQ9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBndCh0LGUsbixyKXtmdW5jdGlvbiBpKHQsZSxuKXtmb3IodD1cIm51bWJlclwiPT10eXBlb2YgdD90LnRvU3RyaW5nKCk6dHx8XCJcIjt0Lmxlbmd0aDxlOyl0PW5bMF0rdDtyZXR1cm4gdH1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGkodCxlLFwiMFwiKX1mdW5jdGlvbiBhKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gMD50Py0xOjA8dD8xOjB9dmFyIHI7cmV0dXJuIDA9PT0ocj1uKHQuZ2V0RnVsbFllYXIoKS1lLmdldEZ1bGxZZWFyKCkpKSYmMD09PShyPW4odC5nZXRNb250aCgpLWUuZ2V0TW9udGgoKSkpJiYocj1uKHQuZ2V0RGF0ZSgpLWUuZ2V0RGF0ZSgpKSkscn1mdW5jdGlvbiBzKHQpe3N3aXRjaCh0LmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIHUodCl7dmFyIGU9dC5CYjtmb3IodD1uZXcgRGF0ZShuZXcgRGF0ZSh0LkNiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZTspe3ZhciBuPXQuZ2V0TW9udGgoKSxyPShmdCh0LmdldEZ1bGxZZWFyKCkpP2R0Omh0KVtuXTtpZighKGU+ci10LmdldERhdGUoKSkpe3Quc2V0RGF0ZSh0LmdldERhdGUoKStlKTticmVha31lLT1yLXQuZ2V0RGF0ZSgpKzEsdC5zZXREYXRlKDEpLDExPm4/dC5zZXRNb250aChuKzEpOih0LnNldE1vbnRoKDApLHQuc2V0RnVsbFllYXIodC5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gbj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCkrMSwwLDQpLGU9cyhuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCw0KSksbj1zKG4pLDA+PWEoZSx0KT8wPj1hKG4sdCk/dC5nZXRGdWxsWWVhcigpKzE6dC5nZXRGdWxsWWVhcigpOnQuZ2V0RnVsbFllYXIoKS0xfXZhciBjPUFbcis0MD4+Mj4+PjBdO2Zvcih2YXIgbCBpbiByPXskYjpBW3I+PjI+Pj4wXSxaYjpBW3IrND4+Mj4+PjBdLEdiOkFbcis4Pj4yPj4+MF0sS2I6QVtyKzEyPj4yPj4+MF0sSGI6QVtyKzE2Pj4yPj4+MF0sQ2I6QVtyKzIwPj4yPj4+MF0sQWI6QVtyKzI0Pj4yPj4+MF0sQmI6QVtyKzI4Pj4yPj4+MF0sYmM6QVtyKzMyPj4yPj4+MF0sWWI6QVtyKzM2Pj4yPj4+MF0sYWM6Yz8kKGMpOlwiXCJ9LG49JChuKSxjPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn0pbj1uLnJlcGxhY2UobmV3IFJlZ0V4cChsLFwiZ1wiKSxjW2xdKTt2YXIgcD1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGY9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO2ZvcihsIGluIGM9e1wiJWFcIjpmdW5jdGlvbih0KXtyZXR1cm4gcFt0LkFiXS5zdWJzdHJpbmcoMCwzKX0sXCIlQVwiOmZ1bmN0aW9uKHQpe3JldHVybiBwW3QuQWJdfSxcIiViXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGZbdC5IYl0uc3Vic3RyaW5nKDAsMyl9LFwiJUJcIjpmdW5jdGlvbih0KXtyZXR1cm4gZlt0LkhiXX0sXCIlQ1wiOmZ1bmN0aW9uKHQpe3JldHVybiBvKCh0LkNiKzE5MDApLzEwMHwwLDIpfSxcIiVkXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5LYiwyKX0sXCIlZVwiOmZ1bmN0aW9uKHQpe3JldHVybiBpKHQuS2IsMixcIiBcIil9LFwiJWdcIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0KS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlR1wiOmZ1bmN0aW9uKHQpe3JldHVybiB1KHQpfSxcIiVIXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5HYiwyKX0sXCIlSVwiOmZ1bmN0aW9uKHQpe3JldHVybiAwPT0odD10LkdiKT90PTEyOjEyPHQmJih0LT0xMiksbyh0LDIpfSxcIiVqXCI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj0wO248PXQuSGItMTtlKz0oZnQodC5DYisxOTAwKT9kdDpodClbbisrXSk7cmV0dXJuIG8odC5LYitlLDMpfSxcIiVtXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5IYisxLDIpfSxcIiVNXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5aYiwyKX0sXCIlblwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXG5cIn0sXCIlcFwiOmZ1bmN0aW9uKHQpe3JldHVybiAwPD10LkdiJiYxMj50LkdiP1wiQU1cIjpcIlBNXCJ9LFwiJVNcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyh0LiRiLDIpfSxcIiV0XCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcdFwifSxcIiV1XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQWJ8fDd9LFwiJVVcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyhNYXRoLmZsb29yKCh0LkJiKzctdC5BYikvNyksMil9LFwiJVZcIjpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLmZsb29yKCh0LkJiKzctKHQuQWIrNiklNykvNyk7aWYoMj49KHQuQWIrMzcxLXQuQmItMiklNyYmZSsrLGUpNTM9PWUmJig0PT0obj0odC5BYiszNzEtdC5CYiklNyl8fDM9PW4mJmZ0KHQuQ2IpfHwoZT0xKSk7ZWxzZXtlPTUyO3ZhciBuPSh0LkFiKzctdC5CYi0xKSU3Oyg0PT1ufHw1PT1uJiZmdCh0LkNiJTQwMC0xKSkmJmUrK31yZXR1cm4gbyhlLDIpfSxcIiV3XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQWJ9LFwiJVdcIjpmdW5jdGlvbih0KXtyZXR1cm4gbyhNYXRoLmZsb29yKCh0LkJiKzctKHQuQWIrNiklNykvNyksMil9LFwiJXlcIjpmdW5jdGlvbih0KXtyZXR1cm4odC5DYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlWVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LkNiKzE5MDB9LFwiJXpcIjpmdW5jdGlvbih0KXt2YXIgZT0wPD0odD10LlliKTtyZXR1cm4gdD1NYXRoLmFicyh0KS82MCwoZT9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiKyh0LzYwKjEwMCt0JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuYWN9LFwiJSVcIjpmdW5jdGlvbigpe3JldHVyblwiJVwifX0sbj1uLnJlcGxhY2UoLyUlL2csXCJcXDBcXDBcIiksYyluLmluY2x1ZGVzKGwpJiYobj1uLnJlcGxhY2UobmV3IFJlZ0V4cChsLFwiZ1wiKSxjW2xdKHIpKSk7cmV0dXJuIGw9ZnVuY3Rpb24odCl7dmFyIGU9QXJyYXkoQyh0KSsxKTtyZXR1cm4gayh0LGUsMCxlLmxlbmd0aCksZX0obj1uLnJlcGxhY2UoL1xcMFxcMC9nLFwiJVwiKSksbC5sZW5ndGg+ZT8wOihTLnNldChsLHQ+Pj4wKSxsLmxlbmd0aC0xKX12YXIgYnQ9e2E6ZnVuY3Rpb24odCl7cmV0dXJuIHl0KHQrMjQpKzI0fSxtOmZ1bmN0aW9uKHQpe3JldHVybih0PW5ldyBldCh0KSkuUGIoKXx8KHQuSWIoITApLFEtLSksdC5KYighMSksSi5wdXNoKHQpLHQuTmIoKSx0LlFiKCl9LGlhOmZ1bmN0aW9uKHQpe3Rocm93IHYoXCJVbmV4cGVjdGVkIGV4Y2VwdGlvbiB0aHJvd24sIHRoaXMgaXMgbm90IHByb3Blcmx5IHN1cHBvcnRlZCAtIGFib3J0aW5nXCIpLEk9ITAsdH0sdzpmdW5jdGlvbigpe3h0KDApO3ZhciB0PUoucG9wKCk7aWYodC5YYigpJiYhdC5MYigpKXt2YXIgZT10LldiKCk7ZSYmaXQoZSkodC5EYiksbnQodC5EYil9dHQ9MH0sZDpmdW5jdGlvbigpe3ZhciB0PXR0O2lmKCF0KXJldHVybiBwdD0wO3ZhciBlPW5ldyBldCh0KTtlLkZiKHQpO3ZhciBuPWUuRWIoKTtpZighbilyZXR1cm4gcHQ9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGk9MDtpPHIubGVuZ3RoO2krKyl7dmFyIG89cltpXTtpZigwPT09b3x8bz09PW4pYnJlYWs7aWYoQXQobyxuLGUuemIrMTYpKXJldHVybiBwdD1vLHR9cmV0dXJuIHB0PW4sdH0sazpmdW5jdGlvbigpe3ZhciB0PXR0O2lmKCF0KXJldHVybiBwdD0wO3ZhciBlPW5ldyBldCh0KTtlLkZiKHQpO3ZhciBuPWUuRWIoKTtpZighbilyZXR1cm4gcHQ9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGk9MDtpPHIubGVuZ3RoO2krKyl7dmFyIG89cltpXTtpZigwPT09b3x8bz09PW4pYnJlYWs7aWYoQXQobyxuLGUuemIrMTYpKXJldHVybiBwdD1vLHR9cmV0dXJuIHB0PW4sdH0sZzpmdW5jdGlvbigpe3ZhciB0PXR0O2lmKCF0KXJldHVybiBwdD0wO3ZhciBlPW5ldyBldCh0KTtlLkZiKHQpO3ZhciBuPWUuRWIoKTtpZighbilyZXR1cm4gcHQ9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGk9MDtpPHIubGVuZ3RoO2krKyl7dmFyIG89cltpXTtpZigwPT09b3x8bz09PW4pYnJlYWs7aWYoQXQobyxuLGUuemIrMTYpKXJldHVybiBwdD1vLHR9cmV0dXJuIHB0PW4sdH0sczpudCxMOmZ1bmN0aW9uKCl7dmFyIHQ9Si5wb3AoKTt0fHxXKFwibm8gZXhjZXB0aW9uIHRvIHRocm93XCIpO3ZhciBlPXQuRGI7dGhyb3cgdC5MYigpfHwoSi5wdXNoKHQpLHQuSmIoITApLHQuSWIoITEpLFErKyksdHQ9ZSxlfSxiOmZ1bmN0aW9uKHQsZSxuKXt0aHJvdyBuZXcgZXQodCkuUmIoZSxuKSx0dD10LFErKyx0fSxsYTpmdW5jdGlvbigpe3JldHVybiBRfSxpOmZ1bmN0aW9uKHQpe3Rocm93IHR0fHwodHQ9dCksdH0sSDpmdW5jdGlvbigpe3JldHVybiAwfSxCYTpmdW5jdGlvbigpe30scGE6ZnVuY3Rpb24oKXt9LHJhOmZ1bmN0aW9uKCl7fSxrYTpmdW5jdGlvbigpe3JldHVybiAwfSx6YTpmdW5jdGlvbigpe30sdWE6ZnVuY3Rpb24oKXt9LHlhOmZ1bmN0aW9uKCl7fSxSOmZ1bmN0aW9uKCl7fSxxYTpmdW5jdGlvbigpe30sbmE6ZnVuY3Rpb24oKXt9LEFhOmZ1bmN0aW9uKCl7fSxvYTpmdW5jdGlvbigpe30sSGE6ZnVuY3Rpb24oKXt9LEphOmZ1bmN0aW9uKCl7VyhcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxJYTpmdW5jdGlvbigpe1coXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX0sUzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSxDYTpmdW5jdGlvbigpe3JldHVybiEwfSxEYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKihFW3Q+Pj4yXSs0Mjk0OTY3Mjk2KkFbdCs0Pj4+Ml0pKSxBW2U+PjI+Pj4wXT10LmdldFVUQ1NlY29uZHMoKSxBW2UrND4+Mj4+PjBdPXQuZ2V0VVRDTWludXRlcygpLEFbZSs4Pj4yPj4+MF09dC5nZXRVVENIb3VycygpLEFbZSsxMj4+Mj4+PjBdPXQuZ2V0VVRDRGF0ZSgpLEFbZSsxNj4+Mj4+PjBdPXQuZ2V0VVRDTW9udGgoKSxBW2UrMjA+PjI+Pj4wXT10LmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxBW2UrMjQ+PjI+Pj4wXT10LmdldFVUQ0RheSgpLEFbZSsyOD4+Mj4+PjBdPSh0LmdldFRpbWUoKS1EYXRlLlVUQyh0LmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwfSxFYTpmdW5jdGlvbih0LGUpe3Q9bmV3IERhdGUoMWUzKihFW3Q+Pj4yXSs0Mjk0OTY3Mjk2KkFbdCs0Pj4+Ml0pKSxBW2U+PjI+Pj4wXT10LmdldFNlY29uZHMoKSxBW2UrND4+Mj4+PjBdPXQuZ2V0TWludXRlcygpLEFbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLEFbZSsxMj4+Mj4+PjBdPXQuZ2V0RGF0ZSgpLEFbZSsxNj4+Mj4+PjBdPXQuZ2V0TW9udGgoKSxBW2UrMjA+PjI+Pj4wXT10LmdldEZ1bGxZZWFyKCktMTkwMCxBW2UrMjQ+PjI+Pj4wXT10LmdldERheSgpO3ZhciBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpO0FbZSsyOD4+Mj4+PjBdPSh0LmdldFRpbWUoKS1uLmdldFRpbWUoKSkvODY0ZTV8MCxBW2UrMzY+PjI+Pj4wXT0tNjAqdC5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciByPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7bj1uLmdldFRpbWV6b25lT2Zmc2V0KCksQVtlKzMyPj4yPj4+MF09MHwociE9biYmdC5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihuLHIpKX0sRmE6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IERhdGUoQVt0KzIwPj4yPj4+MF0rMTkwMCxBW3QrMTY+PjI+Pj4wXSxBW3QrMTI+PjI+Pj4wXSxBW3QrOD4+Mj4+PjBdLEFbdCs0Pj4yPj4+MF0sQVt0Pj4yPj4+MF0sMCksbj1BW3QrMzI+PjI+Pj4wXSxyPWUuZ2V0VGltZXpvbmVPZmZzZXQoKSxpPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpLG89bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxhPWkuZ2V0VGltZXpvbmVPZmZzZXQoKSxzPU1hdGgubWluKGEsbyk7cmV0dXJuIDA+bj9BW3QrMzI+PjI+Pj4wXT1OdW1iZXIobyE9YSYmcz09cik6MDxuIT0ocz09cikmJihvPU1hdGgubWF4KGEsbyksZS5zZXRUaW1lKGUuZ2V0VGltZSgpKzZlNCooKDA8bj9zOm8pLXIpKSksQVt0KzI0Pj4yPj4+MF09ZS5nZXREYXkoKSxBW3QrMjg+PjI+Pj4wXT0oZS5nZXRUaW1lKCktaS5nZXRUaW1lKCkpLzg2NGU1fDAsQVt0Pj4yPj4+MF09ZS5nZXRTZWNvbmRzKCksQVt0KzQ+PjI+Pj4wXT1lLmdldE1pbnV0ZXMoKSxBW3QrOD4+Mj4+PjBdPWUuZ2V0SG91cnMoKSxBW3QrMTI+PjI+Pj4wXT1lLmdldERhdGUoKSxBW3QrMTY+PjI+Pj4wXT1lLmdldE1vbnRoKCksZS5nZXRUaW1lKCkvMWUzfDB9LHNhOmZ1bmN0aW9uKCl7cmV0dXJuLTUyfSx0YTpmdW5jdGlvbigpe30sR2E6ZnVuY3Rpb24gdChlLG4scil7dC5WYnx8KHQuVmI9ITAsZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7cmV0dXJuKHQ9dC50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pKT90WzFdOlwiR01UXCJ9dmFyIGk9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLG89bmV3IERhdGUoaSwwLDEpLGE9bmV3IERhdGUoaSw2LDEpO2k9by5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzPWEuZ2V0VGltZXpvbmVPZmZzZXQoKTtBW3Q+PjI+Pj4wXT02MCpNYXRoLm1heChpLHMpLEFbZT4+Mj4+PjBdPU51bWJlcihpIT1zKSx0PXIobyksZT1yKGEpLHQ9b3QodCksZT1vdChlKSxzPGk/KEVbbj4+Mj4+PjBdPXQsRVtuKzQ+PjI+Pj4wXT1lKTooRVtuPj4yPj4+MF09ZSxFW24rND4+Mj4+PjBdPXQpfShlLG4scikpfSxCOmZ1bmN0aW9uKCl7VyhcIlwiKX0sbWE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sSTpiPygpPT57dmFyIHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKnRbMF0rdFsxXS8xZTZ9OigpPT5wZXJmb3JtYW5jZS5ub3coKSx4YTpmdW5jdGlvbih0LGUsbil7Ty5jb3B5V2l0aGluKHQ+Pj4wLGU+Pj4wLGUrbj4+PjApfSxHOmZ1bmN0aW9uKHQpe3ZhciBlPU8ubGVuZ3RoO2lmKDQyOTQ5MDE3NjA8KHQ+Pj49MCkpcmV0dXJuITE7Zm9yKHZhciBuPTE7ND49bjtuKj0yKXt2YXIgcj1lKigxKy4yL24pO3I9TWF0aC5taW4ocix0KzEwMDY2MzI5Nik7dmFyIGk9TWF0aDtyPU1hdGgubWF4KHQsciksaT1pLm1pbi5jYWxsKGksNDI5NDkwMTc2MCxyKyg2NTUzNi1yJTY1NTM2KSU2NTUzNik7dDp7dHJ5e3guZ3JvdyhpLVQuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2KSxGKCk7dmFyIG89MTticmVhayB0fWNhdGNoKHQpe31vPXZvaWQgMH1pZihvKXJldHVybiEwfXJldHVybiExfSx2YTpmdW5jdGlvbih0LGUpe3ZhciBuPTA7cmV0dXJuIHN0KCkuZm9yRWFjaCgoZnVuY3Rpb24ocixpKXt2YXIgbz1lK247Zm9yKGk9RVt0KzQqaT4+Mj4+PjBdPW8sbz0wO288ci5sZW5ndGg7KytvKVNbaSsrPj4wPj4+MF09ci5jaGFyQ29kZUF0KG8pO1NbaT4+MD4+PjBdPTAsbis9ci5sZW5ndGgrMX0pKSwwfSx3YTpmdW5jdGlvbih0LGUpe3ZhciBuPXN0KCk7RVt0Pj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtyKz10Lmxlbmd0aCsxfSkpLEVbZT4+Mj4+PjBdPXIsMH0sYmE6ZnVuY3Rpb24odCl7d3x8MDxVfHwod3QoKSxaKGopLHZ0KDApLGN0WzFdLmxlbmd0aCYmbHQoMSwxMCksY3RbMl0ubGVuZ3RoJiZsdCgyLDEwKSksd3x8MDxVfHwoZS5vbkV4aXQmJmUub25FeGl0KHQpLEk9ITApLGQodCxuZXcgSyh0KSl9LEU6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LFE6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LGNhOmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxQOmZ1bmN0aW9uKHQsZSxuLHIpe2Zvcih2YXIgaT0wLG89MDtvPG47bysrKXt2YXIgYT1FW2U+PjI+Pj4wXSxzPUVbZSs0Pj4yPj4+MF07ZSs9ODtmb3IodmFyIHU9MDt1PHM7dSsrKWx0KHQsT1thK3U+Pj4wXSk7aSs9c31yZXR1cm4gRVtyPj4yPj4+MF09aSwwfSxjOmZ1bmN0aW9uKCl7cmV0dXJuIHB0fSxqYTpmdW5jdGlvbiB0KGUscil7dC5NYnx8KHQuTWI9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYoYil0cnl7dmFyIGU9bihPYmplY3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ2NyeXB0bydcIik7dGhyb3cgdC5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLHR9KCkpKTtyZXR1cm4oKT0+ZS5yYW5kb21CeXRlcygxKVswXX1jYXRjaCh0KXt9cmV0dXJuKCk9PlcoXCJyYW5kb21EZXZpY2VcIil9KCkpO2Zvcih2YXIgaT0wO2k8cjtpKyspU1tlK2k+PjA+Pj4wXT10Lk1iKCk7cmV0dXJuIDB9LGVhOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGZhOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LEo6ZnVuY3Rpb24odCl7dmFyIGU9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKCl9Y2F0Y2godCl7aWYoU3QoZSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxlOmZ1bmN0aW9uKHQsZSl7dmFyIG49VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUpfWNhdGNoKHQpe2lmKFN0KG4pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sTjpmdW5jdGlvbih0LGUsbil7dmFyIHI9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxPOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGo6ZnVuY3Rpb24odCxlLG4pe3ZhciByPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sbzpmdW5jdGlvbih0LGUsbixyKXt2YXIgaT1UdCgpO3RyeXtyZXR1cm4gaXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKFN0KGkpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0scDpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4scixpKX1jYXRjaCh0KXtpZihTdChvKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LE06ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4scixpLG8pfWNhdGNoKHQpe2lmKFN0KGEpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0scjpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyl9Y2F0Y2godCl7aWYoU3QoYSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSx2OmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzPVR0KCk7dHJ5e3JldHVybiBpdCh0KShlLG4scixpLG8sYSl9Y2F0Y2godCl7aWYoU3QocyksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxLOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sRDpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMsdSxjLGwscCl7dmFyIGY9VHQoKTt0cnl7cmV0dXJuIGl0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCl9Y2F0Y2godCl7aWYoU3QoZiksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxYOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9VHQoKTt0cnl7cmV0dXJuIEx0KHQsZSxuLHIsaSxvLGEscyl9Y2F0Y2godCl7aWYoU3QodSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxWOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEpe3ZhciBzPVR0KCk7dHJ5e3JldHVybiBQdCh0LGUsbixyLGksbyxhKX1jYXRjaCh0KXtpZihTdChzKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFU6ZnVuY3Rpb24odCxlLG4scixpKXt2YXIgbz1UdCgpO3RyeXtyZXR1cm4gUnQodCxlLG4scixpKX1jYXRjaCh0KXtpZihTdChvKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LFo6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9VHQoKTt0cnl7cmV0dXJuIEZ0KHQsZSxuLHIpfWNhdGNoKHQpe2lmKFN0KGkpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sVzpmdW5jdGlvbih0KXt2YXIgZT1UdCgpO3RyeXtyZXR1cm4gSXQodCl9Y2F0Y2godCl7aWYoU3QoZSksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxZOmZ1bmN0aW9uKHQsZSl7dmFyIG49VHQoKTt0cnl7cmV0dXJuIE50KHQsZSl9Y2F0Y2godCl7aWYoU3QobiksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxUOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1UdCgpO3RyeXtyZXR1cm4gRHQodCxlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sZjpmdW5jdGlvbih0KXt2YXIgZT1UdCgpO3RyeXtpdCh0KSgpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0scTpmdW5jdGlvbih0LGUpe3ZhciBuPVR0KCk7dHJ5e2l0KHQpKGUpfWNhdGNoKHQpe2lmKFN0KG4pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0saDpmdW5jdGlvbih0LGUsbil7dmFyIHI9VHQoKTt0cnl7aXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGRhOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPVR0KCk7dHJ5e2l0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChpKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGw6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9VHQoKTt0cnl7aXQodCkoZSxuLHIpfWNhdGNoKHQpe2lmKFN0KGkpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sdDpmdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPVR0KCk7dHJ5e2l0KHQpKGUsbixyLGkpfWNhdGNoKHQpe2lmKFN0KG8pLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sdTpmdW5jdGlvbih0LGUsbixyLGksbyl7dmFyIGE9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LHg6ZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvLGEpfWNhdGNoKHQpe2lmKFN0KHMpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sejpmdW5jdGlvbih0LGUsbixyLGksbyxhLHMpe3ZhciB1PVR0KCk7dHJ5e2l0KHQpKGUsbixyLGksbyxhLHMpfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDt4dCgxLDApfX0sZ2E6ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUpe3ZhciBjPVR0KCk7dHJ5e2l0KHQpKGUsbixyLGksbyxhLHMsdSl9Y2F0Y2godCl7aWYoU3QoYyksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxBOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCl7dmFyIHA9VHQoKTt0cnl7aXQodCkoZSxuLHIsaSxvLGEscyx1LGMsbCl9Y2F0Y2godCl7aWYoU3QocCksdCE9PXQrMCl0aHJvdyB0O3h0KDEsMCl9fSxDOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwLGYsZCxoLGcpe3ZhciBiPVR0KCk7dHJ5e2l0KHQpKGUsbixyLGksbyxhLHMsdSxjLGwscCxmLGQsaCxnKX1jYXRjaCh0KXtpZihTdChiKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LGFhOmZ1bmN0aW9uKHQsZSxuLHIsaSxvLGEscyl7dmFyIHU9VHQoKTt0cnl7JHQodCxlLG4scixpLG8sYSxzKX1jYXRjaCh0KXtpZihTdCh1KSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LF86ZnVuY3Rpb24odCxlLG4scixpLG8sYSxzLHUsYyxsLHApe3ZhciBmPVR0KCk7dHJ5e0N0KHQsZSxuLHIsaSxvLGEscyx1LGMsbCxwKX1jYXRjaCh0KXtpZihTdChmKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LCQ6ZnVuY3Rpb24odCxlLG4scixpLG8pe3ZhciBhPVR0KCk7dHJ5e2t0KHQsZSxuLHIsaSxvKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7eHQoMSwwKX19LG46ZnVuY3Rpb24odCl7cmV0dXJuIHR9LEY6ZnVuY3Rpb24odCl7cHQ9dH0saGE6Z3QseTpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gZ3QodCxlLG4scil9fTshZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2UuYXNtPXQuZXhwb3J0cyx4PWUuYXNtLkthLEYoKSxOPWUuYXNtLmliLFIudW5zaGlmdChlLmFzbS5MYSksei0tLGUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHopLDA9PXomJihudWxsIT09RyYmKGNsZWFySW50ZXJ2YWwoRyksRz1udWxsKSxIJiYodD1ILEg9bnVsbCx0KCkpKX1mdW5jdGlvbiBuKGUpe3QoZS5pbnN0YW5jZSl9ZnVuY3Rpb24gcih0KXtyZXR1cm4gZnVuY3Rpb24oKXtpZigheSYmKGh8fGcpKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBmZXRjaCYmIUIuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKEIse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIitCK1wiJ1wiO3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIFkoKX0pKTtpZihhKXJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxlKXthKEIsKGZ1bmN0aW9uKGUpe3QobmV3IFVpbnQ4QXJyYXkoZSkpfSksZSl9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIFkoKX0pKX0oKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodCxvKX0pKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKS50aGVuKHQsKGZ1bmN0aW9uKHQpe3YoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIit0KSxXKHQpfSkpfXZhciBvPXthOmJ0fTtpZih6KyssZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoeiksZS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBlLmluc3RhbnRpYXRlV2FzbShvLHQpfWNhdGNoKHQpe3JldHVybiB2KFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrdCksITF9KHl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxxKCl8fEIuc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fGJ8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoP3Iobik6ZmV0Y2goQix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHQsbykudGhlbihuLChmdW5jdGlvbih0KXtyZXR1cm4gdihcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIit0KSx2KFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIikscihuKX0pKX0pKSkuY2F0Y2goaSl9KCksZS5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fX193YXNtX2NhbGxfY3RvcnM9ZS5hc20uTGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0SW5pdD1mdW5jdGlvbigpe3JldHVybihlLl9PcnRJbml0PWUuYXNtLk1hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPWUuYXNtLk5hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPWUuYXNtLk9hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9ZS5hc20uUGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1lLmFzbS5RYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVTZXNzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVNlc3Npb249ZS5hc20uUmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVNlc3Npb249ZS5hc20uU2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0SW5wdXRDb3VudD1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRJbnB1dENvdW50PWUuYXNtLlRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEdldE91dHB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldE91dHB1dENvdW50PWUuYXNtLlVhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEdldElucHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRJbnB1dE5hbWU9ZS5hc20uVmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0T3V0cHV0TmFtZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRPdXRwdXROYW1lPWUuYXNtLldhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0RnJlZT1lLmFzbS5YYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlVGVuc29yPWUuYXNtLllhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEdldFRlbnNvckRhdGE9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0R2V0VGVuc29yRGF0YT1lLmFzbS5aYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlVGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJlbGVhc2VUZW5zb3I9ZS5hc20uX2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1mdW5jdGlvbigpe3JldHVybihlLl9PcnRDcmVhdGVSdW5PcHRpb25zPWUuYXNtLiRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PWUuYXNtLmFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJlbGVhc2VSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJlbGVhc2VSdW5PcHRpb25zPWUuYXNtLmJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJ1bj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRSdW49ZS5hc20uY2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0RW5kUHJvZmlsaW5nPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEVuZFByb2ZpbGluZz1lLmFzbS5kYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgbXQseXQ9ZS5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKHl0PWUuX21hbGxvYz1lLmFzbS5lYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfdD1lLl9mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKF90PWUuX2ZyZWU9ZS5hc20uZmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdnQ9ZS5fZmZsdXNoPWZ1bmN0aW9uKCl7cmV0dXJuKHZ0PWUuX2ZmbHVzaD1lLmFzbS5nYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx3dD1lLl9fX2Z1bmNzX29uX2V4aXQ9ZnVuY3Rpb24oKXtyZXR1cm4od3Q9ZS5fX19mdW5jc19vbl9leGl0PWUuYXNtLmhiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHh0PWUuX3NldFRocmV3PWZ1bmN0aW9uKCl7cmV0dXJuKHh0PWUuX3NldFRocmV3PWUuYXNtLmpiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFR0PWUuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKFR0PWUuc3RhY2tTYXZlPWUuYXNtLmtiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFN0PWUuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKFN0PWUuc3RhY2tSZXN0b3JlPWUuYXNtLmxiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE90PWUuc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihPdD1lLnN0YWNrQWxsb2M9ZS5hc20ubWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQXQ9ZS5fX19jeGFfY2FuX2NhdGNoPWZ1bmN0aW9uKCl7cmV0dXJuKEF0PWUuX19fY3hhX2Nhbl9jYXRjaD1lLmFzbS5uYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFdD1lLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4oRXQ9ZS5fX19jeGFfaXNfcG9pbnRlcl90eXBlPWUuYXNtLm9iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEl0PWUuZHluQ2FsbF9qPWZ1bmN0aW9uKCl7cmV0dXJuKEl0PWUuZHluQ2FsbF9qPWUuYXNtLnBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFB0PWUuZHluQ2FsbF9paWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oUHQ9ZS5keW5DYWxsX2lpaWlpaj1lLmFzbS5xYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxEdD1lLmR5bkNhbGxfamlpPWZ1bmN0aW9uKCl7cmV0dXJuKER0PWUuZHluQ2FsbF9qaWk9ZS5hc20ucmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sJHQ9ZS5keW5DYWxsX3ZpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oJHQ9ZS5keW5DYWxsX3ZpaWlpaWo9ZS5hc20uc2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sa3Q9ZS5keW5DYWxsX3Zqamk9ZnVuY3Rpb24oKXtyZXR1cm4oa3Q9ZS5keW5DYWxsX3Zqamk9ZS5hc20udGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ3Q9ZS5keW5DYWxsX3ZpaWlqamppaT1mdW5jdGlvbigpe3JldHVybihDdD1lLmR5bkNhbGxfdmlpaWpqamlpPWUuYXNtLnViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZ0PWUuZHluQ2FsbF9paWo9ZnVuY3Rpb24oKXtyZXR1cm4oRnQ9ZS5keW5DYWxsX2lpaj1lLmFzbS52YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxOdD1lLmR5bkNhbGxfamk9ZnVuY3Rpb24oKXtyZXR1cm4oTnQ9ZS5keW5DYWxsX2ppPWUuYXNtLndiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEx0PWUuZHluQ2FsbF9paWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEx0PWUuZHluQ2FsbF9paWlpaWlqPWUuYXNtLnhiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJ0PWUuZHluQ2FsbF9paWlqPWZ1bmN0aW9uKCl7cmV0dXJuKFJ0PWUuZHluQ2FsbF9paWlqPWUuYXNtLnliKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIGp0KCl7ZnVuY3Rpb24gdCgpe2lmKCFtdCYmKG10PSEwLGUuY2FsbGVkUnVuPSEwLCFJKSl7aWYoWihSKSxyKGUpLGUub25SdW50aW1lSW5pdGlhbGl6ZWQmJmUub25SdW50aW1lSW5pdGlhbGl6ZWQoKSxlLnBvc3RSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucG9zdFJ1biYmKGUucG9zdFJ1bj1bZS5wb3N0UnVuXSk7ZS5wb3N0UnVuLmxlbmd0aDspe3ZhciB0PWUucG9zdFJ1bi5zaGlmdCgpO00udW5zaGlmdCh0KX1aKE0pfX1pZighKDA8eikpe2lmKGUucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnByZVJ1biYmKGUucHJlUnVuPVtlLnByZVJ1bl0pO2UucHJlUnVuLmxlbmd0aDspVigpO1ooTCksMDx6fHwoZS5zZXRTdGF0dXM/KGUuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS5zZXRTdGF0dXMoXCJcIil9KSwxKSx0KCl9KSwxKSk6dCgpKX19aWYoZS5VVEY4VG9TdHJpbmc9JCxlLnN0cmluZ1RvVVRGOD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGsodCxPLGUsbil9LGUubGVuZ3RoQnl0ZXNVVEY4PUMsZS5zdGFja1NhdmU9VHQsZS5zdGFja1Jlc3RvcmU9U3QsZS5zdGFja0FsbG9jPU90LEg9ZnVuY3Rpb24gdCgpe210fHxqdCgpLG10fHwoSD10KX0sZS5wcmVJbml0KWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnByZUluaXQmJihlLnByZUluaXQ9W2UucHJlSW5pdF0pOzA8ZS5wcmVJbml0Lmxlbmd0aDspZS5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIGp0KCksdC5yZWFkeX0pO3QuZXhwb3J0cz1yfSw0NTM3OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSkscj0wLGk9MixvPSEwO2k8YXJndW1lbnRzLmxlbmd0aDspbltyKytdPWFyZ3VtZW50c1tpKytdO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oaSxhKXtuW3JdPWZ1bmN0aW9uKHQpe2lmKG8paWYobz0hMSx0KWEodCk7ZWxzZXtmb3IodmFyIGU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksbj0wO248ZS5sZW5ndGg7KWVbbisrXT1hcmd1bWVudHNbbl07aS5hcHBseShudWxsLGUpfX07dHJ5e3QuYXBwbHkoZXx8bnVsbCxuKX1jYXRjaCh0KXtvJiYobz0hMSxhKHQpKX19KSl9fSw3NDE5Oih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZTtuLmxlbmd0aD1mdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtpZighZSlyZXR1cm4gMDtmb3IodmFyIG49MDstLWUlND4xJiZcIj1cIj09PXQuY2hhckF0KGUpOykrK247cmV0dXJuIE1hdGguY2VpbCgzKnQubGVuZ3RoKS80LW59O2Zvcih2YXIgcj1uZXcgQXJyYXkoNjQpLGk9bmV3IEFycmF5KDEyMyksbz0wO288NjQ7KWlbcltvXT1vPDI2P28rNjU6bzw1Mj9vKzcxOm88NjI/by00Om8tNTl8NDNdPW8rKztuLmVuY29kZT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpLG89bnVsbCxhPVtdLHM9MCx1PTA7ZTxuOyl7dmFyIGM9dFtlKytdO3N3aXRjaCh1KXtjYXNlIDA6YVtzKytdPXJbYz4+Ml0saT0oMyZjKTw8NCx1PTE7YnJlYWs7Y2FzZSAxOmFbcysrXT1yW2l8Yz4+NF0saT0oMTUmYyk8PDIsdT0yO2JyZWFrO2Nhc2UgMjphW3MrK109cltpfGM+PjZdLGFbcysrXT1yWzYzJmNdLHU9MH1zPjgxOTEmJigob3x8KG89W10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGEpKSxzPTApfXJldHVybiB1JiYoYVtzKytdPXJbaV0sYVtzKytdPTYxLDE9PT11JiYoYVtzKytdPTYxKSksbz8ocyYmby5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGEuc2xpY2UoMCxzKSkpLG8uam9pbihcIlwiKSk6U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsYS5zbGljZSgwLHMpKX07dmFyIGE9XCJpbnZhbGlkIGVuY29kaW5nXCI7bi5kZWNvZGU9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcixvPW4scz0wLHU9MDt1PHQubGVuZ3RoOyl7dmFyIGM9dC5jaGFyQ29kZUF0KHUrKyk7aWYoNjE9PT1jJiZzPjEpYnJlYWs7aWYodm9pZCAwPT09KGM9aVtjXSkpdGhyb3cgRXJyb3IoYSk7c3dpdGNoKHMpe2Nhc2UgMDpyPWMscz0xO2JyZWFrO2Nhc2UgMTplW24rK109cjw8MnwoNDgmYyk+PjQscj1jLHM9MjticmVhaztjYXNlIDI6ZVtuKytdPSgxNSZyKTw8NHwoNjAmYyk+PjIscj1jLHM9MzticmVhaztjYXNlIDM6ZVtuKytdPSgzJnIpPDw2fGMscz0wfX1pZigxPT09cyl0aHJvdyBFcnJvcihhKTtyZXR1cm4gbi1vfSxuLnRlc3Q9ZnVuY3Rpb24odCl7cmV0dXJuL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3QodCl9fSw5MjExOnQ9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKCl7dGhpcy5fbGlzdGVuZXJzPXt9fXQuZXhwb3J0cz1lLGUucHJvdG90eXBlLm9uPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4odGhpcy5fbGlzdGVuZXJzW3RdfHwodGhpcy5fbGlzdGVuZXJzW3RdPVtdKSkucHVzaCh7Zm46ZSxjdHg6bnx8dGhpc30pLHRoaXN9LGUucHJvdG90eXBlLm9mZj1mdW5jdGlvbih0LGUpe2lmKHZvaWQgMD09PXQpdGhpcy5fbGlzdGVuZXJzPXt9O2Vsc2UgaWYodm9pZCAwPT09ZSl0aGlzLl9saXN0ZW5lcnNbdF09W107ZWxzZSBmb3IodmFyIG49dGhpcy5fbGlzdGVuZXJzW3RdLHI9MDtyPG4ubGVuZ3RoOyluW3JdLmZuPT09ZT9uLnNwbGljZShyLDEpOisrcjtyZXR1cm4gdGhpc30sZS5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9saXN0ZW5lcnNbdF07aWYoZSl7Zm9yKHZhciBuPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7KW4ucHVzaChhcmd1bWVudHNbcisrXSk7Zm9yKHI9MDtyPGUubGVuZ3RoOyllW3JdLmZuLmFwcGx5KGVbcisrXS5jdHgsbil9cmV0dXJuIHRoaXN9fSw5NDU6dD0+e1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUodCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEZsb2F0MzJBcnJheT9mdW5jdGlvbigpe3ZhciBlPW5ldyBGbG9hdDMyQXJyYXkoWy0wXSksbj1uZXcgVWludDhBcnJheShlLmJ1ZmZlcikscj0xMjg9PT1uWzNdO2Z1bmN0aW9uIGkodCxyLGkpe2VbMF09dCxyW2ldPW5bMF0scltpKzFdPW5bMV0scltpKzJdPW5bMl0scltpKzNdPW5bM119ZnVuY3Rpb24gbyh0LHIsaSl7ZVswXT10LHJbaV09blszXSxyW2krMV09blsyXSxyW2krMl09blsxXSxyW2krM109blswXX1mdW5jdGlvbiBhKHQscil7cmV0dXJuIG5bMF09dFtyXSxuWzFdPXRbcisxXSxuWzJdPXRbcisyXSxuWzNdPXRbciszXSxlWzBdfWZ1bmN0aW9uIHModCxyKXtyZXR1cm4gblszXT10W3JdLG5bMl09dFtyKzFdLG5bMV09dFtyKzJdLG5bMF09dFtyKzNdLGVbMF19dC53cml0ZUZsb2F0TEU9cj9pOm8sdC53cml0ZUZsb2F0QkU9cj9vOmksdC5yZWFkRmxvYXRMRT1yP2E6cyx0LnJlYWRGbG9hdEJFPXI/czphfSgpOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LGUsbixyKXt2YXIgaT1lPDA/MTowO2lmKGkmJihlPS1lKSwwPT09ZSl0KDEvZT4wPzA6MjE0NzQ4MzY0OCxuLHIpO2Vsc2UgaWYoaXNOYU4oZSkpdCgyMTQzMjg5MzQ0LG4scik7ZWxzZSBpZihlPjM0MDI4MjM0NjYzODUyODg2ZTIyKXQoKGk8PDMxfDIxMzkwOTUwNDApPj4+MCxuLHIpO2Vsc2UgaWYoZTwxMTc1NDk0MzUwODIyMjg3NWUtNTQpdCgoaTw8MzF8TWF0aC5yb3VuZChlLzE0MDEyOTg0NjQzMjQ4MTdlLTYwKSk+Pj4wLG4scik7ZWxzZXt2YXIgbz1NYXRoLmZsb29yKE1hdGgubG9nKGUpL01hdGguTE4yKTt0KChpPDwzMXxvKzEyNzw8MjN8ODM4ODYwNyZNYXRoLnJvdW5kKGUqTWF0aC5wb3coMiwtbykqODM4ODYwOCkpPj4+MCxuLHIpfX1mdW5jdGlvbiBhKHQsZSxuKXt2YXIgcj10KGUsbiksaT0yKihyPj4zMSkrMSxvPXI+Pj4yMyYyNTUsYT04Mzg4NjA3JnI7cmV0dXJuIDI1NT09PW8/YT9OYU46aSooMS8wKTowPT09bz8xNDAxMjk4NDY0MzI0ODE3ZS02MCppKmE6aSpNYXRoLnBvdygyLG8tMTUwKSooYSs4Mzg4NjA4KX10LndyaXRlRmxvYXRMRT1lLmJpbmQobnVsbCxuKSx0LndyaXRlRmxvYXRCRT1lLmJpbmQobnVsbCxyKSx0LnJlYWRGbG9hdExFPWEuYmluZChudWxsLGkpLHQucmVhZEZsb2F0QkU9YS5iaW5kKG51bGwsbyl9KCksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEZsb2F0NjRBcnJheT9mdW5jdGlvbigpe3ZhciBlPW5ldyBGbG9hdDY0QXJyYXkoWy0wXSksbj1uZXcgVWludDhBcnJheShlLmJ1ZmZlcikscj0xMjg9PT1uWzddO2Z1bmN0aW9uIGkodCxyLGkpe2VbMF09dCxyW2ldPW5bMF0scltpKzFdPW5bMV0scltpKzJdPW5bMl0scltpKzNdPW5bM10scltpKzRdPW5bNF0scltpKzVdPW5bNV0scltpKzZdPW5bNl0scltpKzddPW5bN119ZnVuY3Rpb24gbyh0LHIsaSl7ZVswXT10LHJbaV09bls3XSxyW2krMV09bls2XSxyW2krMl09bls1XSxyW2krM109bls0XSxyW2krNF09blszXSxyW2krNV09blsyXSxyW2krNl09blsxXSxyW2krN109blswXX1mdW5jdGlvbiBhKHQscil7cmV0dXJuIG5bMF09dFtyXSxuWzFdPXRbcisxXSxuWzJdPXRbcisyXSxuWzNdPXRbciszXSxuWzRdPXRbcis0XSxuWzVdPXRbcis1XSxuWzZdPXRbcis2XSxuWzddPXRbcis3XSxlWzBdfWZ1bmN0aW9uIHModCxyKXtyZXR1cm4gbls3XT10W3JdLG5bNl09dFtyKzFdLG5bNV09dFtyKzJdLG5bNF09dFtyKzNdLG5bM109dFtyKzRdLG5bMl09dFtyKzVdLG5bMV09dFtyKzZdLG5bMF09dFtyKzddLGVbMF19dC53cml0ZURvdWJsZUxFPXI/aTpvLHQud3JpdGVEb3VibGVCRT1yP286aSx0LnJlYWREb3VibGVMRT1yP2E6cyx0LnJlYWREb3VibGVCRT1yP3M6YX0oKTpmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxlLG4scixpLG8pe3ZhciBhPXI8MD8xOjA7aWYoYSYmKHI9LXIpLDA9PT1yKXQoMCxpLG8rZSksdCgxL3I+MD8wOjIxNDc0ODM2NDgsaSxvK24pO2Vsc2UgaWYoaXNOYU4ocikpdCgwLGksbytlKSx0KDIxNDY5NTkzNjAsaSxvK24pO2Vsc2UgaWYocj4xNzk3NjkzMTM0ODYyMzE1N2UyOTIpdCgwLGksbytlKSx0KChhPDwzMXwyMTQ2NDM1MDcyKT4+PjAsaSxvK24pO2Vsc2V7dmFyIHM7aWYocjwyMjI1MDczODU4NTA3MjAxNGUtMzI0KXQoKHM9ci81ZS0zMjQpPj4+MCxpLG8rZSksdCgoYTw8MzF8cy80Mjk0OTY3Mjk2KT4+PjAsaSxvK24pO2Vsc2V7dmFyIHU9TWF0aC5mbG9vcihNYXRoLmxvZyhyKS9NYXRoLkxOMik7MTAyND09PXUmJih1PTEwMjMpLHQoNDUwMzU5OTYyNzM3MDQ5Nioocz1yKk1hdGgucG93KDIsLXUpKT4+PjAsaSxvK2UpLHQoKGE8PDMxfHUrMTAyMzw8MjB8MTA0ODU3NipzJjEwNDg1NzUpPj4+MCxpLG8rbil9fX1mdW5jdGlvbiBhKHQsZSxuLHIsaSl7dmFyIG89dChyLGkrZSksYT10KHIsaStuKSxzPTIqKGE+PjMxKSsxLHU9YT4+PjIwJjIwNDcsYz00Mjk0OTY3Mjk2KigxMDQ4NTc1JmEpK287cmV0dXJuIDIwNDc9PT11P2M/TmFOOnMqKDEvMCk6MD09PXU/NWUtMzI0KnMqYzpzKk1hdGgucG93KDIsdS0xMDc1KSooYys0NTAzNTk5NjI3MzcwNDk2KX10LndyaXRlRG91YmxlTEU9ZS5iaW5kKG51bGwsbiwwLDQpLHQud3JpdGVEb3VibGVCRT1lLmJpbmQobnVsbCxyLDQsMCksdC5yZWFkRG91YmxlTEU9YS5iaW5kKG51bGwsaSwwLDQpLHQucmVhZERvdWJsZUJFPWEuYmluZChudWxsLG8sNCwwKX0oKSx0fWZ1bmN0aW9uIG4odCxlLG4pe2Vbbl09MjU1JnQsZVtuKzFdPXQ+Pj44JjI1NSxlW24rMl09dD4+PjE2JjI1NSxlW24rM109dD4+PjI0fWZ1bmN0aW9uIHIodCxlLG4pe2Vbbl09dD4+PjI0LGVbbisxXT10Pj4+MTYmMjU1LGVbbisyXT10Pj4+OCYyNTUsZVtuKzNdPTI1NSZ0fWZ1bmN0aW9uIGkodCxlKXtyZXR1cm4odFtlXXx0W2UrMV08PDh8dFtlKzJdPDwxNnx0W2UrM108PDI0KT4+PjB9ZnVuY3Rpb24gbyh0LGUpe3JldHVybih0W2VdPDwyNHx0W2UrMV08PDE2fHRbZSsyXTw8OHx0W2UrM10pPj4+MH10LmV4cG9ydHM9ZShlKX0sNzE5OTptb2R1bGU9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpbnF1aXJlKG1vZHVsZU5hbWUpe3RyeXt2YXIgbW9kPWV2YWwoXCJxdWlyZVwiLnJlcGxhY2UoL14vLFwicmVcIikpKG1vZHVsZU5hbWUpO2lmKG1vZCYmKG1vZC5sZW5ndGh8fE9iamVjdC5rZXlzKG1vZCkubGVuZ3RoKSlyZXR1cm4gbW9kfWNhdGNoKHQpe31yZXR1cm4gbnVsbH1tb2R1bGUuZXhwb3J0cz1pbnF1aXJlfSw2NjYyOnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW58fDgxOTIsaT1yPj4+MSxvPW51bGwsYT1yO3JldHVybiBmdW5jdGlvbihuKXtpZihuPDF8fG4+aSlyZXR1cm4gdChuKTthK24+ciYmKG89dChyKSxhPTApO3ZhciBzPWUuY2FsbChvLGEsYSs9bik7cmV0dXJuIDcmYSYmKGE9MSsoN3xhKSksc319fSw0OTk3Oih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ZTtuLmxlbmd0aD1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTAscj0wO3I8dC5sZW5ndGg7KytyKShuPXQuY2hhckNvZGVBdChyKSk8MTI4P2UrPTE6bjwyMDQ4P2UrPTI6NTUyOTY9PSg2NDUxMiZuKSYmNTYzMjA9PSg2NDUxMiZ0LmNoYXJDb2RlQXQocisxKSk/KCsrcixlKz00KTplKz0zO3JldHVybiBlfSxuLnJlYWQ9ZnVuY3Rpb24odCxlLG4pe2lmKG4tZTwxKXJldHVyblwiXCI7Zm9yKHZhciByLGk9bnVsbCxvPVtdLGE9MDtlPG47KShyPXRbZSsrXSk8MTI4P29bYSsrXT1yOnI+MTkxJiZyPDIyND9vW2ErK109KDMxJnIpPDw2fDYzJnRbZSsrXTpyPjIzOSYmcjwzNjU/KHI9KCg3JnIpPDwxOHwoNjMmdFtlKytdKTw8MTJ8KDYzJnRbZSsrXSk8PDZ8NjMmdFtlKytdKS02NTUzNixvW2ErK109NTUyOTYrKHI+PjEwKSxvW2ErK109NTYzMjArKDEwMjMmcikpOm9bYSsrXT0oMTUmcik8PDEyfCg2MyZ0W2UrK10pPDw2fDYzJnRbZSsrXSxhPjgxOTEmJigoaXx8KGk9W10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLG8pKSxhPTApO3JldHVybiBpPyhhJiZpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsby5zbGljZSgwLGEpKSksaS5qb2luKFwiXCIpKTpTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxvLnNsaWNlKDAsYSkpfSxuLndyaXRlPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHIsaSxvPW4sYT0wO2E8dC5sZW5ndGg7KythKShyPXQuY2hhckNvZGVBdChhKSk8MTI4P2VbbisrXT1yOnI8MjA0OD8oZVtuKytdPXI+PjZ8MTkyLGVbbisrXT02MyZyfDEyOCk6NTUyOTY9PSg2NDUxMiZyKSYmNTYzMjA9PSg2NDUxMiYoaT10LmNoYXJDb2RlQXQoYSsxKSkpPyhyPTY1NTM2KygoMTAyMyZyKTw8MTApKygxMDIzJmkpLCsrYSxlW24rK109cj4+MTh8MjQwLGVbbisrXT1yPj4xMiY2M3wxMjgsZVtuKytdPXI+PjYmNjN8MTI4LGVbbisrXT02MyZyfDEyOCk6KGVbbisrXT1yPj4xMnwyMjQsZVtuKytdPXI+PjYmNjN8MTI4LGVbbisrXT02MyZyfDEyOCk7cmV0dXJuIG4tb319LDM0NDI6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtlLl9fZXNNb2R1bGU9ITA7dmFyIG49ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe2lmKCFlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50OyBgdmFsdWVgIGhhcyBubyB2YWx1ZS5cIik7dGhpcy52YWx1ZT10LkVNUFRZLGUmJnQuaXNHdWlkKGUpJiYodGhpcy52YWx1ZT1lKX1yZXR1cm4gdC5pc0d1aWQ9ZnVuY3Rpb24oZSl7dmFyIG49ZS50b1N0cmluZygpO3JldHVybiBlJiYoZSBpbnN0YW5jZW9mIHR8fHQudmFsaWRhdG9yLnRlc3QobikpfSx0LmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgdChbdC5nZW4oMiksdC5nZW4oMSksdC5nZW4oMSksdC5nZW4oMSksdC5nZW4oMyldLmpvaW4oXCItXCIpKX0sdC5jcmVhdGVFbXB0eT1mdW5jdGlvbigpe3JldHVybiBuZXcgdChcImVtcHR5Z3VpZFwiKX0sdC5wYXJzZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQucmF3PWZ1bmN0aW9uKCl7cmV0dXJuW3QuZ2VuKDIpLHQuZ2VuKDEpLHQuZ2VuKDEpLHQuZ2VuKDEpLHQuZ2VuKDMpXS5qb2luKFwiLVwiKX0sdC5nZW49ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVwiXCIsbj0wO248dDtuKyspZSs9KDY1NTM2KigxK01hdGgucmFuZG9tKCkpfDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7cmV0dXJuIGV9LHQucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihlKXtyZXR1cm4gdC5pc0d1aWQoZSkmJnRoaXMudmFsdWU9PT1lLnRvU3RyaW5nKCl9LHQucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZT09PXQuRU1QVFl9LHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt2YWx1ZTp0aGlzLnZhbHVlfX0sdC52YWxpZGF0b3I9bmV3IFJlZ0V4cChcIl5bYS16MC05XXs4fS1bYS16MC05XXs0fS1bYS16MC05XXs0fS1bYS16MC05XXs0fS1bYS16MC05XXsxMn0kXCIsXCJpXCIpLHQuRU1QVFk9XCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIix0fSgpO2UuR3VpZD1ufSwzNzIwOnQ9Pnt0LmV4cG9ydHM9bjt2YXIgZT1udWxsO3RyeXtlPW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDEzLDIsOTYsMCwxLDEyNyw5Niw0LDEyNywxMjcsMTI3LDEyNywxLDEyNywzLDcsNiwwLDEsMSwxLDEsMSw2LDYsMSwxMjcsMSw2NSwwLDExLDcsNTAsNiwzLDEwOSwxMTcsMTA4LDAsMSw1LDEwMCwxMDUsMTE4LDk1LDExNSwwLDIsNSwxMDAsMTA1LDExOCw5NSwxMTcsMCwzLDUsMTE0LDEwMSwxMDksOTUsMTE1LDAsNCw1LDExNCwxMDEsMTA5LDk1LDExNywwLDUsOCwxMDMsMTAxLDExNiw5NSwxMDQsMTA1LDEwMywxMDQsMCwwLDEwLDE5MSwxLDYsNCwwLDM1LDAsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI2LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyNywzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjgsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI5LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEzMCwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMV0pKSx7fSkuZXhwb3J0c31jYXRjaCh0KXt9ZnVuY3Rpb24gbih0LGUsbil7dGhpcy5sb3c9MHx0LHRoaXMuaGlnaD0wfGUsdGhpcy51bnNpZ25lZD0hIW59ZnVuY3Rpb24gcih0KXtyZXR1cm4hMD09PSh0JiZ0Ll9faXNMb25nX18pfW4ucHJvdG90eXBlLl9faXNMb25nX18sT2JqZWN0LmRlZmluZVByb3BlcnR5KG4ucHJvdG90eXBlLFwiX19pc0xvbmdfX1wiLHt2YWx1ZTohMH0pLG4uaXNMb25nPXI7dmFyIGk9e30sbz17fTtmdW5jdGlvbiBhKHQsZSl7dmFyIG4scixhO3JldHVybiBlPyhhPTA8PSh0Pj4+PTApJiZ0PDI1NikmJihyPW9bdF0pP3I6KG49dSh0LCgwfHQpPDA/LTE6MCwhMCksYSYmKG9bdF09biksbik6KGE9LTEyODw9KHR8PTApJiZ0PDEyOCkmJihyPWlbdF0pP3I6KG49dSh0LHQ8MD8tMTowLCExKSxhJiYoaVt0XT1uKSxuKX1mdW5jdGlvbiBzKHQsZSl7aWYoaXNOYU4odCkpcmV0dXJuIGU/bTpiO2lmKGUpe2lmKHQ8MClyZXR1cm4gbTtpZih0Pj1kKXJldHVybiB4fWVsc2V7aWYodDw9LWgpcmV0dXJuIFQ7aWYodCsxPj1oKXJldHVybiB3fXJldHVybiB0PDA/cygtdCxlKS5uZWcoKTp1KHQlZnwwLHQvZnwwLGUpfWZ1bmN0aW9uIHUodCxlLHIpe3JldHVybiBuZXcgbih0LGUscil9bi5mcm9tSW50PWEsbi5mcm9tTnVtYmVyPXMsbi5mcm9tQml0cz11O3ZhciBjPU1hdGgucG93O2Z1bmN0aW9uIGwodCxlLG4pe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtpZihcIk5hTlwiPT09dHx8XCJJbmZpbml0eVwiPT09dHx8XCIrSW5maW5pdHlcIj09PXR8fFwiLUluZmluaXR5XCI9PT10KXJldHVybiBiO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlPyhuPWUsZT0hMSk6ZT0hIWUsKG49bnx8MTApPDJ8fDM2PG4pdGhyb3cgUmFuZ2VFcnJvcihcInJhZGl4XCIpO3ZhciByO2lmKChyPXQuaW5kZXhPZihcIi1cIikpPjApdGhyb3cgRXJyb3IoXCJpbnRlcmlvciBoeXBoZW5cIik7aWYoMD09PXIpcmV0dXJuIGwodC5zdWJzdHJpbmcoMSksZSxuKS5uZWcoKTtmb3IodmFyIGk9cyhjKG4sOCkpLG89YixhPTA7YTx0Lmxlbmd0aDthKz04KXt2YXIgdT1NYXRoLm1pbig4LHQubGVuZ3RoLWEpLHA9cGFyc2VJbnQodC5zdWJzdHJpbmcoYSxhK3UpLG4pO2lmKHU8OCl7dmFyIGY9cyhjKG4sdSkpO289by5tdWwoZikuYWRkKHMocCkpfWVsc2Ugbz0obz1vLm11bChpKSkuYWRkKHMocCkpfXJldHVybiBvLnVuc2lnbmVkPWUsb31mdW5jdGlvbiBwKHQsZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/cyh0LGUpOlwic3RyaW5nXCI9PXR5cGVvZiB0P2wodCxlKTp1KHQubG93LHQuaGlnaCxcImJvb2xlYW5cIj09dHlwZW9mIGU/ZTp0LnVuc2lnbmVkKX1uLmZyb21TdHJpbmc9bCxuLmZyb21WYWx1ZT1wO3ZhciBmPTQyOTQ5NjcyOTYsZD1mKmYsaD1kLzIsZz1hKDE8PDI0KSxiPWEoMCk7bi5aRVJPPWI7dmFyIG09YSgwLCEwKTtuLlVaRVJPPW07dmFyIHk9YSgxKTtuLk9ORT15O3ZhciBfPWEoMSwhMCk7bi5VT05FPV87dmFyIHY9YSgtMSk7bi5ORUdfT05FPXY7dmFyIHc9dSgtMSwyMTQ3NDgzNjQ3LCExKTtuLk1BWF9WQUxVRT13O3ZhciB4PXUoLTEsLTEsITApO24uTUFYX1VOU0lHTkVEX1ZBTFVFPXg7dmFyIFQ9dSgwLC0yMTQ3NDgzNjQ4LCExKTtuLk1JTl9WQUxVRT1UO3ZhciBTPW4ucHJvdG90eXBlO1MudG9JbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD90aGlzLmxvdz4+PjA6dGhpcy5sb3d9LFMudG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD8odGhpcy5oaWdoPj4+MCkqZisodGhpcy5sb3c+Pj4wKTp0aGlzLmhpZ2gqZisodGhpcy5sb3c+Pj4wKX0sUy50b1N0cmluZz1mdW5jdGlvbih0KXtpZigodD10fHwxMCk8Mnx8MzY8dCl0aHJvdyBSYW5nZUVycm9yKFwicmFkaXhcIik7aWYodGhpcy5pc1plcm8oKSlyZXR1cm5cIjBcIjtpZih0aGlzLmlzTmVnYXRpdmUoKSl7aWYodGhpcy5lcShUKSl7dmFyIGU9cyh0KSxuPXRoaXMuZGl2KGUpLHI9bi5tdWwoZSkuc3ViKHRoaXMpO3JldHVybiBuLnRvU3RyaW5nKHQpK3IudG9JbnQoKS50b1N0cmluZyh0KX1yZXR1cm5cIi1cIit0aGlzLm5lZygpLnRvU3RyaW5nKHQpfWZvcih2YXIgaT1zKGModCw2KSx0aGlzLnVuc2lnbmVkKSxvPXRoaXMsYT1cIlwiOzspe3ZhciB1PW8uZGl2KGkpLGw9KG8uc3ViKHUubXVsKGkpKS50b0ludCgpPj4+MCkudG9TdHJpbmcodCk7aWYoKG89dSkuaXNaZXJvKCkpcmV0dXJuIGwrYTtmb3IoO2wubGVuZ3RoPDY7KWw9XCIwXCIrbDthPVwiXCIrbCthfX0sUy5nZXRIaWdoQml0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2h9LFMuZ2V0SGlnaEJpdHNVbnNpZ25lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2g+Pj4wfSxTLmdldExvd0JpdHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb3d9LFMuZ2V0TG93Qml0c1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG93Pj4+MH0sUy5nZXROdW1CaXRzQWJzPWZ1bmN0aW9uKCl7aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMuZXEoVCk/NjQ6dGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7Zm9yKHZhciB0PTAhPXRoaXMuaGlnaD90aGlzLmhpZ2g6dGhpcy5sb3csZT0zMTtlPjAmJjA9PSh0JjE8PGUpO2UtLSk7cmV0dXJuIDAhPXRoaXMuaGlnaD9lKzMzOmUrMX0sUy5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuaGlnaCYmMD09PXRoaXMubG93fSxTLmVxej1TLmlzWmVybyxTLmlzTmVnYXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy51bnNpZ25lZCYmdGhpcy5oaWdoPDB9LFMuaXNQb3NpdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkfHx0aGlzLmhpZ2g+PTB9LFMuaXNPZGQ9ZnVuY3Rpb24oKXtyZXR1cm4gMT09KDEmdGhpcy5sb3cpfSxTLmlzRXZlbj1mdW5jdGlvbigpe3JldHVybiAwPT0oMSZ0aGlzLmxvdyl9LFMuZXF1YWxzPWZ1bmN0aW9uKHQpe3JldHVybiByKHQpfHwodD1wKHQpKSwodGhpcy51bnNpZ25lZD09PXQudW5zaWduZWR8fHRoaXMuaGlnaD4+PjMxIT0xfHx0LmhpZ2g+Pj4zMSE9MSkmJnRoaXMuaGlnaD09PXQuaGlnaCYmdGhpcy5sb3c9PT10Lmxvd30sUy5lcT1TLmVxdWFscyxTLm5vdEVxdWFscz1mdW5jdGlvbih0KXtyZXR1cm4hdGhpcy5lcSh0KX0sUy5uZXE9Uy5ub3RFcXVhbHMsUy5uZT1TLm5vdEVxdWFscyxTLmxlc3NUaGFuPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXAodCk8MH0sUy5sdD1TLmxlc3NUaGFuLFMubGVzc1RoYW5PckVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXAodCk8PTB9LFMubHRlPVMubGVzc1RoYW5PckVxdWFsLFMubGU9Uy5sZXNzVGhhbk9yRXF1YWwsUy5ncmVhdGVyVGhhbj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wKHQpPjB9LFMuZ3Q9Uy5ncmVhdGVyVGhhbixTLmdyZWF0ZXJUaGFuT3JFcXVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wKHQpPj0wfSxTLmd0ZT1TLmdyZWF0ZXJUaGFuT3JFcXVhbCxTLmdlPVMuZ3JlYXRlclRoYW5PckVxdWFsLFMuY29tcGFyZT1mdW5jdGlvbih0KXtpZihyKHQpfHwodD1wKHQpKSx0aGlzLmVxKHQpKXJldHVybiAwO3ZhciBlPXRoaXMuaXNOZWdhdGl2ZSgpLG49dC5pc05lZ2F0aXZlKCk7cmV0dXJuIGUmJiFuPy0xOiFlJiZuPzE6dGhpcy51bnNpZ25lZD90LmhpZ2g+Pj4wPnRoaXMuaGlnaD4+PjB8fHQuaGlnaD09PXRoaXMuaGlnaCYmdC5sb3c+Pj4wPnRoaXMubG93Pj4+MD8tMToxOnRoaXMuc3ViKHQpLmlzTmVnYXRpdmUoKT8tMToxfSxTLmNvbXA9Uy5jb21wYXJlLFMubmVnYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMudW5zaWduZWQmJnRoaXMuZXEoVCk/VDp0aGlzLm5vdCgpLmFkZCh5KX0sUy5uZWc9Uy5uZWdhdGUsUy5hZGQ9ZnVuY3Rpb24odCl7cih0KXx8KHQ9cCh0KSk7dmFyIGU9dGhpcy5oaWdoPj4+MTYsbj02NTUzNSZ0aGlzLmhpZ2gsaT10aGlzLmxvdz4+PjE2LG89NjU1MzUmdGhpcy5sb3csYT10LmhpZ2g+Pj4xNixzPTY1NTM1JnQuaGlnaCxjPXQubG93Pj4+MTYsbD0wLGY9MCxkPTAsaD0wO3JldHVybiBkKz0oaCs9bysoNjU1MzUmdC5sb3cpKT4+PjE2LGYrPShkKz1pK2MpPj4+MTYsbCs9KGYrPW4rcyk+Pj4xNixsKz1lK2EsdSgoZCY9NjU1MzUpPDwxNnwoaCY9NjU1MzUpLChsJj02NTUzNSk8PDE2fChmJj02NTUzNSksdGhpcy51bnNpZ25lZCl9LFMuc3VidHJhY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHIodCl8fCh0PXAodCkpLHRoaXMuYWRkKHQubmVnKCkpfSxTLnN1Yj1TLnN1YnRyYWN0LFMubXVsdGlwbHk9ZnVuY3Rpb24odCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gYjtpZihyKHQpfHwodD1wKHQpKSxlKXJldHVybiB1KGUubXVsKHRoaXMubG93LHRoaXMuaGlnaCx0Lmxvdyx0LmhpZ2gpLGUuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKTtpZih0LmlzWmVybygpKXJldHVybiBiO2lmKHRoaXMuZXEoVCkpcmV0dXJuIHQuaXNPZGQoKT9UOmI7aWYodC5lcShUKSlyZXR1cm4gdGhpcy5pc09kZCgpP1Q6YjtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gdC5pc05lZ2F0aXZlKCk/dGhpcy5uZWcoKS5tdWwodC5uZWcoKSk6dGhpcy5uZWcoKS5tdWwodCkubmVnKCk7aWYodC5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMubXVsKHQubmVnKCkpLm5lZygpO2lmKHRoaXMubHQoZykmJnQubHQoZykpcmV0dXJuIHModGhpcy50b051bWJlcigpKnQudG9OdW1iZXIoKSx0aGlzLnVuc2lnbmVkKTt2YXIgbj10aGlzLmhpZ2g+Pj4xNixpPTY1NTM1JnRoaXMuaGlnaCxvPXRoaXMubG93Pj4+MTYsYT02NTUzNSZ0aGlzLmxvdyxjPXQuaGlnaD4+PjE2LGw9NjU1MzUmdC5oaWdoLGY9dC5sb3c+Pj4xNixkPTY1NTM1JnQubG93LGg9MCxtPTAseT0wLF89MDtyZXR1cm4geSs9KF8rPWEqZCk+Pj4xNixtKz0oeSs9bypkKT4+PjE2LHkmPTY1NTM1LG0rPSh5Kz1hKmYpPj4+MTYsaCs9KG0rPWkqZCk+Pj4xNixtJj02NTUzNSxoKz0obSs9bypmKT4+PjE2LG0mPTY1NTM1LGgrPShtKz1hKmwpPj4+MTYsaCs9bipkK2kqZitvKmwrYSpjLHUoKHkmPTY1NTM1KTw8MTZ8KF8mPTY1NTM1KSwoaCY9NjU1MzUpPDwxNnwobSY9NjU1MzUpLHRoaXMudW5zaWduZWQpfSxTLm11bD1TLm11bHRpcGx5LFMuZGl2aWRlPWZ1bmN0aW9uKHQpe2lmKHIodCl8fCh0PXAodCkpLHQuaXNaZXJvKCkpdGhyb3cgRXJyb3IoXCJkaXZpc2lvbiBieSB6ZXJvXCIpO3ZhciBuLGksbztpZihlKXJldHVybiB0aGlzLnVuc2lnbmVkfHwtMjE0NzQ4MzY0OCE9PXRoaXMuaGlnaHx8LTEhPT10Lmxvd3x8LTEhPT10LmhpZ2g/dSgodGhpcy51bnNpZ25lZD9lLmRpdl91OmUuZGl2X3MpKHRoaXMubG93LHRoaXMuaGlnaCx0Lmxvdyx0LmhpZ2gpLGUuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKTp0aGlzO2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/bTpiO2lmKHRoaXMudW5zaWduZWQpe2lmKHQudW5zaWduZWR8fCh0PXQudG9VbnNpZ25lZCgpKSx0Lmd0KHRoaXMpKXJldHVybiBtO2lmKHQuZ3QodGhpcy5zaHJ1KDEpKSlyZXR1cm4gXztvPW19ZWxzZXtpZih0aGlzLmVxKFQpKXJldHVybiB0LmVxKHkpfHx0LmVxKHYpP1Q6dC5lcShUKT95OihuPXRoaXMuc2hyKDEpLmRpdih0KS5zaGwoMSkpLmVxKGIpP3QuaXNOZWdhdGl2ZSgpP3k6djooaT10aGlzLnN1Yih0Lm11bChuKSksbz1uLmFkZChpLmRpdih0KSkpO2lmKHQuZXEoVCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/bTpiO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiB0LmlzTmVnYXRpdmUoKT90aGlzLm5lZygpLmRpdih0Lm5lZygpKTp0aGlzLm5lZygpLmRpdih0KS5uZWcoKTtpZih0LmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5kaXYodC5uZWcoKSkubmVnKCk7bz1ifWZvcihpPXRoaXM7aS5ndGUodCk7KXtuPU1hdGgubWF4KDEsTWF0aC5mbG9vcihpLnRvTnVtYmVyKCkvdC50b051bWJlcigpKSk7Zm9yKHZhciBhPU1hdGguY2VpbChNYXRoLmxvZyhuKS9NYXRoLkxOMiksbD1hPD00OD8xOmMoMixhLTQ4KSxmPXMobiksZD1mLm11bCh0KTtkLmlzTmVnYXRpdmUoKXx8ZC5ndChpKTspZD0oZj1zKG4tPWwsdGhpcy51bnNpZ25lZCkpLm11bCh0KTtmLmlzWmVybygpJiYoZj15KSxvPW8uYWRkKGYpLGk9aS5zdWIoZCl9cmV0dXJuIG99LFMuZGl2PVMuZGl2aWRlLFMubW9kdWxvPWZ1bmN0aW9uKHQpe3JldHVybiByKHQpfHwodD1wKHQpKSxlP3UoKHRoaXMudW5zaWduZWQ/ZS5yZW1fdTplLnJlbV9zKSh0aGlzLmxvdyx0aGlzLmhpZ2gsdC5sb3csdC5oaWdoKSxlLmdldF9oaWdoKCksdGhpcy51bnNpZ25lZCk6dGhpcy5zdWIodGhpcy5kaXYodCkubXVsKHQpKX0sUy5tb2Q9Uy5tb2R1bG8sUy5yZW09Uy5tb2R1bG8sUy5ub3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdSh+dGhpcy5sb3csfnRoaXMuaGlnaCx0aGlzLnVuc2lnbmVkKX0sUy5hbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHIodCl8fCh0PXAodCkpLHUodGhpcy5sb3cmdC5sb3csdGhpcy5oaWdoJnQuaGlnaCx0aGlzLnVuc2lnbmVkKX0sUy5vcj1mdW5jdGlvbih0KXtyZXR1cm4gcih0KXx8KHQ9cCh0KSksdSh0aGlzLmxvd3x0Lmxvdyx0aGlzLmhpZ2h8dC5oaWdoLHRoaXMudW5zaWduZWQpfSxTLnhvcj1mdW5jdGlvbih0KXtyZXR1cm4gcih0KXx8KHQ9cCh0KSksdSh0aGlzLmxvd150Lmxvdyx0aGlzLmhpZ2hedC5oaWdoLHRoaXMudW5zaWduZWQpfSxTLnNoaWZ0TGVmdD1mdW5jdGlvbih0KXtyZXR1cm4gcih0KSYmKHQ9dC50b0ludCgpKSwwPT0odCY9NjMpP3RoaXM6dDwzMj91KHRoaXMubG93PDx0LHRoaXMuaGlnaDw8dHx0aGlzLmxvdz4+PjMyLXQsdGhpcy51bnNpZ25lZCk6dSgwLHRoaXMubG93PDx0LTMyLHRoaXMudW5zaWduZWQpfSxTLnNobD1TLnNoaWZ0TGVmdCxTLnNoaWZ0UmlnaHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHIodCkmJih0PXQudG9JbnQoKSksMD09KHQmPTYzKT90aGlzOnQ8MzI/dSh0aGlzLmxvdz4+PnR8dGhpcy5oaWdoPDwzMi10LHRoaXMuaGlnaD4+dCx0aGlzLnVuc2lnbmVkKTp1KHRoaXMuaGlnaD4+dC0zMix0aGlzLmhpZ2g+PTA/MDotMSx0aGlzLnVuc2lnbmVkKX0sUy5zaHI9Uy5zaGlmdFJpZ2h0LFMuc2hpZnRSaWdodFVuc2lnbmVkPWZ1bmN0aW9uKHQpe2lmKHIodCkmJih0PXQudG9JbnQoKSksMD09KHQmPTYzKSlyZXR1cm4gdGhpczt2YXIgZT10aGlzLmhpZ2g7cmV0dXJuIHQ8MzI/dSh0aGlzLmxvdz4+PnR8ZTw8MzItdCxlPj4+dCx0aGlzLnVuc2lnbmVkKTp1KDMyPT09dD9lOmU+Pj50LTMyLDAsdGhpcy51bnNpZ25lZCl9LFMuc2hydT1TLnNoaWZ0UmlnaHRVbnNpZ25lZCxTLnNocl91PVMuc2hpZnRSaWdodFVuc2lnbmVkLFMudG9TaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD91KHRoaXMubG93LHRoaXMuaGlnaCwhMSk6dGhpc30sUy50b1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWQ/dGhpczp1KHRoaXMubG93LHRoaXMuaGlnaCwhMCl9LFMudG9CeXRlcz1mdW5jdGlvbih0KXtyZXR1cm4gdD90aGlzLnRvQnl0ZXNMRSgpOnRoaXMudG9CeXRlc0JFKCl9LFMudG9CeXRlc0xFPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5oaWdoLGU9dGhpcy5sb3c7cmV0dXJuWzI1NSZlLGU+Pj44JjI1NSxlPj4+MTYmMjU1LGU+Pj4yNCwyNTUmdCx0Pj4+OCYyNTUsdD4+PjE2JjI1NSx0Pj4+MjRdfSxTLnRvQnl0ZXNCRT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGlnaCxlPXRoaXMubG93O3JldHVyblt0Pj4+MjQsdD4+PjE2JjI1NSx0Pj4+OCYyNTUsMjU1JnQsZT4+PjI0LGU+Pj4xNiYyNTUsZT4+PjgmMjU1LDI1NSZlXX0sbi5mcm9tQnl0ZXM9ZnVuY3Rpb24odCxlLHIpe3JldHVybiByP24uZnJvbUJ5dGVzTEUodCxlKTpuLmZyb21CeXRlc0JFKHQsZSl9LG4uZnJvbUJ5dGVzTEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IG4odFswXXx0WzFdPDw4fHRbMl08PDE2fHRbM108PDI0LHRbNF18dFs1XTw8OHx0WzZdPDwxNnx0WzddPDwyNCxlKX0sbi5mcm9tQnl0ZXNCRT1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgbih0WzRdPDwyNHx0WzVdPDwxNnx0WzZdPDw4fHRbN10sdFswXTw8MjR8dFsxXTw8MTZ8dFsyXTw8OHx0WzNdLGUpfX0sMTQ0NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsaSxvLGE9bigyMTAwKSxzPWEuUmVhZGVyLHU9YS5Xcml0ZXIsYz1hLnV0aWwsbD1hLnJvb3RzLmRlZmF1bHR8fChhLnJvb3RzLmRlZmF1bHQ9e30pO2wub25ueD0oKG89e30pLlZlcnNpb249KHI9e30sKGk9T2JqZWN0LmNyZWF0ZShyKSlbclswXT1cIl9TVEFSVF9WRVJTSU9OXCJdPTAsaVtyWzFdPVwiSVJfVkVSU0lPTl8yMDE3XzEwXzEwXCJdPTEsaVtyWzJdPVwiSVJfVkVSU0lPTl8yMDE3XzEwXzMwXCJdPTIsaVtyWzNdPVwiSVJfVkVSU0lPTl8yMDE3XzExXzNcIl09MyxpW3JbNF09XCJJUl9WRVJTSU9OXzIwMTlfMV8yMlwiXT00LGlbcls1XT1cIklSX1ZFUlNJT05cIl09NSxpKSxvLkF0dHJpYnV0ZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmZsb2F0cz1bXSx0aGlzLmludHM9W10sdGhpcy5zdHJpbmdzPVtdLHRoaXMudGVuc29ycz1bXSx0aGlzLmdyYXBocz1bXSx0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS5yZWZBdHRyTmFtZT1cIlwiLHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQucHJvdG90eXBlLnR5cGU9MCx0LnByb3RvdHlwZS5mPTAsdC5wcm90b3R5cGUuaT1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LnByb3RvdHlwZS5zPWMubmV3QnVmZmVyKFtdKSx0LnByb3RvdHlwZS50PW51bGwsdC5wcm90b3R5cGUuZz1udWxsLHQucHJvdG90eXBlLmZsb2F0cz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuaW50cz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuc3RyaW5ncz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUudGVuc29ycz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZ3JhcGhzPWMuZW1wdHlBcnJheSx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmZS51aW50MzIoMTApLnN0cmluZyh0Lm5hbWUpLG51bGwhPXQuZiYmdC5oYXNPd25Qcm9wZXJ0eShcImZcIikmJmUudWludDMyKDIxKS5mbG9hdCh0LmYpLG51bGwhPXQuaSYmdC5oYXNPd25Qcm9wZXJ0eShcImlcIikmJmUudWludDMyKDI0KS5pbnQ2NCh0LmkpLG51bGwhPXQucyYmdC5oYXNPd25Qcm9wZXJ0eShcInNcIikmJmUudWludDMyKDM0KS5ieXRlcyh0LnMpLG51bGwhPXQudCYmdC5oYXNPd25Qcm9wZXJ0eShcInRcIikmJmwub25ueC5UZW5zb3JQcm90by5lbmNvZGUodC50LGUudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPXQuZyYmdC5oYXNPd25Qcm9wZXJ0eShcImdcIikmJmwub25ueC5HcmFwaFByb3RvLmVuY29kZSh0LmcsZS51aW50MzIoNTApLmZvcmsoKSkubGRlbGltKCksbnVsbCE9dC5mbG9hdHMmJnQuZmxvYXRzLmxlbmd0aCl7ZS51aW50MzIoNTgpLmZvcmsoKTtmb3IodmFyIG49MDtuPHQuZmxvYXRzLmxlbmd0aDsrK24pZS5mbG9hdCh0LmZsb2F0c1tuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10LmludHMmJnQuaW50cy5sZW5ndGgpe2ZvcihlLnVpbnQzMig2NikuZm9yaygpLG49MDtuPHQuaW50cy5sZW5ndGg7KytuKWUuaW50NjQodC5pbnRzW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuc3RyaW5ncyYmdC5zdHJpbmdzLmxlbmd0aClmb3Iobj0wO248dC5zdHJpbmdzLmxlbmd0aDsrK24pZS51aW50MzIoNzQpLmJ5dGVzKHQuc3RyaW5nc1tuXSk7aWYobnVsbCE9dC50ZW5zb3JzJiZ0LnRlbnNvcnMubGVuZ3RoKWZvcihuPTA7bjx0LnRlbnNvcnMubGVuZ3RoOysrbilsLm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKHQudGVuc29yc1tuXSxlLnVpbnQzMig4MikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT10LmdyYXBocyYmdC5ncmFwaHMubGVuZ3RoKWZvcihuPTA7bjx0LmdyYXBocy5sZW5ndGg7KytuKWwub25ueC5HcmFwaFByb3RvLmVuY29kZSh0LmdyYXBoc1tuXSxlLnVpbnQzMig5MCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJmUudWludDMyKDEwNikuc3RyaW5nKHQuZG9jU3RyaW5nKSxudWxsIT10LnR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpJiZlLnVpbnQzMigxNjApLmludDMyKHQudHlwZSksbnVsbCE9dC5yZWZBdHRyTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpJiZlLnVpbnQzMigxNzApLnN0cmluZyh0LnJlZkF0dHJOYW1lKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguQXR0cmlidXRlUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5uYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyMTpyLnJlZkF0dHJOYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAxMzpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2Nhc2UgMjA6ci50eXBlPXQuaW50MzIoKTticmVhaztjYXNlIDI6ci5mPXQuZmxvYXQoKTticmVhaztjYXNlIDM6ci5pPXQuaW50NjQoKTticmVhaztjYXNlIDQ6ci5zPXQuYnl0ZXMoKTticmVhaztjYXNlIDU6ci50PWwub25ueC5UZW5zb3JQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKTticmVhaztjYXNlIDY6ci5nPWwub25ueC5HcmFwaFByb3RvLmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgNzppZihyLmZsb2F0cyYmci5mbG9hdHMubGVuZ3RofHwoci5mbG9hdHM9W10pLDI9PSg3JmkpKWZvcih2YXIgbz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIuZmxvYXRzLnB1c2godC5mbG9hdCgpKTtlbHNlIHIuZmxvYXRzLnB1c2godC5mbG9hdCgpKTticmVhaztjYXNlIDg6aWYoci5pbnRzJiZyLmludHMubGVuZ3RofHwoci5pbnRzPVtdKSwyPT0oNyZpKSlmb3Iobz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIuaW50cy5wdXNoKHQuaW50NjQoKSk7ZWxzZSByLmludHMucHVzaCh0LmludDY0KCkpO2JyZWFrO2Nhc2UgOTpyLnN0cmluZ3MmJnIuc3RyaW5ncy5sZW5ndGh8fChyLnN0cmluZ3M9W10pLHIuc3RyaW5ncy5wdXNoKHQuYnl0ZXMoKSk7YnJlYWs7Y2FzZSAxMDpyLnRlbnNvcnMmJnIudGVuc29ycy5sZW5ndGh8fChyLnRlbnNvcnM9W10pLHIudGVuc29ycy5wdXNoKGwub25ueC5UZW5zb3JQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxMTpyLmdyYXBocyYmci5ncmFwaHMubGVuZ3RofHwoci5ncmFwaHM9W10pLHIuZ3JhcGhzLnB1c2gobC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWMuaXNTdHJpbmcodC5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQucmVmQXR0ck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJyZWZBdHRyTmFtZVwiKSYmIWMuaXNTdHJpbmcodC5yZWZBdHRyTmFtZSkpcmV0dXJuXCJyZWZBdHRyTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJiFjLmlzU3RyaW5nKHQuZG9jU3RyaW5nKSlyZXR1cm5cImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC50eXBlJiZ0Lmhhc093blByb3BlcnR5KFwidHlwZVwiKSlzd2l0Y2godC50eXBlKXtkZWZhdWx0OnJldHVyblwidHlwZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO2Nhc2UgMDpjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmNhc2UgNjpjYXNlIDc6Y2FzZSA4OmNhc2UgOTpjYXNlIDEwOn1pZihudWxsIT10LmYmJnQuaGFzT3duUHJvcGVydHkoXCJmXCIpJiZcIm51bWJlclwiIT10eXBlb2YgdC5mKXJldHVyblwiZjogbnVtYmVyIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5pJiZ0Lmhhc093blByb3BlcnR5KFwiaVwiKSYmIShjLmlzSW50ZWdlcih0LmkpfHx0LmkmJmMuaXNJbnRlZ2VyKHQuaS5sb3cpJiZjLmlzSW50ZWdlcih0LmkuaGlnaCkpKXJldHVyblwiaTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5zJiZ0Lmhhc093blByb3BlcnR5KFwic1wiKSYmISh0LnMmJlwibnVtYmVyXCI9PXR5cGVvZiB0LnMubGVuZ3RofHxjLmlzU3RyaW5nKHQucykpKXJldHVyblwiczogYnVmZmVyIGV4cGVjdGVkXCI7aWYobnVsbCE9dC50JiZ0Lmhhc093blByb3BlcnR5KFwidFwiKSYmKG49bC5vbm54LlRlbnNvclByb3RvLnZlcmlmeSh0LnQpKSlyZXR1cm5cInQuXCIrbjtpZihudWxsIT10LmcmJnQuaGFzT3duUHJvcGVydHkoXCJnXCIpJiYobj1sLm9ubnguR3JhcGhQcm90by52ZXJpZnkodC5nKSkpcmV0dXJuXCJnLlwiK247aWYobnVsbCE9dC5mbG9hdHMmJnQuaGFzT3duUHJvcGVydHkoXCJmbG9hdHNcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuZmxvYXRzKSlyZXR1cm5cImZsb2F0czogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIGU9MDtlPHQuZmxvYXRzLmxlbmd0aDsrK2UpaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQuZmxvYXRzW2VdKXJldHVyblwiZmxvYXRzOiBudW1iZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuaW50cyYmdC5oYXNPd25Qcm9wZXJ0eShcImludHNcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuaW50cykpcmV0dXJuXCJpbnRzOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmludHMubGVuZ3RoOysrZSlpZighKGMuaXNJbnRlZ2VyKHQuaW50c1tlXSl8fHQuaW50c1tlXSYmYy5pc0ludGVnZXIodC5pbnRzW2VdLmxvdykmJmMuaXNJbnRlZ2VyKHQuaW50c1tlXS5oaWdoKSkpcmV0dXJuXCJpbnRzOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuc3RyaW5ncyYmdC5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ3NcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuc3RyaW5ncykpcmV0dXJuXCJzdHJpbmdzOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnN0cmluZ3MubGVuZ3RoOysrZSlpZighKHQuc3RyaW5nc1tlXSYmXCJudW1iZXJcIj09dHlwZW9mIHQuc3RyaW5nc1tlXS5sZW5ndGh8fGMuaXNTdHJpbmcodC5zdHJpbmdzW2VdKSkpcmV0dXJuXCJzdHJpbmdzOiBidWZmZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQudGVuc29ycyYmdC5oYXNPd25Qcm9wZXJ0eShcInRlbnNvcnNcIikpe2lmKCFBcnJheS5pc0FycmF5KHQudGVuc29ycykpcmV0dXJuXCJ0ZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnRlbnNvcnMubGVuZ3RoOysrZSlpZihuPWwub25ueC5UZW5zb3JQcm90by52ZXJpZnkodC50ZW5zb3JzW2VdKSlyZXR1cm5cInRlbnNvcnMuXCIrbn1pZihudWxsIT10LmdyYXBocyYmdC5oYXNPd25Qcm9wZXJ0eShcImdyYXBoc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5ncmFwaHMpKXJldHVyblwiZ3JhcGhzOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmdyYXBocy5sZW5ndGg7KytlKXt2YXIgbjtpZihuPWwub25ueC5HcmFwaFByb3RvLnZlcmlmeSh0LmdyYXBoc1tlXSkpcmV0dXJuXCJncmFwaHMuXCIrbn19cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LkF0dHJpYnV0ZVByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguQXR0cmlidXRlUHJvdG87c3dpdGNoKG51bGwhPXQubmFtZSYmKGUubmFtZT1TdHJpbmcodC5uYW1lKSksbnVsbCE9dC5yZWZBdHRyTmFtZSYmKGUucmVmQXR0ck5hbWU9U3RyaW5nKHQucmVmQXR0ck5hbWUpKSxudWxsIT10LmRvY1N0cmluZyYmKGUuZG9jU3RyaW5nPVN0cmluZyh0LmRvY1N0cmluZykpLHQudHlwZSl7Y2FzZVwiVU5ERUZJTkVEXCI6Y2FzZSAwOmUudHlwZT0wO2JyZWFrO2Nhc2VcIkZMT0FUXCI6Y2FzZSAxOmUudHlwZT0xO2JyZWFrO2Nhc2VcIklOVFwiOmNhc2UgMjplLnR5cGU9MjticmVhaztjYXNlXCJTVFJJTkdcIjpjYXNlIDM6ZS50eXBlPTM7YnJlYWs7Y2FzZVwiVEVOU09SXCI6Y2FzZSA0OmUudHlwZT00O2JyZWFrO2Nhc2VcIkdSQVBIXCI6Y2FzZSA1OmUudHlwZT01O2JyZWFrO2Nhc2VcIkZMT0FUU1wiOmNhc2UgNjplLnR5cGU9NjticmVhaztjYXNlXCJJTlRTXCI6Y2FzZSA3OmUudHlwZT03O2JyZWFrO2Nhc2VcIlNUUklOR1NcIjpjYXNlIDg6ZS50eXBlPTg7YnJlYWs7Y2FzZVwiVEVOU09SU1wiOmNhc2UgOTplLnR5cGU9OTticmVhaztjYXNlXCJHUkFQSFNcIjpjYXNlIDEwOmUudHlwZT0xMH1pZihudWxsIT10LmYmJihlLmY9TnVtYmVyKHQuZikpLG51bGwhPXQuaSYmKGMuTG9uZz8oZS5pPWMuTG9uZy5mcm9tVmFsdWUodC5pKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuaT9lLmk9cGFyc2VJbnQodC5pLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5pP2UuaT10Lmk6XCJvYmplY3RcIj09dHlwZW9mIHQuaSYmKGUuaT1uZXcgYy5Mb25nQml0cyh0LmkubG93Pj4+MCx0LmkuaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxudWxsIT10LnMmJihcInN0cmluZ1wiPT10eXBlb2YgdC5zP2MuYmFzZTY0LmRlY29kZSh0LnMsZS5zPWMubmV3QnVmZmVyKGMuYmFzZTY0Lmxlbmd0aCh0LnMpKSwwKTp0LnMubGVuZ3RoJiYoZS5zPXQucykpLG51bGwhPXQudCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQudCl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS50PWwub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KHQudCl9aWYobnVsbCE9dC5nKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5nKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmc6IG9iamVjdCBleHBlY3RlZFwiKTtlLmc9bC5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdCh0LmcpfWlmKHQuZmxvYXRzKXtpZighQXJyYXkuaXNBcnJheSh0LmZsb2F0cykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZmxvYXRzOiBhcnJheSBleHBlY3RlZFwiKTtlLmZsb2F0cz1bXTtmb3IodmFyIG49MDtuPHQuZmxvYXRzLmxlbmd0aDsrK24pZS5mbG9hdHNbbl09TnVtYmVyKHQuZmxvYXRzW25dKX1pZih0LmludHMpe2lmKCFBcnJheS5pc0FycmF5KHQuaW50cykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uaW50czogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW50cz1bXSxuPTA7bjx0LmludHMubGVuZ3RoOysrbiljLkxvbmc/KGUuaW50c1tuXT1jLkxvbmcuZnJvbVZhbHVlKHQuaW50c1tuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmludHNbbl0/ZS5pbnRzW25dPXBhcnNlSW50KHQuaW50c1tuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuaW50c1tuXT9lLmludHNbbl09dC5pbnRzW25dOlwib2JqZWN0XCI9PXR5cGVvZiB0LmludHNbbl0mJihlLmludHNbbl09bmV3IGMuTG9uZ0JpdHModC5pbnRzW25dLmxvdz4+PjAsdC5pbnRzW25dLmhpZ2g+Pj4wKS50b051bWJlcigpKX1pZih0LnN0cmluZ3Mpe2lmKCFBcnJheS5pc0FycmF5KHQuc3RyaW5ncykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uc3RyaW5nczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuc3RyaW5ncz1bXSxuPTA7bjx0LnN0cmluZ3MubGVuZ3RoOysrbilcInN0cmluZ1wiPT10eXBlb2YgdC5zdHJpbmdzW25dP2MuYmFzZTY0LmRlY29kZSh0LnN0cmluZ3Nbbl0sZS5zdHJpbmdzW25dPWMubmV3QnVmZmVyKGMuYmFzZTY0Lmxlbmd0aCh0LnN0cmluZ3Nbbl0pKSwwKTp0LnN0cmluZ3Nbbl0ubGVuZ3RoJiYoZS5zdHJpbmdzW25dPXQuc3RyaW5nc1tuXSl9aWYodC50ZW5zb3JzKXtpZighQXJyYXkuaXNBcnJheSh0LnRlbnNvcnMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLnRlbnNvcnM9W10sbj0wO248dC50ZW5zb3JzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnRlbnNvcnNbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udGVuc29yczogb2JqZWN0IGV4cGVjdGVkXCIpO2UudGVuc29yc1tuXT1sLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdCh0LnRlbnNvcnNbbl0pfX1pZih0LmdyYXBocyl7aWYoIUFycmF5LmlzQXJyYXkodC5ncmFwaHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmdyYXBoczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuZ3JhcGhzPVtdLG49MDtuPHQuZ3JhcGhzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmdyYXBoc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5ncmFwaHM6IG9iamVjdCBleHBlY3RlZFwiKTtlLmdyYXBoc1tuXT1sLm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KHQuZ3JhcGhzW25dKX19cmV0dXJuIGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoKGUuYXJyYXlzfHxlLmRlZmF1bHRzKSYmKG4uZmxvYXRzPVtdLG4uaW50cz1bXSxuLnN0cmluZ3M9W10sbi50ZW5zb3JzPVtdLG4uZ3JhcGhzPVtdKSxlLmRlZmF1bHRzKXtpZihuLm5hbWU9XCJcIixuLmY9MCxjLkxvbmcpe3ZhciByPW5ldyBjLkxvbmcoMCwwLCExKTtuLmk9ZS5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6ZS5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cn1lbHNlIG4uaT1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7ZS5ieXRlcz09PVN0cmluZz9uLnM9XCJcIjoobi5zPVtdLGUuYnl0ZXMhPT1BcnJheSYmKG4ucz1jLm5ld0J1ZmZlcihuLnMpKSksbi50PW51bGwsbi5nPW51bGwsbi5kb2NTdHJpbmc9XCJcIixuLnR5cGU9ZS5lbnVtcz09PVN0cmluZz9cIlVOREVGSU5FRFwiOjAsbi5yZWZBdHRyTmFtZT1cIlwifWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9dC5uYW1lKSxudWxsIT10LmYmJnQuaGFzT3duUHJvcGVydHkoXCJmXCIpJiYobi5mPWUuanNvbiYmIWlzRmluaXRlKHQuZik/U3RyaW5nKHQuZik6dC5mKSxudWxsIT10LmkmJnQuaGFzT3duUHJvcGVydHkoXCJpXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIHQuaT9uLmk9ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5pKTp0Lmk6bi5pPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuaSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmkubG93Pj4+MCx0LmkuaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5pKSxudWxsIT10LnMmJnQuaGFzT3duUHJvcGVydHkoXCJzXCIpJiYobi5zPWUuYnl0ZXM9PT1TdHJpbmc/Yy5iYXNlNjQuZW5jb2RlKHQucywwLHQucy5sZW5ndGgpOmUuYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LnMpOnQucyksbnVsbCE9dC50JiZ0Lmhhc093blByb3BlcnR5KFwidFwiKSYmKG4udD1sLm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QodC50LGUpKSxudWxsIT10LmcmJnQuaGFzT3duUHJvcGVydHkoXCJnXCIpJiYobi5nPWwub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KHQuZyxlKSksdC5mbG9hdHMmJnQuZmxvYXRzLmxlbmd0aCl7bi5mbG9hdHM9W107Zm9yKHZhciBpPTA7aTx0LmZsb2F0cy5sZW5ndGg7KytpKW4uZmxvYXRzW2ldPWUuanNvbiYmIWlzRmluaXRlKHQuZmxvYXRzW2ldKT9TdHJpbmcodC5mbG9hdHNbaV0pOnQuZmxvYXRzW2ldfWlmKHQuaW50cyYmdC5pbnRzLmxlbmd0aClmb3Iobi5pbnRzPVtdLGk9MDtpPHQuaW50cy5sZW5ndGg7KytpKVwibnVtYmVyXCI9PXR5cGVvZiB0LmludHNbaV0/bi5pbnRzW2ldPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQuaW50c1tpXSk6dC5pbnRzW2ldOm4uaW50c1tpXT1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LmludHNbaV0pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC5pbnRzW2ldLmxvdz4+PjAsdC5pbnRzW2ldLmhpZ2g+Pj4wKS50b051bWJlcigpOnQuaW50c1tpXTtpZih0LnN0cmluZ3MmJnQuc3RyaW5ncy5sZW5ndGgpZm9yKG4uc3RyaW5ncz1bXSxpPTA7aTx0LnN0cmluZ3MubGVuZ3RoOysraSluLnN0cmluZ3NbaV09ZS5ieXRlcz09PVN0cmluZz9jLmJhc2U2NC5lbmNvZGUodC5zdHJpbmdzW2ldLDAsdC5zdHJpbmdzW2ldLmxlbmd0aCk6ZS5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQuc3RyaW5nc1tpXSk6dC5zdHJpbmdzW2ldO2lmKHQudGVuc29ycyYmdC50ZW5zb3JzLmxlbmd0aClmb3Iobi50ZW5zb3JzPVtdLGk9MDtpPHQudGVuc29ycy5sZW5ndGg7KytpKW4udGVuc29yc1tpXT1sLm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QodC50ZW5zb3JzW2ldLGUpO2lmKHQuZ3JhcGhzJiZ0LmdyYXBocy5sZW5ndGgpZm9yKG4uZ3JhcGhzPVtdLGk9MDtpPHQuZ3JhcGhzLmxlbmd0aDsrK2kpbi5ncmFwaHNbaV09bC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QodC5ncmFwaHNbaV0sZSk7cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJihuLnR5cGU9ZS5lbnVtcz09PVN0cmluZz9sLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVt0LnR5cGVdOnQudHlwZSksbnVsbCE9dC5yZWZBdHRyTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpJiYobi5yZWZBdHRyTmFtZT10LnJlZkF0dHJOYW1lKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdC5BdHRyaWJ1dGVUeXBlPWZ1bmN0aW9uKCl7dmFyIHQ9e30sZT1PYmplY3QuY3JlYXRlKHQpO3JldHVybiBlW3RbMF09XCJVTkRFRklORURcIl09MCxlW3RbMV09XCJGTE9BVFwiXT0xLGVbdFsyXT1cIklOVFwiXT0yLGVbdFszXT1cIlNUUklOR1wiXT0zLGVbdFs0XT1cIlRFTlNPUlwiXT00LGVbdFs1XT1cIkdSQVBIXCJdPTUsZVt0WzZdPVwiRkxPQVRTXCJdPTYsZVt0WzddPVwiSU5UU1wiXT03LGVbdFs4XT1cIlNUUklOR1NcIl09OCxlW3RbOV09XCJURU5TT1JTXCJdPTksZVt0WzEwXT1cIkdSQVBIU1wiXT0xMCxlfSgpLHR9KCksby5WYWx1ZUluZm9Qcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5uYW1lPVwiXCIsdC5wcm90b3R5cGUudHlwZT1udWxsLHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmZS51aW50MzIoMTApLnN0cmluZyh0Lm5hbWUpLG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJmwub25ueC5UeXBlUHJvdG8uZW5jb2RlKHQudHlwZSxlLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmZS51aW50MzIoMjYpLnN0cmluZyh0LmRvY1N0cmluZyksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlZhbHVlSW5mb1Byb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIubmFtZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnR5cGU9bC5vbm54LlR5cGVQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKTticmVhaztjYXNlIDM6ci5kb2NTdHJpbmc9dC5zdHJpbmcoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFjLmlzU3RyaW5nKHQubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKXt2YXIgZT1sLm9ubnguVHlwZVByb3RvLnZlcmlmeSh0LnR5cGUpO2lmKGUpcmV0dXJuXCJ0eXBlLlwiK2V9cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZyk/XCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlZhbHVlSW5mb1Byb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVmFsdWVJbmZvUHJvdG87aWYobnVsbCE9dC5uYW1lJiYoZS5uYW1lPVN0cmluZyh0Lm5hbWUpKSxudWxsIT10LnR5cGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnR5cGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVmFsdWVJbmZvUHJvdG8udHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO2UudHlwZT1sLm9ubnguVHlwZVByb3RvLmZyb21PYmplY3QodC50eXBlKX1yZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJihlLmRvY1N0cmluZz1TdHJpbmcodC5kb2NTdHJpbmcpKSxlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O3JldHVybiBlLmRlZmF1bHRzJiYobi5uYW1lPVwiXCIsbi50eXBlPW51bGwsbi5kb2NTdHJpbmc9XCJcIiksbnVsbCE9dC5uYW1lJiZ0Lmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT10Lm5hbWUpLG51bGwhPXQudHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikmJihuLnR5cGU9bC5vbm54LlR5cGVQcm90by50b09iamVjdCh0LnR5cGUsZSkpLG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8uTm9kZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmlucHV0PVtdLHRoaXMub3V0cHV0PVtdLHRoaXMuYXR0cmlidXRlPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuaW5wdXQ9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLm91dHB1dD1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLm9wVHlwZT1cIlwiLHQucHJvdG90eXBlLmRvbWFpbj1cIlwiLHQucHJvdG90eXBlLmF0dHJpYnV0ZT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuaW5wdXQmJnQuaW5wdXQubGVuZ3RoKWZvcih2YXIgbj0wO248dC5pbnB1dC5sZW5ndGg7KytuKWUudWludDMyKDEwKS5zdHJpbmcodC5pbnB1dFtuXSk7aWYobnVsbCE9dC5vdXRwdXQmJnQub3V0cHV0Lmxlbmd0aClmb3Iobj0wO248dC5vdXRwdXQubGVuZ3RoOysrbillLnVpbnQzMigxOCkuc3RyaW5nKHQub3V0cHV0W25dKTtpZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZlLnVpbnQzMigyNikuc3RyaW5nKHQubmFtZSksbnVsbCE9dC5vcFR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikmJmUudWludDMyKDM0KS5zdHJpbmcodC5vcFR5cGUpLG51bGwhPXQuYXR0cmlidXRlJiZ0LmF0dHJpYnV0ZS5sZW5ndGgpZm9yKG49MDtuPHQuYXR0cmlidXRlLmxlbmd0aDsrK24pbC5vbm54LkF0dHJpYnV0ZVByb3RvLmVuY29kZSh0LmF0dHJpYnV0ZVtuXSxlLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJmUudWludDMyKDUwKS5zdHJpbmcodC5kb2NTdHJpbmcpLG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiZlLnVpbnQzMig1OCkuc3RyaW5nKHQuZG9tYWluKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguTm9kZVByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO3N3aXRjaChpPj4+Myl7Y2FzZSAxOnIuaW5wdXQmJnIuaW5wdXQubGVuZ3RofHwoci5pbnB1dD1bXSksci5pbnB1dC5wdXNoKHQuc3RyaW5nKCkpO2JyZWFrO2Nhc2UgMjpyLm91dHB1dCYmci5vdXRwdXQubGVuZ3RofHwoci5vdXRwdXQ9W10pLHIub3V0cHV0LnB1c2godC5zdHJpbmcoKSk7YnJlYWs7Y2FzZSAzOnIubmFtZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgNDpyLm9wVHlwZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgNzpyLmRvbWFpbj10LnN0cmluZygpO2JyZWFrO2Nhc2UgNTpyLmF0dHJpYnV0ZSYmci5hdHRyaWJ1dGUubGVuZ3RofHwoci5hdHRyaWJ1dGU9W10pLHIuYXR0cmlidXRlLnB1c2gobC5vbm54LkF0dHJpYnV0ZVByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDY6ci5kb2NTdHJpbmc9dC5zdHJpbmcoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQuaW5wdXQmJnQuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnB1dCkpcmV0dXJuXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIGU9MDtlPHQuaW5wdXQubGVuZ3RoOysrZSlpZighYy5pc1N0cmluZyh0LmlucHV0W2VdKSlyZXR1cm5cImlucHV0OiBzdHJpbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQub3V0cHV0JiZ0Lmhhc093blByb3BlcnR5KFwib3V0cHV0XCIpKXtpZighQXJyYXkuaXNBcnJheSh0Lm91dHB1dCkpcmV0dXJuXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQub3V0cHV0Lmxlbmd0aDsrK2UpaWYoIWMuaXNTdHJpbmcodC5vdXRwdXRbZV0pKXJldHVyblwib3V0cHV0OiBzdHJpbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFjLmlzU3RyaW5nKHQubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10Lm9wVHlwZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSYmIWMuaXNTdHJpbmcodC5vcFR5cGUpKXJldHVyblwib3BUeXBlOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmIWMuaXNTdHJpbmcodC5kb21haW4pKXJldHVyblwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmF0dHJpYnV0ZSYmdC5oYXNPd25Qcm9wZXJ0eShcImF0dHJpYnV0ZVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5hdHRyaWJ1dGUpKXJldHVyblwiYXR0cmlidXRlOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmF0dHJpYnV0ZS5sZW5ndGg7KytlKXt2YXIgbj1sLm9ubnguQXR0cmlidXRlUHJvdG8udmVyaWZ5KHQuYXR0cmlidXRlW2VdKTtpZihuKXJldHVyblwiYXR0cmlidXRlLlwiK259fXJldHVybiBudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWMuaXNTdHJpbmcodC5kb2NTdHJpbmcpP1wiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5Ob2RlUHJvdG8pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5Ob2RlUHJvdG87aWYodC5pbnB1dCl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmlucHV0OiBhcnJheSBleHBlY3RlZFwiKTtlLmlucHV0PVtdO2Zvcih2YXIgbj0wO248dC5pbnB1dC5sZW5ndGg7KytuKWUuaW5wdXRbbl09U3RyaW5nKHQuaW5wdXRbbl0pfWlmKHQub3V0cHV0KXtpZighQXJyYXkuaXNBcnJheSh0Lm91dHB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUub3V0cHV0PVtdLG49MDtuPHQub3V0cHV0Lmxlbmd0aDsrK24pZS5vdXRwdXRbbl09U3RyaW5nKHQub3V0cHV0W25dKX1pZihudWxsIT10Lm5hbWUmJihlLm5hbWU9U3RyaW5nKHQubmFtZSkpLG51bGwhPXQub3BUeXBlJiYoZS5vcFR5cGU9U3RyaW5nKHQub3BUeXBlKSksbnVsbCE9dC5kb21haW4mJihlLmRvbWFpbj1TdHJpbmcodC5kb21haW4pKSx0LmF0dHJpYnV0ZSl7aWYoIUFycmF5LmlzQXJyYXkodC5hdHRyaWJ1dGUpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5hdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmF0dHJpYnV0ZT1bXSxuPTA7bjx0LmF0dHJpYnV0ZS5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5hdHRyaWJ1dGVbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmF0dHJpYnV0ZTogb2JqZWN0IGV4cGVjdGVkXCIpO2UuYXR0cmlidXRlW25dPWwub25ueC5BdHRyaWJ1dGVQcm90by5mcm9tT2JqZWN0KHQuYXR0cmlidXRlW25dKX19cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiYoZS5kb2NTdHJpbmc9U3RyaW5nKHQuZG9jU3RyaW5nKSksZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZigoZS5hcnJheXN8fGUuZGVmYXVsdHMpJiYobi5pbnB1dD1bXSxuLm91dHB1dD1bXSxuLmF0dHJpYnV0ZT1bXSksZS5kZWZhdWx0cyYmKG4ubmFtZT1cIlwiLG4ub3BUeXBlPVwiXCIsbi5kb2NTdHJpbmc9XCJcIixuLmRvbWFpbj1cIlwiKSx0LmlucHV0JiZ0LmlucHV0Lmxlbmd0aCl7bi5pbnB1dD1bXTtmb3IodmFyIHI9MDtyPHQuaW5wdXQubGVuZ3RoOysrciluLmlucHV0W3JdPXQuaW5wdXRbcl19aWYodC5vdXRwdXQmJnQub3V0cHV0Lmxlbmd0aClmb3Iobi5vdXRwdXQ9W10scj0wO3I8dC5vdXRwdXQubGVuZ3RoOysrciluLm91dHB1dFtyXT10Lm91dHB1dFtyXTtpZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPXQubmFtZSksbnVsbCE9dC5vcFR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikmJihuLm9wVHlwZT10Lm9wVHlwZSksdC5hdHRyaWJ1dGUmJnQuYXR0cmlidXRlLmxlbmd0aClmb3Iobi5hdHRyaWJ1dGU9W10scj0wO3I8dC5hdHRyaWJ1dGUubGVuZ3RoOysrciluLmF0dHJpYnV0ZVtyXT1sLm9ubnguQXR0cmlidXRlUHJvdG8udG9PYmplY3QodC5hdHRyaWJ1dGVbcl0sZSk7cmV0dXJuIG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49dC5kb21haW4pLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8uTW9kZWxQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5vcHNldEltcG9ydD1bXSx0aGlzLm1ldGFkYXRhUHJvcHM9W10sdClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5pclZlcnNpb249Yy5Mb25nP2MuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsdC5wcm90b3R5cGUub3BzZXRJbXBvcnQ9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLnByb2R1Y2VyTmFtZT1cIlwiLHQucHJvdG90eXBlLnByb2R1Y2VyVmVyc2lvbj1cIlwiLHQucHJvdG90eXBlLmRvbWFpbj1cIlwiLHQucHJvdG90eXBlLm1vZGVsVmVyc2lvbj1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIix0LnByb3RvdHlwZS5ncmFwaD1udWxsLHQucHJvdG90eXBlLm1ldGFkYXRhUHJvcHM9Yy5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmlyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImlyVmVyc2lvblwiKSYmZS51aW50MzIoOCkuaW50NjQodC5pclZlcnNpb24pLG51bGwhPXQucHJvZHVjZXJOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpJiZlLnVpbnQzMigxOCkuc3RyaW5nKHQucHJvZHVjZXJOYW1lKSxudWxsIT10LnByb2R1Y2VyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSYmZS51aW50MzIoMjYpLnN0cmluZyh0LnByb2R1Y2VyVmVyc2lvbiksbnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJmUudWludDMyKDM0KS5zdHJpbmcodC5kb21haW4pLG51bGwhPXQubW9kZWxWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpJiZlLnVpbnQzMig0MCkuaW50NjQodC5tb2RlbFZlcnNpb24pLG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiZlLnVpbnQzMig1MCkuc3RyaW5nKHQuZG9jU3RyaW5nKSxudWxsIT10LmdyYXBoJiZ0Lmhhc093blByb3BlcnR5KFwiZ3JhcGhcIikmJmwub25ueC5HcmFwaFByb3RvLmVuY29kZSh0LmdyYXBoLGUudWludDMyKDU4KS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPXQub3BzZXRJbXBvcnQmJnQub3BzZXRJbXBvcnQubGVuZ3RoKWZvcih2YXIgbj0wO248dC5vcHNldEltcG9ydC5sZW5ndGg7KytuKWwub25ueC5PcGVyYXRvclNldElkUHJvdG8uZW5jb2RlKHQub3BzZXRJbXBvcnRbbl0sZS51aW50MzIoNjYpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC5tZXRhZGF0YVByb3BzJiZ0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoKWZvcihuPTA7bjx0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrbilsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUodC5tZXRhZGF0YVByb3BzW25dLGUudWludDMyKDExNCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54Lk1vZGVsUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5pclZlcnNpb249dC5pbnQ2NCgpO2JyZWFrO2Nhc2UgODpyLm9wc2V0SW1wb3J0JiZyLm9wc2V0SW1wb3J0Lmxlbmd0aHx8KHIub3BzZXRJbXBvcnQ9W10pLHIub3BzZXRJbXBvcnQucHVzaChsLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDI6ci5wcm9kdWNlck5hbWU9dC5zdHJpbmcoKTticmVhaztjYXNlIDM6ci5wcm9kdWNlclZlcnNpb249dC5zdHJpbmcoKTticmVhaztjYXNlIDQ6ci5kb21haW49dC5zdHJpbmcoKTticmVhaztjYXNlIDU6ci5tb2RlbFZlcnNpb249dC5pbnQ2NCgpO2JyZWFrO2Nhc2UgNjpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2Nhc2UgNzpyLmdyYXBoPWwub25ueC5HcmFwaFByb3RvLmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgMTQ6ci5tZXRhZGF0YVByb3BzJiZyLm1ldGFkYXRhUHJvcHMubGVuZ3RofHwoci5tZXRhZGF0YVByb3BzPVtdKSxyLm1ldGFkYXRhUHJvcHMucHVzaChsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LmlyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImlyVmVyc2lvblwiKSYmIShjLmlzSW50ZWdlcih0LmlyVmVyc2lvbil8fHQuaXJWZXJzaW9uJiZjLmlzSW50ZWdlcih0LmlyVmVyc2lvbi5sb3cpJiZjLmlzSW50ZWdlcih0LmlyVmVyc2lvbi5oaWdoKSkpcmV0dXJuXCJpclZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPXQub3BzZXRJbXBvcnQmJnQuaGFzT3duUHJvcGVydHkoXCJvcHNldEltcG9ydFwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5vcHNldEltcG9ydCkpcmV0dXJuXCJvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIGU9MDtlPHQub3BzZXRJbXBvcnQubGVuZ3RoOysrZSlpZihuPWwub25ueC5PcGVyYXRvclNldElkUHJvdG8udmVyaWZ5KHQub3BzZXRJbXBvcnRbZV0pKXJldHVyblwib3BzZXRJbXBvcnQuXCIrbn1pZihudWxsIT10LnByb2R1Y2VyTmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyTmFtZVwiKSYmIWMuaXNTdHJpbmcodC5wcm9kdWNlck5hbWUpKXJldHVyblwicHJvZHVjZXJOYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnByb2R1Y2VyVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSYmIWMuaXNTdHJpbmcodC5wcm9kdWNlclZlcnNpb24pKXJldHVyblwicHJvZHVjZXJWZXJzaW9uOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmIWMuaXNTdHJpbmcodC5kb21haW4pKXJldHVyblwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10Lm1vZGVsVmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcIm1vZGVsVmVyc2lvblwiKSYmIShjLmlzSW50ZWdlcih0Lm1vZGVsVmVyc2lvbil8fHQubW9kZWxWZXJzaW9uJiZjLmlzSW50ZWdlcih0Lm1vZGVsVmVyc2lvbi5sb3cpJiZjLmlzSW50ZWdlcih0Lm1vZGVsVmVyc2lvbi5oaWdoKSkpcmV0dXJuXCJtb2RlbFZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuZ3JhcGgmJnQuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSYmKG49bC5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KHQuZ3JhcGgpKSlyZXR1cm5cImdyYXBoLlwiK247aWYobnVsbCE9dC5tZXRhZGF0YVByb3BzJiZ0Lmhhc093blByb3BlcnR5KFwibWV0YWRhdGFQcm9wc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5tZXRhZGF0YVByb3BzKSlyZXR1cm5cIm1ldGFkYXRhUHJvcHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytlKXt2YXIgbjtpZihuPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeSh0Lm1ldGFkYXRhUHJvcHNbZV0pKXJldHVyblwibWV0YWRhdGFQcm9wcy5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguTW9kZWxQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54Lk1vZGVsUHJvdG87aWYobnVsbCE9dC5pclZlcnNpb24mJihjLkxvbmc/KGUuaXJWZXJzaW9uPWMuTG9uZy5mcm9tVmFsdWUodC5pclZlcnNpb24pKS51bnNpZ25lZD0hMTpcInN0cmluZ1wiPT10eXBlb2YgdC5pclZlcnNpb24/ZS5pclZlcnNpb249cGFyc2VJbnQodC5pclZlcnNpb24sMTApOlwibnVtYmVyXCI9PXR5cGVvZiB0LmlyVmVyc2lvbj9lLmlyVmVyc2lvbj10LmlyVmVyc2lvbjpcIm9iamVjdFwiPT10eXBlb2YgdC5pclZlcnNpb24mJihlLmlyVmVyc2lvbj1uZXcgYy5Mb25nQml0cyh0LmlyVmVyc2lvbi5sb3c+Pj4wLHQuaXJWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpKSksdC5vcHNldEltcG9ydCl7aWYoIUFycmF5LmlzQXJyYXkodC5vcHNldEltcG9ydCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIik7ZS5vcHNldEltcG9ydD1bXTtmb3IodmFyIG49MDtuPHQub3BzZXRJbXBvcnQubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQub3BzZXRJbXBvcnRbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogb2JqZWN0IGV4cGVjdGVkXCIpO2Uub3BzZXRJbXBvcnRbbl09bC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5mcm9tT2JqZWN0KHQub3BzZXRJbXBvcnRbbl0pfX1pZihudWxsIT10LnByb2R1Y2VyTmFtZSYmKGUucHJvZHVjZXJOYW1lPVN0cmluZyh0LnByb2R1Y2VyTmFtZSkpLG51bGwhPXQucHJvZHVjZXJWZXJzaW9uJiYoZS5wcm9kdWNlclZlcnNpb249U3RyaW5nKHQucHJvZHVjZXJWZXJzaW9uKSksbnVsbCE9dC5kb21haW4mJihlLmRvbWFpbj1TdHJpbmcodC5kb21haW4pKSxudWxsIT10Lm1vZGVsVmVyc2lvbiYmKGMuTG9uZz8oZS5tb2RlbFZlcnNpb249Yy5Mb25nLmZyb21WYWx1ZSh0Lm1vZGVsVmVyc2lvbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0Lm1vZGVsVmVyc2lvbj9lLm1vZGVsVmVyc2lvbj1wYXJzZUludCh0Lm1vZGVsVmVyc2lvbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQubW9kZWxWZXJzaW9uP2UubW9kZWxWZXJzaW9uPXQubW9kZWxWZXJzaW9uOlwib2JqZWN0XCI9PXR5cGVvZiB0Lm1vZGVsVmVyc2lvbiYmKGUubW9kZWxWZXJzaW9uPW5ldyBjLkxvbmdCaXRzKHQubW9kZWxWZXJzaW9uLmxvdz4+PjAsdC5tb2RlbFZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxudWxsIT10LmRvY1N0cmluZyYmKGUuZG9jU3RyaW5nPVN0cmluZyh0LmRvY1N0cmluZykpLG51bGwhPXQuZ3JhcGgpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LmdyYXBoKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8uZ3JhcGg6IG9iamVjdCBleHBlY3RlZFwiKTtlLmdyYXBoPWwub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3QodC5ncmFwaCl9aWYodC5tZXRhZGF0YVByb3BzKXtpZighQXJyYXkuaXNBcnJheSh0Lm1ldGFkYXRhUHJvcHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUubWV0YWRhdGFQcm9wcz1bXSxuPTA7bjx0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQubWV0YWRhdGFQcm9wc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm1ldGFkYXRhUHJvcHM6IG9iamVjdCBleHBlY3RlZFwiKTtlLm1ldGFkYXRhUHJvcHNbbl09bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdCh0Lm1ldGFkYXRhUHJvcHNbbl0pfX1yZXR1cm4gZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZigoZS5hcnJheXN8fGUuZGVmYXVsdHMpJiYobi5vcHNldEltcG9ydD1bXSxuLm1ldGFkYXRhUHJvcHM9W10pLGUuZGVmYXVsdHMpe2lmKGMuTG9uZyl7dmFyIHI9bmV3IGMuTG9uZygwLDAsITEpO24uaXJWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOmUubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnJ9ZWxzZSBuLmlyVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7bi5wcm9kdWNlck5hbWU9XCJcIixuLnByb2R1Y2VyVmVyc2lvbj1cIlwiLG4uZG9tYWluPVwiXCIsYy5Mb25nPyhyPW5ldyBjLkxvbmcoMCwwLCExKSxuLm1vZGVsVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyKTpuLm1vZGVsVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjAsbi5kb2NTdHJpbmc9XCJcIixuLmdyYXBoPW51bGx9aWYobnVsbCE9dC5pclZlcnNpb24mJnQuaGFzT3duUHJvcGVydHkoXCJpclZlcnNpb25cIikmJihcIm51bWJlclwiPT10eXBlb2YgdC5pclZlcnNpb24/bi5pclZlcnNpb249ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5pclZlcnNpb24pOnQuaXJWZXJzaW9uOm4uaXJWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuaXJWZXJzaW9uKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuaXJWZXJzaW9uLmxvdz4+PjAsdC5pclZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5pclZlcnNpb24pLG51bGwhPXQucHJvZHVjZXJOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpJiYobi5wcm9kdWNlck5hbWU9dC5wcm9kdWNlck5hbWUpLG51bGwhPXQucHJvZHVjZXJWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwicHJvZHVjZXJWZXJzaW9uXCIpJiYobi5wcm9kdWNlclZlcnNpb249dC5wcm9kdWNlclZlcnNpb24pLG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49dC5kb21haW4pLG51bGwhPXQubW9kZWxWZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIHQubW9kZWxWZXJzaW9uP24ubW9kZWxWZXJzaW9uPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQubW9kZWxWZXJzaW9uKTp0Lm1vZGVsVmVyc2lvbjpuLm1vZGVsVmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0Lm1vZGVsVmVyc2lvbik6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0Lm1vZGVsVmVyc2lvbi5sb3c+Pj4wLHQubW9kZWxWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpOnQubW9kZWxWZXJzaW9uKSxudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmKG4uZG9jU3RyaW5nPXQuZG9jU3RyaW5nKSxudWxsIT10LmdyYXBoJiZ0Lmhhc093blByb3BlcnR5KFwiZ3JhcGhcIikmJihuLmdyYXBoPWwub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KHQuZ3JhcGgsZSkpLHQub3BzZXRJbXBvcnQmJnQub3BzZXRJbXBvcnQubGVuZ3RoKXtuLm9wc2V0SW1wb3J0PVtdO2Zvcih2YXIgaT0wO2k8dC5vcHNldEltcG9ydC5sZW5ndGg7KytpKW4ub3BzZXRJbXBvcnRbaV09bC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by50b09iamVjdCh0Lm9wc2V0SW1wb3J0W2ldLGUpfWlmKHQubWV0YWRhdGFQcm9wcyYmdC5tZXRhZGF0YVByb3BzLmxlbmd0aClmb3Iobi5tZXRhZGF0YVByb3BzPVtdLGk9MDtpPHQubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytpKW4ubWV0YWRhdGFQcm9wc1tpXT1sLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdCh0Lm1ldGFkYXRhUHJvcHNbaV0sZSk7cmV0dXJuIG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8uU3RyaW5nU3RyaW5nRW50cnlQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5rZXk9XCJcIix0LnByb3RvdHlwZS52YWx1ZT1cIlwiLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5rZXkmJnQuaGFzT3duUHJvcGVydHkoXCJrZXlcIikmJmUudWludDMyKDEwKS5zdHJpbmcodC5rZXkpLG51bGwhPXQudmFsdWUmJnQuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSYmZS51aW50MzIoMTgpLnN0cmluZyh0LnZhbHVlKSxlfSx0LmVuY29kZURlbGltaXRlZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuY29kZSh0LGUpLmxkZWxpbSgpfSx0LmRlY29kZT1mdW5jdGlvbih0LGUpe3QgaW5zdGFuY2VvZiBzfHwodD1zLmNyZWF0ZSh0KSk7Zm9yKHZhciBuPXZvaWQgMD09PWU/dC5sZW46dC5wb3MrZSxyPW5ldyBsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmtleT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnZhbHVlPXQuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQ/XCJvYmplY3QgZXhwZWN0ZWRcIjpudWxsIT10LmtleSYmdC5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSYmIWMuaXNTdHJpbmcodC5rZXkpP1wia2V5OiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsIT10LnZhbHVlJiZ0Lmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJiFjLmlzU3RyaW5nKHQudmFsdWUpP1widmFsdWU6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8pcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvO3JldHVybiBudWxsIT10LmtleSYmKGUua2V5PVN0cmluZyh0LmtleSkpLG51bGwhPXQudmFsdWUmJihlLnZhbHVlPVN0cmluZyh0LnZhbHVlKSksZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtyZXR1cm4gZS5kZWZhdWx0cyYmKG4ua2V5PVwiXCIsbi52YWx1ZT1cIlwiKSxudWxsIT10LmtleSYmdC5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSYmKG4ua2V5PXQua2V5KSxudWxsIT10LnZhbHVlJiZ0Lmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJihuLnZhbHVlPXQudmFsdWUpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8uVGVuc29yQW5ub3RhdGlvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUudGVuc29yTmFtZT1cIlwiLHQucHJvdG90eXBlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9Yy5lbXB0eUFycmF5LHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LnRlbnNvck5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpJiZlLnVpbnQzMigxMCkuc3RyaW5nKHQudGVuc29yTmFtZSksbnVsbCE9dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzJiZ0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKWZvcih2YXIgbj0wO248dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK24pbC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXSxlLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlRlbnNvckFubm90YXRpb247dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci50ZW5zb3JOYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aHx8KHIucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXSksci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLnB1c2gobC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC50ZW5zb3JOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmIWMuaXNTdHJpbmcodC50ZW5zb3JOYW1lKSlyZXR1cm5cInRlbnNvck5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmdC5oYXNPd25Qcm9wZXJ0eShcInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcIikpe2lmKCFBcnJheS5pc0FycmF5KHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcykpcmV0dXJuXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK2Upe3ZhciBuPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeSh0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbZV0pO2lmKG4pcmV0dXJuXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLlwiK259fXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5UZW5zb3JBbm5vdGF0aW9uKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVGVuc29yQW5ub3RhdGlvbjtpZihudWxsIT10LnRlbnNvck5hbWUmJihlLnRlbnNvck5hbWU9U3RyaW5nKHQudGVuc29yTmFtZSkpLHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyl7aWYoIUFycmF5LmlzQXJyYXkodC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JBbm5vdGF0aW9uLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IGFycmF5IGV4cGVjdGVkXCIpO2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXTtmb3IodmFyIG49MDtuPHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvckFubm90YXRpb24ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogb2JqZWN0IGV4cGVjdGVkXCIpO2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXT1sLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXSl9fXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9W10pLGUuZGVmYXVsdHMmJihuLnRlbnNvck5hbWU9XCJcIiksbnVsbCE9dC50ZW5zb3JOYW1lJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmKG4udGVuc29yTmFtZT10LnRlbnNvck5hbWUpLHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aCl7bi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdO2Zvcih2YXIgcj0wO3I8dC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK3Ipbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW3JdPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KHQucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tyXSxlKX1yZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5HcmFwaFByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLm5vZGU9W10sdGhpcy5pbml0aWFsaXplcj1bXSx0aGlzLmlucHV0PVtdLHRoaXMub3V0cHV0PVtdLHRoaXMudmFsdWVJbmZvPVtdLHRoaXMucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSx0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLm5vZGU9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLm5hbWU9XCJcIix0LnByb3RvdHlwZS5pbml0aWFsaXplcj1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsdC5wcm90b3R5cGUuaW5wdXQ9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLm91dHB1dD1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUudmFsdWVJbmZvPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPWMuZW1wdHlBcnJheSx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7aWYoZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5ub2RlJiZ0Lm5vZGUubGVuZ3RoKWZvcih2YXIgbj0wO248dC5ub2RlLmxlbmd0aDsrK24pbC5vbm54Lk5vZGVQcm90by5lbmNvZGUodC5ub2RlW25dLGUudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJmUudWludDMyKDE4KS5zdHJpbmcodC5uYW1lKSxudWxsIT10LmluaXRpYWxpemVyJiZ0LmluaXRpYWxpemVyLmxlbmd0aClmb3Iobj0wO248dC5pbml0aWFsaXplci5sZW5ndGg7KytuKWwub25ueC5UZW5zb3JQcm90by5lbmNvZGUodC5pbml0aWFsaXplcltuXSxlLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmZS51aW50MzIoODIpLnN0cmluZyh0LmRvY1N0cmluZyksbnVsbCE9dC5pbnB1dCYmdC5pbnB1dC5sZW5ndGgpZm9yKG49MDtuPHQuaW5wdXQubGVuZ3RoOysrbilsLm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKHQuaW5wdXRbbl0sZS51aW50MzIoOTApLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC5vdXRwdXQmJnQub3V0cHV0Lmxlbmd0aClmb3Iobj0wO248dC5vdXRwdXQubGVuZ3RoOysrbilsLm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKHQub3V0cHV0W25dLGUudWludDMyKDk4KS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPXQudmFsdWVJbmZvJiZ0LnZhbHVlSW5mby5sZW5ndGgpZm9yKG49MDtuPHQudmFsdWVJbmZvLmxlbmd0aDsrK24pbC5vbm54LlZhbHVlSW5mb1Byb3RvLmVuY29kZSh0LnZhbHVlSW5mb1tuXSxlLnVpbnQzMigxMDYpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZ0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKWZvcihuPTA7bjx0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrbilsLm9ubnguVGVuc29yQW5ub3RhdGlvbi5lbmNvZGUodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW25dLGUudWludDMyKDExNCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LkdyYXBoUHJvdG87dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5ub2RlJiZyLm5vZGUubGVuZ3RofHwoci5ub2RlPVtdKSxyLm5vZGUucHVzaChsLm9ubnguTm9kZVByb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDI6ci5uYW1lPXQuc3RyaW5nKCk7YnJlYWs7Y2FzZSA1OnIuaW5pdGlhbGl6ZXImJnIuaW5pdGlhbGl6ZXIubGVuZ3RofHwoci5pbml0aWFsaXplcj1bXSksci5pbml0aWFsaXplci5wdXNoKGwub25ueC5UZW5zb3JQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxMDpyLmRvY1N0cmluZz10LnN0cmluZygpO2JyZWFrO2Nhc2UgMTE6ci5pbnB1dCYmci5pbnB1dC5sZW5ndGh8fChyLmlucHV0PVtdKSxyLmlucHV0LnB1c2gobC5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztjYXNlIDEyOnIub3V0cHV0JiZyLm91dHB1dC5sZW5ndGh8fChyLm91dHB1dD1bXSksci5vdXRwdXQucHVzaChsLm9ubnguVmFsdWVJbmZvUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTM6ci52YWx1ZUluZm8mJnIudmFsdWVJbmZvLmxlbmd0aHx8KHIudmFsdWVJbmZvPVtdKSxyLnZhbHVlSW5mby5wdXNoKGwub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxNDpyLnF1YW50aXphdGlvbkFubm90YXRpb24mJnIucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGh8fChyLnF1YW50aXphdGlvbkFubm90YXRpb249W10pLHIucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5wdXNoKGwub25ueC5UZW5zb3JBbm5vdGF0aW9uLmRlY29kZSh0LHQudWludDMyKCkpKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPXQubm9kZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5vZGVcIikpe2lmKCFBcnJheS5pc0FycmF5KHQubm9kZSkpcmV0dXJuXCJub2RlOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5ub2RlLmxlbmd0aDsrK2UpaWYobj1sLm9ubnguTm9kZVByb3RvLnZlcmlmeSh0Lm5vZGVbZV0pKXJldHVyblwibm9kZS5cIitufWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFjLmlzU3RyaW5nKHQubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmluaXRpYWxpemVyJiZ0Lmhhc093blByb3BlcnR5KFwiaW5pdGlhbGl6ZXJcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuaW5pdGlhbGl6ZXIpKXJldHVyblwiaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuaW5pdGlhbGl6ZXIubGVuZ3RoOysrZSlpZihuPWwub25ueC5UZW5zb3JQcm90by52ZXJpZnkodC5pbml0aWFsaXplcltlXSkpcmV0dXJuXCJpbml0aWFsaXplci5cIitufWlmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhYy5pc1N0cmluZyh0LmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPXQuaW5wdXQmJnQuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnB1dCkpcmV0dXJuXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5pbnB1dC5sZW5ndGg7KytlKWlmKG49bC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeSh0LmlucHV0W2VdKSlyZXR1cm5cImlucHV0LlwiK259aWYobnVsbCE9dC5vdXRwdXQmJnQuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpe2lmKCFBcnJheS5pc0FycmF5KHQub3V0cHV0KSlyZXR1cm5cIm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5vdXRwdXQubGVuZ3RoOysrZSlpZihuPWwub25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnkodC5vdXRwdXRbZV0pKXJldHVyblwib3V0cHV0LlwiK259aWYobnVsbCE9dC52YWx1ZUluZm8mJnQuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZUluZm9cIikpe2lmKCFBcnJheS5pc0FycmF5KHQudmFsdWVJbmZvKSlyZXR1cm5cInZhbHVlSW5mbzogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC52YWx1ZUluZm8ubGVuZ3RoOysrZSlpZihuPWwub25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnkodC52YWx1ZUluZm9bZV0pKXJldHVyblwidmFsdWVJbmZvLlwiK259aWYobnVsbCE9dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwicXVhbnRpemF0aW9uQW5ub3RhdGlvblwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uKSlyZXR1cm5cInF1YW50aXphdGlvbkFubm90YXRpb246IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7KytlKXt2YXIgbjtpZihuPWwub25ueC5UZW5zb3JBbm5vdGF0aW9uLnZlcmlmeSh0LnF1YW50aXphdGlvbkFubm90YXRpb25bZV0pKXJldHVyblwicXVhbnRpemF0aW9uQW5ub3RhdGlvbi5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguR3JhcGhQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LkdyYXBoUHJvdG87aWYodC5ub2RlKXtpZighQXJyYXkuaXNBcnJheSh0Lm5vZGUpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ubm9kZTogYXJyYXkgZXhwZWN0ZWRcIik7ZS5ub2RlPVtdO2Zvcih2YXIgbj0wO248dC5ub2RlLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0Lm5vZGVbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5ub2RlOiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5ub2RlW25dPWwub25ueC5Ob2RlUHJvdG8uZnJvbU9iamVjdCh0Lm5vZGVbbl0pfX1pZihudWxsIT10Lm5hbWUmJihlLm5hbWU9U3RyaW5nKHQubmFtZSkpLHQuaW5pdGlhbGl6ZXIpe2lmKCFBcnJheS5pc0FycmF5KHQuaW5pdGlhbGl6ZXIpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmluaXRpYWxpemVyPVtdLG49MDtuPHQuaW5pdGlhbGl6ZXIubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuaW5pdGlhbGl6ZXJbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbml0aWFsaXplcjogb2JqZWN0IGV4cGVjdGVkXCIpO2UuaW5pdGlhbGl6ZXJbbl09bC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3QodC5pbml0aWFsaXplcltuXSl9fWlmKG51bGwhPXQuZG9jU3RyaW5nJiYoZS5kb2NTdHJpbmc9U3RyaW5nKHQuZG9jU3RyaW5nKSksdC5pbnB1dCl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW5wdXQ9W10sbj0wO248dC5pbnB1dC5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5pbnB1dFtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLmlucHV0OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5pbnB1dFtuXT1sLm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdCh0LmlucHV0W25dKX19aWYodC5vdXRwdXQpe2lmKCFBcnJheS5pc0FycmF5KHQub3V0cHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUub3V0cHV0PVtdLG49MDtuPHQub3V0cHV0Lmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0Lm91dHB1dFtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogb2JqZWN0IGV4cGVjdGVkXCIpO2Uub3V0cHV0W25dPWwub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KHQub3V0cHV0W25dKX19aWYodC52YWx1ZUluZm8pe2lmKCFBcnJheS5pc0FycmF5KHQudmFsdWVJbmZvKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUudmFsdWVJbmZvPVtdLG49MDtuPHQudmFsdWVJbmZvLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnZhbHVlSW5mb1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogb2JqZWN0IGV4cGVjdGVkXCIpO2UudmFsdWVJbmZvW25dPWwub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KHQudmFsdWVJbmZvW25dKX19aWYodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uKXtpZighQXJyYXkuaXNBcnJheSh0LnF1YW50aXphdGlvbkFubm90YXRpb24pKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ucXVhbnRpemF0aW9uQW5ub3RhdGlvbjogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSxuPTA7bjx0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbltuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnF1YW50aXphdGlvbkFubm90YXRpb246IG9iamVjdCBleHBlY3RlZFwiKTtlLnF1YW50aXphdGlvbkFubm90YXRpb25bbl09bC5vbm54LlRlbnNvckFubm90YXRpb24uZnJvbU9iamVjdCh0LnF1YW50aXphdGlvbkFubm90YXRpb25bbl0pfX1yZXR1cm4gZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtpZigoZS5hcnJheXN8fGUuZGVmYXVsdHMpJiYobi5ub2RlPVtdLG4uaW5pdGlhbGl6ZXI9W10sbi5pbnB1dD1bXSxuLm91dHB1dD1bXSxuLnZhbHVlSW5mbz1bXSxuLnF1YW50aXphdGlvbkFubm90YXRpb249W10pLGUuZGVmYXVsdHMmJihuLm5hbWU9XCJcIixuLmRvY1N0cmluZz1cIlwiKSx0Lm5vZGUmJnQubm9kZS5sZW5ndGgpe24ubm9kZT1bXTtmb3IodmFyIHI9MDtyPHQubm9kZS5sZW5ndGg7KytyKW4ubm9kZVtyXT1sLm9ubnguTm9kZVByb3RvLnRvT2JqZWN0KHQubm9kZVtyXSxlKX1pZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPXQubmFtZSksdC5pbml0aWFsaXplciYmdC5pbml0aWFsaXplci5sZW5ndGgpZm9yKG4uaW5pdGlhbGl6ZXI9W10scj0wO3I8dC5pbml0aWFsaXplci5sZW5ndGg7KytyKW4uaW5pdGlhbGl6ZXJbcl09bC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KHQuaW5pdGlhbGl6ZXJbcl0sZSk7aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz10LmRvY1N0cmluZyksdC5pbnB1dCYmdC5pbnB1dC5sZW5ndGgpZm9yKG4uaW5wdXQ9W10scj0wO3I8dC5pbnB1dC5sZW5ndGg7KytyKW4uaW5wdXRbcl09bC5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KHQuaW5wdXRbcl0sZSk7aWYodC5vdXRwdXQmJnQub3V0cHV0Lmxlbmd0aClmb3Iobi5vdXRwdXQ9W10scj0wO3I8dC5vdXRwdXQubGVuZ3RoOysrciluLm91dHB1dFtyXT1sLm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QodC5vdXRwdXRbcl0sZSk7aWYodC52YWx1ZUluZm8mJnQudmFsdWVJbmZvLmxlbmd0aClmb3Iobi52YWx1ZUluZm89W10scj0wO3I8dC52YWx1ZUluZm8ubGVuZ3RoOysrciluLnZhbHVlSW5mb1tyXT1sLm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QodC52YWx1ZUluZm9bcl0sZSk7aWYodC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZ0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKWZvcihuLnF1YW50aXphdGlvbkFubm90YXRpb249W10scj0wO3I8dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsrK3Ipbi5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW3JdPWwub25ueC5UZW5zb3JBbm5vdGF0aW9uLnRvT2JqZWN0KHQucXVhbnRpemF0aW9uQW5ub3RhdGlvbltyXSxlKTtyZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHR9KCksby5UZW5zb3JQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodGhpcy5kaW1zPVtdLHRoaXMuZmxvYXREYXRhPVtdLHRoaXMuaW50MzJEYXRhPVtdLHRoaXMuc3RyaW5nRGF0YT1bXSx0aGlzLmludDY0RGF0YT1bXSx0aGlzLmV4dGVybmFsRGF0YT1bXSx0aGlzLmRvdWJsZURhdGE9W10sdGhpcy51aW50NjREYXRhPVtdLHQpZm9yKHZhciBlPU9iamVjdC5rZXlzKHQpLG49MDtuPGUubGVuZ3RoOysrbiludWxsIT10W2Vbbl1dJiYodGhpc1tlW25dXT10W2Vbbl1dKX1yZXR1cm4gdC5wcm90b3R5cGUuZGltcz1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZGF0YVR5cGU9MCx0LnByb3RvdHlwZS5zZWdtZW50PW51bGwsdC5wcm90b3R5cGUuZmxvYXREYXRhPWMuZW1wdHlBcnJheSx0LnByb3RvdHlwZS5pbnQzMkRhdGE9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLnN0cmluZ0RhdGE9Yy5lbXB0eUFycmF5LHQucHJvdG90eXBlLmludDY0RGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUubmFtZT1cIlwiLHQucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLHQucHJvdG90eXBlLnJhd0RhdGE9Yy5uZXdCdWZmZXIoW10pLHQucHJvdG90eXBlLmV4dGVybmFsRGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUuZGF0YUxvY2F0aW9uPTAsdC5wcm90b3R5cGUuZG91YmxlRGF0YT1jLmVtcHR5QXJyYXksdC5wcm90b3R5cGUudWludDY0RGF0YT1jLmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuZGltcyYmdC5kaW1zLmxlbmd0aCl7ZS51aW50MzIoMTApLmZvcmsoKTtmb3IodmFyIG49MDtuPHQuZGltcy5sZW5ndGg7KytuKWUuaW50NjQodC5kaW1zW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuZGF0YVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmZS51aW50MzIoMTYpLmludDMyKHQuZGF0YVR5cGUpLG51bGwhPXQuc2VnbWVudCYmdC5oYXNPd25Qcm9wZXJ0eShcInNlZ21lbnRcIikmJmwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmVuY29kZSh0LnNlZ21lbnQsZS51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCksbnVsbCE9dC5mbG9hdERhdGEmJnQuZmxvYXREYXRhLmxlbmd0aCl7Zm9yKGUudWludDMyKDM0KS5mb3JrKCksbj0wO248dC5mbG9hdERhdGEubGVuZ3RoOysrbillLmZsb2F0KHQuZmxvYXREYXRhW25dKTtlLmxkZWxpbSgpfWlmKG51bGwhPXQuaW50MzJEYXRhJiZ0LmludDMyRGF0YS5sZW5ndGgpe2ZvcihlLnVpbnQzMig0MikuZm9yaygpLG49MDtuPHQuaW50MzJEYXRhLmxlbmd0aDsrK24pZS5pbnQzMih0LmludDMyRGF0YVtuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10LnN0cmluZ0RhdGEmJnQuc3RyaW5nRGF0YS5sZW5ndGgpZm9yKG49MDtuPHQuc3RyaW5nRGF0YS5sZW5ndGg7KytuKWUudWludDMyKDUwKS5ieXRlcyh0LnN0cmluZ0RhdGFbbl0pO2lmKG51bGwhPXQuaW50NjREYXRhJiZ0LmludDY0RGF0YS5sZW5ndGgpe2ZvcihlLnVpbnQzMig1OCkuZm9yaygpLG49MDtuPHQuaW50NjREYXRhLmxlbmd0aDsrK24pZS5pbnQ2NCh0LmludDY0RGF0YVtuXSk7ZS5sZGVsaW0oKX1pZihudWxsIT10Lm5hbWUmJnQuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiZlLnVpbnQzMig2Nikuc3RyaW5nKHQubmFtZSksbnVsbCE9dC5yYXdEYXRhJiZ0Lmhhc093blByb3BlcnR5KFwicmF3RGF0YVwiKSYmZS51aW50MzIoNzQpLmJ5dGVzKHQucmF3RGF0YSksbnVsbCE9dC5kb3VibGVEYXRhJiZ0LmRvdWJsZURhdGEubGVuZ3RoKXtmb3IoZS51aW50MzIoODIpLmZvcmsoKSxuPTA7bjx0LmRvdWJsZURhdGEubGVuZ3RoOysrbillLmRvdWJsZSh0LmRvdWJsZURhdGFbbl0pO2UubGRlbGltKCl9aWYobnVsbCE9dC51aW50NjREYXRhJiZ0LnVpbnQ2NERhdGEubGVuZ3RoKXtmb3IoZS51aW50MzIoOTApLmZvcmsoKSxuPTA7bjx0LnVpbnQ2NERhdGEubGVuZ3RoOysrbillLnVpbnQ2NCh0LnVpbnQ2NERhdGFbbl0pO2UubGRlbGltKCl9aWYobnVsbCE9dC5kb2NTdHJpbmcmJnQuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJmUudWludDMyKDk4KS5zdHJpbmcodC5kb2NTdHJpbmcpLG51bGwhPXQuZXh0ZXJuYWxEYXRhJiZ0LmV4dGVybmFsRGF0YS5sZW5ndGgpZm9yKG49MDtuPHQuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK24pbC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKHQuZXh0ZXJuYWxEYXRhW25dLGUudWludDMyKDEwNikuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9dC5kYXRhTG9jYXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikmJmUudWludDMyKDExMikuaW50MzIodC5kYXRhTG9jYXRpb24pLGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5UZW5zb3JQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTppZihyLmRpbXMmJnIuZGltcy5sZW5ndGh8fChyLmRpbXM9W10pLDI9PSg3JmkpKWZvcih2YXIgbz10LnVpbnQzMigpK3QucG9zO3QucG9zPG87KXIuZGltcy5wdXNoKHQuaW50NjQoKSk7ZWxzZSByLmRpbXMucHVzaCh0LmludDY0KCkpO2JyZWFrO2Nhc2UgMjpyLmRhdGFUeXBlPXQuaW50MzIoKTticmVhaztjYXNlIDM6ci5zZWdtZW50PWwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmRlY29kZSh0LHQudWludDMyKCkpO2JyZWFrO2Nhc2UgNDppZihyLmZsb2F0RGF0YSYmci5mbG9hdERhdGEubGVuZ3RofHwoci5mbG9hdERhdGE9W10pLDI9PSg3JmkpKWZvcihvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5mbG9hdERhdGEucHVzaCh0LmZsb2F0KCkpO2Vsc2Ugci5mbG9hdERhdGEucHVzaCh0LmZsb2F0KCkpO2JyZWFrO2Nhc2UgNTppZihyLmludDMyRGF0YSYmci5pbnQzMkRhdGEubGVuZ3RofHwoci5pbnQzMkRhdGE9W10pLDI9PSg3JmkpKWZvcihvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5pbnQzMkRhdGEucHVzaCh0LmludDMyKCkpO2Vsc2Ugci5pbnQzMkRhdGEucHVzaCh0LmludDMyKCkpO2JyZWFrO2Nhc2UgNjpyLnN0cmluZ0RhdGEmJnIuc3RyaW5nRGF0YS5sZW5ndGh8fChyLnN0cmluZ0RhdGE9W10pLHIuc3RyaW5nRGF0YS5wdXNoKHQuYnl0ZXMoKSk7YnJlYWs7Y2FzZSA3OmlmKHIuaW50NjREYXRhJiZyLmludDY0RGF0YS5sZW5ndGh8fChyLmludDY0RGF0YT1bXSksMj09KDcmaSkpZm9yKG89dC51aW50MzIoKSt0LnBvczt0LnBvczxvOylyLmludDY0RGF0YS5wdXNoKHQuaW50NjQoKSk7ZWxzZSByLmludDY0RGF0YS5wdXNoKHQuaW50NjQoKSk7YnJlYWs7Y2FzZSA4OnIubmFtZT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMTI6ci5kb2NTdHJpbmc9dC5zdHJpbmcoKTticmVhaztjYXNlIDk6ci5yYXdEYXRhPXQuYnl0ZXMoKTticmVhaztjYXNlIDEzOnIuZXh0ZXJuYWxEYXRhJiZyLmV4dGVybmFsRGF0YS5sZW5ndGh8fChyLmV4dGVybmFsRGF0YT1bXSksci5leHRlcm5hbERhdGEucHVzaChsLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUodCx0LnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxNDpyLmRhdGFMb2NhdGlvbj10LmludDMyKCk7YnJlYWs7Y2FzZSAxMDppZihyLmRvdWJsZURhdGEmJnIuZG91YmxlRGF0YS5sZW5ndGh8fChyLmRvdWJsZURhdGE9W10pLDI9PSg3JmkpKWZvcihvPXQudWludDMyKCkrdC5wb3M7dC5wb3M8bzspci5kb3VibGVEYXRhLnB1c2godC5kb3VibGUoKSk7ZWxzZSByLmRvdWJsZURhdGEucHVzaCh0LmRvdWJsZSgpKTticmVhaztjYXNlIDExOmlmKHIudWludDY0RGF0YSYmci51aW50NjREYXRhLmxlbmd0aHx8KHIudWludDY0RGF0YT1bXSksMj09KDcmaSkpZm9yKG89dC51aW50MzIoKSt0LnBvczt0LnBvczxvOylyLnVpbnQ2NERhdGEucHVzaCh0LnVpbnQ2NCgpKTtlbHNlIHIudWludDY0RGF0YS5wdXNoKHQudWludDY0KCkpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC5kaW1zJiZ0Lmhhc093blByb3BlcnR5KFwiZGltc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5kaW1zKSlyZXR1cm5cImRpbXM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciBlPTA7ZTx0LmRpbXMubGVuZ3RoOysrZSlpZighKGMuaXNJbnRlZ2VyKHQuZGltc1tlXSl8fHQuZGltc1tlXSYmYy5pc0ludGVnZXIodC5kaW1zW2VdLmxvdykmJmMuaXNJbnRlZ2VyKHQuZGltc1tlXS5oaWdoKSkpcmV0dXJuXCJkaW1zOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQuZGF0YVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmIWMuaXNJbnRlZ2VyKHQuZGF0YVR5cGUpKXJldHVyblwiZGF0YVR5cGU6IGludGVnZXIgZXhwZWN0ZWRcIjtpZihudWxsIT10LnNlZ21lbnQmJnQuaGFzT3duUHJvcGVydHkoXCJzZWdtZW50XCIpJiYobj1sLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC52ZXJpZnkodC5zZWdtZW50KSkpcmV0dXJuXCJzZWdtZW50LlwiK247aWYobnVsbCE9dC5mbG9hdERhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJmbG9hdERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuZmxvYXREYXRhKSlyZXR1cm5cImZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5mbG9hdERhdGEubGVuZ3RoOysrZSlpZihcIm51bWJlclwiIT10eXBlb2YgdC5mbG9hdERhdGFbZV0pcmV0dXJuXCJmbG9hdERhdGE6IG51bWJlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9dC5pbnQzMkRhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJpbnQzMkRhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KHQuaW50MzJEYXRhKSlyZXR1cm5cImludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5pbnQzMkRhdGEubGVuZ3RoOysrZSlpZighYy5pc0ludGVnZXIodC5pbnQzMkRhdGFbZV0pKXJldHVyblwiaW50MzJEYXRhOiBpbnRlZ2VyW10gZXhwZWN0ZWRcIn1pZihudWxsIT10LnN0cmluZ0RhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdEYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheSh0LnN0cmluZ0RhdGEpKXJldHVyblwic3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IoZT0wO2U8dC5zdHJpbmdEYXRhLmxlbmd0aDsrK2UpaWYoISh0LnN0cmluZ0RhdGFbZV0mJlwibnVtYmVyXCI9PXR5cGVvZiB0LnN0cmluZ0RhdGFbZV0ubGVuZ3RofHxjLmlzU3RyaW5nKHQuc3RyaW5nRGF0YVtlXSkpKXJldHVyblwic3RyaW5nRGF0YTogYnVmZmVyW10gZXhwZWN0ZWRcIn1pZihudWxsIT10LmludDY0RGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcImludDY0RGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnQ2NERhdGEpKXJldHVyblwiaW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmludDY0RGF0YS5sZW5ndGg7KytlKWlmKCEoYy5pc0ludGVnZXIodC5pbnQ2NERhdGFbZV0pfHx0LmludDY0RGF0YVtlXSYmYy5pc0ludGVnZXIodC5pbnQ2NERhdGFbZV0ubG93KSYmYy5pc0ludGVnZXIodC5pbnQ2NERhdGFbZV0uaGlnaCkpKXJldHVyblwiaW50NjREYXRhOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFjLmlzU3RyaW5nKHQubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRvY1N0cmluZyYmdC5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWMuaXNTdHJpbmcodC5kb2NTdHJpbmcpKXJldHVyblwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LnJhd0RhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpJiYhKHQucmF3RGF0YSYmXCJudW1iZXJcIj09dHlwZW9mIHQucmF3RGF0YS5sZW5ndGh8fGMuaXNTdHJpbmcodC5yYXdEYXRhKSkpcmV0dXJuXCJyYXdEYXRhOiBidWZmZXIgZXhwZWN0ZWRcIjtpZihudWxsIT10LmV4dGVybmFsRGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcImV4dGVybmFsRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5leHRlcm5hbERhdGEpKXJldHVyblwiZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LmV4dGVybmFsRGF0YS5sZW5ndGg7KytlKXt2YXIgbjtpZihuPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeSh0LmV4dGVybmFsRGF0YVtlXSkpcmV0dXJuXCJleHRlcm5hbERhdGEuXCIrbn19aWYobnVsbCE9dC5kYXRhTG9jYXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikpc3dpdGNoKHQuZGF0YUxvY2F0aW9uKXtkZWZhdWx0OnJldHVyblwiZGF0YUxvY2F0aW9uOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7Y2FzZSAwOmNhc2UgMTp9aWYobnVsbCE9dC5kb3VibGVEYXRhJiZ0Lmhhc093blByb3BlcnR5KFwiZG91YmxlRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5kb3VibGVEYXRhKSlyZXR1cm5cImRvdWJsZURhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKGU9MDtlPHQuZG91YmxlRGF0YS5sZW5ndGg7KytlKWlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmRvdWJsZURhdGFbZV0pcmV0dXJuXCJkb3VibGVEYXRhOiBudW1iZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPXQudWludDY0RGF0YSYmdC5oYXNPd25Qcm9wZXJ0eShcInVpbnQ2NERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KHQudWludDY0RGF0YSkpcmV0dXJuXCJ1aW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO2ZvcihlPTA7ZTx0LnVpbnQ2NERhdGEubGVuZ3RoOysrZSlpZighKGMuaXNJbnRlZ2VyKHQudWludDY0RGF0YVtlXSl8fHQudWludDY0RGF0YVtlXSYmYy5pc0ludGVnZXIodC51aW50NjREYXRhW2VdLmxvdykmJmMuaXNJbnRlZ2VyKHQudWludDY0RGF0YVtlXS5oaWdoKSkpcmV0dXJuXCJ1aW50NjREYXRhOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifXJldHVybiBudWxsfSx0LmZyb21PYmplY3Q9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIGwub25ueC5UZW5zb3JQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlRlbnNvclByb3RvO2lmKHQuZGltcyl7aWYoIUFycmF5LmlzQXJyYXkodC5kaW1zKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5kaW1zOiBhcnJheSBleHBlY3RlZFwiKTtlLmRpbXM9W107Zm9yKHZhciBuPTA7bjx0LmRpbXMubGVuZ3RoOysrbiljLkxvbmc/KGUuZGltc1tuXT1jLkxvbmcuZnJvbVZhbHVlKHQuZGltc1tuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmRpbXNbbl0/ZS5kaW1zW25dPXBhcnNlSW50KHQuZGltc1tuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuZGltc1tuXT9lLmRpbXNbbl09dC5kaW1zW25dOlwib2JqZWN0XCI9PXR5cGVvZiB0LmRpbXNbbl0mJihlLmRpbXNbbl09bmV3IGMuTG9uZ0JpdHModC5kaW1zW25dLmxvdz4+PjAsdC5kaW1zW25dLmhpZ2g+Pj4wKS50b051bWJlcigpKX1pZihudWxsIT10LmRhdGFUeXBlJiYoZS5kYXRhVHlwZT0wfHQuZGF0YVR5cGUpLG51bGwhPXQuc2VnbWVudCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuc2VnbWVudCl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5zZWdtZW50OiBvYmplY3QgZXhwZWN0ZWRcIik7ZS5zZWdtZW50PWwub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmZyb21PYmplY3QodC5zZWdtZW50KX1pZih0LmZsb2F0RGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5mbG9hdERhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuZmxvYXREYXRhPVtdLG49MDtuPHQuZmxvYXREYXRhLmxlbmd0aDsrK24pZS5mbG9hdERhdGFbbl09TnVtYmVyKHQuZmxvYXREYXRhW25dKX1pZih0LmludDMyRGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5pbnQzMkRhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuaW50MzJEYXRhPVtdLG49MDtuPHQuaW50MzJEYXRhLmxlbmd0aDsrK24pZS5pbnQzMkRhdGFbbl09MHx0LmludDMyRGF0YVtuXX1pZih0LnN0cmluZ0RhdGEpe2lmKCFBcnJheS5pc0FycmF5KHQuc3RyaW5nRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uc3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUuc3RyaW5nRGF0YT1bXSxuPTA7bjx0LnN0cmluZ0RhdGEubGVuZ3RoOysrbilcInN0cmluZ1wiPT10eXBlb2YgdC5zdHJpbmdEYXRhW25dP2MuYmFzZTY0LmRlY29kZSh0LnN0cmluZ0RhdGFbbl0sZS5zdHJpbmdEYXRhW25dPWMubmV3QnVmZmVyKGMuYmFzZTY0Lmxlbmd0aCh0LnN0cmluZ0RhdGFbbl0pKSwwKTp0LnN0cmluZ0RhdGFbbl0ubGVuZ3RoJiYoZS5zdHJpbmdEYXRhW25dPXQuc3RyaW5nRGF0YVtuXSl9aWYodC5pbnQ2NERhdGEpe2lmKCFBcnJheS5pc0FycmF5KHQuaW50NjREYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5pbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2ZvcihlLmludDY0RGF0YT1bXSxuPTA7bjx0LmludDY0RGF0YS5sZW5ndGg7KytuKWMuTG9uZz8oZS5pbnQ2NERhdGFbbl09Yy5Mb25nLmZyb21WYWx1ZSh0LmludDY0RGF0YVtuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmludDY0RGF0YVtuXT9lLmludDY0RGF0YVtuXT1wYXJzZUludCh0LmludDY0RGF0YVtuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuaW50NjREYXRhW25dP2UuaW50NjREYXRhW25dPXQuaW50NjREYXRhW25dOlwib2JqZWN0XCI9PXR5cGVvZiB0LmludDY0RGF0YVtuXSYmKGUuaW50NjREYXRhW25dPW5ldyBjLkxvbmdCaXRzKHQuaW50NjREYXRhW25dLmxvdz4+PjAsdC5pbnQ2NERhdGFbbl0uaGlnaD4+PjApLnRvTnVtYmVyKCkpfWlmKG51bGwhPXQubmFtZSYmKGUubmFtZT1TdHJpbmcodC5uYW1lKSksbnVsbCE9dC5kb2NTdHJpbmcmJihlLmRvY1N0cmluZz1TdHJpbmcodC5kb2NTdHJpbmcpKSxudWxsIT10LnJhd0RhdGEmJihcInN0cmluZ1wiPT10eXBlb2YgdC5yYXdEYXRhP2MuYmFzZTY0LmRlY29kZSh0LnJhd0RhdGEsZS5yYXdEYXRhPWMubmV3QnVmZmVyKGMuYmFzZTY0Lmxlbmd0aCh0LnJhd0RhdGEpKSwwKTp0LnJhd0RhdGEubGVuZ3RoJiYoZS5yYXdEYXRhPXQucmF3RGF0YSkpLHQuZXh0ZXJuYWxEYXRhKXtpZighQXJyYXkuaXNBcnJheSh0LmV4dGVybmFsRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5leHRlcm5hbERhdGE9W10sbj0wO248dC5leHRlcm5hbERhdGEubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuZXh0ZXJuYWxEYXRhW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmV4dGVybmFsRGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO2UuZXh0ZXJuYWxEYXRhW25dPWwub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QodC5leHRlcm5hbERhdGFbbl0pfX1zd2l0Y2godC5kYXRhTG9jYXRpb24pe2Nhc2VcIkRFRkFVTFRcIjpjYXNlIDA6ZS5kYXRhTG9jYXRpb249MDticmVhaztjYXNlXCJFWFRFUk5BTFwiOmNhc2UgMTplLmRhdGFMb2NhdGlvbj0xfWlmKHQuZG91YmxlRGF0YSl7aWYoIUFycmF5LmlzQXJyYXkodC5kb3VibGVEYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5kb3VibGVEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IoZS5kb3VibGVEYXRhPVtdLG49MDtuPHQuZG91YmxlRGF0YS5sZW5ndGg7KytuKWUuZG91YmxlRGF0YVtuXT1OdW1iZXIodC5kb3VibGVEYXRhW25dKX1pZih0LnVpbnQ2NERhdGEpe2lmKCFBcnJheS5pc0FycmF5KHQudWludDY0RGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8udWludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKGUudWludDY0RGF0YT1bXSxuPTA7bjx0LnVpbnQ2NERhdGEubGVuZ3RoOysrbiljLkxvbmc/KGUudWludDY0RGF0YVtuXT1jLkxvbmcuZnJvbVZhbHVlKHQudWludDY0RGF0YVtuXSkpLnVuc2lnbmVkPSEwOlwic3RyaW5nXCI9PXR5cGVvZiB0LnVpbnQ2NERhdGFbbl0/ZS51aW50NjREYXRhW25dPXBhcnNlSW50KHQudWludDY0RGF0YVtuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQudWludDY0RGF0YVtuXT9lLnVpbnQ2NERhdGFbbl09dC51aW50NjREYXRhW25dOlwib2JqZWN0XCI9PXR5cGVvZiB0LnVpbnQ2NERhdGFbbl0mJihlLnVpbnQ2NERhdGFbbl09bmV3IGMuTG9uZ0JpdHModC51aW50NjREYXRhW25dLmxvdz4+PjAsdC51aW50NjREYXRhW25dLmhpZ2g+Pj4wKS50b051bWJlcighMCkpfXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLmRpbXM9W10sbi5mbG9hdERhdGE9W10sbi5pbnQzMkRhdGE9W10sbi5zdHJpbmdEYXRhPVtdLG4uaW50NjREYXRhPVtdLG4uZG91YmxlRGF0YT1bXSxuLnVpbnQ2NERhdGE9W10sbi5leHRlcm5hbERhdGE9W10pLGUuZGVmYXVsdHMmJihuLmRhdGFUeXBlPTAsbi5zZWdtZW50PW51bGwsbi5uYW1lPVwiXCIsZS5ieXRlcz09PVN0cmluZz9uLnJhd0RhdGE9XCJcIjoobi5yYXdEYXRhPVtdLGUuYnl0ZXMhPT1BcnJheSYmKG4ucmF3RGF0YT1jLm5ld0J1ZmZlcihuLnJhd0RhdGEpKSksbi5kb2NTdHJpbmc9XCJcIixuLmRhdGFMb2NhdGlvbj1lLmVudW1zPT09U3RyaW5nP1wiREVGQVVMVFwiOjApLHQuZGltcyYmdC5kaW1zLmxlbmd0aCl7bi5kaW1zPVtdO2Zvcih2YXIgcj0wO3I8dC5kaW1zLmxlbmd0aDsrK3IpXCJudW1iZXJcIj09dHlwZW9mIHQuZGltc1tyXT9uLmRpbXNbcl09ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5kaW1zW3JdKTp0LmRpbXNbcl06bi5kaW1zW3JdPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuZGltc1tyXSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmRpbXNbcl0ubG93Pj4+MCx0LmRpbXNbcl0uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5kaW1zW3JdfWlmKG51bGwhPXQuZGF0YVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmKG4uZGF0YVR5cGU9dC5kYXRhVHlwZSksbnVsbCE9dC5zZWdtZW50JiZ0Lmhhc093blByb3BlcnR5KFwic2VnbWVudFwiKSYmKG4uc2VnbWVudD1sLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC50b09iamVjdCh0LnNlZ21lbnQsZSkpLHQuZmxvYXREYXRhJiZ0LmZsb2F0RGF0YS5sZW5ndGgpZm9yKG4uZmxvYXREYXRhPVtdLHI9MDtyPHQuZmxvYXREYXRhLmxlbmd0aDsrK3Ipbi5mbG9hdERhdGFbcl09ZS5qc29uJiYhaXNGaW5pdGUodC5mbG9hdERhdGFbcl0pP1N0cmluZyh0LmZsb2F0RGF0YVtyXSk6dC5mbG9hdERhdGFbcl07aWYodC5pbnQzMkRhdGEmJnQuaW50MzJEYXRhLmxlbmd0aClmb3Iobi5pbnQzMkRhdGE9W10scj0wO3I8dC5pbnQzMkRhdGEubGVuZ3RoOysrciluLmludDMyRGF0YVtyXT10LmludDMyRGF0YVtyXTtpZih0LnN0cmluZ0RhdGEmJnQuc3RyaW5nRGF0YS5sZW5ndGgpZm9yKG4uc3RyaW5nRGF0YT1bXSxyPTA7cjx0LnN0cmluZ0RhdGEubGVuZ3RoOysrciluLnN0cmluZ0RhdGFbcl09ZS5ieXRlcz09PVN0cmluZz9jLmJhc2U2NC5lbmNvZGUodC5zdHJpbmdEYXRhW3JdLDAsdC5zdHJpbmdEYXRhW3JdLmxlbmd0aCk6ZS5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQuc3RyaW5nRGF0YVtyXSk6dC5zdHJpbmdEYXRhW3JdO2lmKHQuaW50NjREYXRhJiZ0LmludDY0RGF0YS5sZW5ndGgpZm9yKG4uaW50NjREYXRhPVtdLHI9MDtyPHQuaW50NjREYXRhLmxlbmd0aDsrK3IpXCJudW1iZXJcIj09dHlwZW9mIHQuaW50NjREYXRhW3JdP24uaW50NjREYXRhW3JdPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQuaW50NjREYXRhW3JdKTp0LmludDY0RGF0YVtyXTpuLmludDY0RGF0YVtyXT1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LmludDY0RGF0YVtyXSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmludDY0RGF0YVtyXS5sb3c+Pj4wLHQuaW50NjREYXRhW3JdLmhpZ2g+Pj4wKS50b051bWJlcigpOnQuaW50NjREYXRhW3JdO2lmKG51bGwhPXQubmFtZSYmdC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9dC5uYW1lKSxudWxsIT10LnJhd0RhdGEmJnQuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpJiYobi5yYXdEYXRhPWUuYnl0ZXM9PT1TdHJpbmc/Yy5iYXNlNjQuZW5jb2RlKHQucmF3RGF0YSwwLHQucmF3RGF0YS5sZW5ndGgpOmUuYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LnJhd0RhdGEpOnQucmF3RGF0YSksdC5kb3VibGVEYXRhJiZ0LmRvdWJsZURhdGEubGVuZ3RoKWZvcihuLmRvdWJsZURhdGE9W10scj0wO3I8dC5kb3VibGVEYXRhLmxlbmd0aDsrK3Ipbi5kb3VibGVEYXRhW3JdPWUuanNvbiYmIWlzRmluaXRlKHQuZG91YmxlRGF0YVtyXSk/U3RyaW5nKHQuZG91YmxlRGF0YVtyXSk6dC5kb3VibGVEYXRhW3JdO2lmKHQudWludDY0RGF0YSYmdC51aW50NjREYXRhLmxlbmd0aClmb3Iobi51aW50NjREYXRhPVtdLHI9MDtyPHQudWludDY0RGF0YS5sZW5ndGg7KytyKVwibnVtYmVyXCI9PXR5cGVvZiB0LnVpbnQ2NERhdGFbcl0/bi51aW50NjREYXRhW3JdPWUubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKHQudWludDY0RGF0YVtyXSk6dC51aW50NjREYXRhW3JdOm4udWludDY0RGF0YVtyXT1lLmxvbmdzPT09U3RyaW5nP2MuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LnVpbnQ2NERhdGFbcl0pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC51aW50NjREYXRhW3JdLmxvdz4+PjAsdC51aW50NjREYXRhW3JdLmhpZ2g+Pj4wKS50b051bWJlcighMCk6dC51aW50NjREYXRhW3JdO2lmKG51bGwhPXQuZG9jU3RyaW5nJiZ0Lmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9dC5kb2NTdHJpbmcpLHQuZXh0ZXJuYWxEYXRhJiZ0LmV4dGVybmFsRGF0YS5sZW5ndGgpZm9yKG4uZXh0ZXJuYWxEYXRhPVtdLHI9MDtyPHQuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK3Ipbi5leHRlcm5hbERhdGFbcl09bC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QodC5leHRlcm5hbERhdGFbcl0sZSk7cmV0dXJuIG51bGwhPXQuZGF0YUxvY2F0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGF0YUxvY2F0aW9uXCIpJiYobi5kYXRhTG9jYXRpb249ZS5lbnVtcz09PVN0cmluZz9sLm9ubnguVGVuc29yUHJvdG8uRGF0YUxvY2F0aW9uW3QuZGF0YUxvY2F0aW9uXTp0LmRhdGFMb2NhdGlvbiksbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuRGF0YVR5cGU9ZnVuY3Rpb24oKXt2YXIgdD17fSxlPU9iamVjdC5jcmVhdGUodCk7cmV0dXJuIGVbdFswXT1cIlVOREVGSU5FRFwiXT0wLGVbdFsxXT1cIkZMT0FUXCJdPTEsZVt0WzJdPVwiVUlOVDhcIl09MixlW3RbM109XCJJTlQ4XCJdPTMsZVt0WzRdPVwiVUlOVDE2XCJdPTQsZVt0WzVdPVwiSU5UMTZcIl09NSxlW3RbNl09XCJJTlQzMlwiXT02LGVbdFs3XT1cIklOVDY0XCJdPTcsZVt0WzhdPVwiU1RSSU5HXCJdPTgsZVt0WzldPVwiQk9PTFwiXT05LGVbdFsxMF09XCJGTE9BVDE2XCJdPTEwLGVbdFsxMV09XCJET1VCTEVcIl09MTEsZVt0WzEyXT1cIlVJTlQzMlwiXT0xMixlW3RbMTNdPVwiVUlOVDY0XCJdPTEzLGVbdFsxNF09XCJDT01QTEVYNjRcIl09MTQsZVt0WzE1XT1cIkNPTVBMRVgxMjhcIl09MTUsZVt0WzE2XT1cIkJGTE9BVDE2XCJdPTE2LGV9KCksdC5TZWdtZW50PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmJlZ2luPWMuTG9uZz9jLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQucHJvdG90eXBlLmVuZD1jLkxvbmc/Yy5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCx0LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LHQuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuYmVnaW4mJnQuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmZS51aW50MzIoOCkuaW50NjQodC5iZWdpbiksbnVsbCE9dC5lbmQmJnQuaGFzT3duUHJvcGVydHkoXCJlbmRcIikmJmUudWludDMyKDE2KS5pbnQ2NCh0LmVuZCksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQ7dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5iZWdpbj10LmludDY0KCk7YnJlYWs7Y2FzZSAyOnIuZW5kPXQuaW50NjQoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe3JldHVyblwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dD9cIm9iamVjdCBleHBlY3RlZFwiOm51bGwhPXQuYmVnaW4mJnQuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmIShjLmlzSW50ZWdlcih0LmJlZ2luKXx8dC5iZWdpbiYmYy5pc0ludGVnZXIodC5iZWdpbi5sb3cpJiZjLmlzSW50ZWdlcih0LmJlZ2luLmhpZ2gpKT9cImJlZ2luOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjpudWxsIT10LmVuZCYmdC5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSYmIShjLmlzSW50ZWdlcih0LmVuZCl8fHQuZW5kJiZjLmlzSW50ZWdlcih0LmVuZC5sb3cpJiZjLmlzSW50ZWdlcih0LmVuZC5oaWdoKSk/XCJlbmQ6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQpcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5UZW5zb3JQcm90by5TZWdtZW50O3JldHVybiBudWxsIT10LmJlZ2luJiYoYy5Mb25nPyhlLmJlZ2luPWMuTG9uZy5mcm9tVmFsdWUodC5iZWdpbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiB0LmJlZ2luP2UuYmVnaW49cGFyc2VJbnQodC5iZWdpbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIHQuYmVnaW4/ZS5iZWdpbj10LmJlZ2luOlwib2JqZWN0XCI9PXR5cGVvZiB0LmJlZ2luJiYoZS5iZWdpbj1uZXcgYy5Mb25nQml0cyh0LmJlZ2luLmxvdz4+PjAsdC5iZWdpbi5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLG51bGwhPXQuZW5kJiYoYy5Mb25nPyhlLmVuZD1jLkxvbmcuZnJvbVZhbHVlKHQuZW5kKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuZW5kP2UuZW5kPXBhcnNlSW50KHQuZW5kLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5lbmQ/ZS5lbmQ9dC5lbmQ6XCJvYmplY3RcIj09dHlwZW9mIHQuZW5kJiYoZS5lbmQ9bmV3IGMuTG9uZ0JpdHModC5lbmQubG93Pj4+MCx0LmVuZC5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307aWYoZS5kZWZhdWx0cyl7aWYoYy5Mb25nKXt2YXIgcj1uZXcgYy5Mb25nKDAsMCwhMSk7bi5iZWdpbj1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyfWVsc2Ugbi5iZWdpbj1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7Yy5Mb25nPyhyPW5ldyBjLkxvbmcoMCwwLCExKSxuLmVuZD1lLmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTplLmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyKTpuLmVuZD1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjB9cmV0dXJuIG51bGwhPXQuYmVnaW4mJnQuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiB0LmJlZ2luP24uYmVnaW49ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5iZWdpbik6dC5iZWdpbjpuLmJlZ2luPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuYmVnaW4pOmUubG9uZ3M9PT1OdW1iZXI/bmV3IGMuTG9uZ0JpdHModC5iZWdpbi5sb3c+Pj4wLHQuYmVnaW4uaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5iZWdpbiksbnVsbCE9dC5lbmQmJnQuaGFzT3duUHJvcGVydHkoXCJlbmRcIikmJihcIm51bWJlclwiPT10eXBlb2YgdC5lbmQ/bi5lbmQ9ZS5sb25ncz09PVN0cmluZz9TdHJpbmcodC5lbmQpOnQuZW5kOm4uZW5kPWUubG9uZ3M9PT1TdHJpbmc/Yy5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQuZW5kKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQuZW5kLmxvdz4+PjAsdC5lbmQuaGlnaD4+PjApLnRvTnVtYmVyKCk6dC5lbmQpLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLHQuRGF0YUxvY2F0aW9uPWZ1bmN0aW9uKCl7dmFyIHQ9e30sZT1PYmplY3QuY3JlYXRlKHQpO3JldHVybiBlW3RbMF09XCJERUZBVUxUXCJdPTAsZVt0WzFdPVwiRVhURVJOQUxcIl09MSxlfSgpLHR9KCksby5UZW5zb3JTaGFwZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmRpbT1bXSx0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmRpbT1jLmVtcHR5QXJyYXksdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe2lmKGV8fChlPXUuY3JlYXRlKCkpLG51bGwhPXQuZGltJiZ0LmRpbS5sZW5ndGgpZm9yKHZhciBuPTA7bjx0LmRpbS5sZW5ndGg7KytuKWwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5lbmNvZGUodC5kaW1bbl0sZS51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5UZW5zb3JTaGFwZVByb3RvO3QucG9zPG47KXt2YXIgaT10LnVpbnQzMigpO2k+Pj4zPT0xPyhyLmRpbSYmci5kaW0ubGVuZ3RofHwoci5kaW09W10pLHIuZGltLnB1c2gobC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmRlY29kZSh0LHQudWludDMyKCkpKSk6dC5za2lwVHlwZSg3JmkpfXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRpbSYmdC5oYXNPd25Qcm9wZXJ0eShcImRpbVwiKSl7aWYoIUFycmF5LmlzQXJyYXkodC5kaW0pKXJldHVyblwiZGltOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgZT0wO2U8dC5kaW0ubGVuZ3RoOysrZSl7dmFyIG49bC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnZlcmlmeSh0LmRpbVtlXSk7aWYobilyZXR1cm5cImRpbS5cIitufX1yZXR1cm4gbnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguVGVuc29yU2hhcGVQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlRlbnNvclNoYXBlUHJvdG87aWYodC5kaW0pe2lmKCFBcnJheS5pc0FycmF5KHQuZGltKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JTaGFwZVByb3RvLmRpbTogYXJyYXkgZXhwZWN0ZWRcIik7ZS5kaW09W107Zm9yKHZhciBuPTA7bjx0LmRpbS5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdC5kaW1bbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IG9iamVjdCBleHBlY3RlZFwiKTtlLmRpbVtuXT1sLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZnJvbU9iamVjdCh0LmRpbVtuXSl9fXJldHVybiBlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKChlLmFycmF5c3x8ZS5kZWZhdWx0cykmJihuLmRpbT1bXSksdC5kaW0mJnQuZGltLmxlbmd0aCl7bi5kaW09W107Zm9yKHZhciByPTA7cjx0LmRpbS5sZW5ndGg7KytyKW4uZGltW3JdPWwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi50b09iamVjdCh0LmRpbVtyXSxlKX1yZXR1cm4gbn0sdC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxhLnV0aWwudG9KU09OT3B0aW9ucyl9LHQuRGltZW5zaW9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9dmFyIGU7cmV0dXJuIHQucHJvdG90eXBlLmRpbVZhbHVlPWMuTG9uZz9jLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLHQucHJvdG90eXBlLmRpbVBhcmFtPVwiXCIsdC5wcm90b3R5cGUuZGVub3RhdGlvbj1cIlwiLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcInZhbHVlXCIse2dldDpjLm9uZU9mR2V0dGVyKGU9W1wiZGltVmFsdWVcIixcImRpbVBhcmFtXCJdKSxzZXQ6Yy5vbmVPZlNldHRlcihlKX0pLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC5kaW1WYWx1ZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpJiZlLnVpbnQzMig4KS5pbnQ2NCh0LmRpbVZhbHVlKSxudWxsIT10LmRpbVBhcmFtJiZ0Lmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikmJmUudWludDMyKDE4KS5zdHJpbmcodC5kaW1QYXJhbSksbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmZS51aW50MzIoMjYpLnN0cmluZyh0LmRlbm90YXRpb24pLGV9LHQuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlKHQsZSkubGRlbGltKCl9LHQuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7dCBpbnN0YW5jZW9mIHN8fCh0PXMuY3JlYXRlKHQpKTtmb3IodmFyIG49dm9pZCAwPT09ZT90Lmxlbjp0LnBvcytlLHI9bmV3IGwub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbjt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmRpbVZhbHVlPXQuaW50NjQoKTticmVhaztjYXNlIDI6ci5kaW1QYXJhbT10LnN0cmluZygpO2JyZWFrO2Nhc2UgMzpyLmRlbm90YXRpb249dC5zdHJpbmcoKTticmVhaztkZWZhdWx0OnQuc2tpcFR5cGUoNyZpKX19cmV0dXJuIHJ9LHQuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygc3x8KHQ9bmV3IHModCkpLHRoaXMuZGVjb2RlKHQsdC51aW50MzIoKSl9LHQudmVyaWZ5PWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dClyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO3ZhciBlPXt9O2lmKG51bGwhPXQuZGltVmFsdWUmJnQuaGFzT3duUHJvcGVydHkoXCJkaW1WYWx1ZVwiKSYmKGUudmFsdWU9MSwhKGMuaXNJbnRlZ2VyKHQuZGltVmFsdWUpfHx0LmRpbVZhbHVlJiZjLmlzSW50ZWdlcih0LmRpbVZhbHVlLmxvdykmJmMuaXNJbnRlZ2VyKHQuZGltVmFsdWUuaGlnaCkpKSlyZXR1cm5cImRpbVZhbHVlOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtpZihudWxsIT10LmRpbVBhcmFtJiZ0Lmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikpe2lmKDE9PT1lLnZhbHVlKXJldHVyblwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO2lmKGUudmFsdWU9MSwhYy5pc1N0cmluZyh0LmRpbVBhcmFtKSlyZXR1cm5cImRpbVBhcmFtOiBzdHJpbmcgZXhwZWN0ZWRcIn1yZXR1cm4gbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmIWMuaXNTdHJpbmcodC5kZW5vdGF0aW9uKT9cImRlbm90YXRpb246IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb247cmV0dXJuIG51bGwhPXQuZGltVmFsdWUmJihjLkxvbmc/KGUuZGltVmFsdWU9Yy5Mb25nLmZyb21WYWx1ZSh0LmRpbVZhbHVlKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQuZGltVmFsdWU/ZS5kaW1WYWx1ZT1wYXJzZUludCh0LmRpbVZhbHVlLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC5kaW1WYWx1ZT9lLmRpbVZhbHVlPXQuZGltVmFsdWU6XCJvYmplY3RcIj09dHlwZW9mIHQuZGltVmFsdWUmJihlLmRpbVZhbHVlPW5ldyBjLkxvbmdCaXRzKHQuZGltVmFsdWUubG93Pj4+MCx0LmRpbVZhbHVlLmhpZ2g+Pj4wKS50b051bWJlcigpKSksbnVsbCE9dC5kaW1QYXJhbSYmKGUuZGltUGFyYW09U3RyaW5nKHQuZGltUGFyYW0pKSxudWxsIT10LmRlbm90YXRpb24mJihlLmRlbm90YXRpb249U3RyaW5nKHQuZGVub3RhdGlvbikpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307cmV0dXJuIGUuZGVmYXVsdHMmJihuLmRlbm90YXRpb249XCJcIiksbnVsbCE9dC5kaW1WYWx1ZSYmdC5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIHQuZGltVmFsdWU/bi5kaW1WYWx1ZT1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LmRpbVZhbHVlKTp0LmRpbVZhbHVlOm4uZGltVmFsdWU9ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC5kaW1WYWx1ZSk6ZS5sb25ncz09PU51bWJlcj9uZXcgYy5Mb25nQml0cyh0LmRpbVZhbHVlLmxvdz4+PjAsdC5kaW1WYWx1ZS5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LmRpbVZhbHVlLGUub25lb2ZzJiYobi52YWx1ZT1cImRpbVZhbHVlXCIpKSxudWxsIT10LmRpbVBhcmFtJiZ0Lmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikmJihuLmRpbVBhcmFtPXQuZGltUGFyYW0sZS5vbmVvZnMmJihuLnZhbHVlPVwiZGltUGFyYW1cIikpLG51bGwhPXQuZGVub3RhdGlvbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJihuLmRlbm90YXRpb249dC5kZW5vdGF0aW9uKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdH0oKSx0fSgpLG8uVHlwZVByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9dmFyIGU7cmV0dXJuIHQucHJvdG90eXBlLnRlbnNvclR5cGU9bnVsbCx0LnByb3RvdHlwZS5kZW5vdGF0aW9uPVwiXCIsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwidmFsdWVcIix7Z2V0OmMub25lT2ZHZXR0ZXIoZT1bXCJ0ZW5zb3JUeXBlXCJdKSxzZXQ6Yy5vbmVPZlNldHRlcihlKX0pLHQuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0sdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8KGU9dS5jcmVhdGUoKSksbnVsbCE9dC50ZW5zb3JUeXBlJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSYmbC5vbm54LlR5cGVQcm90by5UZW5zb3IuZW5jb2RlKHQudGVuc29yVHlwZSxlLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT10LmRlbm90YXRpb24mJnQuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiZlLnVpbnQzMig1MCkuc3RyaW5nKHQuZGVub3RhdGlvbiksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlR5cGVQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLnRlbnNvclR5cGU9bC5vbm54LlR5cGVQcm90by5UZW5zb3IuZGVjb2RlKHQsdC51aW50MzIoKSk7YnJlYWs7Y2FzZSA2OnIuZGVub3RhdGlvbj10LnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9dC50ZW5zb3JUeXBlJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSl7dmFyIGU9bC5vbm54LlR5cGVQcm90by5UZW5zb3IudmVyaWZ5KHQudGVuc29yVHlwZSk7aWYoZSlyZXR1cm5cInRlbnNvclR5cGUuXCIrZX1yZXR1cm4gbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmIWMuaXNTdHJpbmcodC5kZW5vdGF0aW9uKT9cImRlbm90YXRpb246IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlR5cGVQcm90bylyZXR1cm4gdDt2YXIgZT1uZXcgbC5vbm54LlR5cGVQcm90bztpZihudWxsIT10LnRlbnNvclR5cGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0LnRlbnNvclR5cGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLnRlbnNvclR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTtlLnRlbnNvclR5cGU9bC5vbm54LlR5cGVQcm90by5UZW5zb3IuZnJvbU9iamVjdCh0LnRlbnNvclR5cGUpfXJldHVybiBudWxsIT10LmRlbm90YXRpb24mJihlLmRlbm90YXRpb249U3RyaW5nKHQuZGVub3RhdGlvbikpLGV9LHQudG9PYmplY3Q9ZnVuY3Rpb24odCxlKXtlfHwoZT17fSk7dmFyIG49e307cmV0dXJuIGUuZGVmYXVsdHMmJihuLmRlbm90YXRpb249XCJcIiksbnVsbCE9dC50ZW5zb3JUeXBlJiZ0Lmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSYmKG4udGVuc29yVHlwZT1sLm9ubnguVHlwZVByb3RvLlRlbnNvci50b09iamVjdCh0LnRlbnNvclR5cGUsZSksZS5vbmVvZnMmJihuLnZhbHVlPVwidGVuc29yVHlwZVwiKSksbnVsbCE9dC5kZW5vdGF0aW9uJiZ0Lmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSYmKG4uZGVub3RhdGlvbj10LmRlbm90YXRpb24pLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0LlRlbnNvcj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7aWYodClmb3IodmFyIGU9T2JqZWN0LmtleXModCksbj0wO248ZS5sZW5ndGg7KytuKW51bGwhPXRbZVtuXV0mJih0aGlzW2Vbbl1dPXRbZVtuXV0pfXJldHVybiB0LnByb3RvdHlwZS5lbGVtVHlwZT0wLHQucHJvdG90eXBlLnNoYXBlPW51bGwsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmVsZW1UeXBlJiZ0Lmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJmUudWludDMyKDgpLmludDMyKHQuZWxlbVR5cGUpLG51bGwhPXQuc2hhcGUmJnQuaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSYmbC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZW5jb2RlKHQuc2hhcGUsZS51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54LlR5cGVQcm90by5UZW5zb3I7dC5wb3M8bjspe3ZhciBpPXQudWludDMyKCk7c3dpdGNoKGk+Pj4zKXtjYXNlIDE6ci5lbGVtVHlwZT10LmludDMyKCk7YnJlYWs7Y2FzZSAyOnIuc2hhcGU9bC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGVjb2RlKHQsdC51aW50MzIoKSk7YnJlYWs7ZGVmYXVsdDp0LnNraXBUeXBlKDcmaSl9fXJldHVybiByfSx0LmRlY29kZURlbGltaXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHN8fCh0PW5ldyBzKHQpKSx0aGlzLmRlY29kZSh0LHQudWludDMyKCkpfSx0LnZlcmlmeT1mdW5jdGlvbih0KXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT10LmVsZW1UeXBlJiZ0Lmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJiFjLmlzSW50ZWdlcih0LmVsZW1UeXBlKSlyZXR1cm5cImVsZW1UeXBlOiBpbnRlZ2VyIGV4cGVjdGVkXCI7aWYobnVsbCE9dC5zaGFwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpKXt2YXIgZT1sLm9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnkodC5zaGFwZSk7aWYoZSlyZXR1cm5cInNoYXBlLlwiK2V9cmV0dXJuIG51bGx9LHQuZnJvbU9iamVjdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgbC5vbm54LlR5cGVQcm90by5UZW5zb3IpcmV0dXJuIHQ7dmFyIGU9bmV3IGwub25ueC5UeXBlUHJvdG8uVGVuc29yO2lmKG51bGwhPXQuZWxlbVR5cGUmJihlLmVsZW1UeXBlPTB8dC5lbGVtVHlwZSksbnVsbCE9dC5zaGFwZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQuc2hhcGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLlRlbnNvci5zaGFwZTogb2JqZWN0IGV4cGVjdGVkXCIpO2Uuc2hhcGU9bC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZnJvbU9iamVjdCh0LnNoYXBlKX1yZXR1cm4gZX0sdC50b09iamVjdD1mdW5jdGlvbih0LGUpe2V8fChlPXt9KTt2YXIgbj17fTtyZXR1cm4gZS5kZWZhdWx0cyYmKG4uZWxlbVR5cGU9MCxuLnNoYXBlPW51bGwpLG51bGwhPXQuZWxlbVR5cGUmJnQuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSYmKG4uZWxlbVR5cGU9dC5lbGVtVHlwZSksbnVsbCE9dC5zaGFwZSYmdC5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpJiYobi5zaGFwZT1sLm9ubnguVGVuc29yU2hhcGVQcm90by50b09iamVjdCh0LnNoYXBlLGUpKSxufSx0LnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLGEudXRpbC50b0pTT05PcHRpb25zKX0sdH0oKSx0fSgpLG8uT3BlcmF0b3JTZXRJZFByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0KWZvcih2YXIgZT1PYmplY3Qua2V5cyh0KSxuPTA7bjxlLmxlbmd0aDsrK24pbnVsbCE9dFtlW25dXSYmKHRoaXNbZVtuXV09dFtlW25dXSl9cmV0dXJuIHQucHJvdG90eXBlLmRvbWFpbj1cIlwiLHQucHJvdG90eXBlLnZlcnNpb249Yy5Mb25nP2MuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsdC5jcmVhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LmVuY29kZT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHwoZT11LmNyZWF0ZSgpKSxudWxsIT10LmRvbWFpbiYmdC5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmZS51aW50MzIoMTApLnN0cmluZyh0LmRvbWFpbiksbnVsbCE9dC52ZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSYmZS51aW50MzIoMTYpLmludDY0KHQudmVyc2lvbiksZX0sdC5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbmNvZGUodCxlKS5sZGVsaW0oKX0sdC5kZWNvZGU9ZnVuY3Rpb24odCxlKXt0IGluc3RhbmNlb2Ygc3x8KHQ9cy5jcmVhdGUodCkpO2Zvcih2YXIgbj12b2lkIDA9PT1lP3QubGVuOnQucG9zK2Uscj1uZXcgbC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bzt0LnBvczxuOyl7dmFyIGk9dC51aW50MzIoKTtzd2l0Y2goaT4+PjMpe2Nhc2UgMTpyLmRvbWFpbj10LnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnZlcnNpb249dC5pbnQ2NCgpO2JyZWFrO2RlZmF1bHQ6dC5za2lwVHlwZSg3JmkpfX1yZXR1cm4gcn0sdC5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBzfHwodD1uZXcgcyh0KSksdGhpcy5kZWNvZGUodCx0LnVpbnQzMigpKX0sdC52ZXJpZnk9ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10P1wib2JqZWN0IGV4cGVjdGVkXCI6bnVsbCE9dC5kb21haW4mJnQuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJiFjLmlzU3RyaW5nKHQuZG9tYWluKT9cImRvbWFpbjogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbCE9dC52ZXJzaW9uJiZ0Lmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSYmIShjLmlzSW50ZWdlcih0LnZlcnNpb24pfHx0LnZlcnNpb24mJmMuaXNJbnRlZ2VyKHQudmVyc2lvbi5sb3cpJiZjLmlzSW50ZWdlcih0LnZlcnNpb24uaGlnaCkpP1widmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI6bnVsbH0sdC5mcm9tT2JqZWN0PWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBsLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvKXJldHVybiB0O3ZhciBlPW5ldyBsLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvO3JldHVybiBudWxsIT10LmRvbWFpbiYmKGUuZG9tYWluPVN0cmluZyh0LmRvbWFpbikpLG51bGwhPXQudmVyc2lvbiYmKGMuTG9uZz8oZS52ZXJzaW9uPWMuTG9uZy5mcm9tVmFsdWUodC52ZXJzaW9uKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIHQudmVyc2lvbj9lLnZlcnNpb249cGFyc2VJbnQodC52ZXJzaW9uLDEwKTpcIm51bWJlclwiPT10eXBlb2YgdC52ZXJzaW9uP2UudmVyc2lvbj10LnZlcnNpb246XCJvYmplY3RcIj09dHlwZW9mIHQudmVyc2lvbiYmKGUudmVyc2lvbj1uZXcgYy5Mb25nQml0cyh0LnZlcnNpb24ubG93Pj4+MCx0LnZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxlfSx0LnRvT2JqZWN0PWZ1bmN0aW9uKHQsZSl7ZXx8KGU9e30pO3ZhciBuPXt9O2lmKGUuZGVmYXVsdHMpaWYobi5kb21haW49XCJcIixjLkxvbmcpe3ZhciByPW5ldyBjLkxvbmcoMCwwLCExKTtuLnZlcnNpb249ZS5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6ZS5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cn1lbHNlIG4udmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7cmV0dXJuIG51bGwhPXQuZG9tYWluJiZ0Lmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYobi5kb21haW49dC5kb21haW4pLG51bGwhPXQudmVyc2lvbiYmdC5oYXNPd25Qcm9wZXJ0eShcInZlcnNpb25cIikmJihcIm51bWJlclwiPT10eXBlb2YgdC52ZXJzaW9uP24udmVyc2lvbj1lLmxvbmdzPT09U3RyaW5nP1N0cmluZyh0LnZlcnNpb24pOnQudmVyc2lvbjpuLnZlcnNpb249ZS5sb25ncz09PVN0cmluZz9jLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodC52ZXJzaW9uKTplLmxvbmdzPT09TnVtYmVyP25ldyBjLkxvbmdCaXRzKHQudmVyc2lvbi5sb3c+Pj4wLHQudmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKTp0LnZlcnNpb24pLG59LHQucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsYS51dGlsLnRvSlNPTk9wdGlvbnMpfSx0fSgpLG8pLHQuZXhwb3J0cz1sfSwyMTAwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9big5NDgyKX0sOTQ4MjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9ZTtmdW5jdGlvbiBpKCl7ci51dGlsLl9jb25maWd1cmUoKSxyLldyaXRlci5fY29uZmlndXJlKHIuQnVmZmVyV3JpdGVyKSxyLlJlYWRlci5fY29uZmlndXJlKHIuQnVmZmVyUmVhZGVyKX1yLmJ1aWxkPVwibWluaW1hbFwiLHIuV3JpdGVyPW4oMTE3Myksci5CdWZmZXJXcml0ZXI9bigzMTU1KSxyLlJlYWRlcj1uKDE0MDgpLHIuQnVmZmVyUmVhZGVyPW4oNTkzKSxyLnV0aWw9big5NjkzKSxyLnJwYz1uKDU5OTQpLHIucm9vdHM9big1MDU0KSxyLmNvbmZpZ3VyZT1pLGkoKX0sMTQwODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXU7dmFyIHIsaT1uKDk2OTMpLG89aS5Mb25nQml0cyxhPWkudXRmODtmdW5jdGlvbiBzKHQsZSl7cmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiK3QucG9zK1wiICsgXCIrKGV8fDEpK1wiID4gXCIrdC5sZW4pfWZ1bmN0aW9uIHUodCl7dGhpcy5idWY9dCx0aGlzLnBvcz0wLHRoaXMubGVuPXQubGVuZ3RofXZhciBjLGw9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIG5ldyB1KHQpO3Rocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIil9OmZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIG5ldyB1KHQpO3Rocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIil9LHA9ZnVuY3Rpb24oKXtyZXR1cm4gaS5CdWZmZXI/ZnVuY3Rpb24odCl7cmV0dXJuKHUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBpLkJ1ZmZlci5pc0J1ZmZlcih0KT9uZXcgcih0KTpsKHQpfSkodCl9Omx9O2Z1bmN0aW9uIGYoKXt2YXIgdD1uZXcgbygwLDApLGU9MDtpZighKHRoaXMubGVuLXRoaXMucG9zPjQpKXtmb3IoO2U8MzsrK2Upe2lmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBzKHRoaXMpO2lmKHQubG89KHQubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIHR9cmV0dXJuIHQubG89KHQubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvcysrXSk8PDcqZSk+Pj4wLHR9Zm9yKDtlPDQ7KytlKWlmKHQubG89KHQubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIHQ7aWYodC5sbz0odC5sb3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDI4KT4+PjAsdC5oaT0odC5oaXwoMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk+PjQpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIHQ7aWYoZT0wLHRoaXMubGVuLXRoaXMucG9zPjQpe2Zvcig7ZTw1OysrZSlpZih0LmhpPSh0LmhpfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8NyplKzMpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIHR9ZWxzZSBmb3IoO2U8NTsrK2Upe2lmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBzKHRoaXMpO2lmKHQuaGk9KHQuaGl8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KmUrMyk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gdH10aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpfWZ1bmN0aW9uIGQodCxlKXtyZXR1cm4odFtlLTRdfHRbZS0zXTw8OHx0W2UtMl08PDE2fHRbZS0xXTw8MjQpPj4+MH1mdW5jdGlvbiBoKCl7aWYodGhpcy5wb3MrOD50aGlzLmxlbil0aHJvdyBzKHRoaXMsOCk7cmV0dXJuIG5ldyBvKGQodGhpcy5idWYsdGhpcy5wb3MrPTQpLGQodGhpcy5idWYsdGhpcy5wb3MrPTQpKX11LmNyZWF0ZT1wKCksdS5wcm90b3R5cGUuX3NsaWNlPWkuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5fHxpLkFycmF5LnByb3RvdHlwZS5zbGljZSx1LnByb3RvdHlwZS51aW50MzI9KGM9NDI5NDk2NzI5NSxmdW5jdGlvbigpe2lmKGM9KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGM7aWYoYz0oY3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGM7aWYoYz0oY3woMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDE0KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBjO2lmKGM9KGN8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwyMSk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gYztpZihjPShjfCgxNSZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwyOCk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gYztpZigodGhpcy5wb3MrPTUpPnRoaXMubGVuKXRocm93IHRoaXMucG9zPXRoaXMubGVuLHModGhpcywxMCk7cmV0dXJuIGN9KSx1LnByb3RvdHlwZS5pbnQzMj1mdW5jdGlvbigpe3JldHVybiAwfHRoaXMudWludDMyKCl9LHUucHJvdG90eXBlLnNpbnQzMj1mdW5jdGlvbigpe3ZhciB0PXRoaXMudWludDMyKCk7cmV0dXJuIHQ+Pj4xXi0oMSZ0KXwwfSx1LnByb3RvdHlwZS5ib29sPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPT10aGlzLnVpbnQzMigpfSx1LnByb3RvdHlwZS5maXhlZDMyPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3MrND50aGlzLmxlbil0aHJvdyBzKHRoaXMsNCk7cmV0dXJuIGQodGhpcy5idWYsdGhpcy5wb3MrPTQpfSx1LnByb3RvdHlwZS5zZml4ZWQzMj1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzQ+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLDQpO3JldHVybiAwfGQodGhpcy5idWYsdGhpcy5wb3MrPTQpfSx1LnByb3RvdHlwZS5mbG9hdD1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzQ+dGhpcy5sZW4pdGhyb3cgcyh0aGlzLDQpO3ZhciB0PWkuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCx0fSx1LnByb3RvdHlwZS5kb3VibGU9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys4PnRoaXMubGVuKXRocm93IHModGhpcyw0KTt2YXIgdD1pLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1Zix0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz04LHR9LHUucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy51aW50MzIoKSxlPXRoaXMucG9zLG49dGhpcy5wb3MrdDtpZihuPnRoaXMubGVuKXRocm93IHModGhpcyx0KTtyZXR1cm4gdGhpcy5wb3MrPXQsQXJyYXkuaXNBcnJheSh0aGlzLmJ1Zik/dGhpcy5idWYuc2xpY2UoZSxuKTplPT09bj9uZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMCk6dGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1ZixlLG4pfSx1LnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmJ5dGVzKCk7cmV0dXJuIGEucmVhZCh0LDAsdC5sZW5ndGgpfSx1LnByb3RvdHlwZS5za2lwPWZ1bmN0aW9uKHQpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXtpZih0aGlzLnBvcyt0PnRoaXMubGVuKXRocm93IHModGhpcyx0KTt0aGlzLnBvcys9dH1lbHNlIGRve2lmKHRoaXMucG9zPj10aGlzLmxlbil0aHJvdyBzKHRoaXMpfXdoaWxlKDEyOCZ0aGlzLmJ1Zlt0aGlzLnBvcysrXSk7cmV0dXJuIHRoaXN9LHUucHJvdG90eXBlLnNraXBUeXBlPWZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIDA6dGhpcy5za2lwKCk7YnJlYWs7Y2FzZSAxOnRoaXMuc2tpcCg4KTticmVhaztjYXNlIDI6dGhpcy5za2lwKHRoaXMudWludDMyKCkpO2JyZWFrO2Nhc2UgMzpmb3IoOzQhPSh0PTcmdGhpcy51aW50MzIoKSk7KXRoaXMuc2tpcFR5cGUodCk7YnJlYWs7Y2FzZSA1OnRoaXMuc2tpcCg0KTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIrdCtcIiBhdCBvZmZzZXQgXCIrdGhpcy5wb3MpfXJldHVybiB0aGlzfSx1Ll9jb25maWd1cmU9ZnVuY3Rpb24odCl7cj10LHUuY3JlYXRlPXAoKSxyLl9jb25maWd1cmUoKTt2YXIgZT1pLkxvbmc/XCJ0b0xvbmdcIjpcInRvTnVtYmVyXCI7aS5tZXJnZSh1LnByb3RvdHlwZSx7aW50NjQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5jYWxsKHRoaXMpW2VdKCExKX0sdWludDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuY2FsbCh0aGlzKVtlXSghMCl9LHNpbnQ2NDpmdW5jdGlvbigpe3JldHVybiBmLmNhbGwodGhpcykuenpEZWNvZGUoKVtlXSghMSl9LGZpeGVkNjQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5jYWxsKHRoaXMpW2VdKCEwKX0sc2ZpeGVkNjQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5jYWxsKHRoaXMpW2VdKCExKX19KX19LDU5MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPW87dmFyIHI9bigxNDA4KTsoby5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPW87dmFyIGk9big5NjkzKTtmdW5jdGlvbiBvKHQpe3IuY2FsbCh0aGlzLHQpfW8uX2NvbmZpZ3VyZT1mdW5jdGlvbigpe2kuQnVmZmVyJiYoby5wcm90b3R5cGUuX3NsaWNlPWkuQnVmZmVyLnByb3RvdHlwZS5zbGljZSl9LG8ucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbigpe3ZhciB0PXRoaXMudWludDMyKCk7cmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZT90aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsdGhpcy5wb3M9TWF0aC5taW4odGhpcy5wb3MrdCx0aGlzLmxlbikpOnRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIix0aGlzLnBvcyx0aGlzLnBvcz1NYXRoLm1pbih0aGlzLnBvcyt0LHRoaXMubGVuKSl9LG8uX2NvbmZpZ3VyZSgpfSw1MDU0OnQ9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9e319LDU5OTQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuU2VydmljZT1uKDc5NDgpfSw3OTQ4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9aTt2YXIgcj1uKDk2OTMpO2Z1bmN0aW9uIGkodCxlLG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7ci5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSx0aGlzLnJwY0ltcGw9dCx0aGlzLnJlcXVlc3REZWxpbWl0ZWQ9Qm9vbGVhbihlKSx0aGlzLnJlc3BvbnNlRGVsaW1pdGVkPUJvb2xlYW4obil9KGkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5ycGNDYWxsPWZ1bmN0aW9uIHQoZSxuLGksbyxhKXtpZighbyl0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO3ZhciBzPXRoaXM7aWYoIWEpcmV0dXJuIHIuYXNQcm9taXNlKHQscyxlLG4saSxvKTtpZihzLnJwY0ltcGwpdHJ5e3JldHVybiBzLnJwY0ltcGwoZSxuW3MucmVxdWVzdERlbGltaXRlZD9cImVuY29kZURlbGltaXRlZFwiOlwiZW5jb2RlXCJdKG8pLmZpbmlzaCgpLChmdW5jdGlvbih0LG4pe2lmKHQpcmV0dXJuIHMuZW1pdChcImVycm9yXCIsdCxlKSxhKHQpO2lmKG51bGwhPT1uKXtpZighKG4gaW5zdGFuY2VvZiBpKSl0cnl7bj1pW3MucmVzcG9uc2VEZWxpbWl0ZWQ/XCJkZWNvZGVEZWxpbWl0ZWRcIjpcImRlY29kZVwiXShuKX1jYXRjaCh0KXtyZXR1cm4gcy5lbWl0KFwiZXJyb3JcIix0LGUpLGEodCl9cmV0dXJuIHMuZW1pdChcImRhdGFcIixuLGUpLGEobnVsbCxuKX1zLmVuZCghMCl9KSl9Y2F0Y2godCl7cmV0dXJuIHMuZW1pdChcImVycm9yXCIsdCxlKSx2b2lkIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7YSh0KX0pLDApfWVsc2Ugc2V0VGltZW91dCgoZnVuY3Rpb24oKXthKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSl9KSwwKX0saS5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJwY0ltcGwmJih0fHx0aGlzLnJwY0ltcGwobnVsbCxudWxsLG51bGwpLHRoaXMucnBjSW1wbD1udWxsLHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKSksdGhpc319LDE5NDU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1pO3ZhciByPW4oOTY5Myk7ZnVuY3Rpb24gaSh0LGUpe3RoaXMubG89dD4+PjAsdGhpcy5oaT1lPj4+MH12YXIgbz1pLnplcm89bmV3IGkoMCwwKTtvLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LG8uenpFbmNvZGU9by56ekRlY29kZT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxvLmxlbmd0aD1mdW5jdGlvbigpe3JldHVybiAxfTt2YXIgYT1pLnplcm9IYXNoPVwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7aS5mcm9tTnVtYmVyPWZ1bmN0aW9uKHQpe2lmKDA9PT10KXJldHVybiBvO3ZhciBlPXQ8MDtlJiYodD0tdCk7dmFyIG49dD4+PjAscj0odC1uKS80Mjk0OTY3Mjk2Pj4+MDtyZXR1cm4gZSYmKHI9fnI+Pj4wLG49fm4+Pj4wLCsrbj40Mjk0OTY3Mjk1JiYobj0wLCsrcj40Mjk0OTY3Mjk1JiYocj0wKSkpLG5ldyBpKG4scil9LGkuZnJvbT1mdW5jdGlvbih0KXtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gaS5mcm9tTnVtYmVyKHQpO2lmKHIuaXNTdHJpbmcodCkpe2lmKCFyLkxvbmcpcmV0dXJuIGkuZnJvbU51bWJlcihwYXJzZUludCh0LDEwKSk7dD1yLkxvbmcuZnJvbVN0cmluZyh0KX1yZXR1cm4gdC5sb3d8fHQuaGlnaD9uZXcgaSh0Lmxvdz4+PjAsdC5oaWdoPj4+MCk6b30saS5wcm90b3R5cGUudG9OdW1iZXI9ZnVuY3Rpb24odCl7aWYoIXQmJnRoaXMuaGk+Pj4zMSl7dmFyIGU9MSt+dGhpcy5sbz4+PjAsbj1+dGhpcy5oaT4+PjA7cmV0dXJuIGV8fChuPW4rMT4+PjApLC0oZSs0Mjk0OTY3Mjk2Km4pfXJldHVybiB0aGlzLmxvKzQyOTQ5NjcyOTYqdGhpcy5oaX0saS5wcm90b3R5cGUudG9Mb25nPWZ1bmN0aW9uKHQpe3JldHVybiByLkxvbmc/bmV3IHIuTG9uZygwfHRoaXMubG8sMHx0aGlzLmhpLEJvb2xlYW4odCkpOntsb3c6MHx0aGlzLmxvLGhpZ2g6MHx0aGlzLmhpLHVuc2lnbmVkOkJvb2xlYW4odCl9fTt2YXIgcz1TdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7aS5mcm9tSGFzaD1mdW5jdGlvbih0KXtyZXR1cm4gdD09PWE/bzpuZXcgaSgocy5jYWxsKHQsMCl8cy5jYWxsKHQsMSk8PDh8cy5jYWxsKHQsMik8PDE2fHMuY2FsbCh0LDMpPDwyNCk+Pj4wLChzLmNhbGwodCw0KXxzLmNhbGwodCw1KTw8OHxzLmNhbGwodCw2KTw8MTZ8cy5jYWxsKHQsNyk8PDI0KT4+PjApfSxpLnByb3RvdHlwZS50b0hhc2g9ZnVuY3Rpb24oKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmdGhpcy5sbyx0aGlzLmxvPj4+OCYyNTUsdGhpcy5sbz4+PjE2JjI1NSx0aGlzLmxvPj4+MjQsMjU1JnRoaXMuaGksdGhpcy5oaT4+PjgmMjU1LHRoaXMuaGk+Pj4xNiYyNTUsdGhpcy5oaT4+PjI0KX0saS5wcm90b3R5cGUuenpFbmNvZGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhpPj4zMTtyZXR1cm4gdGhpcy5oaT0oKHRoaXMuaGk8PDF8dGhpcy5sbz4+PjMxKV50KT4+PjAsdGhpcy5sbz0odGhpcy5sbzw8MV50KT4+PjAsdGhpc30saS5wcm90b3R5cGUuenpEZWNvZGU9ZnVuY3Rpb24oKXt2YXIgdD0tKDEmdGhpcy5sbyk7cmV0dXJuIHRoaXMubG89KCh0aGlzLmxvPj4+MXx0aGlzLmhpPDwzMSledCk+Pj4wLHRoaXMuaGk9KHRoaXMuaGk+Pj4xXnQpPj4+MCx0aGlzfSxpLnByb3RvdHlwZS5sZW5ndGg9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxvLGU9KHRoaXMubG8+Pj4yOHx0aGlzLmhpPDw0KT4+PjAsbj10aGlzLmhpPj4+MjQ7cmV0dXJuIDA9PT1uPzA9PT1lP3Q8MTYzODQ/dDwxMjg/MToyOnQ8MjA5NzE1Mj8zOjQ6ZTwxNjM4ND9lPDEyOD81OjY6ZTwyMDk3MTUyPzc6ODpuPDEyOD85OjEwfX0sOTY5MzpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9ZTtmdW5jdGlvbiBpKHQsZSxuKXtmb3IodmFyIHI9T2JqZWN0LmtleXMoZSksaT0wO2k8ci5sZW5ndGg7KytpKXZvaWQgMCE9PXRbcltpXV0mJm58fCh0W3JbaV1dPWVbcltpXV0pO3JldHVybiB0fWZ1bmN0aW9uIG8odCl7ZnVuY3Rpb24gZSh0LG4pe2lmKCEodGhpcyBpbnN0YW5jZW9mIGUpKXJldHVybiBuZXcgZSh0LG4pO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwibWVzc2FnZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH19KSxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT9FcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLGUpOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwic3RhY2tcIix7dmFsdWU6KG5ldyBFcnJvcikuc3RhY2t8fFwiXCJ9KSxuJiZpKHRoaXMsbil9cmV0dXJuKGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3I9ZSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJuYW1lXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0fX0pLGUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZStcIjogXCIrdGhpcy5tZXNzYWdlfSxlfXIuYXNQcm9taXNlPW4oNDUzNyksci5iYXNlNjQ9big3NDE5KSxyLkV2ZW50RW1pdHRlcj1uKDkyMTEpLHIuZmxvYXQ9big5NDUpLHIuaW5xdWlyZT1uKDcxOTkpLHIudXRmOD1uKDQ5OTcpLHIucG9vbD1uKDY2NjIpLHIuTG9uZ0JpdHM9bigxOTQ1KSxyLmlzTm9kZT1Cb29sZWFuKHZvaWQgMCE9PW4uZyYmbi5nJiZuLmcucHJvY2VzcyYmbi5nLnByb2Nlc3MudmVyc2lvbnMmJm4uZy5wcm9jZXNzLnZlcnNpb25zLm5vZGUpLHIuZ2xvYmFsPXIuaXNOb2RlJiZuLmd8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvd3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGZ8fHRoaXMsci5lbXB0eUFycmF5PU9iamVjdC5mcmVlemU/T2JqZWN0LmZyZWV6ZShbXSk6W10sci5lbXB0eU9iamVjdD1PYmplY3QuZnJlZXplP09iamVjdC5mcmVlemUoe30pOnt9LHIuaXNJbnRlZ2VyPU51bWJlci5pc0ludGVnZXJ8fGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZpc0Zpbml0ZSh0KSYmTWF0aC5mbG9vcih0KT09PXR9LHIuaXNTdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBTdHJpbmd9LHIuaXNPYmplY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwib2JqZWN0XCI9PXR5cGVvZiB0fSxyLmlzc2V0PXIuaXNTZXQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10W2VdO3JldHVybiEobnVsbD09bnx8IXQuaGFzT3duUHJvcGVydHkoZSkpJiYoXCJvYmplY3RcIiE9dHlwZW9mIG58fChBcnJheS5pc0FycmF5KG4pP24ubGVuZ3RoOk9iamVjdC5rZXlzKG4pLmxlbmd0aCk+MCl9LHIuQnVmZmVyPWZ1bmN0aW9uKCl7dHJ5e3ZhciB0PXIuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7cmV0dXJuIHQucHJvdG90eXBlLnV0ZjhXcml0ZT90Om51bGx9Y2F0Y2godCl7cmV0dXJuIG51bGx9fSgpLHIuX0J1ZmZlcl9mcm9tPW51bGwsci5fQnVmZmVyX2FsbG9jVW5zYWZlPW51bGwsci5uZXdCdWZmZXI9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/ci5CdWZmZXI/ci5fQnVmZmVyX2FsbG9jVW5zYWZlKHQpOm5ldyByLkFycmF5KHQpOnIuQnVmZmVyP3IuX0J1ZmZlcl9mcm9tKHQpOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBVaW50OEFycmF5P3Q6bmV3IFVpbnQ4QXJyYXkodCl9LHIuQXJyYXk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/VWludDhBcnJheTpBcnJheSxyLkxvbmc9ci5nbG9iYWwuZGNvZGVJTyYmci5nbG9iYWwuZGNvZGVJTy5Mb25nfHxyLmdsb2JhbC5Mb25nfHxyLmlucXVpcmUoXCJsb25nXCIpLHIua2V5MlJlPS9edHJ1ZXxmYWxzZXwwfDEkLyxyLmtleTMyUmU9L14tPyg/OjB8WzEtOV1bMC05XSopJC8sci5rZXk2NFJlPS9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLyxyLmxvbmdUb0hhc2g9ZnVuY3Rpb24odCl7cmV0dXJuIHQ/ci5Mb25nQml0cy5mcm9tKHQpLnRvSGFzaCgpOnIuTG9uZ0JpdHMuemVyb0hhc2h9LHIubG9uZ0Zyb21IYXNoPWZ1bmN0aW9uKHQsZSl7dmFyIG49ci5Mb25nQml0cy5mcm9tSGFzaCh0KTtyZXR1cm4gci5Mb25nP3IuTG9uZy5mcm9tQml0cyhuLmxvLG4uaGksZSk6bi50b051bWJlcihCb29sZWFuKGUpKX0sci5tZXJnZT1pLHIubGNGaXJzdD1mdW5jdGlvbih0KXtyZXR1cm4gdC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSt0LnN1YnN0cmluZygxKX0sci5uZXdFcnJvcj1vLHIuUHJvdG9jb2xFcnJvcj1vKFwiUHJvdG9jb2xFcnJvclwiKSxyLm9uZU9mR2V0dGVyPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT17fSxuPTA7bjx0Lmxlbmd0aDsrK24pZVt0W25dXT0xO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgdD1PYmplY3Qua2V5cyh0aGlzKSxuPXQubGVuZ3RoLTE7bj4tMTstLW4paWYoMT09PWVbdFtuXV0mJnZvaWQgMCE9PXRoaXNbdFtuXV0mJm51bGwhPT10aGlzW3Rbbl1dKXJldHVybiB0W25dfX0sci5vbmVPZlNldHRlcj1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDsrK24pdFtuXSE9PWUmJmRlbGV0ZSB0aGlzW3Rbbl1dfX0sci50b0pTT05PcHRpb25zPXtsb25nczpTdHJpbmcsZW51bXM6U3RyaW5nLGJ5dGVzOlN0cmluZyxqc29uOiEwfSxyLl9jb25maWd1cmU9ZnVuY3Rpb24oKXt2YXIgdD1yLkJ1ZmZlcjt0PyhyLl9CdWZmZXJfZnJvbT10LmZyb20hPT1VaW50OEFycmF5LmZyb20mJnQuZnJvbXx8ZnVuY3Rpb24oZSxuKXtyZXR1cm4gbmV3IHQoZSxuKX0sci5fQnVmZmVyX2FsbG9jVW5zYWZlPXQuYWxsb2NVbnNhZmV8fGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdChlKX0pOnIuX0J1ZmZlcl9mcm9tPXIuX0J1ZmZlcl9hbGxvY1Vuc2FmZT1udWxsfX0sMTE3MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPXA7dmFyIHIsaT1uKDk2OTMpLG89aS5Mb25nQml0cyxhPWkuYmFzZTY0LHM9aS51dGY4O2Z1bmN0aW9uIHUodCxlLG4pe3RoaXMuZm49dCx0aGlzLmxlbj1lLHRoaXMubmV4dD12b2lkIDAsdGhpcy52YWw9bn1mdW5jdGlvbiBjKCl7fWZ1bmN0aW9uIGwodCl7dGhpcy5oZWFkPXQuaGVhZCx0aGlzLnRhaWw9dC50YWlsLHRoaXMubGVuPXQubGVuLHRoaXMubmV4dD10LnN0YXRlc31mdW5jdGlvbiBwKCl7dGhpcy5sZW49MCx0aGlzLmhlYWQ9bmV3IHUoYywwLDApLHRoaXMudGFpbD10aGlzLmhlYWQsdGhpcy5zdGF0ZXM9bnVsbH12YXIgZj1mdW5jdGlvbigpe3JldHVybiBpLkJ1ZmZlcj9mdW5jdGlvbigpe3JldHVybihwLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgcn0pKCl9OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBwfX07ZnVuY3Rpb24gZCh0LGUsbil7ZVtuXT0yNTUmdH1mdW5jdGlvbiBoKHQsZSl7dGhpcy5sZW49dCx0aGlzLm5leHQ9dm9pZCAwLHRoaXMudmFsPWV9ZnVuY3Rpb24gZyh0LGUsbil7Zm9yKDt0LmhpOyllW24rK109MTI3JnQubG98MTI4LHQubG89KHQubG8+Pj43fHQuaGk8PDI1KT4+PjAsdC5oaT4+Pj03O2Zvcig7dC5sbz4xMjc7KWVbbisrXT0xMjcmdC5sb3wxMjgsdC5sbz10LmxvPj4+NztlW24rK109dC5sb31mdW5jdGlvbiBiKHQsZSxuKXtlW25dPTI1NSZ0LGVbbisxXT10Pj4+OCYyNTUsZVtuKzJdPXQ+Pj4xNiYyNTUsZVtuKzNdPXQ+Pj4yNH1wLmNyZWF0ZT1mKCkscC5hbGxvYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkuQXJyYXkodCl9LGkuQXJyYXkhPT1BcnJheSYmKHAuYWxsb2M9aS5wb29sKHAuYWxsb2MsaS5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpKSxwLnByb3RvdHlwZS5fcHVzaD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgdSh0LGUsbiksdGhpcy5sZW4rPWUsdGhpc30saC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh1LnByb3RvdHlwZSksaC5wcm90b3R5cGUuZm49ZnVuY3Rpb24odCxlLG4pe2Zvcig7dD4xMjc7KWVbbisrXT0xMjcmdHwxMjgsdD4+Pj03O2Vbbl09dH0scC5wcm90b3R5cGUudWludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxlbis9KHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgaCgodD4+Pj0wKTwxMjg/MTp0PDE2Mzg0PzI6dDwyMDk3MTUyPzM6dDwyNjg0MzU0NTY/NDo1LHQpKS5sZW4sdGhpc30scC5wcm90b3R5cGUuaW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD90aGlzLl9wdXNoKGcsMTAsby5mcm9tTnVtYmVyKHQpKTp0aGlzLnVpbnQzMih0KX0scC5wcm90b3R5cGUuc2ludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnVpbnQzMigodDw8MV50Pj4zMSk+Pj4wKX0scC5wcm90b3R5cGUudWludDY0PWZ1bmN0aW9uKHQpe3ZhciBlPW8uZnJvbSh0KTtyZXR1cm4gdGhpcy5fcHVzaChnLGUubGVuZ3RoKCksZSl9LHAucHJvdG90eXBlLmludDY0PXAucHJvdG90eXBlLnVpbnQ2NCxwLnByb3RvdHlwZS5zaW50NjQ9ZnVuY3Rpb24odCl7dmFyIGU9by5mcm9tKHQpLnp6RW5jb2RlKCk7cmV0dXJuIHRoaXMuX3B1c2goZyxlLmxlbmd0aCgpLGUpfSxwLnByb3RvdHlwZS5ib29sPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wdXNoKGQsMSx0PzE6MCl9LHAucHJvdG90eXBlLmZpeGVkMzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3B1c2goYiw0LHQ+Pj4wKX0scC5wcm90b3R5cGUuc2ZpeGVkMzI9cC5wcm90b3R5cGUuZml4ZWQzMixwLnByb3RvdHlwZS5maXhlZDY0PWZ1bmN0aW9uKHQpe3ZhciBlPW8uZnJvbSh0KTtyZXR1cm4gdGhpcy5fcHVzaChiLDQsZS5sbykuX3B1c2goYiw0LGUuaGkpfSxwLnByb3RvdHlwZS5zZml4ZWQ2ND1wLnByb3RvdHlwZS5maXhlZDY0LHAucHJvdG90eXBlLmZsb2F0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wdXNoKGkuZmxvYXQud3JpdGVGbG9hdExFLDQsdCl9LHAucHJvdG90eXBlLmRvdWJsZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcHVzaChpLmZsb2F0LndyaXRlRG91YmxlTEUsOCx0KX07dmFyIG09aS5BcnJheS5wcm90b3R5cGUuc2V0P2Z1bmN0aW9uKHQsZSxuKXtlLnNldCh0LG4pfTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDsrK3IpZVtuK3JdPXRbcl19O3AucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoPj4+MDtpZighZSlyZXR1cm4gdGhpcy5fcHVzaChkLDEsMCk7aWYoaS5pc1N0cmluZyh0KSl7dmFyIG49cC5hbGxvYyhlPWEubGVuZ3RoKHQpKTthLmRlY29kZSh0LG4sMCksdD1ufXJldHVybiB0aGlzLnVpbnQzMihlKS5fcHVzaChtLGUsdCl9LHAucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbih0KXt2YXIgZT1zLmxlbmd0aCh0KTtyZXR1cm4gZT90aGlzLnVpbnQzMihlKS5fcHVzaChzLndyaXRlLGUsdCk6dGhpcy5fcHVzaChkLDEsMCl9LHAucHJvdG90eXBlLmZvcms9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZXM9bmV3IGwodGhpcyksdGhpcy5oZWFkPXRoaXMudGFpbD1uZXcgdShjLDAsMCksdGhpcy5sZW49MCx0aGlzfSxwLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlcz8odGhpcy5oZWFkPXRoaXMuc3RhdGVzLmhlYWQsdGhpcy50YWlsPXRoaXMuc3RhdGVzLnRhaWwsdGhpcy5sZW49dGhpcy5zdGF0ZXMubGVuLHRoaXMuc3RhdGVzPXRoaXMuc3RhdGVzLm5leHQpOih0aGlzLmhlYWQ9dGhpcy50YWlsPW5ldyB1KGMsMCwwKSx0aGlzLmxlbj0wKSx0aGlzfSxwLnByb3RvdHlwZS5sZGVsaW09ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhlYWQsZT10aGlzLnRhaWwsbj10aGlzLmxlbjtyZXR1cm4gdGhpcy5yZXNldCgpLnVpbnQzMihuKSxuJiYodGhpcy50YWlsLm5leHQ9dC5uZXh0LHRoaXMudGFpbD1lLHRoaXMubGVuKz1uKSx0aGlzfSxwLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5oZWFkLm5leHQsZT10aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxuPTA7dDspdC5mbih0LnZhbCxlLG4pLG4rPXQubGVuLHQ9dC5uZXh0O3JldHVybiBlfSxwLl9jb25maWd1cmU9ZnVuY3Rpb24odCl7cj10LHAuY3JlYXRlPWYoKSxyLl9jb25maWd1cmUoKX19LDMxNTU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1vO3ZhciByPW4oMTE3Myk7KG8ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1vO3ZhciBpPW4oOTY5Myk7ZnVuY3Rpb24gbygpe3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBhKHQsZSxuKXt0Lmxlbmd0aDw0MD9pLnV0Zjgud3JpdGUodCxlLG4pOmUudXRmOFdyaXRlP2UudXRmOFdyaXRlKHQsbik6ZS53cml0ZSh0LG4pfW8uX2NvbmZpZ3VyZT1mdW5jdGlvbigpe28uYWxsb2M9aS5fQnVmZmVyX2FsbG9jVW5zYWZlLG8ud3JpdGVCeXRlc0J1ZmZlcj1pLkJ1ZmZlciYmaS5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSYmXCJzZXRcIj09PWkuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZT9mdW5jdGlvbih0LGUsbil7ZS5zZXQodCxuKX06ZnVuY3Rpb24odCxlLG4pe2lmKHQuY29weSl0LmNvcHkoZSxuLDAsdC5sZW5ndGgpO2Vsc2UgZm9yKHZhciByPTA7cjx0Lmxlbmd0aDspZVtuKytdPXRbcisrXX19LG8ucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKHQpe2kuaXNTdHJpbmcodCkmJih0PWkuX0J1ZmZlcl9mcm9tKHQsXCJiYXNlNjRcIikpO3ZhciBlPXQubGVuZ3RoPj4+MDtyZXR1cm4gdGhpcy51aW50MzIoZSksZSYmdGhpcy5fcHVzaChvLndyaXRlQnl0ZXNCdWZmZXIsZSx0KSx0aGlzfSxvLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24odCl7dmFyIGU9aS5CdWZmZXIuYnl0ZUxlbmd0aCh0KTtyZXR1cm4gdGhpcy51aW50MzIoZSksZSYmdGhpcy5fcHVzaChhLGUsdCksdGhpc30sby5fY29uZmlndXJlKCl9LDc3MTQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuUj12b2lkIDA7Y29uc3Qgcj1uKDY5MTkpLGk9big3NDQ4KTtlLlI9bmV3IGNsYXNze2FzeW5jIGluaXQoKXt9YXN5bmMgY3JlYXRlU2Vzc2lvbkhhbmRsZXIodCxlKXtjb25zdCBuPW5ldyByLlNlc3Npb24oZSk7cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKHQpLG5ldyBpLk9ubnhqc1Nlc3Npb25IYW5kbGVyKG4pfX19LDQyMDA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO2UuYzg9ZS5yWD12b2lkIDA7Y29uc3Qgcj1uKDE2NzApLGk9big1MzgxKSxvPW4oMjE1NyksYT1uKDIzMDYpO2Uuclg9KCk9PntpZigoXCJudW1iZXJcIiE9dHlwZW9mIHIuZW52Lndhc20uaW5pdFRpbWVvdXR8fHIuZW52Lndhc20uaW5pdFRpbWVvdXQ8MCkmJihyLmVudi53YXNtLmluaXRUaW1lb3V0PTApLFwiYm9vbGVhblwiIT10eXBlb2Ygci5lbnYud2FzbS5zaW1kJiYoci5lbnYud2FzbS5zaW1kPSEwKSxcImJvb2xlYW5cIiE9dHlwZW9mIHIuZW52Lndhc20ucHJveHkmJihyLmVudi53YXNtLnByb3h5PSExKSxcIm51bWJlclwiIT10eXBlb2Ygci5lbnYud2FzbS5udW1UaHJlYWRzfHwhTnVtYmVyLmlzSW50ZWdlcihyLmVudi53YXNtLm51bVRocmVhZHMpfHxyLmVudi53YXNtLm51bVRocmVhZHM8PTApe2NvbnN0IHQ9XCJ1bmRlZmluZWRcIj09dHlwZW9mIG5hdmlnYXRvcj8oMCxpLmNwdXMpKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O3IuZW52Lndhc20ubnVtVGhyZWFkcz1NYXRoLm1pbig0LE1hdGguY2VpbCgodHx8MSkvMikpfX0sZS5jOD1uZXcgY2xhc3N7YXN5bmMgaW5pdCgpeygwLGUuclgpKCksYXdhaXQoMCxvLmluaXRXYXNtKSgpfWFzeW5jIGNyZWF0ZVNlc3Npb25IYW5kbGVyKHQsZSl7Y29uc3Qgbj1uZXcgYS5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI7cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKHQsZSksUHJvbWlzZS5yZXNvbHZlKG4pfX19LDYwMTg6ZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKTt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsbik7aSYmIShcImdldFwiaW4gaT8hZS5fX2VzTW9kdWxlOmkud3JpdGFibGV8fGkuY29uZmlndXJhYmxlKXx8KGk9e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbbl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQscixpKX06ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9biksdFtyXT1lW25dfSksaT10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gdClcImRlZmF1bHRcIj09PW58fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pfHxyKGUsdCxuKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksaShuKDE2NzApLGUpO2NvbnN0IG89bigxNjcwKTt7Y29uc3QgdD1uKDc3MTQpLlI7KDAsby5yZWdpc3RlckJhY2tlbmQpKFwid2ViZ2xcIix0LC0xMCl9e2NvbnN0IHQ9big0MjAwKS5jODsoMCxvLnJlZ2lzdGVyQmFja2VuZCkoXCJjcHVcIix0LDEwKSwoMCxvLnJlZ2lzdGVyQmFja2VuZCkoXCJ3YXNtXCIsdCwxMCksKDAsby5yZWdpc3RlckJhY2tlbmQpKFwieG5ucGFja1wiLHQsOSl9fSwyNDY6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleT12b2lkIDA7Y2xhc3Mgbntjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMuX2NhY2hlS2V5fHwodGhpcy5fY2FjaGVLZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCgodD0+YCR7dGhpc1t0XX1gKSkuam9pbihcIjtcIikpLHRoaXMuX2NhY2hlS2V5fX1lLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleT10PT5uZXcgbih0KX0sNzc3ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5BdHRyaWJ1dGU9dm9pZCAwO2NvbnN0IHI9bigxNDQ2KSxpPW4oOTM5NSksbz1uKDkxNjIpLGE9bigyNTE3KTt2YXIgcz1pLm9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7Y2xhc3MgdXtjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLl9hdHRyaWJ1dGVzPW5ldyBNYXAsbnVsbCE9dCl7Zm9yKGNvbnN0IGUgb2YgdCllIGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuX2F0dHJpYnV0ZXMuc2V0KGUubmFtZSxbdS5nZXRWYWx1ZShlKSx1LmdldFR5cGUoZSldKTplIGluc3RhbmNlb2Ygcy5BdHRyaWJ1dGUmJnRoaXMuX2F0dHJpYnV0ZXMuc2V0KGUubmFtZSgpLFt1LmdldFZhbHVlKGUpLHUuZ2V0VHlwZShlKV0pO2lmKHRoaXMuX2F0dHJpYnV0ZXMuc2l6ZTx0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGVkIGF0dHJpYnV0ZSBuYW1lc1wiKX19c2V0KHQsZSxuKXt0aGlzLl9hdHRyaWJ1dGVzLnNldCh0LFtuLGVdKX1kZWxldGUodCl7dGhpcy5fYXR0cmlidXRlcy5kZWxldGUodCl9Z2V0RmxvYXQodCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcImZsb2F0XCIsZSl9Z2V0SW50KHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJpbnRcIixlKX1nZXRTdHJpbmcodCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcInN0cmluZ1wiLGUpfWdldFRlbnNvcih0LGUpe3JldHVybiB0aGlzLmdldCh0LFwidGVuc29yXCIsZSl9Z2V0RmxvYXRzKHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJmbG9hdHNcIixlKX1nZXRJbnRzKHQsZSl7cmV0dXJuIHRoaXMuZ2V0KHQsXCJpbnRzXCIsZSl9Z2V0U3RyaW5ncyh0LGUpe3JldHVybiB0aGlzLmdldCh0LFwic3RyaW5nc1wiLGUpfWdldFRlbnNvcnModCxlKXtyZXR1cm4gdGhpcy5nZXQodCxcInRlbnNvcnNcIixlKX1nZXQodCxlLG4pe2NvbnN0IHI9dGhpcy5fYXR0cmlidXRlcy5nZXQodCk7aWYodm9pZCAwPT09cil7aWYodm9pZCAwIT09bilyZXR1cm4gbjt0aHJvdyBuZXcgRXJyb3IoYHJlcXVpcmVkIGF0dHJpYnV0ZSBub3QgZm91bmQ6ICR7dH1gKX1pZihyWzFdIT09ZSl0aHJvdyBuZXcgRXJyb3IoYHR5cGUgbWlzbWF0Y2g6IGV4cGVjdGVkICR7ZX0gYnV0IGdvdCAke3JbMV19YCk7cmV0dXJuIHJbMF19c3RhdGljIGdldFR5cGUodCl7Y29uc3QgZT10IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3QudHlwZTp0LnR5cGUoKTtzd2l0Y2goZSl7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVDpyZXR1cm5cImZsb2F0XCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuXCJpbnRcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm5cInN0cmluZ1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVyblwidGVuc29yXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuXCJmbG9hdHNcIjtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuXCJpbnRzXCI7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTOnJldHVyblwic3RyaW5nc1wiO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzpyZXR1cm5cInRlbnNvcnNcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgYXR0cmlidXRlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQ6ICR7ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbZV19YCl9fXN0YXRpYyBnZXRWYWx1ZSh0KXtjb25zdCBlPXQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8/dC50eXBlOnQudHlwZSgpO2lmKGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSHx8ZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUyl0aHJvdyBuZXcgRXJyb3IoXCJncmFwaCBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Y29uc3Qgbj10aGlzLmdldFZhbHVlTm9DaGVjayh0KTtpZihlPT09ci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UJiZhLkxvbmdVdGlsLmlzTG9uZyhuKSlyZXR1cm4gYS5Mb25nVXRpbC5sb25nVG9OdW1iZXIobik7aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFMpe2NvbnN0IHQ9bixlPW5ldyBBcnJheSh0Lmxlbmd0aCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHI9dFtuXTtlW25dPWEuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHIpfXJldHVybiBlfWlmKGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1IpcmV0dXJuIHQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8/by5UZW5zb3IuZnJvbVByb3RvKG4pOm8uVGVuc29yLmZyb21PcnRUZW5zb3Iobik7aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlMpe2lmKHQgaW5zdGFuY2VvZiByLm9ubnguQXR0cmlidXRlUHJvdG8pcmV0dXJuIG4ubWFwKCh0PT5vLlRlbnNvci5mcm9tUHJvdG8odCkpKTtpZih0IGluc3RhbmNlb2Ygcy5BdHRyaWJ1dGUpcmV0dXJuIG4ubWFwKCh0PT5vLlRlbnNvci5mcm9tT3J0VGVuc29yKHQpKSl9aWYoZT09PXIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORyYmdCBpbnN0YW5jZW9mIHIub25ueC5BdHRyaWJ1dGVQcm90byl7Y29uc3QgdD1uO3JldHVybigwLGEuZGVjb2RlVXRmOFN0cmluZykodCl9cmV0dXJuIGU9PT1yLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTJiZ0IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP24ubWFwKGEuZGVjb2RlVXRmOFN0cmluZyk6bn1zdGF0aWMgZ2V0VmFsdWVOb0NoZWNrKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygci5vbm54LkF0dHJpYnV0ZVByb3RvP3RoaXMuZ2V0VmFsdWVOb0NoZWNrRnJvbU9ubnhGb3JtYXQodCk6dGhpcy5nZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0KHQpfXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2tGcm9tT25ueEZvcm1hdCh0KXtzd2l0Y2godC50eXBlKXtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOnJldHVybiB0LmY7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQ6cmV0dXJuIHQuaTtjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpyZXR1cm4gdC5zO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOnJldHVybiB0LnQ7Y2FzZSByLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSDpyZXR1cm4gdC5nO2Nhc2Ugci5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOnJldHVybiB0LmZsb2F0cztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6cmV0dXJuIHQuaW50cztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6cmV0dXJuIHQuc3RyaW5ncztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6cmV0dXJuIHQudGVuc29ycztjYXNlIHIub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpyZXR1cm4gdC5ncmFwaHM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlOiAke3Iub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW3QudHlwZV19YCl9fXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2tGcm9tT3J0Rm9ybWF0KHQpe3N3aXRjaCh0LnR5cGUoKSl7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6cmV0dXJuIHQuZigpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLklOVDpyZXR1cm4gdC5pKCk7Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOnJldHVybiB0LnMoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5URU5TT1I6cmV0dXJuIHQudCgpO2Nhc2Ugcy5BdHRyaWJ1dGVUeXBlLkdSQVBIOnJldHVybiB0LmcoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuIHQuZmxvYXRzQXJyYXkoKTtjYXNlIHMuQXR0cmlidXRlVHlwZS5JTlRTOntjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5pbnRzTGVuZ3RoKCk7bisrKWUucHVzaCh0LmludHMobikpO3JldHVybiBlfWNhc2Ugcy5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6e2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0LnN0cmluZ3NMZW5ndGgoKTtuKyspZS5wdXNoKHQuc3RyaW5ncyhuKSk7cmV0dXJuIGV9Y2FzZSBzLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzp7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQudGVuc29yc0xlbmd0aCgpO24rKyllLnB1c2godC50ZW5zb3JzKG4pKTtyZXR1cm4gZX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7cy5BdHRyaWJ1dGVUeXBlW3QudHlwZSgpXX1gKX19fWUuQXR0cmlidXRlPXV9LDcwOTE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucmVzb2x2ZUJhY2tlbmQ9ZS5iYWNrZW5kPXZvaWQgMDtjb25zdCByPW4oNTAzOCksaT1uZXcgTWFwO2FzeW5jIGZ1bmN0aW9uIG8odCl7Y29uc3Qgbj1lLmJhY2tlbmQ7aWYodm9pZCAwIT09blt0XSYmZnVuY3Rpb24odCl7Y29uc3QgZT10O3JldHVyblwiaW5pdGlhbGl6ZVwiaW4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5pbml0aWFsaXplJiZcImNyZWF0ZVNlc3Npb25IYW5kbGVyXCJpbiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmNyZWF0ZVNlc3Npb25IYW5kbGVyJiZcImRpc3Bvc2VcImluIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuZGlzcG9zZX0oblt0XSkpe2NvbnN0IGU9blt0XTtsZXQgcj1lLmluaXRpYWxpemUoKTtpZihcIm9iamVjdFwiPT10eXBlb2YgciYmXCJ0aGVuXCJpbiByJiYocj1hd2FpdCByKSxyKXJldHVybiBpLnNldCh0LGUpLGV9fWUuYmFja2VuZD17d2ViZ2w6bmV3IHIuV2ViR0xCYWNrZW5kfSxlLnJlc29sdmVCYWNrZW5kPWFzeW5jIGZ1bmN0aW9uIHQoZSl7aWYoIWUpcmV0dXJuIHQoW1wid2ViZ2xcIl0pO3tjb25zdCB0PVwic3RyaW5nXCI9PXR5cGVvZiBlP1tlXTplO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9aS5nZXQoZSk7aWYodClyZXR1cm4gdDtjb25zdCBuPWF3YWl0IG8oZSk7aWYobilyZXR1cm4gbn19dGhyb3cgbmV3IEVycm9yKFwibm8gYXZhaWxhYmxlIGJhY2tlbmQgdG8gdXNlXCIpfX0sNTAzODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5XZWJHTEJhY2tlbmQ9dm9pZCAwO2NvbnN0IHI9bigxNjcwKSxpPW4oNjIzMSksbz1uKDY0MTYpLGE9big3MzA1KTtlLldlYkdMQmFja2VuZD1jbGFzc3tnZXQgY29udGV4dElkKCl7cmV0dXJuIHIuZW52LndlYmdsLmNvbnRleHRJZH1zZXQgY29udGV4dElkKHQpe3IuZW52LndlYmdsLmNvbnRleHRJZD10fWdldCBtYXRtdWxNYXhCYXRjaFNpemUoKXtyZXR1cm4gci5lbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplfXNldCBtYXRtdWxNYXhCYXRjaFNpemUodCl7ci5lbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplPXR9Z2V0IHRleHR1cmVDYWNoZU1vZGUoKXtyZXR1cm4gci5lbnYud2ViZ2wudGV4dHVyZUNhY2hlTW9kZX1zZXQgdGV4dHVyZUNhY2hlTW9kZSh0KXtyLmVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlPXR9Z2V0IHBhY2soKXtyZXR1cm4gci5lbnYud2ViZ2wucGFja31zZXQgcGFjayh0KXtyLmVudi53ZWJnbC5wYWNrPXR9Z2V0IGFzeW5jKCl7cmV0dXJuIHIuZW52LndlYmdsLmFzeW5jfXNldCBhc3luYyh0KXtyLmVudi53ZWJnbC5hc3luYz10fWluaXRpYWxpemUoKXt0cnl7cmV0dXJuIHRoaXMuZ2xDb250ZXh0PSgwLGEuY3JlYXRlV2ViR0xDb250ZXh0KSh0aGlzLmNvbnRleHRJZCksXCJudW1iZXJcIiE9dHlwZW9mIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplJiYodGhpcy5tYXRtdWxNYXhCYXRjaFNpemU9MTYpLFwic3RyaW5nXCIhPXR5cGVvZiB0aGlzLnRleHR1cmVDYWNoZU1vZGUmJih0aGlzLnRleHR1cmVDYWNoZU1vZGU9XCJmdWxsXCIpLFwiYm9vbGVhblwiIT10eXBlb2YgdGhpcy5wYWNrJiYodGhpcy5wYWNrPSExKSxcImJvb2xlYW5cIiE9dHlwZW9mIHRoaXMuYXN5bmMmJih0aGlzLmFzeW5jPSExKSxpLkxvZ2dlci5zZXRXaXRoRW52KHIuZW52KSxpLkxvZ2dlci52ZXJib3NlKFwiV2ViR0xCYWNrZW5kXCIsYENyZWF0ZWQgV2ViR0xDb250ZXh0OiAke3R5cGVvZiB0aGlzLmdsQ29udGV4dH0gd2l0aCBtYXRtdWxNYXhCYXRjaFNpemU6ICR7dGhpcy5tYXRtdWxNYXhCYXRjaFNpemV9OyB0ZXh0dXJlQ2FjaGVNb2RlOiAke3RoaXMudGV4dHVyZUNhY2hlTW9kZX07IHBhY2s6ICR7dGhpcy5wYWNrfTsgYXN5bmM6ICR7dGhpcy5hc3luY30uYCksITB9Y2F0Y2godCl7cmV0dXJuIGkuTG9nZ2VyLndhcm5pbmcoXCJXZWJHTEJhY2tlbmRcIixgVW5hYmxlIHRvIGluaXRpYWxpemUgV2ViR0xCYWNrZW5kLiAke3R9YCksITF9fWNyZWF0ZVNlc3Npb25IYW5kbGVyKHQpe3JldHVybiBuZXcgby5XZWJHTFNlc3Npb25IYW5kbGVyKHRoaXMsdCl9ZGlzcG9zZSgpe3RoaXMuZ2xDb250ZXh0LmRpc3Bvc2UoKX19fSw1MTA3Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkNvb3Jkc0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oODUyMCksbz1uKDUwNjApLGE9big3ODU5KSxzPW4oOTM5MCk7Y2xhc3MgdSBleHRlbmRzIGkuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLm9mZnNldFRvQ29vcmRzKCkpLHRoaXMuY29vcmRzVG9PZmZzZXQoKSksdGhpcy50b1ZlYygpKSx0aGlzLnZhbHVlRnJvbSgpKSx0aGlzLmdldENvbW1vblV0aWxGdW5jcygpKSx0aGlzLmdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKSksdGhpcy5nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1vZmZzZXRUb0Nvb3Jkcygpe3JldHVybntvZmZzZXRUb0Nvb3JkczpuZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgb2Zmc2V0VG9Db29yZHMoaW50IG9mZnNldCwgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XFxuICAgICAgICBpbnQgdCA9IG9mZnNldCAvIHdpZHRoO1xcbiAgICAgICAgaW50IHMgPSBvZmZzZXQgLSB0KndpZHRoO1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSAodmVjMihzLHQpICsgdmVjMigwLjUsMC41KSkgLyB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xcbiAgICAgICAgcmV0dXJuIGNvb3JkcztcXG4gICAgICB9XFxuICAgICAgXCIpfX1jb29yZHNUb09mZnNldCgpe3JldHVybntjb29yZHNUb09mZnNldDpuZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIGludCBjb29yZHNUb09mZnNldCh2ZWMyIGNvb3JkcywgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XFxuICAgICAgICBmbG9hdCBzID0gY29vcmRzLnMgKiBmbG9hdCh3aWR0aCk7XFxuICAgICAgICBmbG9hdCB0ID0gY29vcmRzLnQgKiBmbG9hdChoZWlnaHQpO1xcbiAgICAgICAgaW50IG9mZnNldCA9IGludCh0KSAqIHdpZHRoICsgaW50KHMpO1xcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcXG4gICAgICB9XFxuICAgICAgXCIpfX1nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKXtjb25zdCB0PXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiB0LmlzUGFja2VkP3RoaXMuZ2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KHQpOnRoaXMuZ2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQodCl9Z2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KHQpe2NvbnN0IGU9dC51bnBhY2tlZFNoYXBlLG49W3Qud2lkdGgsdC5oZWlnaHRdLHI9e30sYT1cImdldE91dHB1dENvb3Jkc1wiO3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJbYV09dGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTticmVhaztjYXNlIDE6clthXT10aGlzLmdldE91dHB1dFBhY2tlZDFEQ29vcmRzKGUsbik7YnJlYWs7Y2FzZSAyOnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMzpyW2FdPXRoaXMuZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMoZSxuKTticmVhaztkZWZhdWx0OnJbYV09dGhpcy5nZXRPdXRwdXRQYWNrZWRORENvb3JkcyhlLG4pfWNvbnN0IHM9YFxcbiAgICAgIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XFxuICAgICAgICAkeygwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS5vdXRwdXR9ID0gdmFsO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gci5mbG9hdFRleHR1cmVTZXRSR0JBPW5ldyBpLkdsc2xMaWJSb3V0aW5lKHMpLHJ9Z2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQodCl7Y29uc3QgZT10LnVucGFja2VkU2hhcGUsbj1bdC53aWR0aCx0LmhlaWdodF0scj17fSxhPVwiZ2V0T3V0cHV0Q29vcmRzXCI7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6clthXT10aGlzLmdldE91dHB1dFNjYWxhckNvb3JkcygpO2JyZWFrO2Nhc2UgMTpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQxRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMjpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQyRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgMzpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQzRENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNDpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNTpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ1RENvb3JkcyhlLG4pO2JyZWFrO2Nhc2UgNjpyW2FdPXRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ2RENvb3JkcyhlLG4pO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQgZGltZW5zaW9uYWxpdHk6ICR7ZS5sZW5ndGh9YCl9Y29uc3Qgcz1gXFxuICAgICAgICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcXG4gICAgICAgICAgJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikub3V0cHV0fSA9IHZlYzQodmFsLCAwLCAwLCAwKTtcXG4gICAgICAgIH1cXG4gICAgYDtyZXR1cm4gci5mbG9hdFRleHR1cmVTZXRSPW5ldyBpLkdsc2xMaWJSb3V0aW5lKHMpLHJ9Z2V0T3V0cHV0U2NhbGFyQ29vcmRzKCl7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAwO1xcbiAgICAgIH1cXG4gICAgXCIpfWdldE91dHB1dFBhY2tlZDFEQ29vcmRzKHQsZSl7Y29uc3Qgbj1lO2xldCByPVwiXCI7cmV0dXJuIDE9PT1uWzBdPyhyPWBcXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueSAqICR7blsxXX0uMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUocikpOjE9PT1uWzFdPyhyPWBcXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueCAqICR7blswXX0uMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUocikpOihyPWBcXG4gICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7blswXX0sICR7blsxXX0pKTtcXG4gICAgICAgICAgcmV0dXJuIDIgKiAocmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54KTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBpLkdsc2xMaWJSb3V0aW5lKHIpKX1nZXRPdXRwdXRQYWNrZWQyRENvb3Jkcyh0LGUpe2xldCBuPVwiXCI7aWYoci5BcnJheVV0aWwuYXJyYXlzRXF1YWwodCxlKSlyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIHJldHVybiAyICogaXZlYzIoVGV4Q29vcmRzLnh5ICogdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKTtjb25zdCBvPWUsYT1NYXRoLmNlaWwodFsxXS8yKTtyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtvWzBdfSwgJHtvWzFdfSkpO1xcblxcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtvWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke2F9KSAqIDI7XFxuICAgICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7YX0pO1xcblxcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRQYWNrZWQzRENvb3Jkcyh0LGUpe2NvbnN0IG49W2VbMF0sZVsxXV0scj1NYXRoLmNlaWwodFsyXS8yKSxvPXIqTWF0aC5jZWlsKHRbMV0vMiksYT1gXFxuICAgICAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtuWzBdfSArIHJlc1RleFJDLng7XFxuXFxuICAgICAgICAgIGludCBiID0gaW5kZXggLyAke299O1xcbiAgICAgICAgICBpbmRleCAtPSBiICogJHtvfTtcXG5cXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxcbiAgICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7cn0pICogMjtcXG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtyfSk7XFxuXFxuICAgICAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShhKX1nZXRPdXRwdXRQYWNrZWRORENvb3Jkcyh0LGUpe2NvbnN0IG49W2VbMF0sZVsxXV0scj1NYXRoLmNlaWwodFt0Lmxlbmd0aC0xXS8yKSxvPXIqTWF0aC5jZWlsKHRbdC5sZW5ndGgtMl0vMik7bGV0IGE9byxzPVwiXCIsdT1cImIsIHIsIGNcIjtmb3IobGV0IGU9MjtlPHQubGVuZ3RoLTE7ZSsrKWEqPXRbdC5sZW5ndGgtZS0xXSxzPWBcXG4gICAgICBpbnQgYiR7ZX0gPSBpbmRleCAvICR7YX07XFxuICAgICAgaW5kZXggLT0gYiR7ZX0gKiAke2F9O1xcbiAgICBgK3MsdT1gYiR7ZX0sIGArdTtjb25zdCBjPWBcXG4gICAgICBpdmVjJHt0Lmxlbmd0aH0gZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtuWzBdfSwgJHtuWzFdfSkpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54O1xcblxcbiAgICAgICAgJHtzfVxcblxcbiAgICAgICAgaW50IGIgPSBpbmRleCAvICR7b307XFxuICAgICAgICBpbmRleCAtPSBiICogJHtvfTtcXG5cXG4gICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHtyfSkgKiAyO1xcbiAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHtyfSk7XFxuXFxuICAgICAgICByZXR1cm4gaXZlYyR7dC5sZW5ndGh9KCR7dX0pO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyl9Z2V0T3V0cHV0VW5wYWNrZWQxRENvb3Jkcyh0LGUpe2NvbnN0IG49YFxcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgIHJldHVybiByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQyRENvb3Jkcyh0LGUpe2NvbnN0IG49YFxcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7ZVswXX0sICR7ZVsxXX0pKTtcXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7ZVswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICBpbnQgciA9IGluZGV4IC8gJHt0WzFdfTtcXG4gICAgICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiAke3RbMV19O1xcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQzRENvb3Jkcyh0LGUpe2xldCBuPVwiXCI7Y29uc3Qgcj10Lmxlbmd0aDtsZXQgbz1udWxsO3I8MiYmKG89W10pLG89bmV3IEFycmF5KHItMSksb1tyLTJdPXRbci0xXTtmb3IobGV0IGU9ci0zO2U+PTA7LS1lKW9bZV09b1tlKzFdKnRbZSsxXTtjb25zdCBhPVtcInJcIixcImNcIixcImRcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke2VbMF19ICsgcmVzVGV4UkMueDtcXG4gICAgICAgICAgJHtzfVxcbiAgICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDREQ29vcmRzKHQsZSl7bGV0IG49XCJcIjtjb25zdCByPXQubGVuZ3RoO2xldCBvPW51bGw7cjwyJiYobz1bXSksbz1uZXcgQXJyYXkoci0xKSxvW3ItMl09dFtyLTFdO2ZvcihsZXQgZT1yLTM7ZT49MDstLWUpb1tlXT1vW2UrMV0qdFtlKzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcXG4gICAgICAgIH1cXG4gICAgICBgLG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4pfWdldE91dHB1dFVucGFja2VkNURDb29yZHModCxlKXtsZXQgbj1cIlwiO2NvbnN0IHI9dC5sZW5ndGg7bGV0IG89bnVsbDtyPDImJihvPVtdKSxvPW5ldyBBcnJheShyLTEpLG9bci0yXT10W3ItMV07Zm9yKGxldCBlPXItMztlPj0wOy0tZSlvW2VdPW9bZSsxXSp0W2UrMV07Y29uc3QgYT1bXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIl0scz1vLm1hcCgoKHQsZSk9PmBpbnQgJHthW2VdfSA9IGluZGV4IC8gJHt0fTsgJHtlPT09by5sZW5ndGgtMT9gaW50ICR7YVtlKzFdfSA9IGluZGV4IC0gJHthW2VdfSAqICR7dH1gOmBpbmRleCAtPSAke2FbZV19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtlWzBdfSwgJHtlWzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtlWzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgICAgcmV0dXJuIGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKHQsZSl7bGV0IG49XCJcIjtjb25zdCByPXQubGVuZ3RoO2xldCBvPW51bGw7cjwyJiYobz1bXSksbz1uZXcgQXJyYXkoci0xKSxvW3ItMl09dFtyLTFdO2ZvcihsZXQgZT1yLTM7ZT49MDstLWUpb1tlXT1vW2UrMV0qdFtlKzFdO2NvbnN0IGE9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCIsXCJkNFwiXSxzPW8ubWFwKCgodCxlKT0+YGludCAke2FbZV19ID0gaW5kZXggLyAke3R9OyAke2U9PT1vLmxlbmd0aC0xP2BpbnQgJHthW2UrMV19ID0gaW5kZXggLSAke2FbZV19ICogJHt0fWA6YGluZGV4IC09ICR7YVtlXX0gKiAke3R9YH07YCkpLmpvaW4oXCJcIik7cmV0dXJuIG49YFxcbiAgICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2VbMF19LCAke2VbMV19KSk7XFxuICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7ZVswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICR7c31cXG4gICAgICAgICByZXR1cm4gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XFxuICAgICAgIH1cXG4gICAgIGAsbmV3IGkuR2xzbExpYlJvdXRpbmUobil9Z2V0Q29tbW9uVXRpbEZ1bmNzKCl7Y29uc3QgdD17fTtsZXQgZT1cInV2RnJvbUZsYXRcIjt0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgIHZlYzIgdXZGcm9tRmxhdChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLyB0ZXhOdW1SO1xcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLSB0ZXhDICogdGV4TnVtUjtcXG4gICAgICAvLyBUT0RPOiBzd2FwIHRleFIsIHRleEMgb3JkZXIgaW4gZm9sbG93aW5nIGZ1bmN0aW9uIHNvIHJvdyBpcyBjb3JyZXNwb25kaW5nIHRvIHUgYW5kIGNvbHVtbiBpcyBjb3JyZXNwb25kaW5nIHRvXFxuICAgICAgLy8gICAgICAgdi5cXG4gICAgICByZXR1cm4gKHZlYzIodGV4UiwgdGV4QykgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1SLCB0ZXhOdW1DKTtcXG4gICAgfVxcbiAgICBcIiksZT1cInBhY2tlZFVWZnJvbTFEXCIsdFtlXT1uZXcgaS5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tMUQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSxlPVwicGFja2VkVVZmcm9tMkRcIix0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxuICAgICAgfVxcbiAgICAgIFwiKSxlPVwicGFja2VkVVZmcm9tM0RcIix0W2VdPW5ldyBpLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXFxuICAgICAgICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcXG4gICAgICAgICAgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICAgICAgICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gICAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbiAgICAgIH1cXG4gICAgICBcIiksZT1cInNhbXBsZVRleHR1cmVcIjtjb25zdCBuPSgwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm4gdFtlXT1uZXcgaS5HbHNsTGliUm91dGluZShgXFxuICAgICAgICBmbG9hdCBzYW1wbGVUZXh0dXJlKHNhbXBsZXIyRCB0ZXh0dXJlU2FtcGxlciwgdmVjMiB1dikge1xcbiAgICAgICAgICAgIHJldHVybiAke24udGV4dHVyZTJEfSh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XFxuICAgICAgICB9YCksdH1nZXRJbnB1dHNTYW1wbGluZ1NuaXBwZXRzKCl7Y29uc3QgdD17fSxlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgobixyKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbcl0sbz0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkobik7aS5pc1BhY2tlZD90W29dPXRoaXMuZ2V0UGFja2VkU2FtcGxlckZyb21JbnB1dChvLG4saSk6dFtvXT10aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChvLG4saSk7Y29uc3QgYT0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzKShuKTtpLnVucGFja2VkU2hhcGUubGVuZ3RoPD1lLnVucGFja2VkU2hhcGUubGVuZ3RoJiYoaS5pc1BhY2tlZD90W2FdPXRoaXMuZ2V0UGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKGEsaSxlLG4pOnRbYV09dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhhLGksZSxuKSl9KSksdH1nZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHModCxlLG4sbyl7Y29uc3QgYT1lLnVucGFja2VkU2hhcGUsdT1uLnVucGFja2VkU2hhcGUsYz1vLGw9KDAscy5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUpKGMpLHA9YS5sZW5ndGgsZj11Lmxlbmd0aCxkPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGEsdSksaD0oMCxzLmdldENvb3Jkc0RhdGFUeXBlKShmKSxnPWYtcDtsZXQgYjtjb25zdCBtPSgwLHMuZ2V0R2xDaGFubmVscykoKTtiPTA9PT1wP1wiXCI6ZjwyJiZkLmxlbmd0aD49MT9cImNvb3JkcyA9IDA7XCI6ZC5tYXAoKHQ9PmBjb29yZHMuJHttW3QrZ119ID0gMDtgKSkuam9pbihcIlxcblwiKTtsZXQgeT1cIlwiO3k9ZjwyJiZwPjA/XCJjb29yZHNcIjphLm1hcCgoKHQsZSk9PmBjb29yZHMuJHttW2UrZ119YCkpLmpvaW4oXCIsIFwiKTtsZXQgXz1cInJldHVybiBvdXRwdXRWYWx1ZTtcIjtjb25zdCB2PTE9PT1yLlNoYXBlVXRpbC5zaXplKGEpLHc9MT09PXIuU2hhcGVVdGlsLnNpemUodSk7aWYoMSE9PXB8fHZ8fHcpe2lmKHYmJiF3KV89MT09PWY/XCJcXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueCwgMC4sIDAuKTtcXG4gICAgICAgIFwiOlwiXFxuICAgICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1xcbiAgICAgICAgXCI7ZWxzZSBpZihkLmxlbmd0aCl7Y29uc3QgdD1wLTIsZT1wLTE7ZC5pbmRleE9mKHQpPi0xJiZkLmluZGV4T2YoZSk+LTE/Xz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1wiOmQuaW5kZXhPZih0KT4tMT9fPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7XCI6ZC5pbmRleE9mKGUpPi0xJiYoXz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS56eik7XCIpfX1lbHNlIF89XCJcXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh5LCBvdXRwdXRWYWx1ZS54eSk7XFxuICAgICAgXCI7Y29uc3QgeD1gXFxuICAgICAgdmVjNCAke3R9KCkge1xcbiAgICAgICAgJHtofSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFxcbiAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHttW2YtMV19O1xcbiAgICAgICAgY29vcmRzLiR7bVtmLTFdfSA9IGNvb3Jkcy4ke21bZi0yXX07XFxuICAgICAgICBjb29yZHMuJHttW2YtMl19ID0gbGFzdERpbTtcXG4gICAgICBcXG4gICAgICAgICR7Yn1cXG4gICAgICAgIHZlYzQgb3V0cHV0VmFsdWUgPSAke2x9KCR7eX0pO1xcbiAgICAgICAgJHtffVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoeCxbXCJjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHNcIl0pfWdldFVucGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKHQsZSxuLG8pe2NvbnN0IGE9W24ud2lkdGgsbi5oZWlnaHRdLHU9W2Uud2lkdGgsZS5oZWlnaHRdLGM9ZS51bnBhY2tlZFNoYXBlLmxlbmd0aCxsPW4udW5wYWNrZWRTaGFwZS5sZW5ndGgscD1lLnVucGFja2VkU2hhcGUsZj1uLnVucGFja2VkU2hhcGUsZD0oMCxzLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSkobyk7aWYoYz09PWwmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKHUsYSkpe2NvbnN0IGU9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KCkge1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7b30sIFRleENvb3Jkcyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGUsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Y29uc3QgaD0oMCxzLmdldENvb3Jkc0RhdGFUeXBlKShsKSxnPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKHAsZiksYj1sLWM7bGV0IG07Y29uc3QgeT0oMCxzLmdldEdsQ2hhbm5lbHMpKCk7bT0wPT09Yz9cIlwiOmw8MiYmZy5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOmcubWFwKCh0PT5gY29vcmRzLiR7eVt0K2JdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIik7bGV0IF89XCJcIjtfPWw8MiYmYz4wP1wiY29vcmRzXCI6ZS51bnBhY2tlZFNoYXBlLm1hcCgoKHQsZSk9PmBjb29yZHMuJHt5W2UrYl19YCkpLmpvaW4oXCIsIFwiKTtjb25zdCB2PWBcXG4gICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgICR7aH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgICR7bX1cXG4gICAgICAgICAgcmV0dXJuICR7ZH0oJHtffSk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUodixbXCJjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHNcIl0pfWdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLG4pe3N3aXRjaChuLnVucGFja2VkU2hhcGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlclNjYWxhcih0LGUpO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMUQodCxlLG4pO2Nhc2UgMjpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMkQodCxlLG4pO2Nhc2UgMzpyZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyM0QodCxlLG4pO2RlZmF1bHQ6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlck5EKHQsZSxuKX19Z2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZTtzd2l0Y2goci5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIodCxlLG4pO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIxRCh0LGUsbik7Y2FzZSAyOnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjJEKHQsZSxuKTtjYXNlIDM6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyM0QodCxlLG4pO2Nhc2UgNDpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI0RCh0LGUsbik7Y2FzZSA1OnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjVEKHQsZSxuKTtjYXNlIDY6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyNkQodCxlLG4pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkaW1lbnNpb24gJHtyLmxlbmd0aH0tRGApfX1nZXRQYWNrZWRTYW1wbGVyU2NhbGFyKHQsZSl7Y29uc3Qgbj1gXFxuICAgICAgICAgIHZlYzQgJHt0fSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke2V9LCBoYWxmQ1IpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuKX1nZXRQYWNrZWRTYW1wbGVyMUQodCxlLG4pe2NvbnN0IHI9W24ud2lkdGgsbi5oZWlnaHRdLGE9W3JbMV0sclswXV0scz0oMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksdT1gdmVjNCAke3R9KGludCBpbmRleCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20xRChcXG4gICAgICAke2FbMF19LCAke2FbMV19LCBpbmRleCk7XFxuICAgICAgcmV0dXJuICR7cy50ZXh0dXJlMkR9KCR7ZX0sIHV2KTtcXG4gICAgfWA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKHUsW1wiY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMURcIl0pfWdldFBhY2tlZFNhbXBsZXIyRCh0LGUsbil7Y29uc3QgYT1uLnVucGFja2VkU2hhcGUscz1bbi53aWR0aCxuLmhlaWdodF0sdT0oMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiksYz1zWzBdLGw9c1sxXTtpZihudWxsIT1zJiZyLkFycmF5VXRpbC5hcnJheXNFcXVhbChhLHMpKXtjb25zdCBuPWB2ZWM0ICR7dH0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKCR7bH0uMCwgJHtjfS4wKTtcXG4gICAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke2V9LCB1dik7XFxuICAgICAgfWA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4pfWNvbnN0IHA9cyxmPU1hdGguY2VpbChhWzFdLzIpLGQ9YHZlYzQgJHt0fShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKCR7cFsxXX0sICR7cFswXX0sICR7Zn0sIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gJHt1LnRleHR1cmUyRH0oJHtlfSwgdXYpO1xcbiAgICB9YDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZCxbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20yRFwiXSl9Z2V0UGFja2VkU2FtcGxlcjNEKHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxhPVtuLndpZHRoLG4uaGVpZ2h0XSx1PVthWzBdLGFbMV1dLGM9KDAsby5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO2lmKDE9PT1yWzBdKXtjb25zdCBvPXIuc2xpY2UoMSksYT1bMSwyXSx1PSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIsbyksYz1bXCJiXCIsXCJyb3dcIixcImNvbFwiXSxsPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO2wudW5wYWNrZWRTaGFwZT11O2NvbnN0IHA9dGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSxsKSxmPWAke3Aucm91dGluZUJvZHl9XFxuICAgICAgdmVjNCAke3R9KGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGMsYSl9KTtcXG4gICAgICB9IGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGYscC5kZXBlbmRlbmNpZXMpfWNvbnN0IGw9dVswXSxwPXVbMV0sZj1NYXRoLmNlaWwoclsyXS8yKSxkPWB2ZWM0ICR7dH0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tM0QoXFxuICAgICAgICAke3B9LCAke2x9LCAke2YqTWF0aC5jZWlsKHJbMV0vMil9LCAke2Z9LCBiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuICR7Yy50ZXh0dXJlMkR9KCR7ZX0sIHV2KTt9YDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZCxbXCJjb29yZGluYXRlcy5wYWNrZWRVVmZyb20zRFwiXSl9Z2V0UGFja2VkU2FtcGxlck5EKHQsZSxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxhPXIubGVuZ3RoLHM9W24ud2lkdGgsbi5oZWlnaHRdLHU9KDAsby5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLGM9W3NbMF0sc1sxXV0sbD1jWzFdLHA9Y1swXSxmPU1hdGguY2VpbChyW2EtMV0vMik7bGV0IGQ9ZipNYXRoLmNlaWwoclthLTJdLzIpLGg9XCJpbnQgYiwgaW50IHJvdywgaW50IGNvbFwiLGc9YGIgKiAke2R9ICsgKHJvdyAvIDIpICogJHtmfSArIChjb2wgLyAyKWA7Zm9yKGxldCB0PTI7dDxhLTE7dCsrKWg9YGludCBiJHt0fSwgYCtoLGQqPXJbYS10LTFdLGc9YGIke3R9ICogJHtkfSArIGArZztjb25zdCBiPWB2ZWM0ICR7dH0oJHtofSkge1xcbiAgICAgIGludCBpbmRleCA9ICR7Z307XFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvICR7cH07XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiAke3B9O1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKCR7cH0sICR7bH0pO1xcbiAgICAgIHJldHVybiAke3UudGV4dHVyZTJEfSgke2V9LCB1dik7XFxuICAgIH1gO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShiKX1nZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIodCxlLG4pe2NvbnN0W3Isb109W24ud2lkdGgsbi5oZWlnaHRdO2lmKDE9PT1yJiYxPT09byl7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgaGFsZkNSKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBhPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oKSB7XFxuICAgICAgICAgIGludCBvZmZzZXRfJHtlfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtyfSwgJHtvfSk7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7cn0sICR7b30sIG9mZnNldF8ke2V9KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfWdldFVucGFja2VkU2FtcGxlcjFEKHQsZSxuKXtjb25zdCByPW4ud2lkdGgsbz1uLmhlaWdodDtpZigxPT09byYmMT09PXIpe2NvbnN0IG49YFxcbiAgICAgICAgZmxvYXQgJHt0fShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgaGFsZkNSKTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWlmKDE9PT1vKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvICR7cn0uMCwgMC41KTtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKG4sW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9aWYoMT09PXIpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCBpbmRleCkge1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyAke299LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBhPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IGluZGV4KSB7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7cn0sICR7b30sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyMkQodCxlLG4pe2NvbnN0IG89bi51bnBhY2tlZFNoYXBlLHU9W24uaGVpZ2h0LG4ud2lkdGhdO2lmKG51bGwhPXUmJnIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKG8sdSkpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIocm93LCBjb2wpICsgaGFsZkNSKSAvIHZlYzIoJHt1WzFdfS4wLCAke3VbMF19LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdHtuZXdTaGFwZTpjLGtlcHREaW1zOmx9PSgwLGEuc3F1ZWV6ZVNoYXBlKShvKSxwPWM7aWYocC5sZW5ndGg8by5sZW5ndGgpe2NvbnN0IHI9KDAscy5zcXVlZXplSW5wdXRTaGFwZSkobyxwKSxhPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO2EudW5wYWNrZWRTaGFwZT1yO2NvbnN0IHU9W1wiY29sXCIsXCJyb3dcIl0sYz1gXFxuICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLGEpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKHUsbCl9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1jb25zdCBmPXVbMV0sZD11WzBdO2lmKDE9PT1kKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgaW50IG9mZnNldF8ke2V9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2Z9LCAke2R9KTtcXG4gICAgICAgICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBvZmZzZXRfJHtlfSksIHZlYzMoJHtvWzFdfSwgMSwgMSkpO1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGluZGV4ICsgMC41KSAvICR7Zn0uMCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX1pZigxPT09Zil7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIGludCBvZmZzZXRfJHtlfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtmfSwgJHtkfSk7XFxuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7ZX0pLCB2ZWMzKCR7b1sxXX0sIDEsIDEpKTtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHtkfS4wLCAwLjUpO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7ZX0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Y29uc3QgaD1gXFxuICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgaW50IGluZGV4ID0gY29sICogJHtvWzFdfSArIHJvdztcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtmfSwgJHtkfSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoaCxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyM0QodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89clsxXSpyWzJdLHU9clsyXSx7bmV3U2hhcGU6YyxrZXB0RGltczpsfT0oMCxhLnNxdWVlemVTaGFwZSkocikscD1jO2lmKHAubGVuZ3RoPHIubGVuZ3RoKXtjb25zdCBvPSgwLHMuc3F1ZWV6ZUlucHV0U2hhcGUpKHIscCksYT1bXCJiYXRjaFwiLFwiY29sXCIsXCJyb3dcIl0sdT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG4pKTt1LnVucGFja2VkU2hhcGU9bztjb25zdCBjPXRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSx1KSxmPWwucmV2ZXJzZSgpLGQ9YFxcbiAgICAgICAgICAke2Mucm91dGluZUJvZHl9XFxuICAgICAgICAgIGZsb2F0ICR7dH0oaW50IGJhdGNoLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgcmV0dXJuICR7dH0oJHsoMCxzLmdldFNxdWVlemVkUGFyYW1zKShhLGYpfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGQsYy5kZXBlbmRlbmNpZXMpfWNvbnN0IGY9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCBkZXB0aCwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgICAgICAgICBpbnQgaW5kZXggPSBkZXB0aCAqICR7b30gKyBjb2wgKiAke3V9ICsgcm93O1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoZixbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNEQodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89clszXSxhPXJbMl0qbyxzPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7clsxXSphfSArIGNvbCAqICR7YX0gK1xcbiAgICAgICAgICAgICAgZGVwdGgyICogJHtvfSArIGRlcHRoO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke24ud2lkdGh9LCAke24uaGVpZ2h0fSwgaW5kZXgpO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2V9LCB1dik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUocyxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1nZXRVbnBhY2tlZFNhbXBsZXI1RCh0LGUsbil7Y29uc3Qgcj1uLnVucGFja2VkU2hhcGUsbz1yWzRdLHU9clszXSpvLGM9clsyXSp1LGw9clsxXSpjLHtuZXdTaGFwZTpwLGtlcHREaW1zOmZ9PSgwLGEuc3F1ZWV6ZVNoYXBlKShyKTtpZihwLmxlbmd0aDxyLmxlbmd0aCl7Y29uc3Qgbz0oMCxzLnNxdWVlemVJbnB1dFNoYXBlKShyLHApLGE9W1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1vO2NvbnN0IGM9YFxcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KHQsZSx1KS5yb3V0aW5lQm9keX1cXG4gICAgICAgICAgZmxvYXQgJHt0fShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHt0fSgkeygwLHMuZ2V0U3F1ZWV6ZWRQYXJhbXMpKGEsZil9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IGkuR2xzbExpYlJvdXRpbmUoYyxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCJdKX1jb25zdCBkPWBcXG4gICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7bH0gKyBjb2wgKiAke2N9ICsgZGVwdGggKiAke3V9ICtcXG4gICAgICAgICAgZGVwdGgzICogJHtvfSArIGRlcHRoMjtcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtuLndpZHRofSwgJHtuLmhlaWdodH0sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBpLkdsc2xMaWJSb3V0aW5lKGQsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNkQodCxlLG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLG89cls1XSx1PXJbNF0qbyxjPXJbM10qdSxsPXJbMl0qYyxwPXJbMV0qbCx7bmV3U2hhcGU6ZixrZXB0RGltczpkfT0oMCxhLnNxdWVlemVTaGFwZSkocik7aWYoZi5sZW5ndGg8ci5sZW5ndGgpe2NvbnN0IG89KDAscy5zcXVlZXplSW5wdXRTaGFwZSkocixmKSxhPVtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIixcImRlcHRoNFwiXSx1PUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobikpO3UudW5wYWNrZWRTaGFwZT1vO2NvbnN0IGM9YFxcbiAgICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQodCxlLHUpLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICAgIGZsb2F0ICR7dH0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuICR7dH0oJHsoMCxzLmdldFNxdWVlemVkUGFyYW1zKShhLGQpfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShjLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIl0pfWNvbnN0IGg9YFxcbiAgICAgICAgICBmbG9hdCAke3R9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHtwfSArIGNvbCAqICR7bH0gKyBkZXB0aCAqICR7Y30gK1xcbiAgICAgICAgICAgIGRlcHRoMiAqICR7dX0gKyBkZXB0aDMgKiAke299ICsgZGVwdGg0O1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtlfSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgaS5HbHNsTGliUm91dGluZShoLFtcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIixcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX10b1ZlYygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQsZT10LnNoYXBlLmxlbmd0aCxuPXQuc3RyaWRlcyxyPXQud2lkdGgsbz10LmhlaWdodCxhPVtdO2ZvcihsZXQgdD0wO3Q8ZS0xOysrdClhLnB1c2goYFxcbiAgICAgICAgY1ske3R9XSA9IG9mZnNldCAvICR7blt0XX07YCksYS5wdXNoKGBcXG4gICAgICAgIG9mZnNldCAtPSBjWyR7dH1dICogJHtuW3RdfTtgKTthLnB1c2goYFxcbiAgICAgICAgY1ske2UtMX1dID0gb2Zmc2V0O2ApO2NvbnN0IHM9YFxcbiAgICAgIHZvaWQgdG9WZWModmVjMiB0ZXhDb29yZHMsIG91dCBpbnQgY1ske2V9XSkge1xcbiAgICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KHRleENvb3JkcywgJHtyfSwgJHtvfSk7XFxuICAgICAgICAke2Euam9pbihcIlwiKX1cXG4gICAgICB9XFxuICAgICAgdm9pZCB0b1ZlYyhpbnQgb2Zmc2V0LCBvdXQgaW50IGNbJHtlfV0pIHtcXG4gICAgICAgICR7YS5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm57dG9WZWM6bmV3IGkuR2xzbExpYlJvdXRpbmUocyxbXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9fXZhbHVlRnJvbSgpe2NvbnN0IHQ9e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKChlLG4pPT57Y29uc3Qgcj10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXSxvPShyLnVucGFja2VkU2hhcGUubGVuZ3RoPjA/ci51bnBhY2tlZFNoYXBlOnIuc2hhcGUpLmxlbmd0aDtsZXQgYT1gXyR7ZX1gO3RbYV09bmV3IGkuR2xzbExpYlJvdXRpbmUodGhpcy5nZXRWYWx1ZUZyb21TaW5nbGUoZSxvLHIud2lkdGgsci5oZWlnaHQsITEpLFtgc2hhcGVVdGlscy5pbmRpY2VzVG9PZmZzZXQke2F9YCxcImNvb3JkaW5hdGVzLm9mZnNldFRvQ29vcmRzXCIsXCJmcmFnY29sb3IuZ2V0Q29sb3JBc0Zsb2F0XCJdKSxhKz1cIl9UXCIsdFthXT1uZXcgaS5HbHNsTGliUm91dGluZSh0aGlzLmdldFZhbHVlRnJvbVNpbmdsZShlLG8sci53aWR0aCxyLmhlaWdodCwhMCksW2BzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7YX1gLFwiY29vcmRpbmF0ZXMub2Zmc2V0VG9Db29yZHNcIixcImZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXRcIl0pfSkpLHR9Z2V0VmFsdWVGcm9tU2luZ2xlKHQsZSxuLHIsaSl7bGV0IGE9YF8ke3R9YDtyZXR1cm4gaSYmKGErPVwiX1RcIiksYFxcbiAgICAgICAgZmxvYXQgJHthfShpbnQgbVske2V9XSkge1xcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0JHthfShtKTtcXG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bn0sICR7cn0pO1xcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgkeygwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKS50ZXh0dXJlMkR9KCR7dH0sIGNvb3JkcykpO1xcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBgfWdldFBhY2tlZFZhbHVlRnJvbSh0LGUsbixyLGkpe2xldCBhPWBfJHt0fV9QYWNrYDtyZXR1cm4gaSYmKGErPVwiX1RcIiksYFxcbiAgICAgICAgdmVjNCAke2F9KGludCBtWyR7ZX1dKSB7XFxuICAgICAgICAgIGludCBvZmZzZXQgPSBpbmRpY2VzVG9PZmZzZXRfJHt0fShtKTtcXG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bn0sICR7cn0pO1xcbiAgICAgICAgICByZXR1cm4gJHsoMCxvLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke3R9LCBjb29yZHMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgYH19ZS5Db29yZHNHbHNsTGliPXV9LDg1MjA6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lcz1lLkdsc2xMaWJSb3V0aW5lTm9kZT1lLkdsc2xMaWJSb3V0aW5lPWUuR2xzbExpYj1lLkdsc2xDb250ZXh0PWUuRnVuY3Rpb25UeXBlPXZvaWQgMCwobj1lLkZ1bmN0aW9uVHlwZXx8KGUuRnVuY3Rpb25UeXBlPXt9KSlbbi5WYWx1ZUJhc2VkPTBdPVwiVmFsdWVCYXNlZFwiLG5bbi5Qb3NpdGlvbmFsPTFdPVwiUG9zaXRpb25hbFwiLGUuR2xzbENvbnRleHQ9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4scil7dGhpcy5nbENvbnRleHQ9dCx0aGlzLnByb2dyYW1JbmZvPWUsdGhpcy5pbnB1dFRleHR1cmVMYXlvdXRzPW4sdGhpcy5vdXRwdXRUZXh0dXJlTGF5b3V0PXJ9fSxlLkdsc2xMaWI9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5jb250ZXh0PXR9fSxlLkdsc2xMaWJSb3V0aW5lPWNsYXNze2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5yb3V0aW5lQm9keT10LHRoaXMuZGVwZW5kZW5jaWVzPWV9fSxlLkdsc2xMaWJSb3V0aW5lTm9kZT1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy5uYW1lPXQsdGhpcy5kZXBlbmRlbmNpZXM9bnx8W10sZSYmKHRoaXMucm91dGluZUJvZHk9ZSl9YWRkRGVwZW5kZW5jeSh0KXt0JiZ0aGlzLmRlcGVuZGVuY2llcy5wdXNoKHQpfX0sZS5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXM9Y2xhc3N7c3RhdGljIHJldHVybk9yZGVyZWROb2Rlcyh0KXtpZighdHx8MD09PXQubGVuZ3RoKXJldHVybltdO2lmKDE9PT10Lmxlbmd0aClyZXR1cm4gdDtjb25zdCBlPW5ldyBTZXQsbj1uZXcgU2V0LHI9bmV3IEFycmF5O3JldHVybiB0aGlzLmNyZWF0ZU9yZGVyZWROb2Rlcyh0LGUsbixyKSxyfXN0YXRpYyBjcmVhdGVPcmRlcmVkTm9kZXModCxlLG4scil7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDsrK2kpdGhpcy5kZnNUcmF2ZXJzZSh0W2ldLGUsbixyKX1zdGF0aWMgZGZzVHJhdmVyc2UodCxlLG4scil7aWYoIXR8fG4uaGFzKHQubmFtZSkpcmV0dXJuO2lmKGUuaGFzKHQubmFtZSkpdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3kgZGV0ZWN0ZWQuIENhbid0IHRvcG9sb2dpY2FsbHkgc29ydCByb3V0aW5lcyBuZWVkZWQgZm9yIHNoYWRlci5cIik7ZS5hZGQodC5uYW1lKTtjb25zdCBpPXQuZGVwZW5kZW5jaWVzO2lmKGkmJmkubGVuZ3RoPjApZm9yKGxldCB0PTA7dDxpLmxlbmd0aDsrK3QpdGhpcy5kZnNUcmF2ZXJzZShpW3RdLGUsbixyKTtyLnB1c2godCksbi5hZGQodC5uYW1lKSxlLmRlbGV0ZSh0Lm5hbWUpfX19LDczNDE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuRW5jb2RpbmdHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCk7Y2xhc3MgaSBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuZW5jb2RlRmxvYXQzMigpKSx0aGlzLmRlY29kZUZsb2F0MzIoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1lbmNvZGVGbG9hdDMyKCl7cmV0dXJue2VuY29kZTpuZXcgci5HbHNsTGliUm91dGluZShcImhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KGYsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgIH1cXG4gICAgICAgIFwiKX19ZGVjb2RlRmxvYXQzMigpe3JldHVybntkZWNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJoaWdocCBmbG9hdCBkZWNvZGUoaGlnaHAgdmVjNCByZ2JhKSB7XFxuICAgICAgICByZXR1cm4gcmdiYS5yO1xcbiAgICAgIH1cXG4gICAgICAgIFwiKX19ZW5jb2RlVWludDgoKXtjb25zdCB0PWkuaXNMaXR0bGVFbmRpYW4oKT9cInJnYmEucmdiYT1yZ2JhLmFiZ3I7XCI6XCJcIjtyZXR1cm57ZW5jb2RlOm5ldyByLkdsc2xMaWJSb3V0aW5lKGBcXG4gICAgICBoaWdocCB2ZWM0IGVuY29kZShoaWdocCBmbG9hdCBmKSB7XFxuICAgICAgICBoaWdocCBmbG9hdCBGID0gYWJzKGYpO1xcbiAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IHN0ZXAoMC4wLC1mKTtcXG4gICAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XFxuICAgICAgICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IChleHAyKC0gRXhwb25lbnQpICogRik7XFxuICAgICAgICBFeHBvbmVudCA9IGZsb29yKGxvZzIoRikgKyAxMjcuMCkgKyBmbG9vcihsb2cyKE1hbnRpc3NhKSk7XFxuICAgICAgICBoaWdocCB2ZWM0IHJnYmE7XFxuICAgICAgICByZ2JhWzBdID0gMTI4LjAgKiBTaWduICArIGZsb29yKEV4cG9uZW50KmV4cDIoLTEuMCkpO1xcbiAgICAgICAgcmdiYVsxXSA9IDEyOC4wICogbW9kKEV4cG9uZW50LDIuMCkgKyBtb2QoZmxvb3IoTWFudGlzc2EqMTI4LjApLDEyOC4wKTtcXG4gICAgICAgIHJnYmFbMl0gPSBmbG9vcihtb2QoZmxvb3IoTWFudGlzc2EqZXhwMigyMy4wIC04LjApKSxleHAyKDguMCkpKTtcXG4gICAgICAgIHJnYmFbM10gPSBmbG9vcihleHAyKDIzLjApKm1vZChNYW50aXNzYSxleHAyKC0xNS4wKSkpO1xcbiAgICAgICAgJHt0fVxcbiAgICAgICAgcmdiYSA9IHJnYmEgLyAyNTUuMDsgLy8gdmFsdWVzIG5lZWQgdG8gYmUgbm9ybWFsaXplZCB0byBbMCwxXVxcbiAgICAgICAgcmV0dXJuIHJnYmE7XFxuICAgIH1cXG4gICAgICAgIGApfX1kZWNvZGVVaW50OCgpe2NvbnN0IHQ9aS5pc0xpdHRsZUVuZGlhbigpP1wicmdiYS5yZ2JhPXJnYmEuYWJncjtcIjpcIlwiO3JldHVybntkZWNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgaGlnaHAgZmxvYXQgZGVjb2RlKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgICAgICAgICByZ2JhID0gcmdiYSAqIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBkZS1ub3JtYWxpemVkIGZyb20gWzAsMV0gdG8gWzAsMjU1XVxcbiAgICAgICAgICAke3R9XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyOC4wLHJnYmFbMF0pKjIuMDtcXG4gICAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSAyLjAgKiBtb2QocmdiYVswXSwxMjguMCkgKyBzdGVwKDEyOC4wLHJnYmFbMV0pIC0gMTI3LjA7XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMV0sMTI4LjApKjY1NTM2LjAgKyByZ2JhWzJdKjI1Ni4wICtyZ2JhWzNdICsgZmxvYXQoMHg4MDAwMDApO1xcbiAgICAgICAgICBoaWdocCBmbG9hdCBSZXN1bHQgPSAgU2lnbiAqIGV4cDIoRXhwb25lbnQpICogKE1hbnRpc3NhICogZXhwMigtMjMuMCApKTtcXG4gICAgICAgICAgcmV0dXJuIFJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgICBgKX19c3RhdGljIGlzTGl0dGxlRW5kaWFuKCl7Y29uc3QgdD1uZXcgQXJyYXlCdWZmZXIoNCksZT1uZXcgVWludDMyQXJyYXkodCksbj1uZXcgVWludDhBcnJheSh0KTtpZihlWzBdPTM3MzU5Mjg1NTksMjM5PT09blswXSlyZXR1cm4hMDtpZigyMjI9PT1uWzBdKXJldHVybiExO3Rocm93IG5ldyBFcnJvcihcInVua25vd24gZW5kaWFubmVzc1wiKX19ZS5FbmNvZGluZ0dsc2xMaWI9aX0sOTg5NDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5GcmFnQ29sb3JHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCksaT1uKDUwNjApO2NsYXNzIG8gZXh0ZW5kcyByLkdsc2xMaWJ7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9Z2V0RnVuY3Rpb25zKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLnNldEZyYWdDb2xvcigpKSx0aGlzLmdldENvbG9yQXNGbG9hdCgpKX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fXNldEZyYWdDb2xvcigpe2NvbnN0IHQ9KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO3JldHVybntzZXRGcmFnQ29sb3I6bmV3IHIuR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgdm9pZCBzZXRGcmFnQ29sb3IoZmxvYXQgdmFsdWUpIHtcXG4gICAgICAgICAgICAke3Qub3V0cHV0fSA9IGVuY29kZSh2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICBgLFtcImVuY29kaW5nLmVuY29kZVwiXSl9fWdldENvbG9yQXNGbG9hdCgpe3JldHVybntnZXRDb2xvckFzRmxvYXQ6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgICAgIGZsb2F0IGdldENvbG9yQXNGbG9hdCh2ZWM0IGNvbG9yKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZShjb2xvcik7XFxuICAgICAgICB9XFxuICAgICAgICBcIixbXCJlbmNvZGluZy5kZWNvZGVcIl0pfX19ZS5GcmFnQ29sb3JHbHNsTGliPW99LDI4NDg6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlcGxhY2VJbmxpbmVzPXZvaWQgMDtjb25zdCBuPS9AaW5saW5lW1xcc1xcblxccl0rKFxcdyspW1xcc1xcblxccl0rKFswLTlhLXpBLVpfXSspXFxzKlxcKChbXildKilcXClcXHMqeygoW159XXxbXFxuXFxyXSkqKX0vZ207ZS5yZXBsYWNlSW5saW5lcz1mdW5jdGlvbih0KXtjb25zdCBlPXt9O2xldCByO2Zvcig7bnVsbCE9PShyPW4uZXhlYyh0KSk7KXtjb25zdCB0PXJbM10uc3BsaXQoXCIsXCIpLm1hcCgodD0+e2NvbnN0IGU9dC50cmltKCkuc3BsaXQoXCIgXCIpO3JldHVybiBlJiYyPT09ZS5sZW5ndGg/e3R5cGU6ZVswXSxuYW1lOmVbMV19Om51bGx9KSkuZmlsdGVyKCh0PT5udWxsIT09dCkpO2VbclsyXV09e3BhcmFtczp0LGJvZHk6cls0XX19Zm9yKGNvbnN0IG4gaW4gZSl7Y29uc3QgaT1cIihcXFxcdyspP1xcXFxzKyhbXzAtOWEtekEtWl0rKVxcXFxzKz1cXFxccytfX0ZVTkNfX1xcXFwoKC4qKVxcXFwpXFxcXHMqO1wiLnJlcGxhY2UoXCJfX0ZVTkNfX1wiLG4pLG89bmV3IFJlZ0V4cChpLFwiZ21cIik7Zm9yKDtudWxsIT09KHI9by5leGVjKHQpKTspe2NvbnN0IGk9clsxXSxvPXJbMl0sYT1yWzNdLnNwbGl0KFwiLFwiKSxzPWk/YCR7aX0gJHtvfTtgOlwiXCI7bGV0IHU9ZVtuXS5ib2R5LGM9XCJcIjtlW25dLnBhcmFtcy5mb3JFYWNoKCgodCxlKT0+e3QmJihjKz1gJHt0LnR5cGV9ICR7dC5uYW1lfSA9ICR7YVtlXX07XFxuYCl9KSksdT1gJHtjfVxcbiAke3V9YCx1PXUucmVwbGFjZShcInJldHVyblwiLGAke299ID0gYCk7Y29uc3QgbD1gXFxuICAgICAgJHtzfVxcbiAgICAgIHtcXG4gICAgICAgICR7dX1cXG4gICAgICB9XFxuICAgICAgYDt0PXQucmVwbGFjZShyWzBdLGwpfX1yZXR1cm4gdC5yZXBsYWNlKG4sXCJcIil9fSw4ODc5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLkdsc2xQcmVwcm9jZXNzb3I9dm9pZCAwO2NvbnN0IHI9big4NTIwKSxpPW4oMjg0OCksbz1uKDU0ODMpLGE9big1MDYwKTtlLkdsc2xQcmVwcm9jZXNzb3I9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4saSl7dGhpcy5saWJzPXt9LHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg9e30sdGhpcy5jb250ZXh0PW5ldyByLkdsc2xDb250ZXh0KHQsZSxuLGkpLE9iamVjdC5rZXlzKG8uZ2xzbFJlZ2lzdHJ5KS5mb3JFYWNoKCh0PT57Y29uc3QgZT1uZXcgby5nbHNsUmVnaXN0cnlbdF0odGhpcy5jb250ZXh0KTt0aGlzLmxpYnNbdF09ZX0pKTtjb25zdCBhPXRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg7Zm9yKGNvbnN0IHQgaW4gdGhpcy5saWJzKXtjb25zdCBlPXRoaXMubGlic1t0XS5nZXRGdW5jdGlvbnMoKTtmb3IoY29uc3QgbiBpbiBlKXtjb25zdCBpPXQrXCIuXCIrbjtsZXQgbzthW2ldPyhvPWFbaV0sby5yb3V0aW5lQm9keT1lW25dLnJvdXRpbmVCb2R5KToobz1uZXcgci5HbHNsTGliUm91dGluZU5vZGUoaSxlW25dLnJvdXRpbmVCb2R5KSxhW2ldPW8pO2NvbnN0IHM9ZVtuXS5kZXBlbmRlbmNpZXM7aWYocylmb3IobGV0IHQ9MDt0PHMubGVuZ3RoOysrdClpZihhW3NbdF1dKW8uYWRkRGVwZW5kZW5jeShhW3NbdF1dKTtlbHNle2NvbnN0IGU9bmV3IHIuR2xzbExpYlJvdXRpbmVOb2RlKHNbdF0pO2Fbc1t0XV09ZSxvLmFkZERlcGVuZGVuY3koZSl9fX19cHJlcHJvY2Vzcygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0LnByb2dyYW1JbmZvO2xldCBlPXQuc2hhZGVyU291cmNlO3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaGFzTWFpbnx8KGU9YCR7ZX1cXG4gICAgICAkeygwLGEuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24sdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoKX1gKSxlPSgwLGkucmVwbGFjZUlubGluZXMpKGUpLGAkeygwLGEuZ2V0RnJhZ1NoYWRlclByZWFtYmxlKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pfVxcbiAgICAke3RoaXMuZ2V0VW5pZm9ybXModC5pbnB1dE5hbWVzLHQudmFyaWFibGVzKX1cXG4gICAgJHt0aGlzLmdldEltcG9ydHMoZSl9XFxuICAgICR7ZX1gfWdldEltcG9ydHModCl7Y29uc3QgZT10aGlzLnNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZCh0KTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuXCJcIjtsZXQgbj1cIlwiO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtpZighZVt0XS5yb3V0aW5lQm9keSl0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYm9keSBmb3IgdGhlIEdsc2wgTGlicmFyeSByb3V0aW5lOiAke2VbdF0ubmFtZX1gKTtuKz1lW3RdLnJvdXRpbmVCb2R5K1wiXFxuXCJ9cmV0dXJuIG59c2VsZWN0R2xzbExpYlJvdXRpbmVzVG9CZUluY2x1ZGVkKHQpe2NvbnN0IGU9W107cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGgpLmZvckVhY2goKG49Pntjb25zdCByPW4uc3BsaXQoXCIuXCIpWzFdOy0xIT09dC5pbmRleE9mKHIpJiZlLnB1c2godGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaFtuXSl9KSksci5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMucmV0dXJuT3JkZXJlZE5vZGVzKGUpfWdldFVuaWZvcm1zKHQsZSl7Y29uc3Qgbj1bXTtpZih0KWZvcihjb25zdCBlIG9mIHQpbi5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCAke2V9O2ApO2lmKGUpZm9yKGNvbnN0IHQgb2YgZSluLnB1c2goYHVuaWZvcm0gJHt0LnR5cGV9ICR7dC5uYW1lfSR7dC5hcnJheUxlbmd0aD9gWyR7dC5hcnJheUxlbmd0aH1dYDpcIlwifTtgKTtyZXR1cm4gbi5qb2luKFwiXFxuXCIpfX19LDU0ODM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZ2xzbFJlZ2lzdHJ5PXZvaWQgMDtjb25zdCByPW4oNTEwNyksaT1uKDczNDEpLG89big5ODk0KSxhPW4oMjY1NSkscz1uKDM4OTEpO2UuZ2xzbFJlZ2lzdHJ5PXtlbmNvZGluZzppLkVuY29kaW5nR2xzbExpYixmcmFnY29sb3I6by5GcmFnQ29sb3JHbHNsTGliLHZlYzpzLlZlY0dsc2xMaWIsc2hhcGVVdGlsczphLlNoYXBlVXRpbHNHbHNsTGliLGNvb3JkaW5hdGVzOnIuQ29vcmRzR2xzbExpYn19LDI2NTU6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuU2hhcGVVdGlsc0dsc2xMaWI9dm9pZCAwO2NvbnN0IHI9big4NTIwKTtjbGFzcyBpIGV4dGVuZHMgci5HbHNsTGlie2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdGhpcy5iY2FzdEluZGV4KCkpLHRoaXMuYmNhc3RNYXRtdWxJbmRleCgpKSx0aGlzLm9mZnNldFRvSW5kaWNlcygpKSx0aGlzLmluZGljZXNUb09mZnNldCgpKSx0aGlzLmluY3JlbWVudEluZGljZXMoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1iY2FzdEluZGV4KCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4saSk9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnVucGFja2VkU2hhcGU7aWYoby5sZW5ndGg8PXQpe2NvbnN0IGk9by5sZW5ndGgsYT10LWkscz1gYmNhc3RJbmRpY2VzXyR7bn1gO2xldCB1PVwiXCI7Zm9yKGxldCB0PTA7dDxpOysrdCl1Kz1gXFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7dH1dID0gaW50KCBtb2QoZmxvYXQoYmNhc3RlZEluZGljZXNbJHthK3R9XSksICR7b1t0XX0uMCkgKTtcXG4gICAgICAgICAgYDtjb25zdCBjPWBcXG4gICAgICAgIHZvaWQgJHtzfSAoaW50IGJjYXN0ZWRJbmRpY2VzWyR7dH1dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7aX1dKSB7XFxuICAgICAgICAgICR7dX1cXG4gICAgICAgIH1cXG4gICAgICAgIGA7ZVtzXT1uZXcgci5HbHNsTGliUm91dGluZShjKX19KSksZX1iY2FzdE1hdG11bEluZGV4KCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGgsZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4saSk9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW2ldLnNoYXBlO2lmKCEoby5sZW5ndGg8Mnx8by5sZW5ndGg+dCkpe2NvbnN0IGk9by5sZW5ndGgsYT10LWkscz1gYmNhc3RNYXRtdWxJbmRpY2VzXyR7bn1gO2xldCB1PVwiXCI7Zm9yKGxldCB0PTA7dDxpLTI7Kyt0KXUrPWBcXG4gICAgICAgICAgcmVhbEluZGljZXNbJHt0fV0gPSBpbnQoIG1vZChmbG9hdChiY2FzdGVkSW5kaWNlc1ske2ErdH1dKSwgJHtvW3RdfS4wKSApO1xcbiAgICAgICAgICBgO2NvbnN0IGM9YFxcbiAgICAgICAgdm9pZCAke3N9KGludCBiY2FzdGVkSW5kaWNlc1ske3R9XSwgb3V0IGludCByZWFsSW5kaWNlc1ske2l9XSkge1xcbiAgICAgICAgICAke3V9XFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7aS0xfV0gPSBiY2FzdGVkSW5kaWNlc1ske3QtMX1dO1xcbiAgICAgICAgICByZWFsSW5kaWNlc1ske2ktMn1dID0gYmNhc3RlZEluZGljZXNbJHt0LTJ9XTtcXG4gICAgICAgIH1cXG4gICAgICAgIGA7ZVtzXT1uZXcgci5HbHNsTGliUm91dGluZShjKX19KSksZX1pbmRpY2VzVG9PZmZzZXQoKXtjb25zdCB0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IG89dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsYT10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXS5zdHJpZGVzLHM9by5sZW5ndGg7bGV0IHU9YGluZGljZXNUb09mZnNldF8ke2V9YDt0W3VdPW5ldyByLkdsc2xMaWJSb3V0aW5lKGkuaW5kZXhUb09mZnNldFNpbmdsZSh1LHMsYSkpLHU9YGluZGljZXNUb09mZnNldF8ke2V9X1RgLHRbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoaS5pbmRleFRvT2Zmc2V0U2luZ2xlKHUscyxhLnNsaWNlKCkucmV2ZXJzZSgpKSl9KSksdH1zdGF0aWMgaW5kZXhUb09mZnNldFNpbmdsZSh0LGUsbil7bGV0IHI9XCJcIjtmb3IobGV0IHQ9ZS0xO3Q+PTA7LS10KXIrPWBcXG4gICAgICAgIG9mZnNldCArPSBpbmRpY2VzWyR7dH1dICogJHtuW3RdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGludCAke3R9KGludCBpbmRpY2VzWyR7ZX1dKSB7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgICR7cn1cXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XFxuICAgICAgfVxcbiAgICAgIGB9b2Zmc2V0VG9JbmRpY2VzKCl7Y29uc3QgdD17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKGUsbik9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW25dLnNoYXBlLGE9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc3RyaWRlcyxzPW8ubGVuZ3RoO2xldCB1PWBvZmZzZXRUb0luZGljZXNfJHtlfWA7dFt1XT1uZXcgci5HbHNsTGliUm91dGluZShpLm9mZnNldFRvSW5kaWNlc1NpbmdsZSh1LHMsYSkpLHU9YG9mZnNldFRvSW5kaWNlc18ke2V9X1RgLHRbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoaS5vZmZzZXRUb0luZGljZXNTaW5nbGUodSxzLGEuc2xpY2UoKS5yZXZlcnNlKCkpKX0pKSx0fXN0YXRpYyBvZmZzZXRUb0luZGljZXNTaW5nbGUodCxlLG4pe2NvbnN0IHI9W107Zm9yKGxldCB0PTA7dDxlLTE7Kyt0KXIucHVzaChgXFxuICAgICAgaW5kaWNlc1ske3R9XSA9IG9mZnNldCAvICR7blt0XX07YCksci5wdXNoKGBcXG4gICAgICAgIG9mZnNldCAtPSBpbmRpY2VzWyR7dH1dICogJHtuW3RdfTtgKTtyZXR1cm4gci5wdXNoKGBcXG4gICAgICBpbmRpY2VzWyR7ZS0xfV0gPSBvZmZzZXQ7YCksYFxcbiAgICAgIHZvaWQgJHt0fShpbnQgb2Zmc2V0LCBvdXQgaW50IGluZGljZXNbJHtlfV0pIHtcXG4gICAgICAgICR7ci5qb2luKFwiXCIpfVxcbiAgICAgIH1cXG4gICAgICBgfWluY3JlbWVudEluZGljZXMoKXtjb25zdCB0PXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IGk9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc2hhcGUsbz1pLmxlbmd0aCxhPWBpbmNyZW1lbnRJbmRpY2VzXyR7ZX1gO2xldCBzPVwiXCI7Zm9yKGxldCB0PTA7dDxvOysrdClzKz1gXFxuICAgICAgICBzaGFwZVske3R9XSA9ICR7aVt0XX07YDtjb25zdCB1PWBcXG4gICAgICAgIHZvaWQgJHthfShpbnQgYXhpcywgb3V0IGludCBpbmRpY2VzWyR7b31dKSB7XFxuICAgICAgICAgIGludCBzaGFwZVske299XTtcXG4gICAgICAgICAgJHtzfTtcXG4gICAgICAgICAgZm9yKGludCBpID0gJHtvfSAtMSA7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICAgICAgaWYoaSA+IGF4aXMpIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIGluZGljZXNbaV0gKz0gMTtcXG4gICAgICAgICAgICBpZihpbmRpY2VzW2ldIDwgc2hhcGVbaV0pIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbmRpY2VzW2ldID0gMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgYDt0W2FdPW5ldyByLkdsc2xMaWJSb3V0aW5lKHUpfSkpLHR9fWUuU2hhcGVVdGlsc0dsc2xMaWI9aX0sNTA2MDoodCxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluPWUuZ2V0RnJhZ1NoYWRlclByZWFtYmxlPWUuZ2V0VmVydGV4U2hhZGVyU291cmNlPWUuZ2V0R2xzbD12b2lkIDA7Y29uc3Qgbj17dmVyc2lvbjpcIlwiLGF0dHJpYnV0ZTpcImF0dHJpYnV0ZVwiLHZhcnlpbmdWZXJ0ZXg6XCJ2YXJ5aW5nXCIsdmFyeWluZ0ZyYWc6XCJ2YXJ5aW5nXCIsdGV4dHVyZTJEOlwidGV4dHVyZTJEXCIsb3V0cHV0OlwiZ2xfRnJhZ0NvbG9yXCIsb3V0cHV0RGVjbGFyYXRpb246XCJcIn0scj17dmVyc2lvbjpcIiN2ZXJzaW9uIDMwMCBlc1wiLGF0dHJpYnV0ZTpcImluXCIsdmFyeWluZ1ZlcnRleDpcIm91dFwiLHZhcnlpbmdGcmFnOlwiaW5cIix0ZXh0dXJlMkQ6XCJ0ZXh0dXJlXCIsb3V0cHV0Olwib3V0cHV0Q29sb3JcIixvdXRwdXREZWNsYXJhdGlvbjpcIm91dCB2ZWM0IG91dHB1dENvbG9yO1wifTtmdW5jdGlvbiBpKHQpe3JldHVybiAxPT09dD9uOnJ9ZS5nZXRHbHNsPWksZS5nZXRWZXJ0ZXhTaGFkZXJTb3VyY2U9ZnVuY3Rpb24odCl7Y29uc3QgZT1pKHQpO3JldHVybmAke2UudmVyc2lvbn1cXG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgICAgJHtlLmF0dHJpYnV0ZX0gdmVjMyBwb3NpdGlvbjtcXG4gICAgICAke2UuYXR0cmlidXRlfSB2ZWMyIHRleHR1cmVDb29yZDtcXG5cXG4gICAgICAke2UudmFyeWluZ1ZlcnRleH0gdmVjMiBUZXhDb29yZHM7XFxuXFxuICAgICAgdm9pZCBtYWluKClcXG4gICAgICB7XFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4gICAgICAgICAgVGV4Q29vcmRzID0gdGV4dHVyZUNvb3JkO1xcbiAgICAgIH1gfSxlLmdldEZyYWdTaGFkZXJQcmVhbWJsZT1mdW5jdGlvbih0KXtjb25zdCBlPWkodCk7cmV0dXJuYCR7ZS52ZXJzaW9ufVxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XFxuICAgICR7ZS52YXJ5aW5nRnJhZ30gdmVjMiBUZXhDb29yZHM7XFxuICAgICR7ZS5vdXRwdXREZWNsYXJhdGlvbn1cXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gICAgLy8gQ3VzdG9tIHZlY3RvciB0eXBlcyB0byBoYW5kbGUgaGlnaGVyIGRpbWVuYWxpdGllcy5cXG4gICAgc3RydWN0IGl2ZWM1XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgfTtcXG5cXG4gICAgc3RydWN0IGl2ZWM2XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgICBpbnQgdjtcXG4gICAgfTtcXG5cXG4gICAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XFxuICAgICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcXG4gICAgfVxcblxcbiAgICBgfSxlLmdldERlZmF1bHRGcmFnU2hhZGVyTWFpbj1mdW5jdGlvbih0LGUpe3JldHVybmBcXG4gIHZvaWQgbWFpbigpIHtcXG4gICAgaW50IGluZGljZXNbJHtlfV07XFxuICAgIHRvVmVjKFRleENvb3JkcywgaW5kaWNlcyk7XFxuICAgIHZlYzQgcmVzdWx0ID0gdmVjNChwcm9jZXNzKGluZGljZXMpKTtcXG4gICAgJHtpKHQpLm91dHB1dH0gPSByZXN1bHQ7XFxuICB9XFxuICBgfX0sMzg5MToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5WZWNHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oODUyMCk7Y2xhc3MgaSBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXRDdXN0b21UeXBlcygpe3JldHVybnt9fWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuYmluYXJ5VmVjRnVuY3Rpb25zKCkpLHRoaXMuY29weVZlYygpKSx0aGlzLnNldFZlY0l0ZW0oKSksdGhpcy5nZXRWZWNJdGVtKCkpfWJpbmFyeVZlY0Z1bmN0aW9ucygpe2NvbnN0IHQ9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoLGU9e2FkZDpcIis9XCIsc3ViOlwiLT1cIixtdWw6XCIqPVwiLGRpdjpcIi89XCJ9LG49e307Zm9yKGNvbnN0IGkgaW4gZSl7Y29uc3Qgbz1gJHtpfVZlY2A7bGV0IGE9XCJcIjtmb3IobGV0IG49MDtuPHQ7KytuKWErPWBcXG4gICAgICAgICAgZGVzdFske259XSAke2VbaV19IHNyY1ske259XTtcXG4gICAgICAgICAgYDtjb25zdCBzPWBcXG4gICAgICAgIHZvaWQgJHtvfShpbnQgc3JjWyR7dH1dLCBvdXQgaW50IGRlc3RbJHt0fV0pIHtcXG4gICAgICAgICAgJHthfVxcbiAgICAgICAgfVxcbiAgICAgICAgYDtuW29dPW5ldyByLkdsc2xMaWJSb3V0aW5lKHMpfXJldHVybiBufWNvcHlWZWMoKXtjb25zdCB0PXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtsZXQgZT1cIlwiO2ZvcihsZXQgbj0wO248dDsrK24pZSs9YFxcbiAgICAgICAgZGVzdFske259XSA9IHNyY1ske259XTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgdm9pZCBjb3B5VmVjKGludCBzcmNbJHt0fV0sIG91dCBpbnQgZGVzdFske3R9XSkge1xcbiAgICAgICAgJHtlfVxcbiAgICAgIH1cXG4gICAgICBgO3JldHVybntjb3B5VmVjOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX1zZXRWZWNJdGVtKCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IGU9YFxcbiAgICAgICAgaWYoaW5kZXggPCAwKVxcbiAgICAgICAgICAgIGluZGV4ID0ke3R9ICsgaW5kZXg7XFxuICAgICAgICBpZiAoaW5kZXggPT0gMClcXG4gICAgICAgICAgICBtWzBdID0gdmFsdWU7XFxuICAgICAgICBgO2ZvcihsZXQgbj0xO248dC0xOysrbillKz1gXFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke259KVxcbiAgICAgICAgICAgIG1bJHtufV0gPSB2YWx1ZTtcXG4gICAgICAgICAgICBgO2UrPWBcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICBtWyR7dC0xfV0gPSB2YWx1ZTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgdm9pZCBzZXRWZWNJdGVtKG91dCBpbnQgbVske3R9XSwgaW50IGluZGV4LCBpbnQgdmFsdWUpIHtcXG4gICAgICAgICR7ZX1cXG4gICAgICB9XFxuICAgICAgICBgO3JldHVybntzZXRWZWNJdGVtOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX1nZXRWZWNJdGVtKCl7Y29uc3QgdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IGU9YFxcbiAgICAgICAgaWYoaW5kZXggPCAwKVxcbiAgICAgICAgICAgIGluZGV4ID0gJHt0fSArIGluZGV4O1xcbiAgICAgICAgaWYgKGluZGV4ID09IDApXFxuICAgICAgICAgICAgcmV0dXJuIG1bMF07XFxuICAgICAgYDtmb3IobGV0IG49MTtuPHQtMTsrK24pZSs9YFxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gJHtufSlcXG4gICAgICAgICAgICByZXR1cm4gbVske259XTtcXG4gICAgICBgO2UrPWBcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgICByZXR1cm4gbVske3QtMX1dO1xcbiAgICAgICAgYDtjb25zdCBuPWBcXG4gICAgICBpbnQgZ2V0VmVjSXRlbShpbnQgbVske3R9XSwgaW50IGluZGV4KSB7XFxuICAgICAgICAke2V9XFxuICAgICAgfVxcbiAgICBgO3JldHVybntnZXRWZWNJdGVtOm5ldyByLkdsc2xMaWJSb3V0aW5lKG4pfX19ZS5WZWNHbHNsTGliPWl9LDgzMTY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuV2ViR0xJbmZlcmVuY2VIYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oNjIzMSksaT1uKDkxNjIpLG89bigyNTE3KSxhPW4oMjQwMykscz1uKDcwMTkpLHU9big4NzEwKSxjPW4oNTYxMSksbD1uKDQwNTcpLHA9bigyMDM5KTtlLldlYkdMSW5mZXJlbmNlSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnNlc3Npb249dCx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfWNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0LGUpe3JldHVybigwLGwuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksdCxlKX1leGVjdXRlUHJvZ3JhbSh0LGUpe2lmKGUubGVuZ3RoPHQuaW5wdXROYW1lcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaXplIG11c3RuJ3QgYmUgbGVzcyB0aGFuICR7dC5pbnB1dE5hbWVzLmxlbmd0aH0uYCk7aWYodC5pbnB1dE5hbWVzLmxlbmd0aCE9PXQuaW5wdXRUeXBlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgbmFtZXMgc2l6ZSBkb2VzIG5vdCBtYXRjaCBpbnB1dCB0eXBlc1wiKTtjb25zdCBuPVtdO2ZvcihsZXQgcj0wO3I8dC5pbnB1dE5hbWVzLmxlbmd0aDsrK3IpbltyXT10aGlzLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoZVtyXSx0LmlucHV0VHlwZXNbcl0pO2NvbnN0IHI9KCh0LGUpPT57Y29uc3Qgbj1lLm1hcCgodD0+YCR7dC51bnBhY2tlZFNoYXBlLmpvaW4oXCIsXCIpfTske3Qud2lkdGh9eCR7dC5oZWlnaHR9YCkpLmpvaW4oXCJfXCIpO2xldCByPXQubmFtZTtyZXR1cm4gdC5jYWNoZUhpbnQmJihyKz1cIltcIit0LmNhY2hlSGludCtcIl1cIikscis9XCI6XCIrbixyfSkodCxuKTtsZXQgaT10aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qocik7Y29uc3Qgbz1pP2kucHJvZ3JhbUluZm86XCJmdW5jdGlvblwiPT10eXBlb2YgdC5nZXQ/dC5nZXQoKTp0LGE9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksby5vdXRwdXQuZGltcyxvLm91dHB1dC50ZXh0dXJlVHlwZSkscz10aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGEsby5vdXRwdXQudHlwZSk7cmV0dXJuIGl8fChpPXRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5idWlsZChvLG4scyksdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KHIsaSkpLHRoaXMucnVuUHJvZ3JhbShpLG4scyksc31ydW4odCxlKXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbSh0LGUpLnRlbnNvcn1ydW5Qcm9ncmFtKHQsZSxuKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZighIWVbbl0uaXNQYWNrZWQhPSh0LnByb2dyYW1JbmZvLmlucHV0VHlwZXNbbl09PT1wLlRleHR1cmVUeXBlLnBhY2tlZCkpdGhyb3cgbmV3IEVycm9yKGBpbnB1dFske259XSBwcm9wZXJ0eSBwYWNrZWQgaW5jb25zaXN0ZW50YCk7aWYoISFuLmlzUGFja2VkIT0odC5wcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGU9PT1wLlRleHR1cmVUeXBlLnBhY2tlZCkpdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0IHByb3BlcnR5IHBhY2tlZCBpbmNvbnNpc3RlbnRcIik7dGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnJ1bih0LGUsbil9Z2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LGUpe2xldCBuPXRoaXMuZ2V0VGV4dHVyZURhdGEodC5kYXRhSWQsZT09PXAuVGV4dHVyZVR5cGUucGFja2VkKTtpZighbiYmKG49dGhpcy5nZXRUZXh0dXJlRGF0YSh0LmRhdGFJZCxlIT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpLG4pKXJldHVybiBlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWQ/dGhpcy5wYWNrKG4pOnRoaXMudW5wYWNrKG4pO2lmKCFuKXtjb25zdCByPSgwLGwuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LHQuZGltcyxlKTtpZihlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKXtjb25zdCBuPTEscj00LGk9dC5kaW1zO2lmKDQ9PT1pLmxlbmd0aCl7Y29uc3Qgbz1baVswXSxNYXRoLmNlaWwoaVsxXSppWzJdKmlbM10vcildLGE9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksbyxlKTtsZXQgcz10Lm51bWJlckRhdGE7aWYoaVsxXSppWzJdKmlbM10lciE9MCl7Y29uc3QgZT1pWzBdLG89aVsxXSppWzJdKmlbM10sYT1NYXRoLmNlaWwobypuL3IpKnI7cz1uZXcgRmxvYXQzMkFycmF5KGUqYSk7Zm9yKGxldCByPTA7cjxlOysrcil7Y29uc3QgZT1yKm8saT1yKmErciVuKm87cy5zZXQodC5udW1iZXJEYXRhLnN1YmFycmF5KGUsZStvKSxpKX19cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGEoYSx0LnR5cGUscyx0LDEpfX1pZihlPT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpe2NvbnN0IGU9KDAsbC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksdC5kaW1zLDEsW10se3JldmVyc2VXSDohMH0pLHI9dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShlLHQudHlwZSx0Lm51bWJlckRhdGEsdCwxKTtuPXRoaXMucGFjayhyKX1lbHNlIG49dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShyLHQudHlwZSx0Lm51bWJlckRhdGEsdCwxKX1yZXR1cm4gbn1jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXRCaW5kVGVuc29yKHQsZSxuLHIpe3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKHQsZSxuLHIsMSl9Y3JlYXRlVGV4dHVyZURhdGEodCxlLG4saSxvKXtyLkxvZ2dlci52ZXJib3NlKFwiSW5mZXJlbmNlSGFuZGxlclwiLGBDcmVhdGluZyBUZXh0dXJlRGF0YTogbGF5b3V0Olske0pTT04uc3RyaW5naWZ5KHQpfV1gKTtjb25zdCBhPXRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5jcmVhdGVUZXh0dXJlRnJvbUxheW91dChlLHQsbixvKTtyZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKHQsZSxhLGkpfXJlc2hhcGVVbnBhY2tlZCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS51bnBhY2tlZCkscj17Y2hhbm5lbHM6bi5jaGFubmVscyxoZWlnaHQ6bi5oZWlnaHQsd2lkdGg6bi53aWR0aCxzaGFwZTowIT09ZS5sZW5ndGg/ZTpbMV0sc3RyaWRlczpvLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlKSx1bnBhY2tlZFNoYXBlOmV9O3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUocix0LnR5cGUsbi50ZXh0dXJlKS50ZW5zb3J9cmVzaGFwZVBhY2tlZCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS5wYWNrZWQpO2lmKCgwLHMuaXNSZXNoYXBlQ2hlYXApKHQuZGltcyxlKSl7Y29uc3Qgcj17Y2hhbm5lbHM6bi5jaGFubmVscyxoZWlnaHQ6bi5oZWlnaHQsd2lkdGg6bi53aWR0aCxzaGFwZTowIT09ZS5sZW5ndGg/ZTpbMV0sc3RyaWRlczpvLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhlKSx1bnBhY2tlZFNoYXBlOmUsaXNQYWNrZWQ6ITB9O3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUocix0LnR5cGUsbi50ZXh0dXJlKS50ZW5zb3J9Y29uc3Qgcj0oMCxzLnByb2Nlc3NEaW1zM0QpKHQuZGltcyksaT0oMCxzLnByb2Nlc3NEaW1zM0QpKGUpLGE9dGhpcy5yZXNoYXBlUGFja2VkKHQsciksdT10aGlzLnJ1bigoMCxzLmNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyKSh0aGlzLGEsaSksW2FdKTtyZXR1cm4gdGhpcy5yZXNoYXBlUGFja2VkKHUsZSl9Y2FzdCh0LGUpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQscC5UZXh0dXJlVHlwZS51bnBhY2tlZCk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShuLGUsbi50ZXh0dXJlKS50ZW5zb3J9Y3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZSh0LGUsbixyLG8pe2NvbnN0IGE9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHt0ZW5zb3I6cnx8bmV3IGkuVGVuc29yKHQudW5wYWNrZWRTaGFwZSxlLCh0PT50aGlzLnJlYWRUZXh0dXJlKGEpKSwoYXN5bmMgdD0+dGhpcy5yZWFkVGV4dHVyZUFzeW5jKGEpKSx2b2lkIDAsbyksdGV4dHVyZTpufSk7cmV0dXJuIHRoaXMuc2V0VGV4dHVyZURhdGEoYS50ZW5zb3IuZGF0YUlkLGEsdC5pc1BhY2tlZCksYX1nZXRUZXh0dXJlRGF0YSh0LGU9ITEpe3JldHVybiB0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0KT90aGlzLnNlc3Npb24uZ2V0VGV4dHVyZURhdGEodCxlKTplP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodCk6dGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHQpfXNldFRleHR1cmVEYXRhKHQsZSxuPSExKXt0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0KT90aGlzLnNlc3Npb24uc2V0VGV4dHVyZURhdGEodCxlLG4pOihuP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZTp0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSkuc2V0KHQsZSl9aXNUZXh0dXJlTGF5b3V0Q2FjaGVkKHQsZT0hMSl7cmV0dXJuISF0aGlzLmdldFRleHR1cmVEYXRhKHQuZGF0YUlkLGUpfWRpc3Bvc2UoKXt0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKCh0PT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCkpKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKCh0PT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCkpKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlYWRUZXh0dXJlKHQpe3JldHVybiB0LmlzUGFja2VkP3RoaXMucmVhZFRleHR1cmUodGhpcy51bnBhY2sodCkpOnRoaXMuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD90aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmUodCx0LnRlbnNvci50eXBlLHQuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCgoMCx1LmVuY29kZUFzVWludDgpKHRoaXMsdCkpfWFzeW5jIHJlYWRUZXh0dXJlQXN5bmModCl7cmV0dXJuIHQuaXNQYWNrZWQ/dGhpcy5yZWFkVGV4dHVyZUFzeW5jKHRoaXMudW5wYWNrKHQpKTp0aGlzLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ/dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlQXN5bmModCx0LnRlbnNvci50eXBlLHQuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCgoMCx1LmVuY29kZUFzVWludDgpKHRoaXMsdCkpfXBhY2sodCl7cmV0dXJuIHRoaXMuZXhlY3V0ZVByb2dyYW0oKDAsYS5jcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXIpKHRoaXMsdC50ZW5zb3IpLFt0LnRlbnNvcl0pfXVucGFjayh0KXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbSgoMCxjLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyKSh0aGlzLHQudGVuc29yKSxbdC50ZW5zb3JdKX19fSwxNjQwOmZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmcihlLHQsbik7cmV0dXJuIGkoZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLldFQkdMX09QX1JFU09MVkVfUlVMRVM9dm9pZCAwO2NvbnN0IGE9bigyODk4KSxzPW8obig3ODM5KSksdT1uKDQxOTYpLGM9bigyMDY5KSxsPW4oODEzOCkscD1uKDk2NjMpLGY9big1MTkzKSxkPW4oNzk5MiksaD1uKDEyNTMpLGc9big0Nzc2KSxiPW4oNjU3MiksbT1uKDMzNDYpLHk9big1NjIzKSxfPW4oMjg3MCksdj1uKDIxNDMpLHc9big0OTM5KSx4PW4oNzE4KSxUPW4oMjI2OCksUz1uKDgxMTcpLE89bigyMjc4KSxBPW4oNTUyNCksRT1uKDU5NzUpLEk9bigzOTMzKSxQPW4oNjU1OCksRD1uKDU3MjMpLCQ9bigzNzM4KSxrPW8obig0OTA5KSksQz1uKDg0MjgpLEY9big5NzkzKTtlLldFQkdMX09QX1JFU09MVkVfUlVMRVM9W1tcIkFic1wiLFwiXCIsXCI2K1wiLGsuYWJzXSxbXCJBY29zXCIsXCJcIixcIjcrXCIsay5hY29zXSxbXCJBZGRcIixcIlwiLFwiNytcIixzLmFkZF0sW1wiQW5kXCIsXCJcIixcIjcrXCIscy5hbmRdLFtcIkFzaW5cIixcIlwiLFwiNytcIixrLmFzaW5dLFtcIkF0YW5cIixcIlwiLFwiNytcIixrLmF0YW5dLFtcIkF2ZXJhZ2VQb29sXCIsXCJcIixcIjcrXCIsdi5hdmVyYWdlUG9vbCx2LnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxbXCJCYXRjaE5vcm1hbGl6YXRpb25cIixcIlwiLFwiNytcIixhLmJhdGNoTm9ybWFsaXphdGlvbixhLnBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sW1wiQ2FzdFwiLFwiXCIsXCI2K1wiLHUuY2FzdCx1LnBhcnNlQ2FzdEF0dHJpYnV0ZXNdLFtcIkNlaWxcIixcIlwiLFwiNitcIixrLmNlaWxdLFtcIkNsaXBcIixcIlwiLFwiNi0xMFwiLGsuY2xpcCxrLnBhcnNlQ2xpcEF0dHJpYnV0ZXNdLFtcIkNsaXBcIixcIlwiLFwiMTErXCIsay5jbGlwVjExXSxbXCJDb25jYXRcIixcIlwiLFwiNCtcIixjLmNvbmNhdCxjLnBhcnNlQ29uY2F0QXR0cmlidXRlc10sW1wiQ29udlwiLFwiXCIsXCIxK1wiLGwuY29udixsLnBhcnNlQ29udkF0dHJpYnV0ZXNdLFtcIkNvbnZUcmFuc3Bvc2VcIixcIlwiLFwiMStcIixwLmNvbnZUcmFuc3Bvc2UscC5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzXSxbXCJDb3NcIixcIlwiLFwiNytcIixrLmNvc10sW1wiRGl2XCIsXCJcIixcIjcrXCIscy5kaXZdLFtcIkRyb3BvdXRcIixcIlwiLFwiNytcIixrLmlkZW50aXR5XSxbXCJEZXB0aFRvU3BhY2VcIixcIlwiLFwiMStcIixmLmRlcHRoVG9TcGFjZSxmLnBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlc10sW1wiRXF1YWxcIixcIlwiLFwiNytcIixzLmVxdWFsXSxbXCJFbHVcIixcIlwiLFwiNitcIixrLmVsdSxrLnBhcnNlRWx1QXR0cmlidXRlc10sW1wiRXhwXCIsXCJcIixcIjYrXCIsay5leHBdLFtcIkZsYXR0ZW5cIixcIlwiLFwiMStcIixkLmZsYXR0ZW4sZC5wYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzXSxbXCJGbG9vclwiLFwiXCIsXCI2K1wiLGsuZmxvb3JdLFtcIkZ1c2VkQ29udlwiLFwiY29tLm1pY3Jvc29mdFwiLFwiMStcIixsLmNvbnYsbC5wYXJzZUNvbnZBdHRyaWJ1dGVzXSxbXCJHYXRoZXJcIixcIlwiLFwiMStcIixoLmdhdGhlcixoLnBhcnNlR2F0aGVyQXR0cmlidXRlc10sW1wiR2VtbVwiLFwiXCIsXCI3LTEwXCIsZy5nZW1tLGcucGFyc2VHZW1tQXR0cmlidXRlc1Y3XSxbXCJHZW1tXCIsXCJcIixcIjExK1wiLGcuZ2VtbSxnLnBhcnNlR2VtbUF0dHJpYnV0ZXNWMTFdLFtcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsXCJcIixcIjErXCIsdi5nbG9iYWxBdmVyYWdlUG9vbCx2LnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXSxbXCJHbG9iYWxNYXhQb29sXCIsXCJcIixcIjErXCIsdi5nbG9iYWxNYXhQb29sXSxbXCJHcmVhdGVyXCIsXCJcIixcIjcrXCIscy5ncmVhdGVyXSxbXCJJZGVudGl0eVwiLFwiXCIsXCIxK1wiLGsuaWRlbnRpdHldLFtcIkltYWdlU2NhbGVyXCIsXCJcIixcIjErXCIsYi5pbWFnZVNjYWxlcixiLnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzXSxbXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixcIlwiLFwiNitcIixtLmluc3RhbmNlTm9ybWFsaXphdGlvbixtLnBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sW1wiTGVha3lSZWx1XCIsXCJcIixcIjYrXCIsay5sZWFreVJlbHUsay5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXNdLFtcIkxlc3NcIixcIlwiLFwiNytcIixzLmxlc3NdLFtcIkxvZ1wiLFwiXCIsXCI2K1wiLGsubG9nXSxbXCJNYXRNdWxcIixcIlwiLFwiMStcIix5Lm1hdE11bCx5LnBhcnNlTWF0TXVsQXR0cmlidXRlc10sW1wiTWF4UG9vbFwiLFwiXCIsXCIxK1wiLHYubWF4UG9vbCx2LnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXNdLFtcIk11bFwiLFwiXCIsXCI3K1wiLHMubXVsXSxbXCJOZWdcIixcIlwiLFwiNitcIixrLm5lZ10sW1wiTm90XCIsXCJcIixcIjErXCIsay5ub3RdLFtcIk9yXCIsXCJcIixcIjcrXCIscy5vcl0sW1wiUGFkXCIsXCJcIixcIjItMTBcIixfLnBhZFYyLF8ucGFyc2VQYWRBdHRyaWJ1dGVzVjJdLFtcIlBhZFwiLFwiXCIsXCIxMStcIixfLnBhZFYxMSxfLnBhcnNlUGFkQXR0cmlidXRlc1YxMV0sW1wiUG93XCIsXCJcIixcIjcrXCIscy5wb3ddLFtcIlBSZWx1XCIsXCJcIixcIjcrXCIscy5wUmVsdV0sW1wiUmVkdWNlTG9nU3VtXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VMb2dTdW0sdy5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlZHVjZU1heFwiLFwiXCIsXCIxK1wiLHcucmVkdWNlTWF4LHcucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNZWFuXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VNZWFuLHcucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNaW5cIixcIlwiLFwiMStcIix3LnJlZHVjZU1pbix3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlUHJvZFwiLFwiXCIsXCIxK1wiLHcucmVkdWNlUHJvZCx3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlU3VtXCIsXCJcIixcIjEtMTJcIix3LnJlZHVjZVN1bSx3LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlU3VtU3F1YXJlXCIsXCJcIixcIjErXCIsdy5yZWR1Y2VMb2dTdW1TcXVhcmUsdy5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlbHVcIixcIlwiLFwiNitcIixrLnJlbHVdLFtcIlJlc2hhcGVcIixcIlwiLFwiNStcIix4LnJlc2hhcGVdLFtcIlJlc2l6ZVwiLFwiXCIsXCIxMFwiLFQucmVzaXplLFQucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwXSxbXCJSZXNpemVcIixcIlwiLFwiMTErXCIsVC5yZXNpemUsVC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTFdLFtcIlNoYXBlXCIsXCJcIixcIjErXCIsUy5zaGFwZV0sW1wiU2lnbW9pZFwiLFwiXCIsXCI2K1wiLGsuc2lnbW9pZF0sW1wiU2luXCIsXCJcIixcIjcrXCIsay5zaW5dLFtcIlNsaWNlXCIsXCJcIixcIjEwK1wiLE8uc2xpY2VWMTBdLFtcIlNsaWNlXCIsXCJcIixcIjEtOVwiLE8uc2xpY2UsTy5wYXJzZVNsaWNlQXR0cmlidXRlc10sW1wiU29mdG1heFwiLFwiXCIsXCIxLTEyXCIsQS5zb2Z0bWF4LEEucGFyc2VTb2Z0bWF4QXR0cmlidXRlc10sW1wiU29mdG1heFwiLFwiXCIsXCIxMytcIixBLnNvZnRtYXhWMTMsQS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzXSxbXCJTcGxpdFwiLFwiXCIsXCIyLTEyXCIsRS5zcGxpdCxFLnBhcnNlU3BsaXRBdHRyaWJ1dGVzXSxbXCJTcXJ0XCIsXCJcIixcIjYrXCIsay5zcXJ0XSxbXCJTcXVlZXplXCIsXCJcIixcIjEtMTJcIixJLnNxdWVlemUsSS5wYXJzZVNxdWVlemVBdHRyaWJ1dGVzXSxbXCJTcXVlZXplXCIsXCJcIixcIjEzK1wiLEkuc3F1ZWV6ZVYxM10sW1wiU3ViXCIsXCJcIixcIjcrXCIscy5zdWJdLFtcIlN1bVwiLFwiXCIsXCI2K1wiLFAuc3VtXSxbXCJUYW5cIixcIlwiLFwiNytcIixrLnRhbl0sW1wiVGFuaFwiLFwiXCIsXCI2K1wiLGsudGFuaF0sW1wiVGlsZVwiLFwiXCIsXCI2K1wiLEQudGlsZV0sW1wiVHJhbnNwb3NlXCIsXCJcIixcIjErXCIsJC50cmFuc3Bvc2UsJC5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXNdLFtcIlVwc2FtcGxlXCIsXCJcIixcIjctOFwiLEYudXBzYW1wbGUsRi5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3XSxbXCJVcHNhbXBsZVwiLFwiXCIsXCI5XCIsRi51cHNhbXBsZSxGLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjldLFtcIlVuc3F1ZWV6ZVwiLFwiXCIsXCIxLTEyXCIsQy51bnNxdWVlemUsQy5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXNdLFtcIlVuc3F1ZWV6ZVwiLFwiXCIsXCIxMytcIixDLnVuc3F1ZWV6ZVYxM10sW1wiWG9yXCIsXCJcIixcIjcrXCIscy54b3JdXX0sMjg5ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM9ZS5iYXRjaE5vcm1hbGl6YXRpb249dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9big1MDYwKSxvPW4oMjAzOSksYT17bmFtZTpcIkJhdGNoTm9ybWFsaXphdGlvblwiLGlucHV0TmFtZXM6W1wiQVwiLFwiU2NhbGVcIixcIkJcIixcIk1lYW5cIixcIlZhcmlhbmNlXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UuYmF0Y2hOb3JtYWxpemF0aW9uPSh0LGUsbik9Pih1KGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+cyh0LGUsbil9KSxlKV0pLGUucGFyc2VCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImVwc2lsb25cIiwxZS01KSxuPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1vbWVudHVtXCIsLjkpLGk9dC5hdHRyaWJ1dGVzLmdldEludChcInNwYXRpYWxcIiwxKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2Vwc2lsb246ZSxtb21lbnR1bTpuLHNwYXRpYWw6aX0pfTtjb25zdCBzPSh0LGUsbik9Pntjb25zdCByPSgwLGkuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHM9ZVswXS5kaW1zLmxlbmd0aCxbdSxjXT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlWzFdLmRpbXMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksbD1gXFxuICBmbG9hdCBwcm9jZXNzKGludFske3N9XSBpbmRpY2VzKSB7XFxuICAgIHZlYzIgcG9zaXRpb24gPSBvZmZzZXRUb0Nvb3JkcyhpbmRpY2VzWzFdLCAke3V9LCAke2N9KTtcXG4gICAgZmxvYXQgc2NhbGUgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oU2NhbGUsIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IG1lYW4gPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oTWVhbiwgcG9zaXRpb24pKTtcXG4gICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oVmFyaWFuY2UsIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IGIgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oQiwgcG9zaXRpb24pKTtcXG5cXG4gICAgcmV0dXJuIHNjYWxlICogKCAoX0EoaW5kaWNlcykgLSBtZWFuKSAvIHNxcnQodmFyaWFuY2UgKyBmbG9hdCgke24uZXBzaWxvbn0pKSApICsgYjtcXG4gIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczplWzBdLmRpbXMsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmx9KX0sdT10PT57aWYoIXR8fDUhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gcmVxdWlyZXMgNSBpbnB1dHMuXCIpO2NvbnN0IGU9dFswXSxuPXRbMV0scj10WzJdLGk9dFszXSxvPXRbNF07aWYoZS5kaW1zLmxlbmd0aDwzfHwxIT09bi5kaW1zLmxlbmd0aHx8MSE9PXIuZGltcy5sZW5ndGh8fDEhPT1pLmRpbXMubGVuZ3RofHwxIT09by5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihuLmRpbXNbMF0hPT1lLmRpbXNbMV18fHIuZGltc1swXSE9PWUuZGltc1sxXXx8aS5kaW1zWzBdIT09ZS5kaW1zWzFdfHxvLmRpbXNbMF0hPT1lLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoXCJmbG9hdDMyXCIhPT1lLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZS50eXBlfHxcImZsb2F0MzJcIiE9PW4udHlwZSYmXCJmbG9hdDY0XCIhPT1uLnR5cGV8fFwiZmxvYXQzMlwiIT09ci50eXBlJiZcImZsb2F0NjRcIiE9PXIudHlwZXx8XCJmbG9hdDMyXCIhPT1pLnR5cGUmJlwiZmxvYXQ2NFwiIT09aS50eXBlfHxcImZsb2F0MzJcIiE9PW8udHlwZSYmXCJmbG9hdDY0XCIhPT1vLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfX0sNzgzOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS54b3I9ZS5zdWI9ZS5wUmVsdT1lLnBvdz1lLm9yPWUubXVsPWUubGVzcz1lLmdyZWF0ZXI9ZS5lcXVhbD1lLmRpdj1lLmFuZD1lLmFkZD1lLmdsc2xQUmVsdT1lLmdsc2xQb3c9ZS5nbHNsWG9yPWUuZ2xzbE9yPWUuZ2xzbEFuZD1lLmdsc2xMZXNzPWUuZ2xzbEdyZWF0ZXI9ZS5nbHNsRXF1YWw9ZS5nbHNsU3ViPWUuZ2xzbE11bD1lLmdsc2xEaXY9ZS5nbHNsQWRkPXZvaWQgMDtjb25zdCByPW4oMjUxNyksaT1uKDg1MjApLG89big1MDYwKSxhPW4oMjAzOSk7ZnVuY3Rpb24gcygpe2NvbnN0IHQ9XCJhZGRfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhICsgYjtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSArIHYyO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiB1KCl7Y29uc3QgdD1cImRpdl9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgLyBiO1xcbiAgfVxcbiAgdmVjNCAke3R9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHYxIC8gdjI7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGMoKXtjb25zdCB0PVwibXVsX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gYSAqIGI7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdjEgKiB2MjtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gbCgpe2NvbnN0IHQ9XCJzdWJfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhIC0gYjtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSAtIHYyO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBwKCl7Y29uc3QgdD1cImVxdWFsX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoYSA9PSBiKTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KGVxdWFsKHYxLCB2MikpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBmKCl7Y29uc3QgdD1cImdyZWF0ZXJfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdChhID4gYik7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdmVjNCggdjEuciA+IHYyLnIgLFxcbiAgICAgIHYxLmcgPiB2Mi5nLFxcbiAgICAgIHYxLmIgPiB2Mi5iLFxcbiAgICAgIHYxLmEgPiB2Mi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGQoKXtjb25zdCB0PVwibGVzc19cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGZsb2F0KGEgPCBiKTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KCB2MS5yIDwgdjIuciAsXFxuICAgICAgICAgICAgICAgIHYxLmcgPCB2Mi5nLFxcbiAgICAgICAgICAgICAgICB2MS5iIDwgdjIuYixcXG4gICAgICAgICAgICAgICAgdjEuYSA8IHYyLmEgKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gaCgpe2NvbnN0IHQ9XCJhbmRfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSAmJiBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yICYmIGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nICYmIGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgJiYgYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSAmJiBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGcoKXtjb25zdCB0PVwib3JfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSB8fCBib29sKGIpICk7XFxuICB9XFxuICB2ZWM0ICR7dH0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcXG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XFxuICAgIHJldHVybiB2ZWM0KCBiMS5yIHx8IGIyLnIgLFxcbiAgICAgICAgICAgICAgICBiMS5nIHx8IGIyLmcsXFxuICAgICAgICAgICAgICAgIGIxLmIgfHwgYjIuYixcXG4gICAgICAgICAgICAgICAgYjEuYSB8fCBiMi5hICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGIoKXtjb25zdCB0PVwieG9yX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgXl4gYm9vbChiKSApO1xcbiAgfVxcbiAgdmVjNCAke3R9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XFxuICAgIGJ2ZWM0IGIyID0gYnZlYzQodjIpO1xcbiAgICByZXR1cm4gdmVjNCggYjEuciBeXiBiMi5yICxcXG4gICAgICAgICAgICAgICAgYjEuZyBeXiBiMi5nLFxcbiAgICAgICAgICAgICAgICBiMS5iIF5eIGIyLmIsXFxuICAgICAgICAgICAgICAgIGIxLmEgXl4gYjIuYSApO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBtKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2NvbnN0IGU9YCR7dH1fYDtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuICR7dH0oYSwgYik7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gJHt0fSh2MSwgdjIpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX0oXCJwb3dcIil9ZnVuY3Rpb24geSgpe2NvbnN0IHQ9XCJwcmVsdV9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke3R9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYjogYTtcXG4gIH1cXG4gIHZlYzQgJHt0fSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2ZWM0KFxcbiAgICAgIHYxLnIgPCAwLjAgPyB2MS5yICogdjIucjogdjEucixcXG4gICAgICB2MS5nIDwgMC4wID8gdjEuZyAqIHYyLmc6IHYxLmcsXFxuICAgICAgdjEuYiA8IDAuMCA/IHYxLmIgKiB2Mi5iOiB2MS5iLFxcbiAgICAgIHYxLmEgPCAwLjAgPyB2MS5hICogdjIuYTogdjEuYVxcbiAgICAgICk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWUuZ2xzbEFkZD1zLGUuZ2xzbERpdj11LGUuZ2xzbE11bD1jLGUuZ2xzbFN1Yj1sLGUuZ2xzbEVxdWFsPXAsZS5nbHNsR3JlYXRlcj1mLGUuZ2xzbExlc3M9ZCxlLmdsc2xBbmQ9aCxlLmdsc2xPcj1nLGUuZ2xzbFhvcj1iLGUuZ2xzbFBvdz1tLGUuZ2xzbFBSZWx1PXk7Y29uc3QgXz0odCxlLG4scj1lWzBdLnR5cGUsaSk9Pntjb25zdCBvPXQuc2Vzc2lvbi5wYWNrP2EuVGV4dHVyZVR5cGUucGFja2VkOmEuVGV4dHVyZVR5cGUudW5wYWNrZWQ7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltvLG9dLGNhY2hlSGludDppLGdldDooKT0+dih0LGUsbixyKX19LHY9KHQsZSxuLGk9ZVswXS50eXBlKT0+e2NvbnN0IHM9dC5zZXNzaW9uLnBhY2s/YS5UZXh0dXJlVHlwZS5wYWNrZWQ6YS5UZXh0dXJlVHlwZS51bnBhY2tlZCx1PSFyLlNoYXBlVXRpbC5hcmVFcXVhbChlWzBdLmRpbXMsZVsxXS5kaW1zKTtsZXQgYz1lWzBdLmRpbXM7Y29uc3QgbD10LnNlc3Npb24ucGFjaztpZih1KXtjb25zdCBhPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoZVswXS5kaW1zLGVbMV0uZGltcywhMSk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7Yz1hO2NvbnN0IHU9Yy5sZW5ndGgscD0wIT09ZVswXS5kaW1zLmxlbmd0aD9lWzBdLmRpbXMubGVuZ3RoOjEsZj0wIT09ZVsxXS5kaW1zLmxlbmd0aD9lWzFdLmRpbXMubGVuZ3RoOjEsZD0wIT09ZVswXS5kaW1zLmxlbmd0aD9cImJjYXN0SW5kaWNlc19BKGluZGljZXMsIGFpbmRpY2VzKTtcIjpcImFpbmRpY2VzWzBdID0gMDtcIixoPTAhPT1lWzFdLmRpbXMubGVuZ3RoP1wiYmNhc3RJbmRpY2VzX0IoaW5kaWNlcywgYmluZGljZXMpO1wiOlwiYmluZGljZXNbMF0gPSAwO1wiLGc9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksYj1sP2BcXG4gICAgICAke24uYm9keX1cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke24ubmFtZX0oYSwgYik7XFxuICAgICAgICAke2cub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9YDpgXFxuICAgICAgJHtuLmJvZHl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3V9XSkge1xcbiAgICAgICAgaW50IGFpbmRpY2VzWyR7cH1dO1xcbiAgICAgICAgaW50IGJpbmRpY2VzWyR7Zn1dO1xcbiAgICAgICAgJHtkfVxcbiAgICAgICAgJHtofVxcbiAgICAgICAgcmV0dXJuICR7bi5uYW1lfShfQShhaW5kaWNlcyksIF9CKGJpbmRpY2VzKSk7XFxuICAgICAgfWA7cmV0dXJue25hbWU6bi5uYW1lLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltzLHNdLG91dHB1dDp7ZGltczpjLHR5cGU6aSx0ZXh0dXJlVHlwZTpzfSxzaGFkZXJTb3VyY2U6YixoYXNNYWluOmx9fWNvbnN0IHA9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksZj1gXFxuICAgICR7bi5ib2R5fVxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgdmVjNCB2MSA9ICR7cC50ZXh0dXJlMkR9KEEsIFRleENvb3Jkcyk7XFxuICAgICAgdmVjNCB2MiA9ICR7cC50ZXh0dXJlMkR9KEIsIFRleENvb3Jkcyk7XFxuICAgICAgdmVjNCByZXN1bHQgPSAke24ubmFtZX0odjEsIHYyKTtcXG4gICAgICAke3Aub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgfVxcbiAgICBgO3JldHVybntuYW1lOm4ubmFtZSxpbnB1dE5hbWVzOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpbcyxzXSxvdXRwdXQ6e2RpbXM6ZVswXS5kaW1zLHR5cGU6aSx0ZXh0dXJlVHlwZTpzfSxzaGFkZXJTb3VyY2U6ZixoYXNNYWluOiEwfX07ZS5hZGQ9KHQsZSk9Plt0LnJ1bihfKHQsZSxzKCkpLGUpXSxlLmFuZD0odCxlKT0+W3QucnVuKF8odCxlLGgoKSxcImJvb2xcIiksZSldLGUuZGl2PSh0LGUpPT5bdC5ydW4oXyh0LGUsdSgpKSxlKV0sZS5lcXVhbD0odCxlKT0+W3QucnVuKF8odCxlLHAoKSxcImJvb2xcIiksZSldLGUuZ3JlYXRlcj0odCxlKT0+W3QucnVuKF8odCxlLGYoKSxcImJvb2xcIiksZSldLGUubGVzcz0odCxlKT0+W3QucnVuKF8odCxlLGQoKSxcImJvb2xcIiksZSldLGUubXVsPSh0LGUpPT5bdC5ydW4oXyh0LGUsYygpKSxlKV0sZS5vcj0odCxlKT0+W3QucnVuKF8odCxlLGcoKSxcImJvb2xcIiksZSldLGUucG93PSh0LGUpPT5bdC5ydW4oXyh0LGUsbSgpKSxlKV0sZS5wUmVsdT0odCxlKT0+W3QucnVuKF8odCxlLHkoKSksZSldLGUuc3ViPSh0LGUpPT5bdC5ydW4oXyh0LGUsbCgpKSxlKV0sZS54b3I9KHQsZSk9Plt0LnJ1bihfKHQsZSxiKCksXCJib29sXCIpLGUpXX0sNDE5NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNhc3RBdHRyaWJ1dGVzPWUuY2FzdD12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UuY2FzdD0odCxlLG4pPT4oaShlKSxbdC5jYXN0KGVbMF0sbildKSxlLnBhcnNlQ2FzdEF0dHJpYnV0ZXM9dD0+ci5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5hdHRyaWJ1dGVzLmdldEludChcInRvXCIpKTtjb25zdCBpPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNhc3QgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJzdHJpbmdcIj09PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sMTE2MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpO2UuY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuKT0+e2NvbnN0IHU9KGM9ZS5sZW5ndGgsbD1uLmNhY2hlS2V5LHtuYW1lOlwiQ29uY2F0IChwYWNrZWQpXCIsaW5wdXROYW1lczpBcnJheS5mcm9tKHtsZW5ndGg6Y30sKCh0LGUpPT5gWCR7ZX1gKSksaW5wdXRUeXBlczpBcnJheShjKS5maWxsKGkuVGV4dHVyZVR5cGUucGFja2VkKSxjYWNoZUhpbnQ6bH0pO3ZhciBjLGw7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Z2V0OigpPT4oKHQsZSxuLHUpPT57Y29uc3QgYz1uWzBdLmRpbXMuc2xpY2UoKTtpZih1Pj1jLmxlbmd0aHx8dTwtMSpjLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgZGltZW5zaW9uYWxpdHlcIik7dTwwJiYodT1jLmxlbmd0aCt1KTtjb25zdCBsPWMuc2xpY2UoMCk7Zm9yKGxldCB0PTE7dDxuLmxlbmd0aDt0Kyspe2NvbnN0IGU9blt0XS5kaW1zLnNsaWNlKCk7Zm9yKGxldCB0PTA7dDxjLmxlbmd0aDt0KyspaWYodD09PXUpbFt1XSs9ZVt0XTtlbHNlIGlmKGNbdF0hPT1lW3RdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfWNvbnN0IHA9bC5sZW5ndGgsZj0oMCxhLmdldENoYW5uZWxzKShcImNvb3Jkc1wiLHApLGQ9KDAsby5nZXRDb29yZHNEYXRhVHlwZSkocCksaD0oMCxhLnVucGFja0Zyb21DaGFubmVsKSgpLGc9bi5tYXAoKHQ9PnQuZGltcykpLGI9KDAsby5nZXRHbENoYW5uZWxzKShwKSxtPW5ldyBBcnJheShnLmxlbmd0aC0xKTttWzBdPWdbMF1bdV07Zm9yKGxldCB0PTE7dDxtLmxlbmd0aDt0KyspbVt0XT1tW3QtMV0rZ1t0XVt1XTtjb25zdCB5PWJbdV0sXz1iLnNsaWNlKC0yKSx2PWIuam9pbigpO2xldCB3PWBpZiAoJHt5fSA8ICR7bVswXX0pIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgIGdldFgwKCR7dn0pLCB2ZWMyKCR7Xy5qb2luKCl9KSk7XFxuICAgICAgICB9YDtmb3IobGV0IHQ9MTt0PG0ubGVuZ3RoO3QrKyl7Y29uc3QgZT1tW3QtMV07dys9YFxcbiAgICAgICAgICAgIGlmICgke3l9IDwgJHttW3RdfSAgJiYgJHt5fSA+PSAke21bdC0xXX0pIHtcXG4gICAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgICAgICBnZXRYJHt0fSgke3MoYix5LGUpfSksXFxuICAgICAgICAgICAgICAgIHZlYzIoJHtzKF8seSxlKX0pKTtcXG4gICAgICAgICAgICB9YH1jb25zdCB4PW0ubGVuZ3RoLFQ9bVttLmxlbmd0aC0xXTt3Kz1gXFxuICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXFxuICAgICAgICAgICAgICBnZXRYJHt4fSgke3MoYix5LFQpfSksXFxuICAgICAgICAgICAgICB2ZWMyKCR7cyhfLHksVCl9KSk7YDtjb25zdCBTPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLE89YFxcbiAgICAgICAgICAke2h9XFxuICAgICAgICAgIGZsb2F0IGdldFZhbHVlKCR7Yi5tYXAoKHQ9PlwiaW50IFwiK3QpKX0pIHtcXG4gICAgICAgICAgICAke3d9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICR7ZH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHtiW3AtMV19O1xcbiAgICAgICAgICAgIGNvb3Jkcy4ke2JbcC0xXX0gPSBjb29yZHMuJHtiW3AtMl19O1xcbiAgICAgICAgICAgIGNvb3Jkcy4ke2JbcC0yXX0gPSBsYXN0RGltO1xcblxcbiAgICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZSgke2Z9KSwgMC4sIDAuLCAwLik7XFxuXFxuICAgICAgICAgICAgJHtmW3AtMV19ID0gJHtmW3AtMV19ICsgMTtcXG4gICAgICAgICAgICBpZiAoJHtmW3AtMV19IDwgJHtsW3AtMV19KSB7XFxuICAgICAgICAgICAgICByZXN1bHQuZyA9IGdldFZhbHVlKCR7Zn0pO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAke2ZbcC0yXX0gPSAke2ZbcC0yXX0gKyAxO1xcbiAgICAgICAgICAgIGlmICgke2ZbcC0yXX0gPCAke2xbcC0yXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5hID0gZ2V0VmFsdWUoJHtmfSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICR7ZltwLTFdfSA9ICR7ZltwLTFdfSAtIDE7XFxuICAgICAgICAgICAgaWYgKCR7ZltwLTJdfSA8ICR7bFtwLTJdfSAmJlxcbiAgICAgICAgICAgICAgICAke2ZbcC0xXX0gPCAke2xbcC0xXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5iID0gZ2V0VmFsdWUoJHtmfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICR7Uy5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpsLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6TyxoYXNNYWluOiEwfSl9KSh0LHUsZSxuLmF4aXMpfSl9O2NvbnN0IHM9KHQsZSxuKT0+e2NvbnN0IHI9dC5pbmRleE9mKGUpO3JldHVybiB0Lm1hcCgoKHQsZSk9PmU9PT1yP2Ake3R9IC0gJHtufWA6dCkpLmpvaW4oKX19LDIwNjk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VDb25jYXRBdHRyaWJ1dGVzPWUuY29uY2F0PXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjAzOSksbz1uKDExNjMpO2UuY29uY2F0PSh0LGUsbik9PihwKGUpLHQuc2Vzc2lvbi5wYWNrJiZlWzBdLmRpbXMubGVuZ3RoPjE/W3QucnVuKCgwLG8uY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXIpKHQsZSxuKSxlKV06W3QucnVuKGEodCxlLG4pLGUpXSk7Y29uc3QgYT0odCxlLG4pPT57Y29uc3Qgcj0obz1lLmxlbmd0aCxhPW4uY2FjaGVLZXkse25hbWU6XCJDb25jYXRcIixpbnB1dE5hbWVzOkFycmF5LmZyb20oe2xlbmd0aDpvfSwoKHQsZSk9PmBYJHtlfWApKSxpbnB1dFR5cGVzOkFycmF5KG8pLmZpbGwoaS5UZXh0dXJlVHlwZS51bnBhY2tlZCksY2FjaGVIaW50OmF9KTt2YXIgbyxhO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KCh0LGUsbixyKT0+e2NvbnN0IG89blswXS5kaW1zLnNsaWNlKCk7aWYocj49by5sZW5ndGh8fHI8LTEqby5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2Vzbid0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5XCIpO3I8MCYmKHI9by5sZW5ndGgrcik7Y29uc3QgYT1vLnNsaWNlKDApO2ZvcihsZXQgdD0xO3Q8bi5sZW5ndGg7dCsrKXtjb25zdCBlPW5bdF0uZGltcy5zbGljZSgpO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCsrKWlmKHQ9PT1yKWFbcl0rPWVbdF07ZWxzZSBpZihvW3RdIT09ZVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX1jb25zdCBwPWEubGVuZ3RoLGY9bmV3IEFycmF5KG4ubGVuZ3RoKTtsZXQgZD0wO2ZvcihsZXQgdD0wO3Q8Zi5sZW5ndGg7Kyt0KWQrPW5bdF0uZGltc1tyXSxmW3RdPWQ7bGV0IGg9XCJcIjtoPW4ubGVuZ3RoPDU/cyhmKTp1KGYpO2NvbnN0IGc9YFxcbiAgICAgICAgJHtjKG4ubGVuZ3RoLHApfVxcbiAgICAgICAgJHtsKGYpfVxcbiAgICAgICAgJHtofVxcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3B9XSkge1xcbiAgICAgICAgICBpbnQgdGV4dHVyZUluZGV4ID0gZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMgKGluZGljZXNbJHtyfV0pO1xcblxcbiAgICAgICAgICBpZih0ZXh0dXJlSW5kZXggIT0gMCkge1xcbiAgICAgICAgICAgIGluZGljZXNbJHtyfV0gPSBpbmRpY2VzWyR7cn1dIC0gaW50KGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleCh0ZXh0dXJlSW5kZXgtaW50KDEpKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZSh0ZXh0dXJlSW5kZXgsIGluZGljZXMpO1xcbiAgICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmEsdHlwZTpuWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmd9KX0pKDAscixlLG4uYXhpcyl9KX0scz10PT5gaW50IGdldFRleHR1cmVXaGVyZURhdGFSZXNpZGVzKGludCBpbmRleCkge1xcbiAgICAgICR7dC5tYXAoKCh0LGUpPT5gaWYoaW5kZXg8JHt0fSkge3JldHVybiAke2V9O31cXG5gKSkuam9pbihcIlwiKX1cXG4gICAgfWAsdT10PT5zKHQpLGM9KHQsZSk9Pntjb25zdCBuPVtgZmxvYXQgZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlKGludCB0ZXh0dXJlSW5kZXgsIGludCBpbmRpY2VzWyR7ZX1dKSB7YF07Zm9yKGxldCBlPTA7ZTx0OysrZSkwPT09ZT9uLnB1c2goYFxcdGlmICh0ZXh0dXJlSW5kZXggPT0gJHtlfSkgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk6ZT09PXQtMT9uLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk6bi5wdXNoKGBcXHRlbHNlIGlmICh0ZXh0dXJlSW5kZXggPT0gJHtlfSkgeyByZXR1cm4gX1gke2V9KGluZGljZXMpOyB9YCk7cmV0dXJuIG4ucHVzaChcIlxcdH1cIiksbi5qb2luKFwiXFxuXCIpfSxsPXQ9Pntjb25zdCBlPVtcImludCBnZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXgoaW50IGluZGV4KSB7XCJdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKTA9PT1uP2UucHVzaChgXFx0aWYgKGluZGV4ID09ICR7bn0pIHsgcmV0dXJuICR7dFtuXX07IH1gKTpuPT09dC5sZW5ndGgtMT9lLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gJHt0W25dfTsgfWApOmUucHVzaChgXFx0ZWxzZSBpZiAoaW5kZXggPT0gJHtufSkgeyByZXR1cm4gJHt0W25dfTsgfWApO3JldHVybiBlLnB1c2goXCJcXHR9XCIpLGUuam9pbihcIlxcblwiKX07ZS5wYXJzZUNvbmNhdEF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGlzOnQuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIpfSk7Y29uc3QgcD10PT57aWYoIXR8fHQubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7Y29uc3QgZT10WzBdLnR5cGUsbj10WzBdLmRpbXMubGVuZ3RoO2lmKFwic3RyaW5nXCI9PT1lKXRocm93IG5ldyBFcnJvcihcInN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7Zm9yKGNvbnN0IHIgb2YgdCl7aWYoci50eXBlIT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZVwiKTtpZihyLmRpbXMubGVuZ3RoIT09bil0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpfX19LDQ3NzA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNjIzMSksaT1uKDUwNjApLG89bigyMDM5KSxhPW4oODEzOCkscz1uKDI4MjMpO2UuY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvTG9hZGVyPSh0LGUsbik9Pntjb25zdCB1PShjPWUubGVuZ3RoPjIsbD1uLmNhY2hlS2V5LHtuYW1lOlwiR3JvdXBlZENvbnZcIixpbnB1dE5hbWVzOmM/W1wiWFwiLFwiV1wiLFwiQmlhc1wiXTpbXCJYXCIsXCJXXCJdLGlucHV0VHlwZXM6Yz9bby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpsfSk7dmFyIGMsbDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtnZXQ6KCk9PigodCxlLG4sdSk9Pntjb25zdCBjPWUubGVuZ3RoPjI/XCJ2YWx1ZSArPSBnZXRCaWFzKG91dHB1dF9jaGFubmVsKTtcIjpcIlwiLGw9ZVswXS5kaW1zLnNsaWNlKCkscD1lWzFdLmRpbXMuc2xpY2UoKSxmPXBbMF0vdS5ncm91cDtyLkxvZ2dlci52ZXJib3NlKFwiR3JvdXBlZENvbnZcIixgYXV0cFBhZDoke3UuYXV0b1BhZH0sIGRpbGF0aW9uczoke3UuZGlsYXRpb25zfSwgZ3JvdXA6JHt1Lmdyb3VwfSwga2VybmVsU2hhcGU6JHt1Lmtlcm5lbFNoYXBlfSwgcGFkczoke3UucGFkc30sIHN0cmlkZXM6JHt1LnN0cmlkZXN9YCk7Y29uc3QgZD0oMCxhLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShsLHAsdS5kaWxhdGlvbnMsdS5wYWRzLHUuc3RyaWRlcyksaD0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmcsYXBwbHlBY3RpdmF0aW9uOmJ9PSgwLHMuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKHUpLG09YFxcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7dS5zdHJpZGVzWzBdfSwgJHt1LnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3UucGFkc1swXX0sICR7dS5wYWRzWzFdfSk7XFxuICAke2d9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XFxuICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy56dyAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICBpbnQgZ3JvdXBfaWQgPSBvdXRwdXRfY2hhbm5lbCAvICR7Zn07XFxuXFxuICAgIGZsb2F0IHZhbHVlID0gMC4wO1xcbiAgICBmb3IgKGludCB3SW5DaGFubmVsID0gMDsgd0luQ2hhbm5lbCA8ICR7cFsxXX07IHdJbkNoYW5uZWwrKykge1xcbiAgICAgIGludCBpbnB1dF9jaGFubmVsID0gZ3JvdXBfaWQgKiAke3BbMV19ICsgd0luQ2hhbm5lbDtcXG4gICAgICBmb3IgKGludCB3SGVpZ2h0ID0gMDsgd0hlaWdodCA8ICR7cFsyXX07IHdIZWlnaHQrKykge1xcbiAgICAgICAgaW50IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiAke3UuZGlsYXRpb25zWzBdfTtcXG5cXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMCB8fCB4SGVpZ2h0ID49ICR7bFsyXX0pIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGludCB3V2lkdGggPSAwOyB3V2lkdGggPCAke3BbM119OyB3V2lkdGgrKykge1xcbiAgICAgICAgICBpbnQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiAke3UuZGlsYXRpb25zWzFdfTtcXG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDAgfHwgeFdpZHRoID49ICR7bFszXX0pIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgaW5wdXRfY2hhbm5lbCwgeFdpZHRoLCB4SGVpZ2h0KTtcXG4gICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcob3V0cHV0X2NoYW5uZWwsIHdJbkNoYW5uZWwsIHdXaWR0aCwgd0hlaWdodCk7XFxuICAgICAgICAgIHZhbHVlICs9IHhWYWwqd1ZhbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgJHtjfVxcbiAgICAke2J9XFxuICAgICR7aC5vdXRwdXR9ID0gdmVjNCh2YWx1ZSwgLjAsIC4wLCAuMCk7XFxuICB9XFxuYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6ZCx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6bSxoYXNNYWluOiEwfSl9KSh0LGUsdSxuKX0pfX0sMTM4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jb252MkRQYWNrZWQ9ZS5jb252MkRQYWNrZWRQb2ludHdpc2U9dm9pZCAwO2NvbnN0IHI9big4MTM4KSxpPW4oODU1NSksbz1uKDcwOCk7ZS5jb252MkRQYWNrZWRQb2ludHdpc2U9KHQsZSxuKT0+e2NvbnN0IGk9ZVswXS5kaW1zLGE9ZVsxXS5kaW1zLHM9KDAsci5jYWxjdWxhdGVPdXRwdXRTaGFwZSkoaSxhLG4uZGlsYXRpb25zLG4ucGFkcyxuLnN0cmlkZXMpLHU9dC5yZXNoYXBlUGFja2VkKGVbMF0sW2lbMV0saVsyXSppWzNdXSksYz10LnJlc2hhcGVQYWNrZWQoZVsxXSxbYVswXSxhWzFdXSksbD1lLmxlbmd0aD4yP1tjLHUsZVsyXV06W2MsdV0scD10LnJ1bigoMCxvLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKSh0LGwsbiksbCk7cmV0dXJuIHQucmVzaGFwZVBhY2tlZChwLHMpfSxlLmNvbnYyRFBhY2tlZD0odCxlLG4pPT57Y29uc3QgYT1lWzBdLmRpbXMscz1lWzFdLmRpbXMsdT0oMCxyLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShhLHMsbi5kaWxhdGlvbnMsbi5wYWRzLG4uc3RyaWRlcyksYz10LnJ1bigoMCxpLmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyKSh0LGVbMF0sZVsxXSx1LG4pLFtlWzBdXSksbD10LnJlc2hhcGVQYWNrZWQoZVsxXSxbc1swXSxzWzFdKnNbMl0qc1szXV0pLHA9Mz09PWUubGVuZ3RoP1tsLGMsZVsyXV06W2wsY10sZj10LnJ1bigoMCxvLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKSh0LHAsbikscCk7cmV0dXJuIHQucmVzaGFwZVBhY2tlZChmLHUpfX0sOTY2MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPWUuY29udlRyYW5zcG9zZT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDUwNjApLG89bigyMDM5KSxhPW4oMjgyMykscz0odCxlLG4scixpLG8pPT4odC0xKSplK24rKHItMSkqaSsxLW8sdT0odCxlLG4scixpKT0+e2NvbnN0IG89TWF0aC5mbG9vcih0LzIpO1wiU0FNRV9VUFBFUlwiPT09ZT8obltyXT1vLG5baV09dC1vKTpcIlNBTUVfTE9XRVJcIj09PWUmJihuW3JdPXQtbyxuW2ldPW8pfTtlLmNvbnZUcmFuc3Bvc2U9KHQsZSxuKT0+KGYoZSxuKSxjKHQsZSxuKSk7Y29uc3QgYz0odCxlLG4pPT57Y29uc3Qgcj1wKG4sZSk7cmV0dXJuW2wodCxlLHIpXX0sbD0odCxlLG4pPT50LnJ1bigoKHQsZSxuKT0+e2NvbnN0IHI9KHM9ZS5sZW5ndGg+Mix1PW4uY2FjaGVLZXkse25hbWU6XCJDb252VHJhbnNwb3NlXCIsaW5wdXROYW1lczpzP1tcIlhcIixcIldcIixcIkJcIl06W1wiWFwiLFwiV1wiXSxpbnB1dFR5cGVzOnM/W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkXTpbby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6dX0pO3ZhciBzLHU7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT4oKHQsZSxuLHIpPT57Y29uc3Qgcz1lLmxlbmd0aD4yP1wiZ2V0QihvdXRwdXRfY2hhbm5lbClcIjpcIjAuMFwiLHU9ZVswXS5kaW1zLGM9ZVsxXS5kaW1zLGw9Y1sxXSxwPWNbMF0vci5ncm91cCxmPVtlWzBdLmRpbXNbMF0sZVsxXS5kaW1zWzFdKnIuZ3JvdXAsLi4uci5vdXRwdXRTaGFwZV0sZD0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmgsYXBwbHlBY3RpdmF0aW9uOmd9PSgwLGEuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKHIpLGI9YFxcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7ci5zdHJpZGVzWzBdfSwgJHtyLnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3IucGFkc1swXX0sICR7ci5wYWRzWzFdfSk7XFxuICAke2h9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XFxuXFxuICAgIGl2ZWMyIGxvYyA9IGNvb3Jkcy56dyArIHBhZHM7XFxuXFxuICAgIGludCBncm91cF9pZCA9IG91dHB1dF9jaGFubmVsIC8gJHtsfTtcXG4gICAgaW50IHdPdXRDaGFubmVsID0gb3V0cHV0X2NoYW5uZWwgLSBncm91cF9pZCAqICR7bH07XFxuXFxuICAgIGZsb2F0IHZhbHVlID0gJHtzfTtcXG4gICAgZm9yIChpbnQgaW5DaGFubmVsT2Zmc2V0ID0gMDsgaW5DaGFubmVsT2Zmc2V0IDwgJHtwfTsgaW5DaGFubmVsT2Zmc2V0KyspIHtcXG4gICAgICBpbnQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHtwfSArIGluQ2hhbm5lbE9mZnNldDtcXG4gICAgICBmb3IgKGludCB3V09mZiA9IDA7IHdXT2ZmIDwgJHtjWzJdfTsgd1dPZmYrKykge1xcbiAgICAgICAgZm9yIChpbnQgd0hPZmYgPSAwOyB3SE9mZiA8ICR7Y1szXX07IHdIT2ZmKyspIHtcXG4gICAgICAgICAgaXZlYzIgd09mZiA9IGl2ZWMyKHdXT2ZmICogJHtyLmRpbGF0aW9uc1swXX0sIHdIT2ZmICogJHtyLmRpbGF0aW9uc1sxXX0pO1xcbiAgICAgICAgICBpdmVjMiB3TG9jID0gbG9jIC0gd09mZjtcXG4gICAgICAgICAgaXZlYzIgd0xvY0luID0gd0xvYyAvIHN0cmlkZXM7XFxuICAgICAgICAgIGlmIChcXG4gICAgICAgICAgICB3TG9jSW4gKiBzdHJpZGVzID09IHdMb2MgJiZcXG4gICAgICAgICAgICB3TG9jSW4ueCA+PSAwICYmIHdMb2NJbi54IDwgJHt1WzJdfSAmJlxcbiAgICAgICAgICAgIHdMb2NJbi55ID49IDAgJiYgd0xvY0luLnkgPCAke3VbM119XFxuICAgICAgICAgICkge1xcbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCBpbnB1dF9jaGFubmVsLCB3TG9jSW4ueSwgd0xvY0luLngpO1xcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKGlucHV0X2NoYW5uZWwsIHdPdXRDaGFubmVsLCB3SE9mZiwgd1dPZmYpO1xcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7Z31cXG4gICAgJHtkLm91dHB1dH0gPSB2ZWM0KHZhbHVlLCAuMCwgLjAsIC4wKTtcXG4gIH1cXG5gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpmLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpiLGhhc01haW46ITB9KX0pKHQsZSxyLG4pfSl9KSh0LGUsbiksZSkscD0odCxlKT0+e2NvbnN0IG49dC5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKDA9PT10Lmtlcm5lbFNoYXBlLmxlbmd0aClmb3IobGV0IHQ9Mjt0PGVbMV0uZGltcy5sZW5ndGg7Kyt0KW4ucHVzaChlWzFdLmRpbXNbdF0pO2NvbnN0IHI9dC5wYWRzLnNsaWNlKCksaT10Lm91dHB1dFNoYXBlLnNsaWNlKCk7KCh0LGUsbixyLGksbyxhLGMpPT57Y29uc3QgbD10Lmxlbmd0aC0yLHA9MD09PWMubGVuZ3RoO2ZvcihsZXQgZj0wO2Y8bDsrK2Ype2NvbnN0IGQ9cD90W2YrMl0qb1tmXTpjW2ZdLGg9cyh0W2YrMl0sb1tmXSxpW2ZdLGVbZl0sbltmXSxkKTt1KGgscixpLGYsZitsKSxwJiZjLnB1c2gob1tmXSoodFtmKzJdLTEpK2FbZl0rKGVbZl0tMSkqbltmXSsxLWlbZl0taVtmK2xdKX19KShlWzBdLmRpbXMsbix0LmRpbGF0aW9ucyx0LmF1dG9QYWQscix0LnN0cmlkZXMsdC5vdXRwdXRQYWRkaW5nLGkpO2NvbnN0IG89T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihvLHtrZXJuZWxTaGFwZTpuLHBhZHM6cixvdXRwdXRTaGFwZTppLGNhY2hlS2V5OnQuY2FjaGVLZXl9KSxvfTtlLnBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLG49KDAsYS5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpKGUpLGk9ZS5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG89ZS5nZXRJbnRzKFwiZGlsYXRpb25zXCIsWzEsMV0pLHM9ZS5nZXRJbnQoXCJncm91cFwiLDEpLHU9ZS5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIsW10pLGM9ZS5nZXRJbnRzKFwib3V0cHV0X3BhZGRpbmdcIixbMCwwXSksbD1lLmdldEludHMoXCJvdXRwdXRfc2hhcGVcIixbXSkscD1lLmdldEludHMoXCJwYWRzXCIsWzAsMCwwLDBdKSxmPWUuZ2V0SW50cyhcInN0cmlkZXNcIixbMSwxXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKE9iamVjdC5hc3NpZ24oe2F1dG9QYWQ6aSxkaWxhdGlvbnM6byxncm91cDpzLGtlcm5lbFNoYXBlOnUsb3V0cHV0UGFkZGluZzpjLG91dHB1dFNoYXBlOmwscGFkczpwLHN0cmlkZXM6Zn0sbikpfTtjb25zdCBmPSh0LGUpPT57aWYoIXR8fDIhPT10Lmxlbmd0aCYmMyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZig0IT09dFswXS5kaW1zLmxlbmd0aHx8NCE9PXRbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7aWYodFswXS5kaW1zWzFdIT09dFsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7Y29uc3Qgbj10WzFdLmRpbXNbMV0qZS5ncm91cDtpZigzPT09dC5sZW5ndGgmJigxIT09dFsyXS5kaW1zLmxlbmd0aHx8dFsyXS5kaW1zWzBdIT09bikpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2NvbnN0IHI9dFswXS5kaW1zLmxlbmd0aC0yO2lmKGUuZGlsYXRpb25zLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7cn1EYCk7aWYoZS5zdHJpZGVzLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3J9RGApO2lmKGUucGFkcy5sZW5ndGghPT0yKnIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAkezIqcn1EYCk7aWYoZS5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtyfURgKTtpZigwIT09ZS5rZXJuZWxTaGFwZS5sZW5ndGgmJmUua2VybmVsU2hhcGUubGVuZ3RoIT09dFsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKDAhPT1lLm91dHB1dFNoYXBlLmxlbmd0aCYmZS5vdXRwdXRTaGFwZS5sZW5ndGghPT10WzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnZUcmFuc3Bvc2UgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpO2lmKDM9PT10Lmxlbmd0aCYmXCJmbG9hdDMyXCIhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udlRyYW5zcG9zZSBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sODEzODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUNvbnZBdHRyaWJ1dGVzPWUuY29udj1lLmNhbGN1bGF0ZU91dHB1dFNoYXBlPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDQ3NzApLGE9bigxMzg2KSxzPW4oOTgyOCksdT1uKDI4MjMpLGM9bigzMjQ4KSxsPW4oNTYyMyk7ZS5jYWxjdWxhdGVPdXRwdXRTaGFwZT0odCxlLG4scixpKT0+e2NvbnN0IG89dFswXSxhPXQuc2xpY2UoMikscz1hLmxlbmd0aCx1PWVbMF0sYz1lLnNsaWNlKDIpLm1hcCgoKHQsZSk9PnQrKHQtMSkqKG5bZV0tMSkpKSxsPWEubWFwKCgodCxlKT0+dCtyW2VdK3JbZStzXSkpLm1hcCgoKHQsZSk9Pk1hdGguZmxvb3IoKHQtY1tlXStpW2VdKS9pW2VdKSkpO3JldHVybltvLHVdLmNvbmNhdCguLi5sKX0sZS5jb252PSh0LGUsbik9PihnKGUsbikscCh0LGUsbikpO2NvbnN0IHA9KHQsZSxuKT0+e2NvbnN0IHI9aChuLGUpLGk9dC5zZXNzaW9uLnBhY2sscz0xPT09ci5rZXJuZWxTaGFwZVswXSYmMT09PXIua2VybmVsU2hhcGVbMV07cmV0dXJuIHIuZ3JvdXA+MT9bdC5ydW4oKDAsby5jcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXIpKHQsZSxyKSxlKV06cyYmaT9bZih0LGUscildOmkmJjQ9PT1lWzBdLmRpbXMubGVuZ3RoJiYxPT09ZVswXS5kaW1zWzBdJiYhcz9bKDAsYS5jb252MkRQYWNrZWQpKHQsZSxyKV06W2QodCxlLHIpXX0sZj0odCxuLHIpPT57Y29uc3QgaT1uWzBdLmRpbXMsbz1uWzFdLmRpbXMsYT0oMCxlLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShpLG8sci5kaWxhdGlvbnMsci5wYWRzLHIuc3RyaWRlcykscz10LnJlc2hhcGVVbnBhY2tlZChuWzBdLFtpWzFdLGlbMl0qaVszXV0pLHU9dC5yZXNoYXBlVW5wYWNrZWQoblsxXSxbb1swXSxvWzFdXSksYz1uLmxlbmd0aD4yP1t1LHMsblsyXV06W3Usc10scD10LnJ1bigoMCxsLmNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyKShjLHIpLGMpO3JldHVybiB0LnJlc2hhcGVVbnBhY2tlZChwLGEpfSxkPSh0LG4scik9Pntjb25zdCBpPW5bMF0uZGltcyxvPW5bMV0uZGltcyxhPSgwLGUuY2FsY3VsYXRlT3V0cHV0U2hhcGUpKGksbyxyLmRpbGF0aW9ucyxyLnBhZHMsci5zdHJpZGVzKSx1PXQucnVuKCgwLGMuY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXIpKHQsblswXSxuWzFdLGEsciksW25bMF1dKSxsPTM9PT1uLmxlbmd0aD9bdSxuWzFdLG5bMl1dOlt1LG5bMV1dO3JldHVybiB0LnJ1bigoMCxzLmNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcikodCxuLGEsciksbCl9LGg9KHQsZSk9Pntjb25zdCBuPXQua2VybmVsU2hhcGUuc2xpY2UoKTtpZigwPT09dC5rZXJuZWxTaGFwZS5sZW5ndGgpZm9yKGxldCB0PTI7dDxlWzFdLmRpbXMubGVuZ3RoOysrdCluLnB1c2goZVsxXS5kaW1zW3RdKTtjb25zdCByPXQucGFkcy5zbGljZSgpO2kuUG9vbENvbnZVdGlsLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChlWzBdLmRpbXMsdC5zdHJpZGVzLHQuZGlsYXRpb25zLG4scix0LmF1dG9QYWQpO2NvbnN0IG89T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihvLHtrZXJuZWxTaGFwZTpuLHBhZHM6cixjYWNoZUtleTp0LmNhY2hlS2V5fSksb307ZS5wYXJzZUNvbnZBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcyxuPSgwLHUucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKShlKSxpPWUuZ2V0U3RyaW5nKFwiYXV0b19wYWRcIixcIk5PVFNFVFwiKSxvPWUuZ2V0SW50cyhcImRpbGF0aW9uc1wiLFsxLDFdKSxhPWUuZ2V0SW50KFwiZ3JvdXBcIiwxKSxzPWUuZ2V0SW50cyhcImtlcm5lbF9zaGFwZVwiLFtdKSxjPWUuZ2V0SW50cyhcInBhZHNcIixbMCwwLDAsMF0pLGw9ZS5nZXRJbnRzKFwic3RyaWRlc1wiLFsxLDFdKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoT2JqZWN0LmFzc2lnbih7YXV0b1BhZDppLGRpbGF0aW9uczpvLGdyb3VwOmEsa2VybmVsU2hhcGU6cyxwYWRzOmMsc3RyaWRlczpsfSxuKSl9O2NvbnN0IGc9KHQsZSk9PntpZighdHx8MiE9PXQubGVuZ3RoJiYzIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKDQhPT10WzBdLmRpbXMubGVuZ3RofHw0IT09dFsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZih0WzBdLmRpbXNbMV0hPT10WzFdLmRpbXNbMV0qZS5ncm91cCl0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2lmKDM9PT10Lmxlbmd0aCYmKDEhPT10WzJdLmRpbXMubGVuZ3RofHx0WzFdLmRpbXNbMF0hPT10WzJdLmRpbXNbMF0pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtjb25zdCBuPXRbMF0uZGltcy5sZW5ndGgtMjtpZihlLmRpbGF0aW9ucy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke259RGApO2lmKGUuc3RyaWRlcy5sZW5ndGghPT1uKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtufURgKTtpZihlLnBhZHMubGVuZ3RoIT09MipuKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHsyKm59RGApO2lmKDAhPT1lLmtlcm5lbFNoYXBlLmxlbmd0aCYmZS5rZXJuZWxTaGFwZS5sZW5ndGghPT10WzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnYgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpO2lmKDM9PT10Lmxlbmd0aCYmXCJmbG9hdDMyXCIhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udiBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sNTE5MzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXM9ZS5kZXB0aFRvU3BhY2U9dm9pZCAwO2NvbnN0IHI9bigzNzM4KTtlLmRlcHRoVG9TcGFjZT0odCxlLG4pPT57aShlKTtjb25zdCBvPW4uYmxvY2tzaXplLGE9bypvLHM9XCJEQ1JcIj09PW4ubW9kZT9bMCwzLDQsMSw1LDJdOlswLDEsNCwyLDUsM10sdT1cIkRDUlwiPT09bi5tb2RlP1tlWzBdLmRpbXNbMF0sbyxvLGVbMF0uZGltc1sxXS9hLGVbMF0uZGltc1syXSxlWzBdLmRpbXNbM11dOltlWzBdLmRpbXNbMF0sZVswXS5kaW1zWzFdL2EsbyxvLGVbMF0uZGltc1syXSxlWzBdLmRpbXNbM11dLGM9dC5yZXNoYXBlVW5wYWNrZWQoZVswXSx1KSxsPXtwZXJtOnMsY2FjaGVLZXk6YCR7c31gfSxbcF09KDAsci50cmFuc3Bvc2UpKHQsW2NdLGwpLGY9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0vYSxlWzBdLmRpbXNbMl0qbyxlWzBdLmRpbXNbM10qb107cmV0dXJuW3QucmVzaGFwZVVucGFja2VkKHAsZildfSxlLnBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlcz10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiYmxvY2tzaXplXCIpO2lmKGU8MSl0aHJvdyBuZXcgRXJyb3IoYGJsb2Nrc2l6ZSBtdXN0IGJlID49IDEsIGJ1dCBnb3QgOiAke2V9IGZvciBEZXB0aFRvU3BhY2VgKTtjb25zdCBuPXQuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJtb2RlXCIsXCJEQ1JcIik7aWYoXCJEQ1JcIiE9PW4mJlwiQ1JEXCIhPT1uKXRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIG1vZGU6ICR7bn0gZm9yIERlcHRoVG9TcGFjZWApO3JldHVybnttb2RlOm4sYmxvY2tzaXplOmV9fTtjb25zdCBpPXQ9PntpZigxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBEZXB0aFRvU3BhY2UgZXhwZWN0IDEgaW5wdXRzLCBidXQgZ290ICR7dC5sZW5ndGh9YCk7aWYoXCJzdHJpbmdcIj09PXRbMF0udHlwZXx8NCE9PXRbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcHRoVG9TcGFjZSBpbnB1dCBzaG91bGQgYmUgYSA0LUQgbnVtZXJpYyB0ZW5zb3JcIil9fSw5ODI4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpLGk9big1MDYwKSxvPW4oMjAzOSksYT1uKDI4MjMpLHM9bigzMjQ4KTtlLmNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcj0odCxlLG4sdSk9Pntjb25zdCBjPSgodCxlKT0+KHtuYW1lOlwiQ29udkRvdFByb2R1Y3RcIixpbnB1dE5hbWVzOnQ/W1wiSW0yQ29sXCIsXCJLXCIsXCJCXCJdOltcIkltMkNvbFwiLFwiS1wiXSxpbnB1dFR5cGVzOnQ/W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbl0sY2FjaGVLZXk6ZS5hY3RpdmF0aW9uQ2FjaGVLZXl9KSkoZS5sZW5ndGg+Mix1KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtnZXQ6KCk9PigodCxlLG4sdSxjKT0+e2NvbnN0IGw9blswXS5kaW1zLHA9blsxXS5kaW1zLGY9W3BbMF0sTWF0aC5jZWlsKGxbMV0qcFsyXSpwWzNdLzQpXSxkPSgwLHMuY2FsY3VsYXRlSW0yQ29sRGltcykobCxwLHUpLFtoLGddPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGYsby5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSxiPXIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGQpLFttLHldPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGQsby5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSxfPXUubGVuZ3RoLHY9bi5sZW5ndGg8Mz9cIjAuMFwiOlwiX0IoYilcIix3PU1hdGguY2VpbChsWzFdKnBbMl0qcFszXS80KSx7YWN0aXZhdGlvbkZ1bmN0aW9uOngsYXBwbHlBY3RpdmF0aW9uOlR9PSgwLGEuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKGMpLFM9KDAsaS5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksTz1gXFxuJHt4fVxcbmZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtffV0pIHtcXG4gIGludCBiWzFdO1xcbiAgYlswXSA9IGluZGljZXNbMV07XFxuICBpbnQgaW0yY29sWzRdO1xcbiAgaW0yY29sWzBdID0gaW5kaWNlc1swXTtcXG4gIGltMmNvbFsxXSA9IGluZGljZXNbMl07XFxuICBpbTJjb2xbMl0gPSBpbmRpY2VzWzNdO1xcbiAgaW50IGltMmNvbE9mZnNldCA9IGltMmNvbFswXSAqICR7YlswXX0gKyBpbTJjb2xbMV0gKiAke2JbMV19ICsgaW0yY29sWzJdICogJHtiWzJdfTtcXG4gIGludCBrZXJuZWxPZmZzZXQgPSBpbmRpY2VzWzFdICogJHtmWzFdfTtcXG4gIGZsb2F0IHZhbHVlID0gJHt2fTtcXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgJHt3fTsgKytpKSB7XFxuICAgIHZlYzIgaW0yY29sQ29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW0yY29sT2Zmc2V0LCAke219LCAke3l9KTtcXG4gICAgdmVjMiBrZXJuZWxDb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhrZXJuZWxPZmZzZXQsICR7aH0sICR7Z30pO1xcbiAgICB2YWx1ZSArPSBkb3QoJHtTLnRleHR1cmUyRH0oSW0yQ29sLCBpbTJjb2xDb29yZHMpLCAke1MudGV4dHVyZTJEfShLLCBrZXJuZWxDb29yZHMpKTtcXG4gICAgKytpbTJjb2xPZmZzZXQ7XFxuICAgICsra2VybmVsT2Zmc2V0O1xcbiAgfVxcbiAgJHtUfVxcbiAgcmV0dXJuIHZhbHVlO1xcbn1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczp1LHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpPfSl9KSh0LGMsZSxuLHUpfSl9fSw3OTkyOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlRmxhdHRlbkF0dHJpYnV0ZXM9ZS5mbGF0dGVuPXZvaWQgMDtjb25zdCByPW4oMjUxNyk7ZS5mbGF0dGVuPSh0LGUsbik9PntpKGUsbik7Y29uc3Qgbz1yLlNoYXBlVXRpbC5mbGF0dGVuU2hhcGUoZVswXS5kaW1zLG4pO3JldHVyblt0LnJlc2hhcGVVbnBhY2tlZChlWzBdLG8pXX0sZS5wYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzPXQ9PnQuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIsMSk7Y29uc3QgaT0odCxlKT0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdHRlbiByZXF1aXJlcyAxIGlucHV0LlwiKTtjb25zdCBuPXRbMF0uZGltcy5sZW5ndGg7aWYoMD09PW4pdGhyb3cgbmV3IEVycm9yKFwic2NhbGFyIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLlwiKTtpZihlPC1ufHxlPm4pdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGlzXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLlwiKX19LDI4MjM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzPWUuZ2V0QWN0aXZhdGlvblNuaXBwZXQ9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oNDkwOSk7ZS5nZXRBY3RpdmF0aW9uU25pcHBldD1mdW5jdGlvbih0KXtsZXQgZTtzd2l0Y2godC5hY3RpdmF0aW9uKXtjYXNlXCJSZWx1XCI6ZT0oMCxpLmdsc2xSZWx1KSgpO2JyZWFrO2Nhc2VcIlNpZ21vaWRcIjplPSgwLGkuZ2xzbFNpZ21vaWQpKCk7YnJlYWs7Y2FzZVwiQ2xpcFwiOmU9KDAsaS5nbHNsQ2xpcCkodC5jbGlwTWluLHQuY2xpcE1heCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm57YWN0aXZhdGlvbkZ1bmN0aW9uOlwiXCIsYXBwbHlBY3RpdmF0aW9uOlwiXCJ9fWNvbnN0IG49ZS5uYW1lO3JldHVybnthY3RpdmF0aW9uRnVuY3Rpb246ZS5ib2R5LGFwcGx5QWN0aXZhdGlvbjpgdmFsdWUgPSAke259Xyh2YWx1ZSk7YH19LGUucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuZ2V0U3RyaW5nKFwiYWN0aXZhdGlvblwiLFwiXCIpO2lmKFwiQ2xpcFwiPT09ZSl7Y29uc3RbbixpXT10LmdldEZsb2F0cyhcImFjdGl2YXRpb25fcGFyYW1zXCIsW3IuTUlOX0NMSVAsci5NQVhfQ0xJUF0pO3JldHVybnthY3RpdmF0aW9uOmUsY2xpcE1heDppLGNsaXBNaW46bixhY3RpdmF0aW9uQ2FjaGVLZXk6YCR7ZX06JHtufSwke2l9YH19cmV0dXJue2FjdGl2YXRpb246ZSxhY3RpdmF0aW9uQ2FjaGVLZXk6ZX19fSwxMjUzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlR2F0aGVyQXR0cmlidXRlcz1lLmdhdGhlcj12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDc4Miksbz1uKDI1MTcpLGE9bigyMDM5KTtlLmdhdGhlcj0odCxlLG4pPT4oYyhlLG4uYXhpcyksW3QucnVuKHUodCxlLG4pLGUpXSksZS5wYXJzZUdhdGhlckF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGlzOnQuYXR0cmlidXRlcy5nZXRJbnQoXCJheGlzXCIsMCl9KTtjb25zdCBzPXtuYW1lOlwiR2F0aGVyXCIsaW5wdXROYW1lczpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWQsYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LHU9KHQsZSxuKT0+e2NvbnN0IHI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleX0pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KCh0LGUsbixyKT0+e2NvbnN0IGk9blswXS5kaW1zLnNsaWNlKCkscz1uWzFdLmRpbXMuc2xpY2UoKSx1PW5ldyBBcnJheShpLmxlbmd0aCtzLmxlbmd0aC0xKTtyPW8uU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMocixpLmxlbmd0aCk7Y29uc3QgYz1bXTtmb3IobGV0IHQ9MDt0PHUubGVuZ3RoO3QrKyl0PHI/KHVbdF09aVt0XSxjLnB1c2goYGlucHV0SWR4WyR7dH1dID0gb3V0cHV0SWR4WyR7dH1dO2ApKTp0PHIrcy5sZW5ndGg/KHVbdF09c1t0LXJdLGMucHVzaChgaW5kZXhEYXRhSWR4WyR7dC1yfV0gPSBvdXRwdXRJZHhbJHt0fV07YCkpOih1W3RdPWlbdC1zLmxlbmd0aCsxXSxjLnB1c2goYGlucHV0SWR4WyR7dC1zLmxlbmd0aCsxfV0gPSBvdXRwdXRJZHhbJHt0fV07YCkpO2NvbnN0IGw9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske3UubGVuZ3RofHwxfV0pIHtcXG4gICAgICAgIGludCBpbnB1dElkeFske2kubGVuZ3RofV07XFxuICAgICAgICBpbnQgaW5kZXhEYXRhSWR4WyR7cy5sZW5ndGh8fDF9XTtcXG4gICAgICAgIGluZGV4RGF0YUlkeFswXSA9IDA7XFxuICAgICAgICAke2Muam9pbihcIlxcbiAgICAgICAgXCIpfVxcbiAgICAgICAgaW50IGlkeCA9IGludChfQihpbmRleERhdGFJZHgpKTtcXG4gICAgICAgIGlucHV0SWR4WyR7cn1dID0gaWR4IDwgMCA/IGlkeCArICR7aVtyXX0gOiBpZHg7XFxuICAgICAgICByZXR1cm4gX0EoaW5wdXRJZHgpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczp1LHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpsfSl9KSgwLHIsZSxuLmF4aXMpfSl9LGM9KHQsZSk9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIik7Y29uc3Qgbj10WzBdLmRpbXMubGVuZ3RoO2lmKG48MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZihlPC1ufHxlPm4tMSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF4aXMuXCIpO2lmKC0xPT09aS5OVU1CRVJfVFlQRVMuaW5kZXhPZih0WzBdLnR5cGUpKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCB0eXBlLlwiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGUmJlwiaW50MTZcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgdHlwZS5cIil9fSw0Nzc2Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlR2VtbUF0dHJpYnV0ZXNWMTE9ZS5wYXJzZUdlbW1BdHRyaWJ1dGVzVjc9ZS5nZW1tPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDIwMzkpO2UuZ2VtbT0odCxlLG4pPT4oYyhlLG4pLFt0LnJ1bihzKGUsbiksZSldKTtjb25zdCBhPSh0LGUpPT57Y29uc3Qgbj0wIT09dC5hdHRyaWJ1dGVzLmdldEludChcInRyYW5zQVwiLDApLGk9MCE9PXQuYXR0cmlidXRlcy5nZXRJbnQoXCJ0cmFuc0JcIiwwKSxvPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImFscGhhXCIsMSksYT10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJiZXRhXCIsMSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHt0cmFuc0E6bix0cmFuc0I6aSxhbHBoYTpvLGJldGE6YSxpc09wdGlvbmFsQzplfSl9O2UucGFyc2VHZW1tQXR0cmlidXRlc1Y3PXQ9PmEodCwhMSksZS5wYXJzZUdlbW1BdHRyaWJ1dGVzVjExPXQ9PmEodCwhMCk7Y29uc3Qgcz0odCxlKT0+e2NvbnN0IG49e25hbWU6XCJHZW1tXCIsaW5wdXROYW1lczozPT09dC5sZW5ndGg/W1wiQVwiLFwiQlwiLFwiQ1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6Mz09PXQubGVuZ3RoP1tvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF06W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF0sa2V5OmUuY2FjaGVLZXl9O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+dShuLHQsZSl9KX0sdT0odCxlLG4pPT57Y29uc3Qgcj1lWzBdLmRpbXMuc2xpY2UoKSxhPWVbMV0uZGltcy5zbGljZSgpLFtzLHVdPWkuR2VtbVV0aWwuZ2V0U2hhcGVPZkdlbW1SZXN1bHQocixuLnRyYW5zQSxhLG4udHJhbnNCLDM9PT1lLmxlbmd0aD9lWzJdLmRpbXM6dm9pZCAwKSxjPVtzLHVdO2lmKCFjKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBsPXJbci5sZW5ndGgtMV0scD1cIlwiO24udHJhbnNBJiYobD1yWzBdKSxuLnRyYW5zQSYmbi50cmFuc0I/cD1cInZhbHVlICs9IF9BX1QoYSkgKiBfQl9UKGIpO1wiOm4udHJhbnNBJiYhbi50cmFuc0I/cD1cInZhbHVlICs9IF9BX1QoYSkgKiBfQihiKTtcIjohbi50cmFuc0EmJm4udHJhbnNCP3A9XCJ2YWx1ZSArPSBfQShhKSAqIF9CX1QoYik7XCI6bi50cmFuc0F8fG4udHJhbnNCfHwocD1cInZhbHVlICs9IF9BKGEpICogX0IoYik7XCIpO2NvbnN0IGY9Yy5sZW5ndGgsZD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2Z9XSkge1xcbiAgICAgICAgICBpbnQgYVske2Z9XTtcXG4gICAgICAgICAgaW50IGJbJHtmfV07XFxuICAgICAgICAgICR7Mz09PWUubGVuZ3RoP2BpbnQgY1ske2VbMl0uZGltcy5sZW5ndGh9XTtgOlwiXCJ9XFxuXFxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYSk7XFxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYik7XFxuICAgICAgICAgICR7Mz09PWUubGVuZ3RoP1wiYmNhc3RJbmRpY2VzX0MoaW5kaWNlcywgYyk7XCI6XCJcIn1cXG5cXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAwLjA7XFxuICAgICAgICAgIGZvciAoaW50IGs9MDsgazwke2x9OyArK2spIHtcXG4gICAgICAgICAgICAgIGFbJHtmLTF9XSA9IGs7XFxuICAgICAgICAgICAgICBiWyR7Zi0yfV0gPSBrO1xcbiAgICAgICAgICAgICAgJHtwfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiBhbHBoYTtcXG4gICAgICAgICAgJHszPT09ZS5sZW5ndGg/XCJ2YWx1ZSArPSBiZXRhICogX0MoYyk7XCI6XCJcIn1cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpjLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHZhcmlhYmxlczpbe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmbG9hdFwiLGRhdGE6bi5hbHBoYX0se25hbWU6XCJiZXRhXCIsdHlwZTpcImZsb2F0XCIsZGF0YTpuLmJldGF9XSxzaGFkZXJTb3VyY2U6ZH0pfSxjPSh0LGUpPT57aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZihlLmlzT3B0aW9uYWxDJiYodC5sZW5ndGg8Mnx8dC5sZW5ndGg+MykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IHNoYXBlLlwiKTtpZighZS5pc09wdGlvbmFsQyYmMyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkdlbW0gcmVxdWlyZXMgMyBpbnB1dHNcIik7aWYoMz09PXQubGVuZ3RoJiYxIT09dFsyXS5kaW1zLmxlbmd0aCYmMiE9PXRbMl0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZXx8XCJmbG9hdDMyXCIhPT10WzFdLnR5cGUmJlwiZmxvYXQ2NFwiIT09dFsxXS50eXBlfHwzPT09dC5sZW5ndGgmJlwiZmxvYXQzMlwiIT09dFsyXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMl0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKHRbMF0udHlwZSE9PXRbMV0udHlwZXx8Mz09PXQubGVuZ3RoJiZ0WzBdLnR5cGUhPT10WzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWRcIil9fSw4NTU1Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNTA2MCksaT1uKDIwMzkpLG89bigyODI3KTtlLmNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyPSh0LGUsbixhLHMpPT57Y29uc3QgdT0oYz1zLmNhY2hlS2V5LHtuYW1lOlwiSW0yQ29sIChwYWNrZWQpXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUucGFja2VkXSxjYWNoZUhpbnQ6Y30pO3ZhciBjO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse2dldDooKT0+KCh0LGUsbixhLHMsdSk9Pntjb25zdCBjPW4uZGltcyxsPWEuZGltcyxwPXMubGVuZ3RoLGY9W2xbMV0qbFsyXSpsWzNdLHNbMl0qc1szXV0sZD1sWzJdKmxbM10saD0oMCxvLnVucGFja0Zyb21DaGFubmVsKSgpLGc9KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7bGV0IGI9XCJcIjtmb3IobGV0IHQ9MDt0PD0xO3QrKylmb3IobGV0IGU9MDtlPD0xO2UrKyliKz1gXFxuICAgICAgICAgICAgYmxvY2tJbmRleCA9IHJjLnggKyAke2V9O1xcbiAgICAgICAgICAgIHBvcyA9IHJjLnkgKyAke3R9O1xcblxcbiAgICAgICAgICAgIGlmKGJsb2NrSW5kZXggPCAke2ZbMV19ICYmIHBvcyA8ICR7ZlswXX0pIHtcXG4gICAgICAgICAgICAgIG9mZnNldFkgPSBpbnQoYmxvY2tJbmRleCAvICgke3NbcC0xXX0pKSAqICR7dS5zdHJpZGVzWzBdfSAtXFxuICAgICAgICAgICAgICAgICR7dS5wYWRzWzBdfTtcXG4gICAgICAgICAgICAgIGQwID0gb2Zmc2V0WSArICR7dS5kaWxhdGlvbnNbMF19ICogKGltb2QocG9zLCAke2R9KSAvICR7bFsyXX0pO1xcblxcbiAgICAgICAgICAgICAgaWYoZDAgPCAke2NbMl19ICYmIGQwID49IDApIHtcXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IGltb2QoYmxvY2tJbmRleCwgJHtzW3AtMV19KSAqICR7dS5zdHJpZGVzWzFdfSAtXFxuICAgICAgICAgICAgICAgICAgJHt1LnBhZHNbMV19O1xcbiAgICAgICAgICAgICAgICBkMSA9IG9mZnNldFggKyAke3UuZGlsYXRpb25zWzFdfSAqIGltb2QoaW1vZChwb3MsICR7ZH0pLCAke2xbMl19KTtcXG5cXG4gICAgICAgICAgICAgICAgaWYoZDEgPCAke2NbM119ICYmIGQxID49IDApIHtcXG5cXG4gICAgICAgICAgICAgICAgICBjaCA9IGludChmbG9hdChwb3MpLyAke2R9Lik7XFxuICAgICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQwLCBkMSk7XFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJHsyKnQrZX1dID0gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0QSgwLCBjaCwgaW50KGlubmVyRGltcy54KSxcXG4gICAgICAgICAgICAgICAgICAgICAgaW50KGlubmVyRGltcy55KSksIGlubmVyRGltcyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGA7Y29uc3QgbT1gXFxuICAgICAgJHtofVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLjApO1xcbiAgICAgICAgICBpbnQgYmxvY2tJbmRleCwgcG9zLCBvZmZzZXRZLCBkMCwgb2Zmc2V0WCwgZDEsIGNoO1xcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcztcXG4gICAgICAgICAgJHtifVxcbiAgICAgICAgICAke2cub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgICAgICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6Zix0eXBlOm4udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZH0sc2hhZGVyU291cmNlOm0saGFzTWFpbjohMH0pfSkodCx1LGUsbixhLHMpfSl9fSwzMjQ4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNhbGN1bGF0ZUltMkNvbERpbXM9ZS5jcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDIwMzkpO2UuY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXI9KHQsbixpLG8sYSk9Pntjb25zdCBzPSh1PWEuY2FjaGVLZXkse25hbWU6XCJJbTJDb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbci5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50OnV9KTt2YXIgdTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtnZXQ6KCk9PigodCxuLGksbyxhLHMpPT57Y29uc3QgdT1pLmRpbXMsYz1vLmRpbXMsbD1hLmxlbmd0aCxwPSgwLGUuY2FsY3VsYXRlSW0yQ29sRGltcykodSxjLGEsNCksZj1gXFxuICAgICAgICBjb25zdCBpbnQgWEMgPSAke3VbMV19O1xcbiAgICAgICAgY29uc3QgaW50IFhIID0gJHt1WzJdfTtcXG4gICAgICAgIGNvbnN0IGludCBYVyA9ICR7dVszXX07XFxuICAgICAgICBjb25zdCBpbnQgS0ggPSAke3Mua2VybmVsU2hhcGVbMF19O1xcbiAgICAgICAgY29uc3QgaW50IEtXID0gJHtzLmtlcm5lbFNoYXBlWzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBkaWxhdGlvbkggPSAke3MuZGlsYXRpb25zWzBdfTtcXG4gICAgICAgIGNvbnN0IGludCBkaWxhdGlvblcgPSAke3MuZGlsYXRpb25zWzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBzdHJpZGVIID0gJHtzLnN0cmlkZXNbMF19O1xcbiAgICAgICAgY29uc3QgaW50IHN0cmlkZVcgPSAke3Muc3RyaWRlc1sxXX07XFxuICAgICAgICBjb25zdCBpbnQgcGFkSCA9ICR7cy5wYWRzWzBdfTtcXG4gICAgICAgIGNvbnN0IGludCBwYWRXID0gJHtzLnBhZHNbMV19O1xcbiAgICAgICAgY29uc3QgaW50IEtIS1cgPSBLSCpLVztcXG4gICAgICAgIGNvbnN0IGludCBYQ0tIS1cgPSBYQyAqIEtIS1c7XFxuICAgICAgICBjb25zdCBpbnQgb3V0cHV0Q2hhbm5lbHMgPSA0O1xcbiAgICAgICAgdmVjNCBwcm9jZXNzKGludCBpbmRpY2VzWyR7bH1dKSB7XFxuICAgICAgICAgIGludCBiICA9IGluZGljZXNbMF07IC8vIGJhdGNoIHNpemVcXG4gICAgICAgICAgaW50IG9oID0gaW5kaWNlc1sxXSAqIHN0cmlkZUggLSBwYWRIOyAvL291dHB1dCBoZWlnaHRcXG4gICAgICAgICAgaW50IG93ID0gaW5kaWNlc1syXSAqIHN0cmlkZVcgLSBwYWRXOyAvL291dHB1dCB3aWR0aFxcbiAgICAgICAgICBpbnQgcCA9IGluZGljZXNbM10gKiBvdXRwdXRDaGFubmVsczsgLy9wYXRjaFxcbiAgICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwLjApO1xcbiAgICAgICAgICBmb3IoaW50IGk9MDsgaSA8IG91dHB1dENoYW5uZWxzOyArK2kpIHtcXG4gICAgICAgICAgICBpZihwIDwgWENLSEtXKSB7XFxuICAgICAgICAgICAgICBpbnQgcGF0Y2hDID0gcCAvIEtIS1c7XFxuICAgICAgICAgICAgICBpbnQgcGF0Y2hIID0gKHAgLSBwYXRjaEMqS0hLVykgLyBLVztcXG4gICAgICAgICAgICAgIGludCBwYXRjaFcgPSAocCAtIHBhdGNoQypLSEtXKSAtIHBhdGNoSCAqIEtXO1xcbiAgICAgICAgICAgICAgaW50IHhoMiA9IG9oICsgcGF0Y2hIICogZGlsYXRpb25IO1xcbiAgICAgICAgICAgICAgaW50IHh3MiA9IG93ICsgcGF0Y2hXICogZGlsYXRpb25XO1xcbiAgICAgICAgICAgICAgaW50IHhbJHt1Lmxlbmd0aH1dO1xcbiAgICAgICAgICAgICAgeFswXSA9IGI7XFxuICAgICAgICAgICAgICB4WzFdID0gcGF0Y2hDO1xcbiAgICAgICAgICAgICAgeFsyXSA9IHhoMjtcXG4gICAgICAgICAgICAgIHhbM10gPSB4dzI7XFxuICAgICAgICAgICAgICBpZih4aDIgPj0gMCAmJlxcbiAgICAgICAgICAgICAgICAgIHhoMiA8IFhIICYmXFxuICAgICAgICAgICAgICAgICAgeHcyID49IDAgJiZcXG4gICAgICAgICAgICAgICAgICB4dzIgPCBYVykge1xcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IF9YKHgpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICArK3A7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtvdXRwdXQ6e2RpbXM6cCx0eXBlOmkudHlwZSx0ZXh0dXJlVHlwZTpyLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LHNoYWRlclNvdXJjZTpmfSl9KSgwLHMsbixpLG8sYSl9KX0sZS5jYWxjdWxhdGVJbTJDb2xEaW1zPSh0LGUsbixyPTQpPT5bblswXSxuWzJdLG5bM10sTWF0aC5jZWlsKHRbMV0qZVsyXSplWzNdL3IpXX0sNjU3MjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUltYWdlU2NhbGVyQXR0cmlidXRlcz1lLmltYWdlU2NhbGVyPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjAzOSk7ZS5pbWFnZVNjYWxlcj0odCxlLG4pPT4odShlKSxbdC5ydW4oYSh0LGUsbiksZSldKSxlLnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcInNjYWxlXCIpLG49dC5hdHRyaWJ1dGVzLmdldEZsb2F0cyhcImJpYXNcIik7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtzY2FsZTplLGJpYXM6bn0pfTtjb25zdCBvPXtuYW1lOlwiSW1hZ2VTY2FsZXJcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LGE9KHQsZSxuKT0+e2NvbnN0IHI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHtjYWNoZUhpbnQ6bi5jYWNoZUtleX0pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KCh0LGUsbixyKT0+e2NvbnN0IG89blswXS5kaW1zLnNsaWNlKCksYT1vLmxlbmd0aCx1PWBcXG4gICAgICAke3Moci5iaWFzLmxlbmd0aCl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2F9XSkge1xcbiAgICAgICAgcmV0dXJuIF9YKGluZGljZXMpICogc2NhbGUgKyBnZXRCaWFzKGJpYXMsIGluZGljZXNbMV0pO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpvLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHZhcmlhYmxlczpbe25hbWU6XCJiaWFzXCIsdHlwZTpcImZsb2F0XCIsYXJyYXlMZW5ndGg6ci5iaWFzLmxlbmd0aCxkYXRhOnIuYmlhc30se25hbWU6XCJzY2FsZVwiLHR5cGU6XCJmbG9hdFwiLGRhdGE6ci5zY2FsZX1dLHNoYWRlclNvdXJjZTp1fSl9KSgwLHIsZSxuKX0pfSxzPXQ9Pntjb25zdCBlPVtgZmxvYXQgZ2V0QmlhcyhmbG9hdCBiaWFzWyR7dH1dLCBpbnQgY2hhbm5lbCkge2BdO2ZvcihsZXQgbj0wO248dDsrK24pMD09PW4/ZS5wdXNoKGBcXHRpZiAoY2hhbm5lbCA9PSAke259KSB7IHJldHVybiBiaWFzWyR7bn1dOyB9YCk6bj09PXQtMT9lLnB1c2goYFxcdGVsc2UgeyByZXR1cm4gYmlhc1ske259XTsgfWApOmUucHVzaChgXFx0ZWxzZSBpZiAoY2hhbm5lbCA9PSAke259KSB7IHJldHVybiBiaWFzWyR7bn1dOyB9YCk7cmV0dXJuIGUucHVzaChcIlxcdH1cIiksZS5qb2luKFwiXFxuXCIpfSx1PXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkltYWdlU2NhbGVyIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKDQhPT10WzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sMzM0NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZUluc3RhbmNlTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM9ZS5pbnN0YW5jZU5vcm1hbGl6YXRpb249dm9pZCAwO2NvbnN0IHI9big1MDYwKSxpPW4oMjAzOSk7ZS5pbnN0YW5jZU5vcm1hbGl6YXRpb249KHQsZSxuKT0+e2MoZSk7Y29uc3Qgcj10LnJ1bihhKGVbMF0pLGUpO3JldHVyblt0LnJ1bih1KHQsZVswXSxuLHIuZGltcyksW2VbMF0scixlWzFdLGVbMl1dKV19LGUucGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPXQ9PnQuYXR0cmlidXRlcy5nZXRGbG9hdChcImVwc2lsb25cIiwxZS01KTtjb25zdCBvPXtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uX01lYW5BbmRWYXJpYW5jZVwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXX0sYT10PT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbykse2dldDooKT0+KCh0LGUpPT57Y29uc3Qgbj1lLmRpbXMuc2xpY2UoKSxyPW5bMV0sbz1uWzJdKm5bM10sYT1bblswXSxyXSxzPWBcXG4gICAgICB2ZWM0IHByb2Nlc3MoaW50WzJdIGluZGljZXMpIHtcXG4gICAgICAgIHZlYzQgdiA9IHZlYzQoMC4wKTtcXG4gICAgICAgIGludCBhWzRdO1xcbiAgICAgICAgYVswXSA9IGluZGljZXNbMF07XFxuICAgICAgICBhWzFdID0gaW5kaWNlc1sxXTtcXG4gICAgICAgIGZsb2F0IHRlbXAgPSAwLjA7XFxuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7blsyXX07IGEyKyspIHtcXG4gICAgICAgICAgYVsyXSA9IGEyO1xcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7blszXX07IGEzKyspIHtcXG4gICAgICAgICAgICBhWzNdID0gYTM7XFxuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xcbiAgICAgICAgICAgIHRlbXAgKz0geDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgbWVhbiA9IHRlbXAgLyBmbG9hdCgke299KTtcXG4gICAgICAgIHRlbXAgPSAwLjA7XFxuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7blsyXX07IGEyKyspIHtcXG4gICAgICAgICAgYVsyXSA9IGEyO1xcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7blszXX07IGEzKyspIHtcXG4gICAgICAgICAgICBhWzNdID0gYTM7XFxuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xcbiAgICAgICAgICAgIHRlbXAgKz0gKHggLSBtZWFuKSAqICh4IC0gbWVhbik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHYuciA9IG1lYW47XFxuICAgICAgICB2LmcgPSB0ZW1wIC8gZmxvYXQoJHtvfSk7XFxuXFxuICAgICAgICByZXR1cm4gdjtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6YSx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LHNoYWRlclNvdXJjZTpzfSl9KShvLHQpfSkscz17bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbl9Db21wdXRlT3V0cHV0XCIsaW5wdXROYW1lczpbXCJYXCIsXCJNZWFuQW5kVmFyaWFuY2VcIixcIlNjYWxlXCIsXCJCXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLGkuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LHU9KHQsZSxuLG8pPT57Y29uc3QgYT1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpgJHtufWB9KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtnZXQ6KCk9PigodCxlLG4sbyxhKT0+e2NvbnN0IHM9KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksW3UsY109dC5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoYSxpLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pLFtsLHBdPVt1LzQsY10sZj1gXFxuICAgICAgdmVjNCBnZXRfTWVhbkFuZFZhcmlhbmNlKGludFsyXSBtdikge1xcbiAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bH0sICR7cH0pO1xcbiAgICAgICAgcmV0dXJuICR7cy50ZXh0dXJlMkR9KE1lYW5BbmRWYXJpYW5jZSwgY29vcmRzKTtcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbNF0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IG12WzJdO1xcbiAgICAgICAgbXZbMF0gPSBpbmRpY2VzWzBdO1xcbiAgICAgICAgbXZbMV0gPSBpbmRpY2VzWzFdO1xcbiAgICAgICAgdmVjNCBtZWFuX2FuZF92YXJpYW5jZSA9IGdldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xcbiAgICAgICAgZmxvYXQgbWVhbiA9IG1lYW5fYW5kX3ZhcmlhbmNlLnI7XFxuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IG1lYW5fYW5kX3ZhcmlhbmNlLmc7XFxuXFxuICAgICAgICBpbnQgc2JbMV07XFxuICAgICAgICBzYlswXSA9IGluZGljZXNbMV07XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IF9TY2FsZShzYik7XFxuICAgICAgICBmbG9hdCBiID0gX0Ioc2IpO1xcblxcbiAgICAgICAgcmV0dXJuIHNjYWxlICogKF9YKGluZGljZXMpIC0gbWVhbikgLyBzcXJ0KHZhcmlhbmNlICsgZXBzaWxvbikgKyBiO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpuLmRpbXMsdHlwZTpuLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sdmFyaWFibGVzOlt7bmFtZTpcImVwc2lsb25cIix0eXBlOlwiZmxvYXRcIixkYXRhOm99XSxzaGFkZXJTb3VyY2U6Zn0pfSkodCxhLGUsbixvKX0pfSxjPXQ9PntpZighdHx8MyE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkluc3RhbmNlTm9ybWFsaXphdGlvbiByZXF1aXJlcyAzIGlucHV0cy5cIik7Y29uc3QgZT10WzBdLG49dFsxXSxyPXRbMl07aWYoZS5kaW1zLmxlbmd0aDwzfHwxIT09bi5kaW1zLmxlbmd0aHx8MSE9PXIuZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYobi5kaW1zWzBdIT09ZS5kaW1zWzFdfHxyLmRpbXNbMF0hPT1lLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLlwiKTtpZihcImZsb2F0MzJcIiE9PWUudHlwZSYmXCJmbG9hdDY0XCIhPT1lLnR5cGV8fFwiZmxvYXQzMlwiIT09bi50eXBlJiZcImZsb2F0NjRcIiE9PW4udHlwZXx8XCJmbG9hdDMyXCIhPT1yLnR5cGUmJlwiZmxvYXQ2NFwiIT09ci50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoNCE9PXRbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiT25seSBzdXBwb3J0IDQtRCBpbnB1dCBzaGFwZS5cIil9fSw3MDg6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oNTA2MCksbz1uKDIwMzkpLGE9big5MzkwKSxzPW4oMjgyMyksdT1uKDU2MjMpO2UuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuKT0+e2NvbnN0IGM9KGw9ZS5sZW5ndGg+MixwPW4uYWN0aXZhdGlvbkNhY2hlS2V5LHtuYW1lOlwiTWF0TXVsIChwYWNrZWQpXCIsaW5wdXROYW1lczpsP1tcIkFcIixcIkJcIixcIkJpYXNcIl06W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOmw/W28uVGV4dHVyZVR5cGUucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkLG8uVGV4dHVyZVR5cGUucGFja2VkXTpbby5UZXh0dXJlVHlwZS5wYWNrZWQsby5UZXh0dXJlVHlwZS5wYWNrZWRdLGNhY2hlSGludDpwfSk7dmFyIGwscDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtnZXQ6KCk9PigodCxlLG4sYyk9Pntjb25zdCBsPW4ubGVuZ3RoPjIscD1sP1widmFsdWUgKz0gZ2V0Qmlhc0Zvck1hdG11bCgpO1wiOlwiXCIsZj1uWzBdLmRpbXMsZD1uWzFdLmRpbXMsaD1yLkJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGYsZCwhMCksZz0hci5TaGFwZVV0aWwuYXJlRXF1YWwoblswXS5kaW1zLG5bMV0uZGltcyk7aWYoIWgpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtjb25zdCBiPWZbZi5sZW5ndGgtMV0sbT1NYXRoLmNlaWwoYi8yKSx5PWYubGVuZ3RoLF89ZC5sZW5ndGgsdj0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx3PSgwLGEuZ2V0Q29vcmRzRGF0YVR5cGUpKGgubGVuZ3RoKSx4PWgubGVuZ3RoLFQ9KDAsYS5nZXRHbENoYW5uZWxzKSgpLHthY3RpdmF0aW9uRnVuY3Rpb246UyxhcHBseUFjdGl2YXRpb246T309KDAscy5nZXRBY3RpdmF0aW9uU25pcHBldCkoYyksQT1sP2AkeygwLHUuZ2V0Qmlhc0Zvck1hdG11bCkodyxULG5bMl0uZGltcyxoLCEwKX1gOlwiXCIsRT1nP2Ake2Z1bmN0aW9uKHQsZSxuLGkpe2xldCBvPVtdLGE9W107Y29uc3Qgcz1uWzBdLmRpbXMsdT1uWzFdLmRpbXMsYz1zLmxlbmd0aCxsPXUubGVuZ3RoLHA9aS5sZW5ndGgsZj1wLWMsZD1wLWw7bz1zLm1hcCgoKHQsbik9PmBjb29yZHMuJHtlW24rZl19YCkpLG9bYy0xXT1cImkqMlwiLG8uam9pbihcIiwgXCIpLGE9dS5tYXAoKCh0LG4pPT5gY29vcmRzLiR7ZVtuK2RdfWApKSxhW2wtMl09XCJpKjJcIixhLmpvaW4oXCIsIFwiKTtjb25zdCBoPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKHMsaSksZz1yLkJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyh1LGkpLGI9aC5tYXAoKHQ9PmBjb29yZHMuJHtlW3QrZl19ID0gMDtgKSkuam9pbihcIlxcblwiKSxtPWcubWFwKCh0PT5gY29vcmRzLiR7ZVt0K2RdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIikseT1gaW50IGxhc3REaW0gPSBjb29yZHMuJHtlW3AtMV19O1xcbiAgY29vcmRzLiR7ZVtwLTFdfSA9IGNvb3Jkcy4ke2VbcC0yXX07XFxuICBjb29yZHMuJHtlW3AtMl19ID0gbGFzdERpbTtgO3JldHVybmBcXG52ZWM0IGdldEFBdE91dENvb3Jkc01hdG11bChpbnQgaSkge1xcbiAgJHt0fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7eX1cXG4gICR7Yn1cXG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRBKCR7b30pO1xcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xcbn1cXG5cXG52ZWM0IGdldEJBdE91dENvb3Jkc01hdG11bChpbnQgaSkge1xcbiAgJHt0fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7eX1cXG4gICR7bX1cXG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRCKCR7YX0pO1xcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xcbn1gfSh3LFQsbixoKX1gOlwiXCIsST1nP1wiZ2V0QUF0T3V0Q29vcmRzTWF0bXVsKGkpXCI6YGdldEEoJHtmdW5jdGlvbih0LGUpe2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjxlLTI7cisrKW4rPWByYy4ke3Rbcl19LCBgO3JldHVybiBuKz1gcmMuJHt0W2UtMl19LCBpKjJgLG59KFQseSl9KWAsUD1nP1wiZ2V0QkF0T3V0Q29vcmRzTWF0bXVsKGkpXCI6YGdldEIoJHtmdW5jdGlvbih0LGUpe2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjxlLTI7cisrKW4rPWByYy4ke3Rbcl19LCBgO3JldHVybiBuKz1gaSoyLCByYy4ke3RbZS0xXX1gLG59KFQsXyl9KWAsRD1gXFxuICAgICAgICAgICAgJHtFfVxcbiAgICAgICAgICAgICR7QX1cXG4gICAgICAgICAgICAke1N9XFxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICAgJHtnP1wiXCI6YCR7d30gcmMgPVxcbiAgICAgICAgICBnZXRPdXRwdXRDb29yZHMoKTsgaW50IGxhc3REaW0gPSByYy4ke1RbeC0xXX07IHJjLiR7VFt4LTFdfSA9XFxuICAgICAgICAgIHJjLiR7VFt4LTJdfTsgcmMuJHtUW3gtMl19ID0gbGFzdERpbTtcXG4gICAgICBgfVxcblxcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZSA9IHZlYzQoMCk7XFxuICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7bX07IGkrKykge1xcbiAgICAgICAgICAgICAgICB2ZWM0IGEgPSAke0l9O1xcbiAgICAgICAgICAgICAgICB2ZWM0IGIgPSAke1B9O1xcblxcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAoYS5ycmJiICogYi5yZ3JnKTtcXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gKGEuZ2dhYSAqIGIuYmFiYSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAke3B9XFxuICAgICAgICAgICAgICAke099XFxuICAgICAgICAgICAgICAke3Yub3V0cHV0fSA9IHZhbHVlO1xcbiAgICAgICAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse291dHB1dDp7ZGltczpoLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6RCxoYXNNYWluOiEwfSl9KSh0LGMsZSxuKX0pfX0sNTYyMzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5nZXRCaWFzRm9yTWF0bXVsPWUuY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9ZS5wYXJzZU1hdE11bEF0dHJpYnV0ZXM9ZS5tYXRNdWw9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oMjAzOSksbz1uKDkzOTApLGE9bigyODIzKSxzPW4oNzA4KTtmdW5jdGlvbiB1KHQsZSl7Y29uc3Qgbj0ocz10Lmxlbmd0aD4yLHU9ZS5hY3RpdmF0aW9uQ2FjaGVLZXkse25hbWU6XCJNYXRNdWxcIixpbnB1dE5hbWVzOnM/W1wiQVwiLFwiQlwiLFwiQmlhc1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6cz9baS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdOltpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDp1fSk7dmFyIHMsdTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PmZ1bmN0aW9uKHQsZSxuKXtjb25zdCBzPWVbMF0uZGltcyx1PWVbMV0uZGltcyxjPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUocyx1LCEwKTtpZighYyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2NvbnN0IHA9KDAsby5nZXRDb29yZHNEYXRhVHlwZSkoYy5sZW5ndGgpLGY9KDAsby5nZXRHbENoYW5uZWxzKSgpLHthY3RpdmF0aW9uRnVuY3Rpb246ZCxhcHBseUFjdGl2YXRpb246aH09KDAsYS5nZXRBY3RpdmF0aW9uU25pcHBldCkobiksZz1lLmxlbmd0aD4yLGI9Zz9cInZhbHVlICs9IGdldEJpYXNGb3JNYXRtdWwoKTtcIjpcIlwiLG09Zz9gJHtsKHAsZixlWzJdLmRpbXMsYywhMSl9YDpcIlwiLHk9Yy5sZW5ndGgsXz1zLmxlbmd0aCx2PXUubGVuZ3RoLHc9YFxcbiAgICAke2R9XFxuICAgICR7bX1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3l9XSkge1xcbiAgICAgICAgaW50IGFbJHtffV07XFxuICAgICAgICBpbnQgYlske3Z9XTtcXG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19BKGluZGljZXMsIGEpO1xcbiAgICAgICAgYmNhc3RNYXRtdWxJbmRpY2VzX0IoaW5kaWNlcywgYik7XFxuXFxuICAgICAgICBmbG9hdCB2YWx1ZTtcXG4gICAgICAgIGZvciAoaW50IGs9MDsgazwke3Nbcy5sZW5ndGgtMV19OyArK2spIHtcXG4gICAgICAgICAgICBhWyR7Xy0xfV0gPSBrO1xcbiAgICAgICAgICAgIGJbJHt2LTJ9XSA9IGs7XFxuICAgICAgICAgICAgdmFsdWUgKz0gX0EoYSkgKiBfQihiKTtcXG4gICAgICAgIH1cXG4gICAgICAgICR7Yn1cXG4gICAgICAgICR7aH1cXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOmMsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnd9KX0obix0LGUpfSl9ZS5tYXRNdWw9KHQsZSxuKT0+KGMoZSksdC5zZXNzaW9uLnBhY2s/W3QucnVuKCgwLHMuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIpKHQsZSxuKSxlKV06W3QucnVuKHUoZSxuKSxlKV0pLGUucGFyc2VNYXRNdWxBdHRyaWJ1dGVzPXQ9PigwLGEucGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKSh0LmF0dHJpYnV0ZXMpLGUuY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9dTtjb25zdCBjPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYodFswXS5kaW1zW3RbMF0uZGltcy5sZW5ndGgtMV0hPT10WzFdLmRpbXNbdFsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKTtpZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09dFsxXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dHMgc2hvdWxkIGJlIGZsb2F0IHR5cGVcIik7aWYodFswXS50eXBlIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcImlucHV0cyB0eXBlcyBzaG91bGQgbWF0Y2hcIil9O2Z1bmN0aW9uIGwodCxlLG4saSxvKXtsZXQgYT1cIlwiO2NvbnN0IHM9bi5sZW5ndGgsdT1pLmxlbmd0aCxjPXUtczthPXU8MiYmcz4wP1wiY29vcmRzXCI6bi5tYXAoKCh0LG4pPT5gY29vcmRzLiR7ZVtuK2NdfWApKS5qb2luKFwiLCBcIik7Y29uc3QgbD1yLkJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyhuLGkpLm1hcCgodD0+YGNvb3Jkcy4ke2VbdCtjXX0gPSAwO2ApKS5qb2luKFwiXFxuXCIpO2xldCBwPVwidmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUueXkpXCI7cmV0dXJuIDE9PT1yLlNoYXBlVXRpbC5zaXplKG4pJiYocD1cInZlYzQob3V0cHV0VmFsdWUueClcIiksbz9gXFxudmVjNCBnZXRCaWFzRm9yTWF0bXVsKCkge1xcbiAgJHt0fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICR7bH1cXG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRCaWFzKCR7YX0pO1xcbiAgcmV0dXJuICR7cH07XFxufWA6YFxcbmZsb2F0IGdldEJpYXNGb3JNYXRtdWwoKSB7XFxuICAke3R9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgJHtsfVxcbiAgcmV0dXJuIGdldEJpYXMoY29vcmRzLngpO1xcbn1gfWUuZ2V0Qmlhc0Zvck1hdG11bD1sfSwyNDAzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmNyZWF0ZVBhY2tQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpLHM9e25hbWU6XCJwYWNrXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZF19O2UuY3JlYXRlUGFja1Byb2dyYW1JbmZvTG9hZGVyPSh0LGUpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KCh0LGUpPT57Y29uc3Qgbj0oMCxyLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx1PWUuZGltcyxjPXUubGVuZ3RoLGw9ZS5kaW1zLmxlbmd0aCxwPSgwLG8uZ2V0Q29vcmRzRGF0YVR5cGUpKGwpLGY9KDAsYS5nZXRDaGFubmVscykoXCJyY1wiLGwpLGQ9KGg9bCxnPWYsYj11W3UubGVuZ3RoLTJdLG09dVt1Lmxlbmd0aC0xXSwwPT09aHx8MT09PWg/XCJcIjpgXFxuICAgIGludCByID0gJHtnW2gtMl19O1xcbiAgICBpbnQgYyA9ICR7Z1toLTFdfTtcXG4gICAgaW50IHJwMSA9ICR7Z1toLTJdfSArIDE7XFxuICAgIGludCBjcDEgPSAke2dbaC0xXX0gKyAxO1xcbiAgICBib29sIHJFZGdlID0gcnAxID49ICR7bX07XFxuICAgIGJvb2wgY0VkZ2UgPSBjcDEgPj0gJHtifTtcXG4gICAgYCk7dmFyIGgsZyxiLG07bGV0IHk7eT0wPT09Yz9bMSwxXToxPT09Yz9bdVswXSwxXTpbdVtsLTFdLHVbbC0yXV07Y29uc3QgXz1mdW5jdGlvbih0LGUsbil7aWYoMD09PXQpcmV0dXJuXCJmYWxzZVwiO2lmKDE9PT10KXJldHVybmByYyA+ICR7ZVswXX1gO2xldCByPVwiXCI7Zm9yKGxldCBpPXQtMjtpPHQ7aSsrKXIrPWAke25baV19ID49ICR7ZVtpLXQrMl19YCxpPHQtMSYmKHIrPVwifHxcIik7cmV0dXJuIHJ9KGwseSxmKSx2PWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aDtpZigwPT09bilyZXR1cm5cImdldEEoKSwgMCwgMCwgMFwiO2lmKDE9PT1uKXJldHVybmBnZXRBKHJjKSxcXG4gICAgICAgICAgICByYyArIDEgPj0gJHt0WzBdfSA/IDAuIDogZ2V0QShyYyArIDEpLFxcbiAgICAgICAgICAgIDAsIDBgO2xldCByPVwiXCI7aWYobj4yKWZvcihsZXQgdD0wO3Q8bi0yOysrdClyKz1gJHtlW3RdfSxgO3JldHVybmBnZXRBKCR7cn1yLCBjKSxcXG4gICAgICAgICAgckVkZ2UgPyAwLiA6IGdldEEoJHtyfXJwMSwgYyksXFxuICAgICAgICAgIGNFZGdlID8gMC4gOiBnZXRBKCR7cn1yLCBjcDEpLFxcbiAgICAgICAgICByRWRnZSB8fCBjRWRnZSA/IDAuIDogZ2V0QSgke3J9cnAxLCBjcDEpYH0odSxmKSx3PWBcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgJHtwfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgICBpZigke199KSB7XFxuICAgICAgICAgICAgJHtuLm91dHB1dH0gPSB2ZWM0KDApO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICR7ZH1cXG5cXG4gICAgICAgICAgICAke24ub3V0cHV0fSA9IHZlYzQoJHt2fSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2hhc01haW46ITAsb3V0cHV0OntkaW1zOmUuZGltcyx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZH0sc2hhZGVyU291cmNlOnd9KX0pKHQsZSl9KX0sMjgyNzoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS51bnBhY2tGcm9tQ2hhbm5lbD1lLmdldENoYW5uZWxzPWUuZ2V0VmVjQ2hhbm5lbHM9dm9pZCAwO2NvbnN0IHI9big5MzkwKTtmdW5jdGlvbiBpKHQsZSl7cmV0dXJuKDAsci5nZXRHbENoYW5uZWxzKShlKS5tYXAoKGU9PmAke3R9LiR7ZX1gKSl9ZS5nZXRWZWNDaGFubmVscz1pLGUuZ2V0Q2hhbm5lbHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMT09PWU/W3RdOmkodCxlKX0sZS51bnBhY2tGcm9tQ2hhbm5lbD1mdW5jdGlvbigpe3JldHVyblwiXFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCBpbnQgZGltKSB7XFxuICAgICAgaW50IG1vZENvb3JkID0gaW1vZChkaW0sIDIpO1xcbiAgICAgIHJldHVybiBtb2RDb29yZCA9PSAwID8gZnJhZy5yIDogZnJhZy5nO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCB2ZWMyIGlubmVyRGltcykge1xcbiAgICAgIHZlYzIgbW9kQ29vcmQgPSBtb2QoaW5uZXJEaW1zLCAyLik7XFxuICAgICAgcmV0dXJuIG1vZENvb3JkLnggPT0gMC4gP1xcbiAgICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmcpIDpcXG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5iIDogZnJhZy5hKTtcXG4gICAgfVxcbiAgXCJ9fSwyODcwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlUGFkQXR0cmlidXRlc1YxMT1lLnBhZFYxMT1lLnBhcnNlUGFkQXR0cmlidXRlc1YyPWUucGFkVjI9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oNTA2MCksYT1uKDIwMzkpLHM9e25hbWU6XCJQYWRcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UucGFkVjI9KHQsZSxuKT0+KGwoZSksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5jKHQsZVswXSxuKX0pLGUpXSksZS5wYXJzZVBhZEF0dHJpYnV0ZXNWMj10PT57Y29uc3QgZT10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwiY29uc3RhbnRcIiksbj10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJ2YWx1ZVwiLDApLGk9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJwYWRzXCIpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7bW9kZTplLHZhbHVlOm4scGFkczppfSl9LGUucGFkVjExPSh0LG4scik9PntwKG4pO2NvbnN0IGk9dSh0LG4scik7cmV0dXJuKDAsZS5wYWRWMikodCxbblswXV0saSl9LGUucGFyc2VQYWRBdHRyaWJ1dGVzVjExPXQ9PnQuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJtb2RlXCIsXCJjb25zdGFudFwiKTtjb25zdCB1PSh0LGUsbik9PntpZighdC5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoZVsxXS5kYXRhSWQpfHxlLmxlbmd0aD49MyYmIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMl0uZGF0YUlkKSl0aHJvdyBuZXcgRXJyb3IoXCJkeW5hbWljIHBhZCBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZFwiKTtjb25zdCBpPUFycmF5LmZyb20oZVsxXS5pbnRlZ2VyRGF0YSksbz1lLmxlbmd0aD49Mz9lWzJdLmZsb2F0RGF0YVswXTowO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7bW9kZTpuLHBhZHM6aSx2YWx1ZTpvfSl9LGM9KHQsZSxuKT0+e2NvbnN0IHI9aS5TaGFwZVV0aWwucGFkU2hhcGUoZS5kaW1zLnNsaWNlKCksbi5wYWRzKSxvPXIubGVuZ3RoLHM9YFxcbiAgICAgICR7Zih0LGUsbil9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtvfV0gaW5kaWNlcykge1xcbiAgICAgICAgICByZXR1cm4gcGFkQShpbmRpY2VzKTtcXG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlBhZFwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkXSxvdXRwdXQ6e2RpbXM6cix0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTphLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6c319LGw9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUGFkIHJlcXVpcmVzIDEgaW5wdXRcIik7aWYoXCJmbG9hdDMyXCIhPT10WzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09dFswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LHA9dD0+e2lmKCF0fHwyIT09dC5sZW5ndGgmJjMhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQYWQgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZih0Lmxlbmd0aD49MyYmXCJzdHJpbmdcIj09PXRbMl0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSxmPSh0LGUsbik9Pntjb25zdCByPSgwLG8uZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFtzLHVdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGUuZGltcyxhLlRleHR1cmVUeXBlLnVucGFja2VkKSxjPWkuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGUuZGltcyk7c3dpdGNoKG4ubW9kZSl7Y2FzZVwiY29uc3RhbnRcIjpyZXR1cm4gZChyLGUuZGltcyxjLHMsdSxuLnBhZHMsbi52YWx1ZSk7Y2FzZVwicmVmbGVjdFwiOnJldHVybiBoKHIsZS5kaW1zLGMscyx1LG4ucGFkcyk7Y2FzZVwiZWRnZVwiOnJldHVybiBnKHIsZS5kaW1zLGMscyx1LG4ucGFkcyk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vZGVcIil9fSxkPSh0LGUsbixyLGksbyxhKT0+e2NvbnN0IHM9ZS5sZW5ndGg7bGV0IHU9XCJcIjtmb3IobGV0IHQ9cy0xO3Q+PTA7LS10KXUrPWBcXG4gICAgICAgIGsgPSBtWyR7dH1dIC0gJHtvW3RdfTtcXG4gICAgICAgIGlmIChrIDwgMCkgIHJldHVybiBjb25zdGFudDtcXG4gICAgICAgIGlmIChrID49ICR7ZVt0XX0pIHJldHVybiBjb25zdGFudDtcXG4gICAgICAgIG9mZnNldCArPSBrICogJHtuW3RdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHtzfV0pIHtcXG4gICAgICAgIGNvbnN0IGZsb2F0IGNvbnN0YW50ID0gZmxvYXQoJHthfSk7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgIGludCBrID0gMDtcXG4gICAgICAgICR7dX1cXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3J9LCAke2l9KTtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7dC50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICBgfSxoPSh0LGUsbixyLGksbyk9Pntjb25zdCBhPWUubGVuZ3RoO2xldCBzPVwiXCI7Zm9yKGxldCB0PWEtMTt0Pj0wOy0tdClzKz1gXFxuICAgICAgICBrID0gbVske3R9XSAtICR7b1t0XX07XFxuICAgICAgICBpZiAoayA8IDApIHsgayA9IC1rOyB9XFxuICAgICAgICB7XFxuICAgICAgICAgIGNvbnN0IGludCBfMm5fMSA9ICR7MiooZVt0XS0xKX07XFxuICAgICAgICAgIGsgPSBpbnQoIG1vZCggZmxvYXQoayksIGZsb2F0KF8ybl8xKSApICkgO1xcbiAgICAgICAgICBpZihrID49ICR7ZVt0XX0pIHsgayA9IF8ybl8xIC0gazsgfVxcbiAgICAgICAgfVxcbiAgICAgICAgb2Zmc2V0ICs9IGsgKiAke25bdF19O1xcbiAgICAgICAgYDtyZXR1cm5gXFxuICAgICAgZmxvYXQgcGFkQShpbnQgbVske2F9XSkge1xcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XFxuICAgICAgICBpbnQgayA9IDA7XFxuICAgICAgICAke3N9XFxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHtyfSwgJHtpfSk7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke3QudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgYH0sZz0odCxlLG4scixpLG8pPT57Y29uc3QgYT1lLmxlbmd0aDtsZXQgcz1cIlwiO2ZvcihsZXQgdD1hLTE7dD49MDstLXQpcys9YFxcbiAgICAgICAgayA9IG1bJHt0fV0gLSAke29bdF19O1xcbiAgICAgICAgaWYgKGsgPCAwKSAgayA9IDA7XFxuICAgICAgICBpZiAoayA+PSAke2VbdF19KSBrID0gJHtlW3RdLTF9O1xcbiAgICAgICAgb2Zmc2V0ICs9IGsgKiAke25bdF19O1xcbiAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHthfV0pIHtcXG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xcbiAgICAgICAgaW50IGsgPSAwO1xcbiAgICAgICAgJHtzfVxcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7cn0sICR7aX0pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHt0LnRleHR1cmUyRH0oQSwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGB9fSwyMTQzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmdsb2JhbE1heFBvb2w9ZS5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzPWUubWF4UG9vbD1lLnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPWUuZ2xvYmFsQXZlcmFnZVBvb2w9ZS5wYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlcz1lLmF2ZXJhZ2VQb29sPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDIwMzkpO2UuYXZlcmFnZVBvb2w9KHQsZSxuKT0+e3AoZSk7Y29uc3Qgcj17bmFtZTpcIkF2ZXJhZ2VQb29sXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpuLmNhY2hlS2V5fTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PmEoZSxyLCExLG4pfSksZSldfSxlLnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG49dC5hdHRyaWJ1dGVzLmdldEludChcImNlaWxfbW9kZVwiLDApLGk9MCE9PXQuYXR0cmlidXRlcy5nZXRJbnQoXCJjb3VudF9pbmNsdWRlX3BhZFwiLDApLG89dC5hdHRyaWJ1dGVzLmdldEludHMoXCJrZXJuZWxfc2hhcGVcIiksYT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInN0cmlkZXNcIixbXSkscz10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInBhZHNcIixbXSk7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbFwiKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F1dG9QYWQ6ZSxjZWlsTW9kZTpuLGNvdW50SW5jbHVkZVBhZDppLGtlcm5lbFNoYXBlOm8sc3RyaWRlczphLHBhZHM6c30pfTtjb25zdCBhPSh0LGUsbixyKT0+e2NvbnN0W2Esc109dSh0LHIsbiksYz1pLlNoYXBlVXRpbC5zaXplKGEua2VybmVsU2hhcGUpO2xldCBsPVwiXCI7YS5jb3VudEluY2x1ZGVQYWQ/bCs9YHZhbHVlIC89IGZsb2F0KCR7Y30pO2A6bCs9YHZhbHVlIC89IGZsb2F0KCR7Y30gLSBwYWQpO2A7Y29uc3QgcD1gXFxuICAgICAgICAke2YodFswXS5kaW1zLGEsXCJ2YWx1ZSArPSBfWCh4KTtcIixsLFwiMC4wXCIpfVxcbiAgICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOnMsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnB9KX07ZS5nbG9iYWxBdmVyYWdlUG9vbD0odCxlLG4pPT57cChlKTtjb25zdCByPXtuYW1lOlwiR2xvYmFsQXZlcmFnZVBvb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50OmAke24uY291bnRJbmNsdWRlUGFkfWB9O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+YShlLHIsITAsbil9KSxlKV19LGUucGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9MCE9PXQuYXR0cmlidXRlcy5nZXRJbnQoXCJjb3VudF9pbmNsdWRlX3BhZFwiLDApO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOmUsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdfSl9LGUubWF4UG9vbD0odCxlLG4pPT57cChlKTtjb25zdCByPXtuYW1lOlwiTWF4UG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6bi5jYWNoZUtleX07cmV0dXJuW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT5zKGUsciwhMSxuKX0pLGUpXX0sZS5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLG49dC5hdHRyaWJ1dGVzLmdldEludChcImNlaWxfbW9kZVwiLDApLGk9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJrZXJuZWxfc2hhcGVcIiksbz10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInN0cmlkZXNcIixbXSksYT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcInBhZHNcIixbXSkscz10LmF0dHJpYnV0ZXMuZ2V0SW50KFwic3RvcmFnZV9vcmRlclwiLDApLHU9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJkaWxhdGlvbnNcIixbXSk7aWYoMCE9PXMpdGhyb3cgbmV3IEVycm9yKFwiY29sdW1uIG1ham9yIHN0b3JhZ2Ugb3JkZXIgaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKFwidXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXV0b1BhZDplLGNlaWxNb2RlOm4sY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOmksc3RyaWRlczpvLHBhZHM6YSxzdG9yYWdlT3JkZXI6cyxkaWxhdGlvbnM6dX0pfTtjb25zdCBzPSh0LGUsbixyKT0+e2NvbnN0W2ksYV09dSh0LHIsbikscz1gXFxuICAgICAgJHtmKHRbMF0uZGltcyxpLFwiXFxuICAgICAgdmFsdWUgPSBtYXgoX1goeCksIHZhbHVlKTtcXG4gICAgXCIsXCJcIixcIi0xZTVcIil9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmEsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnN9KX0sdT0odCxlLG4pPT57Y29uc3Qgcj10WzBdLmRpbXMuc2xpY2UoKSxvPU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkaWxhdGlvbnNcIiksYT1lLmtlcm5lbFNoYXBlLnNsaWNlKCkscz1lLnN0cmlkZXMuc2xpY2UoKSx1PW8/ZS5kaWxhdGlvbnMuc2xpY2UoKTpbXSxjPWUucGFkcy5zbGljZSgpO2kuUG9vbENvbnZVdGlsLmFkanVzdFBvb2xBdHRyaWJ1dGVzKG4scixhLHMsdSxjKTtjb25zdCBsPWkuUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUobixyLHMsdSxhLGMsZS5hdXRvUGFkKSxwPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIG8/T2JqZWN0LmFzc2lnbihwLHtrZXJuZWxTaGFwZTphLHN0cmlkZXM6cyxwYWRzOmMsZGlsYXRpb25zOnUsY2FjaGVLZXk6ZS5jYWNoZUtleX0pOk9iamVjdC5hc3NpZ24ocCx7a2VybmVsU2hhcGU6YSxzdHJpZGVzOnMscGFkczpjLGNhY2hlS2V5OmUuY2FjaGVLZXl9KSxbcCxsXX0sYz17YXV0b1BhZDpcIlwiLGNlaWxNb2RlOjAsY291bnRJbmNsdWRlUGFkOiExLGtlcm5lbFNoYXBlOltdLHN0cmlkZXM6W10scGFkczpbXSxzdG9yYWdlT3JkZXI6MCxkaWxhdGlvbnM6W10sY2FjaGVLZXk6XCJcIn0sbD17bmFtZTpcIkdsb2JhbE1heFBvb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UuZ2xvYmFsTWF4UG9vbD0odCxlKT0+KHAoZSksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsKSx7Z2V0OigpPT5zKGUsbCwhMCxjKX0pLGUpXSk7Y29uc3QgcD10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sZj0odCxlLG4scixvKT0+e2NvbnN0IGE9dC5sZW5ndGg7aWYoZS5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2NvbnN0IGk9ZS5rZXJuZWxTaGFwZVtlLmtlcm5lbFNoYXBlLmxlbmd0aC0xXSxzPWUuc3RyaWRlc1tlLnN0cmlkZXMubGVuZ3RoLTFdLHU9ZS5wYWRzW2UucGFkcy5sZW5ndGgvMi0xXSxjPWUucGFkc1tlLnBhZHMubGVuZ3RoLTFdLGw9dFthLTFdO2xldCBwPVwiXCIsZj1cIlwiLGQ9XCJcIjtpZihwPXUrYyE9PTA/YFxcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7aX07IGkrKykge1xcbiAgICAgICAgICAgIHhbJHthfSAtIDFdID0gaW5kaWNlc1ske2F9IC0gMV0gKiAke3N9IC0gJHt1fSArIGk7XFxuICAgICAgICAgICAgaWYgKHhbJHthfSAtIDFdIDwgMCB8fCB4WyR7YX0gLSAxXSA+PSAke2x9KSB7XFxuICAgICAgICAgICAgICBwYWQrKztcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAke259XFxuICAgICAgICAgIH1gOmBcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2l9OyBpKyspIHtcXG4gICAgICAgICAgICB4WyR7YX0gLSAxXSA9IGluZGljZXNbJHthfSAtIDFdICogJHtzfSAtICR7dX0gKyBpO1xcbiAgICAgICAgICAgICR7bn1cXG4gICAgICAgICAgfWAsMj09PWUua2VybmVsU2hhcGUubGVuZ3RoKXtjb25zdCBuPWUua2VybmVsU2hhcGVbZS5rZXJuZWxTaGFwZS5sZW5ndGgtMl0scj1lLnN0cmlkZXNbZS5zdHJpZGVzLmxlbmd0aC0yXSxvPWUucGFkc1tlLnBhZHMubGVuZ3RoLzItMl0scz1lLnBhZHNbZS5wYWRzLmxlbmd0aC0yXSx1PXRbYS0yXTtmPW8rcyE9PTA/YFxcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgJHtufTsgaisrKSB7XFxuICAgICAgICAgICAgICB4WyR7YX0gLSAyXSA9IGluZGljZXNbJHthfSAtIDJdICogJHtyfSAtICR7b30gKyBqO1xcbiAgICAgICAgICAgICAgaWYgKHhbJHthfSAtIDJdIDwgMCB8fCB4WyR7YX0gLSAyXSA+PSAke3V9KSB7XFxuICAgICAgICAgICAgICAgIHBhZCs9ICR7aX07XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICBgOmBcXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7bn07IGorKykge1xcbiAgICAgICAgICAgICAgeFske2F9IC0gMl0gPSBpbmRpY2VzWyR7YX0gLSAyXSAqICR7cn0gLSAke299ICsgajtcXG4gICAgICAgICAgICBgLGQ9XCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJ9cmV0dXJuYFxcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2F9XSkge1xcbiAgICAgICAgICBpbnQgeFske2F9XTtcXG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCB4KTtcXG5cXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAke299O1xcbiAgICAgICAgICBpbnQgcGFkID0gMDtcXG4gICAgICAgICAgJHtmfVxcbiAgICAgICAgICAke3B9XFxuICAgICAgICAgICR7ZH1cXG4gICAgICAgICAgJHtyfVxcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgYH17Y29uc3Qgcz1pLlNoYXBlVXRpbC5zaXplKGUua2VybmVsU2hhcGUpLHU9aS5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZS5rZXJuZWxTaGFwZSksYz11Lmxlbmd0aCxsPWUucGFkcy5sZW5ndGgscD1oKGMpLGY9ZCh0LFwiaW5wdXREaW1zXCIpLGc9ZChlLnBhZHMsXCJwYWRzXCIpLGI9ZCh1LFwia2VybmVsU3RyaWRlc1wiKSxtPWQoZS5zdHJpZGVzLFwic3RyaWRlc1wiKTtsZXQgeT1cIlwiO3JldHVybiB5PWUucGFkcy5yZWR1Y2UoKCh0LGUpPT50K2UpKT9gXFxuICAgICAgICAgICAgaWYgKHhbal0gPj0gaW5wdXREaW1zW2pdIHx8IHhbal0gPCAwKSB7XFxuICAgICAgICAgICAgICBwYWQrKztcXG4gICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoIWlzUGFkKSB7XFxuICAgICAgICAgICAgJHtufVxcbiAgICAgICAgICB9YDpgXFxuICAgICAgICAgIH1cXG4gICAgICAgICAgJHtufVxcbiAgICAgICAgYCxgXFxuICAgICAgICAke3B9XFxuICAgICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7YX1dKSB7XFxuICAgICAgICAgIGludCB4WyR7YX1dO1xcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIHgpO1xcbiAgICAgICAgICBpbnQgb2Zmc2V0WyR7Y31dO1xcbiAgICAgICAgICBpbnQgcGFkc1ske2x9XTtcXG4gICAgICAgICAgaW50IGlucHV0RGltc1ske2F9XTtcXG4gICAgICAgICAgaW50IGtlcm5lbFN0cmlkZXNbJHtjfV07XFxuICAgICAgICAgIGludCBzdHJpZGVzWyR7Y31dO1xcbiAgICAgICAgICAke2d9XFxuICAgICAgICAgICR7Zn1cXG4gICAgICAgICAgJHttfVxcbiAgICAgICAgICAke2J9XFxuXFxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gJHtvfTtcXG4gICAgICAgICAgaW50IHBhZCA9IDA7XFxuICAgICAgICAgIGJvb2wgaXNQYWQgPSBmYWxzZTtcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3N9OyBpKyspIHtcXG4gICAgICAgICAgICBvZmZzZXRUb0luZGljZXMoaSwga2VybmVsU3RyaWRlcywgb2Zmc2V0KTtcXG4gICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAke2F9IC0gJHtjfTsgaiA8ICR7YX07IGorKykge1xcbiAgICAgICAgICAgICAgeFtqXSA9IGluZGljZXNbal0gKiBzdHJpZGVzW2ogLSAke2F9ICsgJHtjfV1cXG4gICAgICAgICAgICAgICAgKyBvZmZzZXRbaiAtICR7YX0gKyAke2N9XSAtIHBhZHNbaiAtIDJdO1xcbiAgICAgICAgICAgICAgJHt5fVxcbiAgICAgICAgICB9XFxuICAgICAgICAgICR7cn1cXG5cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIGB9fSxkPSh0LGUpPT57bGV0IG49XCJcIjtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyluKz1gXFxuICAgICAgJHtlfVske3J9XSA9ICR7dFtyXX07XFxuICAgIGA7cmV0dXJuIG59LGg9dD0+YFxcbiAgdm9pZCBvZmZzZXRUb0luZGljZXMoaW50IG9mZnNldCwgaW50WyR7dH1dIHN0cmlkZXMsIG91dCBpbnRbJHt0fV0gaW5kaWNlcykge1xcbiAgICBpZiAoJHt0fSA9PSAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHt0fSAtIDE7ICsraSkge1xcbiAgICAgIGluZGljZXNbaV0gPSBvZmZzZXQgLyBzdHJpZGVzW2ldO1xcbiAgICAgIG9mZnNldCAtPSBpbmRpY2VzW2ldICogc3RyaWRlc1tpXTtcXG4gICAgfVxcbiAgICBpbmRpY2VzWyR7dH0gLSAxXSA9IG9mZnNldDtcXG4gIH1gfSw0OTM5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlZHVjZUxvZ1N1bVNxdWFyZT1lLnJlZHVjZUxvZ1N1bT1lLnJlZHVjZVByb2Q9ZS5yZWR1Y2VNaW49ZS5yZWR1Y2VNYXg9ZS5yZWR1Y2VNZWFuPWUucmVkdWNlU3VtPWUucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oNzgyKSxvPW4oMjUxNyksYT1uKDIwMzkpLHM9KHQsZSxuLHIsaSk9PntjKGUpO2NvbnN0IG89e25hbWU6cixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+dSh0LGUsbixyLGksbyl9KSxlKV19O2UucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzPXQ9Pntjb25zdCBlPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwiYXhlc1wiLFtdKSxuPTE9PT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwia2VlcGRpbXNcIiwxKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4ZXM6ZSxrZWVwRGltczpufSl9O2NvbnN0IHU9KHQsZSxuLHIsaSxzKT0+e2NvbnN0IHU9W10sYz1lWzBdLmRpbXMubGVuZ3RofHwxLGw9W10scD1vLlNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKG4uYXhlcyxlWzBdLmRpbXMubGVuZ3RoKSxmPWkoZSxwKTtsZXQgZD1mWzFdO2ZvcihsZXQgdD0wO3Q8ZVswXS5kaW1zLmxlbmd0aDt0KyspcC5pbmRleE9mKHQpPj0wfHwwPT09cC5sZW5ndGg/KG4ua2VlcERpbXMmJnUucHVzaCgxKSxkPWBcXG4gICAgICAgICAgZm9yKGludCBqJHt0fSA9IDA7IGoke3R9IDwgJHtlWzBdLmRpbXNbdF19OyBqJHt0fSsrKSB7XFxuICAgICAgICAgICAgaW5wdXRJZHhbJHt0fV0gPSBqJHt0fTtcXG4gICAgICAgICAgICAke2R9XFxuICAgICAgICAgIH1gKToobC5wdXNoKGBpbnB1dElkeFske3R9XSA9IG91dHB1dElkeFske3UubGVuZ3RofV07YCksdS5wdXNoKGVbMF0uZGltc1t0XSkpO2NvbnN0IGg9YFxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske3UubGVuZ3RofHwxfV0pIHtcXG4gICAgICAgIGZsb2F0IHZhbHVlOyAgICAgICAgICAgICAgICAgLy8gZmluYWwgcmVzdWx0XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtjfV07ICAgICAgLy8gYWRkcmVzc2luZyBpbnB1dCBkYXRhXFxuICAgICAgICAke2wuam9pbihcIlxcblwiKX1cXG4gICAgICAgICR7ZlswXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXFxuICAgICAgICAke2R9XFxuICAgICAgICAke2ZbMl19ICAgICAgIC8vIGZpbmFsIGNvbXB1dGF0aW9uIGZvciByZWR1Y2UgbWVhblxcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse291dHB1dDp7ZGltczp1LHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpofSl9LGM9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlIG9wIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKC0xPT09aS5OVU1CRVJfVFlQRVMuaW5kZXhPZih0WzBdLnR5cGUpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9O2UucmVkdWNlU3VtPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VTdW1cIiwoKCk9PltcInZhbHVlID0gMC4wO1wiLFwidmFsdWUgKz0gX0EoaW5wdXRJZHgpO1wiLFwiXCJdKSksZS5yZWR1Y2VNZWFuPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VNZWFuXCIsKCh0LGUpPT57bGV0IG49MTtmb3IobGV0IHI9MDtyPHRbMF0uZGltcy5sZW5ndGg7cisrKShlLmluZGV4T2Yocik+PTB8fDA9PT1lLmxlbmd0aCkmJihuKj10WzBdLmRpbXNbcl0pO3JldHVybltcInZhbHVlID0gMC4wO1wiLFwidmFsdWUgKz0gX0EoaW5wdXRJZHgpO1wiLGB2YWx1ZSAvPSAke259LjtgXX0pKSxlLnJlZHVjZU1heD0odCxlLG4pPT5zKHQsZSxuLFwiUmVkdWNlTWF4XCIsKCh0LGUpPT57Y29uc3Qgbj1bXTtmb3IobGV0IHI9MDtyPHRbMF0uZGltcy5sZW5ndGg7cisrKShlLmluZGV4T2Yocik+PTB8fDA9PT1lLmxlbmd0aCkmJm4ucHVzaChgaW5wdXRJZHhbJHtyfV0gPSAwO2ApO3JldHVybltgJHtuLmpvaW4oXCJcXG5cIil9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCxcInZhbHVlID0gbWF4KHZhbHVlLCBfQShpbnB1dElkeCkpO1wiLFwiXCJdfSkpLGUucmVkdWNlTWluPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VNaW5cIiwoKHQsZSk9Pntjb25zdCBuPVtdO2ZvcihsZXQgcj0wO3I8dFswXS5kaW1zLmxlbmd0aDtyKyspKGUuaW5kZXhPZihyKT49MHx8MD09PWUubGVuZ3RoKSYmbi5wdXNoKGBpbnB1dElkeFske3J9XSA9IDA7YCk7cmV0dXJuW2Ake24uam9pbihcIlxcblwiKX1cXG52YWx1ZSA9IF9BKGlucHV0SWR4KTtgLFwidmFsdWUgPSBtaW4odmFsdWUsIF9BKGlucHV0SWR4KSk7XCIsXCJcIl19KSksZS5yZWR1Y2VQcm9kPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VQcm9kXCIsKCgpPT5bXCJ2YWx1ZSA9IDEuMDtcIixcInZhbHVlICo9IF9BKGlucHV0SWR4KTtcIixcIlwiXSkpLGUucmVkdWNlTG9nU3VtPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VMb2dTdW1cIiwoKCk9PltcInZhbHVlID0gMC4wO1wiLFwidmFsdWUgKz0gX0EoaW5wdXRJZHgpO1wiLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSkpLGUucmVkdWNlTG9nU3VtU3F1YXJlPSh0LGUsbik9PnModCxlLG4sXCJSZWR1Y2VMb2dTdW1TcXVhcmVcIiwoKCk9PltcImZsb2F0IHQ7IHZhbHVlID0gMC4wO1wiLFwidCA9IF9BKGlucHV0SWR4KTsgdmFsdWUgKz0gdCAqIHQ7XCIsXCJcIl0pKX0sNzAxOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5pc1Jlc2hhcGVDaGVhcD1lLnByb2Nlc3NEaW1zM0Q9ZS5jcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpLGk9big1MDYwKSxvPW4oMjAzOSksYT1uKDI4MjcpO2UuY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm9Mb2FkZXI9KHQsZSxuKT0+e2NvbnN0IHM9KHQ9Pih7bmFtZTpcIlJlc2hhcGUgKHBhY2tlZClcIixpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnBhY2tlZF0saW5wdXROYW1lczpbXCJBXCJdLGNhY2hlSGludDpgJHt0fWB9KSkobik7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Z2V0OigpPT4oKHQsZSxuLHMpPT57Y29uc3QgdT1lLmRpbXMsYz1zO2xldCBsPVwiXCI7Zm9yKGxldCB0PTA7dDw0O3QrKyl7bGV0IGU9XCJcIjtzd2l0Y2godCl7Y2FzZSAwOmU9XCJvdXRwdXRDb29yZHMgPSByYztcIjticmVhaztjYXNlIDE6ZT1cIm91dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnkrMSwgcmMueik7XCI7YnJlYWs7Y2FzZSAyOmU9XCJvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55LCByYy56KzEpO1wiO2JyZWFrO2Nhc2UgMzplPVwib3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSsxLCByYy56KzEpO1wiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yfWwrPWBcXG4gICAgICAgICR7ZX1cXG4gICAgICAgICR7dD4wP1wiaWYob3V0cHV0Q29vcmRzLnkgPCByb3dzICYmIG91dHB1dENvb3Jkcy56IDwgY29scyl7XCI6XCJcIn1cXG4gICAgICAgICAgaW50IGZsYXR0ZW5lZEluZGV4ID0gZ2V0RmxhdHRlbmVkSW5kZXgob3V0cHV0Q29vcmRzKTtcXG5cXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXR0ZW5lZEluZGV4KTtcXG4gICAgICAgICAgdmVjMiBpbm5lckRpbXMgPSB2ZWMyKGZsb2F0KGlucHV0UkMueSksZmxvYXQoaW5wdXRSQy56KSk7XFxuXFxuICAgICAgICAgIHJlc3VsdFske3R9XSA9IGdldENoYW5uZWwoZ2V0QShpbnB1dFJDLngsIGlucHV0UkMueSwgaW5wdXRSQy56KSwgaW5uZXJEaW1zKTtcXG5cXG4gICAgICAgICR7dD4wP1wifVwiOlwiXCJ9XFxuICAgICAgYH1jb25zdCBwPSgwLGkuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGY9YFxcbiAgICAgICR7ZnVuY3Rpb24odCl7Y29uc3QgZT1yLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyh0KSxuPVtcImJcIixcInJcIixcImNcIl0saT1cImluZGV4XCI7cmV0dXJuYFxcbiAgICBpdmVjMyBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhpbnQgaW5kZXgpIHtcXG4gICAgICAke2UubWFwKCgodCxyKT0+YGludCAke25bcl19ID0gJHtpfSAvICR7dH07ICR7cj09PWUubGVuZ3RoLTE/YGludCAke25bcisxXX0gPSAke2l9IC0gJHtuW3JdfSAqICR7dH1gOmBpbmRleCAtPSAke25bcl19ICogJHt0fWB9O2ApKS5qb2luKFwiXCIpfVxcbiAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcXG4gICAgfVxcbiAgYH0odSl9XFxuICAgICAgJHtmdW5jdGlvbih0KXtjb25zdCBlPXIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHQpO3JldHVybmBcXG4gIGludCBnZXRGbGF0dGVuZWRJbmRleChpdmVjMyBjb29yZHMpIHtcXG4gICAgLy8gcmV2ZXJzZSB5LCB6IG9yZGVyXFxuICAgIHJldHVybiBjb29yZHMueCAqICR7ZVswXX0gKyBjb29yZHMueiAqICR7ZVsxXX0gKyBjb29yZHMueTtcXG4gIH1cXG5gfShjKX1cXG4gICAgICAkeygwLGEudW5wYWNrRnJvbUNoYW5uZWwpKCl9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLjApO1xcblxcbiAgICAgICAgaXZlYzMgb3V0cHV0Q29vcmRzO1xcbiAgICAgICAgaW50IHJvd3MgPSAke2NbMl19O1xcbiAgICAgICAgaW50IGNvbHMgPSAke2NbMV19O1xcblxcbiAgICAgICAgJHtsfVxcbiAgICAgICAgJHtwLm91dHB1dH0gPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpjLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6ZixoYXNNYWluOiEwfSl9KSh0LGUscyxuKX0pfSxlLnByb2Nlc3NEaW1zM0Q9ZnVuY3Rpb24odCl7aWYoMD09PXQubGVuZ3RoKXJldHVyblsxLDEsMV07bGV0IGU9MTtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTI7KytuKWUqPXRbbl07cmV0dXJuW2UsdC5sZW5ndGg+MT90W3QubGVuZ3RoLTJdOjEsdFt0Lmxlbmd0aC0xXV19LGUuaXNSZXNoYXBlQ2hlYXA9ZnVuY3Rpb24odCxlKXtsZXQgbj0hMTtyZXR1cm4gbj0wPT09dC5sZW5ndGh8fDA9PT1lLmxlbmd0aHx8KHQubGVuZ3RoPDJ8fGUubGVuZ3RoPDI/dFt0Lmxlbmd0aC0xXT09PWVbZS5sZW5ndGgtMV06dFt0Lmxlbmd0aC0xXT09PWVbZS5sZW5ndGgtMV0mJnRbdC5sZW5ndGgtMl09PT1lW2UubGVuZ3RoLTJdKSxufX0sNzE4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlc2hhcGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KTtlLnJlc2hhcGU9KHQsZSk9Pntjb25zdCBuPXIuU2hhcGVVdGlsLmNhbGN1bGF0ZVJlc2hhcGVkRGltcyhlWzBdLmRpbXMsZVsxXS5pbnRlZ2VyRGF0YSk7cmV0dXJuIHQuc2Vzc2lvbi5wYWNrP1t0LnJlc2hhcGVQYWNrZWQoZVswXSxuKV06W3QucmVzaGFwZVVucGFja2VkKGVbMF0sbildfX0sMjI2ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTE9ZS5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTA9ZS5yZXNpemU9dm9pZCAwO2NvbnN0IHI9big1MDYwKSxpPW4oMjAzOSksbz1uKDkzOTApLGE9bigyODI3KSxzPW4oOTc5MyksdT17bmFtZTpcIlJlc2l6ZVwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnBhY2tlZF19O2UucmVzaXplPSh0LGUsbik9PigoMCxzLnZhbGlkYXRlSW5wdXRzKShlLG4pLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+Yyh0LGUsbil9KSxlKV0pLGUucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwPXQ9PigwLHMucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsMTApLGUucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjExPXQ9PigwLHMucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsMTEpO2NvbnN0IGM9KHQsZSxuKT0+e2NvbnN0IHM9KDAsci5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksW2MscF09bChlLG4pO2lmKGMuZXZlcnkoKHQ9PjE9PT10KSkmJlwidGZfY3JvcF9hbmRfcmVzaXplXCIhPT1uLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlKXJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse291dHB1dDp7ZGltczpwLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUucGFja2VkfSxoYXNNYWluOiEwLHNoYWRlclNvdXJjZTpgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICAgICAgICAgdmVjNCB2ID0gJHtzLnRleHR1cmUyRH0oWCwgVGV4Q29vcmRzKTtcXG4gICAgICAgICAgICAgICAgICAgICR7cy5vdXRwdXR9ID0gdjtcXG4gICAgICAgICAgICAgICAgfWB9KTtjb25zdCBmPXAubGVuZ3RoO2lmKGY8Mil0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBkaW1lbnNpb24gc2hvdWxkIGJlIGF0IGxlYXN0IDIsIGJ1dCBnb3QgJHtmfWApO2NvbnN0IGQ9cFtmLTJdLGg9cFtmLTFdLGc9ZVswXS5kaW1zO2lmKGYhPT1nLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBkaW1lbnNpb24gc2hvdWxkIG1hdGNoIGlucHV0ICR7Zy5sZW5ndGh9LCBidXQgZ290ICR7Zn1gKTtjb25zdCBiPWdbZi0yXSxtPWdbZi0xXSx5PWNbZi0yXSxfPWNbZi0xXTtsZXQgdj1cIlwiO2lmKFwibGluZWFyXCIhPT1uLm1vZGUpdGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBtb2RlOiAnJHtuLm1vZGV9J2ApO3N3aXRjaChuLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlKXtjYXNlXCJhc3ltbWV0cmljXCI6dj1cIlxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlYzQoY29vcmRzKSAvIHNjYWxlV0hXSDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXCI7YnJlYWs7Y2FzZVwiaGFsZl9waXhlbFwiOnY9XCJcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgZ2V0U291cmNlRnJhY0luZGV4KGl2ZWM0IGNvb3Jkcykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodmVjNChjb29yZHMpICsgMC41KSAvIHNjYWxlV0hXSCAtIDAuNTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXCI7YnJlYWs7Y2FzZVwicHl0b3JjaF9oYWxmX3BpeGVsXCI6dj1gXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IGZjb29yZHMgPSB2ZWM0KGNvb3Jkcyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7aH0uMCA+IDEuMCA/IChmY29vcmRzLnggKyAwLjUpIC8gc2NhbGVXSFdILnggLSAwLjUgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7ZH0uMCA+IDEuMCA/IChmY29vcmRzLnkgKyAwLjUpIC8gc2NhbGVXSFdILnkgLSAwLjUgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7aH0uMCA+IDEuMCA/IChmY29vcmRzLnogKyAwLjUpIC8gc2NhbGVXSFdILnogLSAwLjUgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7ZH0uMCA+IDEuMCA/IChmY29vcmRzLncgKyAwLjUpIC8gc2NhbGVXSFdILncgLSAwLjUgOiAwLjBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGA7YnJlYWs7Y2FzZVwiYWxpZ25fY29ybmVyc1wiOnY9YFxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCByZXNpemVkID0gdmVjNCgke2h9LjAgLSAxLjAsICR7ZH0uMCAtIDEuMCwgJHtofS4wIC0gMS4wLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2R9LjAgLSAxLjApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgb3JpZ2luYWwgPSB2ZWM0KCR7bX0uMCAtIDEuMCwgJHtifS4wIC0gMS4wLCAke219LjAgLSAxLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7Yn0uMCAtIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBuZXdfc2NhbGUgPSBvcmlnaW5hbCAvIHJlc2l6ZWQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlYzQoY29vcmRzKSAqIG5ld19zY2FsZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgYDticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgcmVzaXplIChwYWNrZWQpIGRvZXMgbm90IHN1cHBvcnQgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyR7bi5jb29yZGluYXRlVHJhbnNmb3JtTW9kZX0nYCl9Y29uc3Qgdz0oMCxvLmdldENvb3Jkc0RhdGFUeXBlKShmKSx4PWBcXG4gICAgICAgICAgICBjb25zdCB2ZWMyIGlucHV0V0ggPSB2ZWMyKCR7Yn0uMCwgJHttfS4wKTtcXG4gICAgICAgICAgICBjb25zdCB2ZWM0IHNjYWxlV0hXSCA9IHZlYzQoZmxvYXQoJHt5fSksIGZsb2F0KCR7X30pLCBmbG9hdCgke3l9KSwgZmxvYXQoJHtffSkpO1xcbiAgICAgICAgICAgICR7KDAsYS51bnBhY2tGcm9tQ2hhbm5lbCkoKX1cXG4gICAgICAgICAgICAke3Z9XFxuICAgICAgICAgICAgZmxvYXQgZ2V0QVZhbHVlKGludCB4MTAsIGludCByLCBpbnQgYywgaW50IGQpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QSh4MTAsIHIsIGMsIGQpLCB2ZWMyKGMsIGQpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICAgICAke3d9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICAgICAgICAgIGludCBiYXRjaCA9IHJjWzBdO1xcbiAgICAgICAgICAgICAgICBpbnQgZGVwdGggPSByY1sxXTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gcmV0cmlldmUgdGhlIDQgY29vcmRpbmF0ZXMgdGhhdCBpcyB1c2VkIGluIHRoZSA0IHBhY2tlZCBvdXRwdXQgdmFsdWVzLlxcbiAgICAgICAgICAgICAgICBpdmVjNCBjb29yZHMgPSBpdmVjNChyYy53eiwgcmMudyArIDEsIHJjLnogKyAxKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzb3VyY2UgaW5kZXggaW4gZnJhY3Rpb25cXG4gICAgICAgICAgICAgICAgdmVjNCBzb3VyY2VGcmFjID0gZ2V0U291cmNlRnJhY0luZGV4KGNvb3Jkcyk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kIG9mIHRoZSA0IHZhbHVlcyB0aGF0IHdpbGwgYmUgcGFja2VkIGludG8gb25lIHRleGVsLlxcbiAgICAgICAgICAgICAgICBpdmVjNCB4MDAgPSBpdmVjNChtYXgoc291cmNlRnJhYy54eSwgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54eSkpKTtcXG4gICAgICAgICAgICAgICAgaXZlYzQgeDAxID0gaXZlYzQobWF4KHNvdXJjZUZyYWMueHcsIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMueHcpKSk7XFxuICAgICAgICAgICAgICAgIGl2ZWM0IHgxMCA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnp5LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnp5KSkpO1xcbiAgICAgICAgICAgICAgICBpdmVjNCB4MTEgPSBpdmVjNChtYXgoc291cmNlRnJhYy56dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy56dykpKTtcXG5cXG4gICAgICAgICAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gcmMudyA8ICR7ZC0xfTtcXG4gICAgICAgICAgICAgICAgYm9vbCBoYXNOZXh0Q29sID0gcmMueiA8ICR7aC0xfTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyB0b3AtbGVmdCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcXG4gICAgICAgICAgICAgICAgdmVjNCB0b3BMZWZ0ID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC54LCB4MDAueSksXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLngsIHgwMS55KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueCwgeDEwLnkpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueCwgeDExLnkpIDogMC4wKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyB0b3AtcmlnaHQgY29ybmVyIGludG8gb25lIHZlYzQgc3RydWN0dXJlXFxuICAgICAgICAgICAgICAgIHZlYzQgdG9wUmlnaHQgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLngsIHgwMC53KSxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueCwgeDAxLncpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC54LCB4MTAudykgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS54LCB4MTEudykgOiAwLjApO1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIGJvdHRvbS1sZWZ0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbUxlZnQgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLnosIHgwMC55KSxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueiwgeDAxLnkpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC56LCB4MTAueSkgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS56LCB4MTEueSkgOiAwLjApO1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIGJvdHRvbS1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcXG4gICAgICAgICAgICAgICAgdmVjNCBib3R0b21SaWdodCA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueiwgeDAwLncpLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS56LCB4MDEudykgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLnosIHgxMC53KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS53KSA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgaW50ZXJwb2xhdGlvbiBmcmFjdGlvbiBvbiB1IGFuZCB2IGRpcmVjdGlvblxcbiAgICAgICAgICAgICAgICB2ZWM0IGZyYWMgPSB2ZWM0KHNvdXJjZUZyYWMpIC0gZmxvb3Ioc291cmNlRnJhYyk7XFxuICAgICAgICAgICAgICAgIHZlYzQgY2xhbXBGcmFjID0gY2xhbXAoZnJhYywgdmVjNCgwLjApLCB2ZWM0KDEuMCkpO1xcblxcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcCA9IG1peCh0b3BMZWZ0LCB0b3BSaWdodCwgY2xhbXBGcmFjLnl3eXcpO1xcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbSA9IG1peChib3R0b21MZWZ0LCBib3R0b21SaWdodCwgY2xhbXBGcmFjLnl3eXcpO1xcbiAgICAgICAgICAgICAgICB2ZWM0IG5ld1ZhbHVlID0gbWl4KHRvcCwgYm90dG9tLCBjbGFtcEZyYWMueHh6eik7XFxuXFxuICAgICAgICAgICAgICAgICR7cy5vdXRwdXR9ID0gdmVjNChuZXdWYWx1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHtvdXRwdXQ6e2RpbXM6cCx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnBhY2tlZH0saGFzTWFpbjohMCxzaGFkZXJTb3VyY2U6eH0pfSxsPSh0LGUpPT57Y29uc3Qgbj10WzBdLmRpbXM7bGV0IHIsaT1lLnNjYWxlcztpZigwPT09aS5sZW5ndGgpe2NvbnN0IG89dFtlLnNjYWxlc0lucHV0SWR4XTtpZihvJiYwIT09by5zaXplKXtpZih0W2Uuc2l6ZXNJbnB1dElkeF0pdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgb2Ygc2NhbGVzIG9yIHNpemVzIG11c3QgYmUgcHJvdmlkZWQgYXMgaW5wdXQuXCIpO2k9cChvLGUubW9kZSxlLmlzUmVzaXplKX1lbHNle2NvbnN0IG89dFtlLnNpemVzSW5wdXRJZHhdO2lmKCFvfHwwPT09by5zaXplKXRocm93IG5ldyBFcnJvcihcIkVpdGhlciBzY2FsZXMgb3Igc2l6ZXMgTVVTVCBiZSBwcm92aWRlZCBhcyBpbnB1dC5cIik7cj1BcnJheS5mcm9tKG8uaW50ZWdlckRhdGEpLGk9ZihyLG4sZS5tb2RlLGUuaXNSZXNpemUpfX1lbHNlIGlmKHRbZS5zaXplc0lucHV0SWR4XSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBzY2FsZXMgb3Igc2l6ZXMgbXVzdCBiZSBwcm92aWRlZCBhcyBpbnB1dC5cIik7Y29uc3Qgbz1yfHxuLm1hcCgoKHQsZSk9Pk1hdGguZmxvb3IodCppW2VdKSkpO3JldHVybltpLG9dfSxwPSh0LGUsbik9Pntjb25zdCByPUFycmF5LmZyb20odC5mbG9hdERhdGEpO3JldHVybigwLHMuc2NhbGVzVmFsaWRhdGlvbikocixlLG4pLHJ9LGY9KHQsZSxuLHIpPT57Y29uc3QgaT1lLmxlbmd0aCxvPW5ldyBBcnJheShpKTtmb3IobGV0IG49MCxyPWk7bjxyO24rKylpZigwPT09ZVtuXSl7aWYoMCE9PXRbbl0pdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGltIGlzIHplcm8gYnV0IHJlcXVpcmVkIG91dHB1dCBkaW0gaXMgbm9uLXplcm8uXCIpO29bbl09MX1lbHNlIG9bbl09dFtuXS9lW25dO3JldHVybigwLHMuc2NhbGVzVmFsaWRhdGlvbikobyxuLHIpLG99fSw4MTE3Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNoYXBlPXZvaWQgMDtjb25zdCByPW4oOTE2Mik7ZS5zaGFwZT0odCxlKT0+KGkoZSksW25ldyByLlRlbnNvcihbZVswXS5kaW1zLmxlbmd0aF0sXCJpbnQzMlwiLHZvaWQgMCx2b2lkIDAsbmV3IEludDMyQXJyYXkoZVswXS5kaW1zKSldKTtjb25zdCBpPXQ9PntpZighdHx8MSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIHJlcXVpcmVzIDEgaW5wdXQuXCIpfX0sMjI3ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zbGljZVYxMD1lLnBhcnNlU2xpY2VBdHRyaWJ1dGVzPWUuc2xpY2U9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9big3ODIpLG89bigyNTE3KSxhPW4oMjAzOSkscz17bmFtZTpcIlNsaWNlXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2EuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtlLnNsaWNlPSh0LGUsbik9PihjKGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+dSh0LGVbMF0sbil9KSxlKV0pLGUucGFyc2VTbGljZUF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLmdldEludHMoXCJzdGFydHNcIiksbj10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcImVuZHNcIiksaT10LmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIixbXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtzdGFydHM6ZSxlbmRzOm4sYXhlczppfSl9O2NvbnN0IHU9KHQsZSxuKT0+e2NvbnN0IHI9MD09PW4uYXhlcy5sZW5ndGg/ZS5kaW1zLnNsaWNlKDApLm1hcCgoKHQsZSk9PmUpKTpuLmF4ZXMsaT1vLlNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKHIsZS5kaW1zLmxlbmd0aCksdT1uLnN0YXJ0cy5tYXAoKCh0LG4pPT50PmUuZGltc1tpW25dXS0xP2UuZGltc1tpW25dXTpvLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKHQsZS5kaW1zW2lbbl1dKSkpLGM9bi5lbmRzLm1hcCgoKHQsbik9PnQ+ZS5kaW1zW2lbbl1dLTE/ZS5kaW1zW2lbbl1dOm8uU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXModCxlLmRpbXNbaVtuXV0pKSksbD1lLmRpbXMuc2xpY2UoKSxwPVtdO2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGg7dCsrKWxbaVt0XV09Y1t0XS11W3RdLHVbdF0+MCYmcC5wdXNoKGBvdXRwdXRJZHhbJHtpW3RdfV0gKz0gJHt1W3RdfTtgKTtjb25zdCBmPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtsLmxlbmd0aH1dKSB7XFxuICAgICAgICAke3Auam9pbihcIlxcbiAgICAgIFwiKX1cXG4gICAgICAgIHJldHVybiBfQShvdXRwdXRJZHgpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse291dHB1dDp7ZGltczpsLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpmfSl9LGM9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU2xpY2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoLTE9PT1pLk5VTUJFUl9UWVBFUy5pbmRleE9mKHRbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX07ZS5zbGljZVYxMD0odCxlKT0+e3AoZSk7Y29uc3Qgbj1sKHQsZSk7cmV0dXJuW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT51KHQsZVswXSxuKX0pLFtlWzBdXSldfTtjb25zdCBsPSh0LGUpPT57aWYoIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMV0uZGF0YUlkKXx8IXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMl0uZGF0YUlkKXx8ZS5sZW5ndGg+PTQmJiF0LnNlc3Npb24uaXNJbml0aWFsaXplcihlWzNdLmRhdGFJZCl8fGUubGVuZ3RoPj01JiYhdC5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoZVs0XS5kYXRhSWQpKXRocm93IG5ldyBFcnJvcihcImR5bmFtaWMgc2xpY2UgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWRcIik7aWYoZS5sZW5ndGg+PTUmJmVbNF0uaW50ZWdlckRhdGEuc29tZSgodD0+MSE9PXQpKSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm9uLTEgc3RlcHMgaXMgbm90IHN1cHBvcnRlZCBmb3IgU2xpY2VcIik7Y29uc3Qgbj1BcnJheS5mcm9tKGVbMV0uaW50ZWdlckRhdGEpLHI9QXJyYXkuZnJvbShlWzJdLmludGVnZXJEYXRhKSxpPWUubGVuZ3RoPj00P0FycmF5LmZyb20oZVszXS5pbnRlZ2VyRGF0YSk6W107cmV0dXJue3N0YXJ0czpuLGVuZHM6cixheGVzOmksY2FjaGVLZXk6YCR7aX07JHtufTske3J9YH19LHA9dD0+e2lmKCF0fHx0Lmxlbmd0aDwzfHx0Lmxlbmd0aD41KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgbnVtYmVyLlwiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGV8fDEhPT10WzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoXCJpbnQzMlwiIT09dFsyXS50eXBlfHwxIT09dFsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKHQubGVuZ3RoPj00JiYoXCJpbnQzMlwiIT09dFszXS50eXBlfHwxIT09dFszXS5kaW1zLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZih0Lmxlbmd0aD49NSYmKFwiaW50MzJcIiE9PXRbNF0udHlwZXx8MSE9PXRbNF0uZGltcy5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw1NTI0Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNvZnRtYXhWMTM9ZS5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzPWUucGFyc2VTb2Z0bWF4QXR0cmlidXRlcz1lLnNvZnRtYXg9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oNTA2MCksYT1uKDIwMzkpLHM9bigzNzM4KSx1PXtuYW1lOlwiU29mdG1heENvbXB1dGVNYXhcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19LGM9e25hbWU6XCJTb2Z0bWF4Q29tcHV0ZVNjYWxlXCIsaW5wdXROYW1lczpbXCJBXCIsXCJNYXhcIl0saW5wdXRUeXBlczpbYS5UZXh0dXJlVHlwZS51bnBhY2tlZCxhLlRleHR1cmVUeXBlLnVucGFja2VkXX0sbD17bmFtZTpcIlNvZnRNYXhcIixpbnB1dE5hbWVzOltcIkFcIixcIk1heFwiLFwiTm9ybVwiXSxpbnB1dFR5cGVzOlthLlRleHR1cmVUeXBlLnVucGFja2VkLGEuVGV4dHVyZVR5cGUudW5wYWNrZWQsYS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2Uuc29mdG1heD0odCxlLG4pPT57ZyhlKTtjb25zdCByPWVbMF0uZGltcy5zbGljZSgpLG89aS5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsci5sZW5ndGgpLGE9aS5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHIsbykscz1pLlNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihyLG8pO3JldHVybiBwKHQsZSxuLGEscyl9LGUucGFyc2VTb2Z0bWF4QXR0cmlidXRlcz10PT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4aXM6dC5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwxKX0pLGUucGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxMz10PT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4aXM6dC5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwtMSl9KSxlLnNvZnRtYXhWMTM9KHQsZSxuKT0+e2coZSk7Y29uc3Qgbz1lWzBdLmRpbXMuc2xpY2UoKSxhPWkuU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMobi5heGlzLG8ubGVuZ3RoKSx1PW8ubGVuZ3RoLGM9YSE9PXUtMSxsPVtdO2xldCBmLGQ9W10saD1bXTtjJiYoZD1BcnJheS5mcm9tKHtsZW5ndGg6dX0pLm1hcCgoKHQsZSk9PmUpKSxkW2FdPXUtMSxkW3UtMV09YSxkLm1hcCgodD0+bC5wdXNoKG9bdF0pKSksZj0oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe3Blcm06ZH0pLGg9KDAscy50cmFuc3Bvc2UpKHQsZSxmKSk7Y29uc3QgYj1jP2kuU2hhcGVVdGlsLnNpemVUb0RpbWVuc2lvbihsLHUtMSk6aS5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKG8sdS0xKSxtPWM/aS5TaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24obCx1LTEpOmkuU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKG8sdS0xKSx5PXAodCxjP2g6ZSxuLGIsbSk7cmV0dXJuIGM/KDAscy50cmFuc3Bvc2UpKHQseSxmKTp5fTtjb25zdCBwPSh0LGUsbixyLGkpPT57Y29uc3Qgbz1mKHQsZVswXSxyLGksW3JdKSxhPXQucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5vfSksZSkscz1kKHQsZVswXSxyLGksby5vdXRwdXQuZGltcyxbcl0pLHA9dC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PnN9KSxbZVswXSxhXSksZz1oKHQsZVswXSxyLGksby5vdXRwdXQuZGltcyxzLm91dHB1dC5kaW1zKTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGwpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9Pmd9KSxbZVswXSxhLHBdKV19LGY9KHQsZSxuLHIsaSk9Pntjb25zdFtzLGNdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGUuZGltcyxhLlRleHR1cmVUeXBlLnVucGFja2VkKSxsPWkubGVuZ3RoO2lmKG48MXx8cjwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKDEhPT1pLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSAxXCIpO2lmKGlbMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50XCIpO2NvbnN0IHA9KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksZj1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtsfV0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke3J9O1xcblxcbiAgICAgICAgZmxvYXQgbWF4ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7cC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCwgJHtzfSxcXG4gICAgICAgICR7Y30gKSkpO1xcbiAgICAgICAgZm9yKGludCBpPTE7IGk8JHtyfTsgKytpKVxcbiAgICAgICAge1xcbiAgICAgICAgICBmbG9hdCBjdXJyZW50ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7cC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXFxuICAgICAgICAgICAgJHtzfSwgJHtjfSkpKTtcXG4gICAgICAgICAgaWYoY3VycmVudCA+IG1heClcXG4gICAgICAgICAgbWF4ID0gY3VycmVudDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBtYXg7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7b3V0cHV0OntkaW1zOmksdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmZ9KX0sZD0odCxlLG4scixpLHMpPT57Y29uc3RbdSxsXT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlLmRpbXMsYS5UZXh0dXJlVHlwZS51bnBhY2tlZCkscD1zLmxlbmd0aDtpZihuPDF8fHI8MSl0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKTtpZigxIT09cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMVwiKTtpZihzWzBdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtpZigxIT09aS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uYWxpdHkgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSAxXCIpO2lmKGlbMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgZj1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtwfV0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke3J9O1xcblxcbiAgICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSAwLjA7XFxuICAgICAgICBmbG9hdCBtYXggPSBfTWF4KGluZGljZXMpO1xcbiAgICAgICAgZm9yKGludCBpPTA7IGk8JHtyfTsgKytpKVxcbiAgICAgICAge1xcbiAgICAgICAgICBub3JtX2ZhY3RvciArPSBleHAoZ2V0Q29sb3JBc0Zsb2F0KCR7KDAsby5nZXRHbHNsKSh0LnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfShBLCBvZmZzZXRUb0Nvb3Jkcyhsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgKyBpLFxcbiAgICAgICAgICAgICR7dX0sICR7bH0pKSkgLSBtYXgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIG5vcm1fZmFjdG9yO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYykse291dHB1dDp7ZGltczpzLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOmEuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpmfSl9LGg9KHQsZSxuLHIsaSxvKT0+e2NvbnN0W3MsdV09dC5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoZS5kaW1zLGEuVGV4dHVyZVR5cGUudW5wYWNrZWQpLGM9ZS5kaW1zLmxlbmd0aDtpZihuPDF8fHI8MSl0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKTtpZigxIT09aS5sZW5ndGh8fDEhPT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDFcIik7aWYoaVswXSE9PW58fG9bMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgcD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtjfV0gaW5kaWNlcykge1xcblxcbiAgICAgIC8vIGdldCBvZmZzZXQgb2YgY3VycmVudCBsb2dpY2FsIHRlbnNvciBpbmRleCBmcm9tIHRoZSAyLUQgdGV4dHVyZSBjb29yZGluYXRlcyAoVGV4Q29vcmRzKVxcbiAgICAgIGludCBvZmZzZXQgPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7c30sICR7dX0pO1xcblxcbiAgICAgIC8vZGV0ZXJtaW5lIHRoZSBsb2dpY2FsIHJvdyBmb3IgdGhpcyBpbmRleFxcbiAgICAgIGludCBsb2dpY2FsX3Jvd19pbmRleFsxXTtcXG4gICAgICBsb2dpY2FsX3Jvd19pbmRleFswXSA9IG9mZnNldCAvICR7cn07XFxuXFxuICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSBfTm9ybShsb2dpY2FsX3Jvd19pbmRleCk7XFxuXFxuICAgICAgLy8gYXZvaWQgcG9zc2libGUgZGl2aXNpb24gYnkgMFxcbiAgICAgIC8vIGlmIG5vcm1fZmFjb3IgaXMgMCwgYWxsIGVsZW1lbnRzIGFyZSB6ZXJvXFxuICAgICAgLy8gaWYgc28sIHJldHVybiAwXFxuICAgICAgaWYobm9ybV9mYWN0b3IgPT0gMC4wKVxcbiAgICAgICAgcmV0dXJuIDAuMDtcXG5cXG4gICAgICByZXR1cm4gZXhwKF9BKGluZGljZXMpIC0gX01heChsb2dpY2FsX3Jvd19pbmRleCkpIC8gbm9ybV9mYWN0b3I7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse291dHB1dDp7ZGltczplLmRpbXMsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6YS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnB9KX0sZz10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0bWF4IHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGVcIil9fSw1OTc1Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlU3BsaXRBdHRyaWJ1dGVzPWUuc3BsaXQ9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oMjAzOSksYT17bmFtZTpcIlNwbGl0XCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtlLnNwbGl0PSh0LGUsbik9PntjKGUpO2NvbnN0IHI9aS5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsZVswXS5kaW1zLmxlbmd0aCksbz1zKHQsZSxyLG4pLGw9W107Zm9yKGxldCBpPTA7aTxvOysraSlsLnB1c2godC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtjYWNoZUhpbnQ6YCR7bi5jYWNoZUtleX07JHtpfWAsZ2V0OigpPT51KHQsZVswXSxuLHIsaSl9KSxlKSk7cmV0dXJuIGx9LGUucGFyc2VTcGxpdEF0dHJpYnV0ZXM9dD0+e2NvbnN0IGU9dC5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwwKSxuPXQuYXR0cmlidXRlcy5nZXRJbnRzKFwic3BsaXRcIixbXSksaT10Lm91dHB1dHMubGVuZ3RoO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczplLHNwbGl0Om4sbnVtT3V0cHV0czppfSl9O2NvbnN0IHM9KHQsZSxuLHIpPT57Y29uc3RbLG9dPWkuU3BsaXRVdGlsLnNwbGl0U2hhcGUoZVswXS5kaW1zLG4sci5zcGxpdCxyLm51bU91dHB1dHMpO3JldHVybiBvLmxlbmd0aH0sdT0odCxlLG4scixzKT0+e2NvbnN0W3UsY109aS5TcGxpdFV0aWwuc3BsaXRTaGFwZShlLmRpbXMscixuLnNwbGl0LG4ubnVtT3V0cHV0cyksbD1jW3NdLHA9dVtzXSxmPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cC5sZW5ndGh9XSkge1xcbiAgICAgICAgaW5kaWNlc1ske3J9XSArPSAke2x9O1xcbiAgICAgICAgcmV0dXJuIF9BKGluZGljZXMpO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtjYWNoZUhpbnQ6YCR7bi5jYWNoZUtleX06JHtzfWAsb3V0cHV0OntkaW1zOnAsdHlwZTplLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmZ9KX0sYz10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTcGxpdCByZXF1aXJlcyBvbmUgaW5wdXQuXCIpO2lmKFwiaW50OFwiIT09dFswXS50eXBlJiZcInVpbnQ4XCIhPT10WzBdLnR5cGUmJlwiaW50MTZcIiE9PXRbMF0udHlwZSYmXCJ1aW50MTZcIiE9PXRbMF0udHlwZSYmXCJpbnQzMlwiIT09dFswXS50eXBlJiZcInVpbnQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUmJlwiYm9vbFwiIT09dFswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSwzOTMzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlU3F1ZWV6ZUF0dHJpYnV0ZXM9ZS5zcXVlZXplVjEzPWUuc3F1ZWV6ZT12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2Uuc3F1ZWV6ZT0odCxlLG4pPT57aShlKTtjb25zdCBvPXIuU2hhcGVVdGlsLnNxdWVlemVTaGFwZShlWzBdLmRpbXMsbik7cmV0dXJuW3QucmVzaGFwZVVucGFja2VkKGVbMF0sbyldfSxlLnNxdWVlemVWMTM9KHQsbik9PihvKG4pLCgwLGUuc3F1ZWV6ZSkodCxbblswXV0sQXJyYXkuZnJvbShuWzFdLmludGVnZXJEYXRhKSkpLGUucGFyc2VTcXVlZXplQXR0cmlidXRlcz10PT50LmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIik7Y29uc3QgaT10PT57aWYoIXR8fDEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxvPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNxdWVlemUgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKFwiaW50MzJcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sNjU1ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zdW09dm9pZCAwO2NvbnN0IHI9big1MDYwKSxpPW4oMjAzOSk7ZS5zdW09KHQsZSk9PnthKGUpO2NvbnN0IG49e25hbWU6XCJTdW1cIixpbnB1dE5hbWVzOmUubWFwKCgodCxlKT0+YFgke2V9YCkpLGlucHV0VHlwZXM6bmV3IEFycmF5KGUubGVuZ3RoKS5maWxsKGkuVGV4dHVyZVR5cGUudW5wYWNrZWQpfTtyZXR1cm5bdC5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9Pm8odCxlLG4pfSksZSldfTtjb25zdCBvPSh0LGUsbik9Pntjb25zdCBvPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGE9ZVswXS5kaW1zLnNsaWNlKCkscz1gXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke2UubWFwKCgodCxlKT0+YCR7by50ZXh0dXJlMkR9KFgke2V9LFRleENvb3JkcylgKSkuam9pbihcIiArIFwiKX07XFxuICAgICAgICAke28ub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmEsdHlwZTplWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0saGFzTWFpbjohMCxzaGFkZXJTb3VyY2U6c30pfSxhPXQ9PntpZighdHx8MD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlN1bSByZXF1aXJlcyBpbnB1dHMuXCIpO2NvbnN0IGU9dFswXS5kaW1zLmxlbmd0aDtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl7aWYoZSE9PXRbbl0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLlwiKTtmb3IobGV0IHI9MDtyPGU7cisrKWlmKHRbMF0uZGltc1tyXSE9PXRbbl0uZGltc1tyXSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBzaGFwZXMgYXJlIG5vdCBtYXRjaGVkLlwiKX1pZihcImZsb2F0MzJcIiE9PXRbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKylpZih0WzBdLnR5cGUhPT10W2VdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG5vdCBtYXRjaGVkLlwiKX19LDU3MjM6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUudGlsZT12b2lkIDA7Y29uc3Qgcj1uKDc4MiksaT1uKDIwMzkpO2UudGlsZT0odCxlKT0+e2EoZSk7Y29uc3Qgbj17bmFtZTpcIlRpbGVcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3JldHVyblt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse2dldDooKT0+byh0LGUsbil9KSxlKV19O2NvbnN0IG89KHQsZSxuKT0+e2NvbnN0IHI9ZVswXS5kaW1zLnNsaWNlKCksbz1uZXcgQXJyYXkoci5sZW5ndGgpLGE9W107Zm9yKGxldCB0PTA7dDxyLmxlbmd0aDt0Kyspb1t0XT1yW3RdKmVbMV0ubnVtYmVyRGF0YVt0XSxhLnB1c2goYGlucHV0SWR4WyR7dH1dID0gaW50KG1vZChmbG9hdChvdXRwdXRJZHhbJHt0fV0pLCAke3JbdF19LikpO2ApO2NvbnN0IHM9by5sZW5ndGgsdT1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7c31dKSB7XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtzfV07XFxuICAgICAgICAke2Euam9pbihcIlxcblwiKX1cXG4gICAgICAgIHJldHVybiBfQShpbnB1dElkeCk7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpvLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTp1fSl9LGE9dD0+e2lmKCF0fHwyIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSByZXF1aXJlcyAyIGlucHV0LlwiKTtpZigxIT09dFsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2Vjb25kIGlucHV0IHNoYXBlIG11c3QgMSBkaW1lbnNpb24uXCIpO2lmKHRbMV0uZGltc1swXSE9PXRbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYoLTE9PT1yLk5VTUJFUl9UWVBFUy5pbmRleE9mKHRbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihcImludDMyXCIhPT10WzFdLnR5cGUmJlwiaW50MTZcIiE9PXRbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlcGVhdCB0eXBlLlwiKX19LDM3Mzg6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUucGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzPWUudHJhbnNwb3NlPXZvaWQgMDtjb25zdCByPW4oMjQ2KSxpPW4oMjUxNyksbz1uKDIwMzkpLGE9e25hbWU6XCJUcmFuc3Bvc2VcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UudHJhbnNwb3NlPSh0LGUsbik9PihwKGUpLFt0LnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+cyh0LGVbMF0sbi5wZXJtKX0pLGUpXSksZS5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtwZXJtOnQuYXR0cmlidXRlcy5nZXRJbnRzKFwicGVybVwiLFtdKX0pO2NvbnN0IHM9KHQsZSxuKT0+e2NvbnN0IHI9ZS5kaW1zO249dShyLG4pO2NvbnN0IGk9YyhyLG4pLHM9ci5sZW5ndGgscD1gXFxuICAgICAgJHtsKFwicGVybVwiLG4scyl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3N9XSkge1xcbiAgICAgICAgaW50IGFbJHtzfV07XFxuICAgICAgICBwZXJtKGEsIGluZGljZXMpO1xcbiAgICAgICAgcmV0dXJuIF9BKGEpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczppLHR5cGU6ZS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpwfSl9LHU9KHQsZSk9PihlJiZlLmxlbmd0aCE9PXQubGVuZ3RoJiYoZT1bLi4udC5rZXlzKCldLnJldmVyc2UoKSksZSksYz0odCxlKT0+KGU9dSh0LGUpLGkuU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybSh0LGUpKSxsPSh0LGUsbik9Pntjb25zdCByPVtdO3IucHVzaChgdm9pZCAke3R9KG91dCBpbnQgYVske259XSwgaW50IHNyY1ske259XSkge2ApO2ZvcihsZXQgdD0wO3Q8bjsrK3Qpci5wdXNoKGBcXHRhWyR7ZVt0XX1dPXNyY1ske3R9XTtgKTtyZXR1cm4gci5wdXNoKFwiXFx0fVwiKSxyLmpvaW4oXCJcXG5cIil9LHA9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09dFswXS50eXBlJiZcImZsb2F0NjRcIiE9PXRbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sODcxMDoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5lbmNvZGVBc1VpbnQ4PXZvaWQgMDtjb25zdCByPW4oNTA2MCksaT1uKDIwMzkpO2UuZW5jb2RlQXNVaW50OD0odCxlKT0+e2NvbnN0IG49ZS5zaGFwZSxvPSgwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGE9YFxcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NQVggPSAxLjcwMTQxMTg0ZTM4O1xcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcXG5cXG4gICAgYm9vbCBpc05hTihmbG9hdCB2YWwpIHtcXG4gICAgICByZXR1cm4gKHZhbCA8IDEuMCB8fCAwLjAgPCB2YWwgfHwgdmFsID09IDAuMCkgPyBmYWxzZSA6IHRydWU7XFxuICAgIH1cXG5cXG4gICAgaGlnaHAgdmVjNCBlbmNvZGVBc1VpbnQ4KGhpZ2hwIGZsb2F0IHYpIHtcXG4gICAgICBpZiAoaXNOYU4odikpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XFxuICAgICAgfVxcblxcbiAgICAgIGhpZ2hwIGZsb2F0IGF2ID0gYWJzKHYpO1xcblxcbiAgICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgIH0gZWxzZSBpZih2ID4gRkxPQVRfTUFYKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xcbiAgICAgIH0gZWxzZSBpZih2IDwgLUZMT0FUX01BWCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XFxuICAgICAgfVxcblxcbiAgICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgZSA9IGZsb29yKGxvZzIoYXYpKTtcXG4gICAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xcblxcbiAgICAgIGNbMl0gPSBmbG9vcigxMjguMCAqIG0pO1xcbiAgICAgIG0gLT0gY1syXSAvIDEyOC4wO1xcbiAgICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XFxuICAgICAgbSAtPSBjWzFdIC8gMzI3NjguMDtcXG4gICAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XFxuICAgICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcXG4gICAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xcbiAgICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XFxuXFxuICAgICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XFxuXFxuICAgICAgcmV0dXJuIGMgLyAyNTUuMDtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZmxvYXQgdmFsdWUgPSAke28udGV4dHVyZTJEfShYLFRleENvb3JkcykucjtcXG4gICAgICAke28ub3V0cHV0fSA9IGVuY29kZUFzVWludDgodmFsdWUpO1xcbiAgICB9YCxzPXtuYW1lOlwiVWludDhFbmNvZGVcIixpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXSxpbnB1dE5hbWVzOltcIlhcIl0sb3V0cHV0OntkaW1zOm4sdHlwZTplLnRlbnNvci50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUuZG93bmxvYWRVaW50OEFzRmxvYXR9LHNoYWRlclNvdXJjZTphLGhhc01haW46ITB9O3JldHVybiB0LmV4ZWN1dGVQcm9ncmFtKHMsW2UudGVuc29yXSl9fSw0OTA5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnRhbmg9ZS50YW49ZS5zcXJ0PWUuc2luPWUuc2lnbW9pZD1lLnJlbHU9ZS5ub3Q9ZS5uZWc9ZS5sb2c9ZS5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXM9ZS5sZWFreVJlbHU9ZS5pZGVudGl0eT1lLmZsb29yPWUuZXhwPWUucGFyc2VFbHVBdHRyaWJ1dGVzPWUuZWx1PWUuY29zPWUuY2VpbD1lLmNsaXBWMTE9ZS5wYXJzZUNsaXBBdHRyaWJ1dGVzPWUuY2xpcD1lLmF0YW49ZS5hc2luPWUuYWNvcz1lLmFicz1lLmdsc2xUYW5oPWUuZ2xzbFRhbj1lLmdsc2xTcXJ0PWUuZ2xzbFNpZ21vaWQ9ZS5nbHNsUmVsdT1lLmdsc2xTaW49ZS5nbHNsTm90PWUuZ2xzbE5lZz1lLmdsc2xMb2c9ZS5nbHNsTGVha3lSZWx1PWUuZ2xzbElkZW50aXR5PWUuZ2xzbENsaXA9ZS5nbHNsRmxvb3I9ZS5nbHNsRXhwPWUuZ2xzbEVsdT1lLmdsc2xDb3M9ZS5nbHNsQ2VpbD1lLmdsc2xBdGFuPWUuZ2xzbEFzaW49ZS5nbHNsQWNvcz1lLmdsc2xBYnM9dm9pZCAwO2NvbnN0IHI9bigyNDYpLGk9bigyNTE3KSxvPW4oODUyMCksYT1uKDUwNjApLHM9bigyMDM5KTtmdW5jdGlvbiB1KCl7cmV0dXJuIFAoXCJhYnNcIil9ZnVuY3Rpb24gYygpe3JldHVybiBQKFwiYWNvc1wiKX1mdW5jdGlvbiBsKCl7cmV0dXJuIFAoXCJhc2luXCIpfWZ1bmN0aW9uIHAoKXtyZXR1cm4gUChcImF0YW5cIil9ZnVuY3Rpb24gZigpe3JldHVybiBQKFwiY2VpbFwiKX1mdW5jdGlvbiBkKCl7cmV0dXJuIFAoXCJjb3NcIil9ZnVuY3Rpb24gaCh0KXtjb25zdCBlPVwiZWx1XCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgYWxwaGEgPSBmbG9hdCgke3R9KTtcXG5cXG4gIGZsb2F0ICR7ZX1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGEgPj0gMC4wID8gYTogKGV4cChhKSAtIDEuMCkgKiBhbHBoYTtcXG4gIH1cXG4gIHZlYzQgJHtlfV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2ZWM0KCR7ZX1fKHYueCksICR7ZX1fKHYueSksICR7ZX1fKHYueiksICR7ZX1fKHYudykpO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBnKCl7cmV0dXJuIFAoXCJleHBcIil9ZnVuY3Rpb24gYigpe3JldHVybiBQKFwiZmxvb3JcIil9ZnVuY3Rpb24gbSh0LGUpe2NvbnN0IG49XCJjbGlwXCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgbWluID0gZmxvYXQoJHt0fSk7XFxuICBjb25zdCBmbG9hdCBtYXggPSBmbG9hdCgke2V9KTtcXG5cXG4gIGZsb2F0ICR7bn1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGNsYW1wKGEsIG1pbiwgbWF4KTtcXG4gIH1cXG4gIHZlYzQgJHtufV8odmVjNCB2KSB7XFxuICAgIHJldHVybiBjbGFtcCh2LCBtaW4sIG1heCk7XFxuICB9XFxuICBgLG5hbWU6bix0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHkoKXtjb25zdCB0PVwiaW5kZW50aXR5XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYTtcXG4gIH1cXG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2O1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBfKHQpe2NvbnN0IGU9XCJsZWFreVJlbHVcIjtyZXR1cm57Ym9keTpgXFxuICBjb25zdCBmbG9hdCBhbHBoYSA9IGZsb2F0KCR7dH0pO1xcblxcbiAgZmxvYXQgJHtlfV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gYSA8IDAuMCA/IGEgKiBhbHBoYSA6IGE7XFxuICB9XFxuICB2ZWM0ICR7ZX1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gdmVjNCgke2V9Xyh2LngpLCAke2V9Xyh2LnkpLCAke2V9Xyh2LnopLCAke2V9Xyh2LncpKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gdigpe3JldHVybiBQKFwibG9nXCIpfWZ1bmN0aW9uIHcoKXtjb25zdCB0PVwibmVnXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gLWE7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gLXY7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHgoKXtjb25zdCB0PVwibm90XCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gZmxvYXQoICEgYm9vbChhKSApO1xcbiAgfVxcbiAgYm9vbCAke3R9Xyhib29sIGEpIHtcXG4gICAgcmV0dXJuICFhO1xcbiAgfVxcbiAgdmVjNCAke3R9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIHZlYzQoIWJvb2wodi54KSwgIWJvb2wodi55KSwgIWJvb2wodi56KSwgIWJvb2wodi53KSk7XFxuICB9XFxuICBidmVjNCAke3R9XyhidmVjNCB2KSB7XFxuICAgIHJldHVybiBidmVjNCghdi54LCAhdi55LCAhdi56LCAhdi53KTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gVCgpe3JldHVybiBQKFwic2luXCIpfWZ1bmN0aW9uIFMoKXtjb25zdCB0PVwicmVsdVwiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7dH1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIG1heCggYSwgMC4wICk7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gbWF4KCB2LCAwLjAgKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gTygpe2NvbnN0IHQ9XCJzaWdtb2lkXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtYSkpO1xcbiAgfVxcbiAgdmVjNCAke3R9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLXYpKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gQSgpe3JldHVybiBQKFwic3FydFwiKX1mdW5jdGlvbiBFKCl7cmV0dXJuIFAoXCJ0YW5cIil9ZnVuY3Rpb24gSSgpe2NvbnN0IHQ9XCJ0YW5oXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICBhID0gY2xhbXAoYSwgLTEwLiwgMTAuKTtcXG4gICAgYSA9IGV4cCgyLiphKTtcXG4gICAgcmV0dXJuIChhIC0gMS4pIC8gKGEgKyAxLik7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICB2ID0gY2xhbXAodiwgLTEwLiwgMTAuKTtcXG4gICAgdiA9IGV4cCgyLip2KTtcXG4gICAgcmV0dXJuICh2IC0gMS4pIC8gKHYgKyAxLik7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIFAodCl7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fV8oZmxvYXQgYSkge1xcbiAgICByZXR1cm4gJHt0fShhKTtcXG4gIH1cXG4gIHZlYzQgJHt0fV8odmVjNCB2KSB7XFxuICAgIHJldHVybiAke3R9KHYpO1xcbiAgfVxcbiAgYCxuYW1lOnQsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1lLmdsc2xBYnM9dSxlLmdsc2xBY29zPWMsZS5nbHNsQXNpbj1sLGUuZ2xzbEF0YW49cCxlLmdsc2xDZWlsPWYsZS5nbHNsQ29zPWQsZS5nbHNsRWx1PWgsZS5nbHNsRXhwPWcsZS5nbHNsRmxvb3I9YixlLmdsc2xDbGlwPW0sZS5nbHNsSWRlbnRpdHk9eSxlLmdsc2xMZWFreVJlbHU9XyxlLmdsc2xMb2c9dixlLmdsc2xOZWc9dyxlLmdsc2xOb3Q9eCxlLmdsc2xTaW49VCxlLmdsc2xSZWx1PVMsZS5nbHNsU2lnbW9pZD1PLGUuZ2xzbFNxcnQ9QSxlLmdsc2xUYW49RSxlLmdsc2xUYW5oPUk7Y29uc3QgRD0odCxlLG4scik9Pntjb25zdCBpPXQuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsbz17bmFtZTpuLm5hbWUsaW5wdXRUeXBlczpbaV0saW5wdXROYW1lczpbXCJBXCJdLGNhY2hlSGludDpyfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHtnZXQ6KCk9PigodCxlLG4scik9Pntjb25zdCBpPXQuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsbz0oMCxhLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6bi5kaW1zLHR5cGU6bi50eXBlLHRleHR1cmVUeXBlOml9LHNoYWRlclNvdXJjZTpgXFxuICAgICAke3IuYm9keX1cXG4gICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgdmVjNCB2ID0gJHtvLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcXG4gICAgICAgdiA9ICR7ci5uYW1lfV8odik7XFxuICAgICAgICR7by5vdXRwdXR9ID0gdjtcXG4gICAgIH1cXG4gICAgIGAsaGFzTWFpbjohMH0pfSkodCxvLGUsbil9KX07ZS5hYnM9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx1KCkpLGUpXSxlLmFjb3M9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxjKCkpLGUpXSxlLmFzaW49KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxsKCkpLGUpXSxlLmF0YW49KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxwKCkpLGUpXSxlLmNsaXA9KHQsZSxuKT0+W3QucnVuKEQodCxlWzBdLG0obi5taW4sbi5tYXgpLG4uY2FjaGVLZXkpLGUpXSxlLnBhcnNlQ2xpcEF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHttaW46dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWluXCIsaS5NSU5fQ0xJUCksbWF4OnQuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1heFwiLGkuTUFYX0NMSVApfSksZS5jbGlwVjExPSh0LG4pPT57Y29uc3Qgcj0kKHQsbik7cmV0dXJuKDAsZS5jbGlwKSh0LFtuWzBdXSxyKX07Y29uc3QgJD0odCxlKT0+e2lmKGUubGVuZ3RoPj0zJiYoIXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMV0uZGF0YUlkKXx8IXQuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGVbMl0uZGF0YUlkKSkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBjbGlwIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbGxvd2VkXCIpO2NvbnN0IG49ZS5sZW5ndGg+PTM/ZVsxXS5udW1iZXJEYXRhWzBdOmkuTUlOX0NMSVAsbz1lLmxlbmd0aD49Mz9lWzJdLm51bWJlckRhdGFbMF06aS5NQVhfQ0xJUDtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21pbjpuLG1heDpvfSl9O2UuY2VpbD0odCxlKT0+W3QucnVuKEQodCxlWzBdLGYoKSksZSldLGUuY29zPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sZCgpKSxlKV0sZS5lbHU9KHQsZSxuKT0+W3QucnVuKEQodCxlWzBdLGgobi5hbHBoYSksbi5jYWNoZUtleSksZSldLGUucGFyc2VFbHVBdHRyaWJ1dGVzPXQ9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YWxwaGE6dC5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYWxwaGFcIiwxKX0pLGUuZXhwPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sZygpKSxlKV0sZS5mbG9vcj0odCxlKT0+W3QucnVuKEQodCxlWzBdLGIoKSksZSldLGUuaWRlbnRpdHk9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx5KCkpLGUpXSxlLmxlYWt5UmVsdT0odCxlLG4pPT5bdC5ydW4oRCh0LGVbMF0sXyhuLmFscGhhKSxuLmNhY2hlS2V5KSxlKV0sZS5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXM9dD0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthbHBoYTp0LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJhbHBoYVwiLC4wMSl9KSxlLmxvZz0odCxlKT0+W3QucnVuKEQodCxlWzBdLHYoKSksZSldLGUubmVnPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sdygpKSxlKV0sZS5ub3Q9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSx4KCkpLGUpXSxlLnJlbHU9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxTKCkpLGUpXSxlLnNpZ21vaWQ9KHQsZSk9Plt0LnJ1bihEKHQsZVswXSxPKCkpLGUpXSxlLnNpbj0odCxlKT0+W3QucnVuKEQodCxlWzBdLFQoKSksZSldLGUuc3FydD0odCxlKT0+W3QucnVuKEQodCxlWzBdLEEoKSksZSldLGUudGFuPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sRSgpKSxlKV0sZS50YW5oPSh0LGUpPT5bdC5ydW4oRCh0LGVbMF0sSSgpKSxlKV19LDU2MTE6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXI9ZS5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbz12b2lkIDA7Y29uc3Qgcj1uKDUwNjApLGk9bigyMDM5KSxvPW4oOTM5MCksYT1uKDI4MjcpLHM9e25hbWU6XCJ1bnBhY2tcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS5wYWNrZWRdfTtlLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvPSh0LGUpPT57Y29uc3Qgbj1lLmRpbXMubGVuZ3RoLHU9KDAsYS5nZXRDaGFubmVscykoXCJyY1wiLG4pLGM9dS5zbGljZSgtMiksbD0oMCxvLmdldENvb3Jkc0RhdGFUeXBlKShuKSxwPSgwLGEudW5wYWNrRnJvbUNoYW5uZWwpKCksZj0wPT09ZS5kaW1zLmxlbmd0aD9cIlwiOmZ1bmN0aW9uKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJyY1wiO2xldCBuPVwiXCI7Zm9yKGxldCByPTA7cjx0O3IrKyluKz1lW3JdLHI8dC0xJiYobis9XCIsXCIpO3JldHVybiBufShuLHUpLGQ9bjw9MT9cInJjXCI6YHZlYzIoJHtjLmpvaW4oXCIsXCIpfSlgLGg9YFxcbiAgICAke3B9XFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAke2x9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgIC8vIFNhbXBsZSB0aGUgdGV4dHVyZSB3aXRoIHRoZSBjb29yZHMgdG8gZ2V0IHRoZSByZ2JhIGNoYW5uZWwgdmFsdWUuXFxuICAgICAgIHZlYzQgcGFja2VkSW5wdXQgPSBnZXRBKCR7Zn0pO1xcblxcbiAgICAgICAkeygwLHIuZ2V0R2xzbCkodC5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLm91dHB1dH0gPSB2ZWM0KGdldENoYW5uZWwocGFja2VkSW5wdXQsICR7ZH0pLCAwLCAwLCAwKTtcXG4gICAgIH1cXG4gICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2hhc01haW46ITAsb3V0cHV0OntkaW1zOmUuZGltcyx0eXBlOmUudHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6aH0pfSxlLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyPSh0LG4pPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2dldDooKT0+KDAsZS5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbykodCxuKX0pfSw4NDI4Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnBhcnNlVW5zcXVlZXplQXR0cmlidXRlcz1lLnVuc3F1ZWV6ZVYxMz1lLnVuc3F1ZWV6ZT12b2lkIDA7Y29uc3Qgcj1uKDI1MTcpO2UudW5zcXVlZXplPSh0LGUsbik9PntpKGUpO2NvbnN0IG89ci5TaGFwZVV0aWwudW5zcXVlZXplU2hhcGUoZVswXS5kaW1zLG4pO3JldHVyblt0LnJlc2hhcGVVbnBhY2tlZChlWzBdLG8pXX0sZS51bnNxdWVlemVWMTM9KHQsbik9PihvKG4pLCgwLGUudW5zcXVlZXplKSh0LFtuWzBdXSxBcnJheS5mcm9tKG5bMV0uaW50ZWdlckRhdGEpKSksZS5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXM9dD0+dC5hdHRyaWJ1dGVzLmdldEludHMoXCJheGVzXCIpO2NvbnN0IGk9dD0+e2lmKCF0fHwxIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVW5zcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxvPXQ9PntpZighdHx8MiE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlVuc3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoXCJpbnQzMlwiIT09dFsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw5NzkzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNjYWxlc1ZhbGlkYXRpb249ZS52YWxpZGF0ZUlucHV0cz1lLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzPWUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOT1lLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjc9ZS51cHNhbXBsZT12b2lkIDA7Y29uc3Qgcj1uKDI0NiksaT1uKDUwNjApLG89bigyMDM5KSxhPXtuYW1lOlwiVXBzYW1wbGVcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19O2UudXBzYW1wbGU9KHQsbixyKT0+KCgwLGUudmFsaWRhdGVJbnB1dHMpKG4sciksW3QucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Y2FjaGVIaW50OnIuY2FjaGVLZXksZ2V0OigpPT5zKHQsbixyKX0pLG4pXSksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3PXQ9PigwLGUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsNyksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y5PXQ9PigwLGUucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKHQsOSksZS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcz0odCxuKT0+e2NvbnN0IGk9bj49MTAsbz10LmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwibmVhcmVzdFwiKTtpZihcIm5lYXJlc3RcIiE9PW8mJlwibGluZWFyXCIhPT1vJiYobjwxMXx8XCJjdWJpY1wiIT09bykpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHtvfWApO2xldCBhPVtdO248OSYmKGE9dC5hdHRyaWJ1dGVzLmdldEZsb2F0cyhcInNjYWxlc1wiKSwoMCxlLnNjYWxlc1ZhbGlkYXRpb24pKGEsbyxpKSk7Y29uc3Qgcz10LmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJleHRyYXBvbGF0aW9uX3ZhbHVlXCIsMCksdT1uPjEwP3QuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJjb29yZGluYXRlX3RyYW5zZm9ybWF0aW9uX21vZGVcIixcImhhbGZfcGl4ZWxcIik6XCJhc3ltbWV0cmljXCI7aWYoLTE9PT1bXCJhc3ltbWV0cmljXCIsXCJweXRvcmNoX2hhbGZfcGl4ZWxcIixcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCIsXCJhbGlnbl9jb3JuZXJzXCIsXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIixcImhhbGZfcGl4ZWxcIl0uaW5kZXhPZih1KSl0aHJvdyBuZXcgRXJyb3IoYGNvb3JkaW5hdGVfdHJhbnNmb3JtX21vZGUgJyR7dX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtjb25zdCBjPVwidGZfY3JvcF9hbmRfcmVzaXplXCI9PT11LGw9YyxwPVwibmVhcmVzdFwiPT09byYmbj49MTE/dC5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm5lYXJlc3RfbW9kZVwiLFwicm91bmRfcHJlZmVyX2Zsb29yXCIpOlwiXCI7aWYoLTE9PT1bXCJyb3VuZF9wcmVmZXJfZmxvb3JcIixcInJvdW5kX3ByZWZlcl9jZWlsXCIsXCJmbG9vclwiLFwiY2VpbFwiLFwiXCJdLmluZGV4T2YocCkpdGhyb3cgbmV3IEVycm9yKGBuZWFyZXN0X21vZGUgJyR7cH0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtjb25zdCBmPXQuYXR0cmlidXRlcy5nZXRGbG9hdChcImN1YmljX2NvZWZmX2FcIiwtLjc1KSxkPTAhPT10LmF0dHJpYnV0ZXMuZ2V0SW50KFwiZXhjbHVkZV9vdXRzaWRlXCIsMCk7aWYoZCYmXCJjdWJpY1wiIT09byl0aHJvdyBuZXcgRXJyb3IoXCJleGNsdWRlX291dHNpZGUgY2FuIGJlIHNldCB0byAxIG9ubHkgd2hlbiBtb2RlIGlzIENVQklDLlwiKTtjb25zdCBoPW48MTF8fFwibmVhcmVzdFwiPT09byYmXCJhc3ltbWV0cmljXCI9PT11JiZcImZsb29yXCI9PT1wO2xldCBnPTAsYj0wLG09MDtyZXR1cm4gbj4xMD90LmlucHV0cy5sZW5ndGg+Mj8oZz0xLGI9MixtPTMpOihiPTEsbT0yKTo5PT09biYmKGI9MSksKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtvcHNldDpuLGlzUmVzaXplOmksbW9kZTpvLHNjYWxlczphLGV4dHJhcG9sYXRpb25WYWx1ZTpzLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOnUsdXNlRXh0cmFwb2xhdGlvbjpsLG5lZWRSb2lJbnB1dDpjLG5lYXJlc3RNb2RlOnAsY3ViaWNDb2VmZmljaWVudEE6ZixleGNsdWRlT3V0c2lkZTpkLHVzZU5lYXJlc3QyeE9wdGltaXphdGlvbjpoLHJvaUlucHV0SWR4Omcsc2NhbGVzSW5wdXRJZHg6YixzaXplc0lucHV0SWR4Om19KX07Y29uc3Qgcz0odCxlLG4pPT57Y29uc3Qgcj0oMCxpLmdldEdsc2wpKHQuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbcyx1XT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlWzBdLmRpbXMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksYz1lWzBdLmRpbXMubWFwKCgodCxlKT0+TWF0aC5mbG9vcih0Km4uc2NhbGVzW2VdKSkpLFtsLHBdPXQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGMsby5UZXh0dXJlVHlwZS51bnBhY2tlZCksZj1jLmxlbmd0aCxkPW5ldyBBcnJheShmKSxoPW5ldyBBcnJheShmKTtsZXQgZz1gXFxuICAgICAgaW50IG91dHB1dF9waXRjaGVzWyR7Zn1dO1xcbiAgICAgIGludCBpbnB1dF9waXRjaGVzWyR7Zn1dO1xcbiAgICAgIGA7Zm9yKGxldCB0PWYtMTt0Pj0wO3QtLSlkW3RdPXQ9PT1mLTE/MTpkW3QrMV0qY1t0KzFdLGhbdF09dD09PWYtMT8xOmhbdCsxXSplWzBdLmRpbXNbdCsxXSxnKz1gXFxuICAgICAgICBvdXRwdXRfcGl0Y2hlc1ske3R9XSA9ICR7ZFt0XX07XFxuICAgICAgICBpbnB1dF9waXRjaGVzWyR7dH1dID0gJHtoW3RdfTtcXG4gICAgICAgIGA7Y29uc3QgYj1gXFxuICAgICAgZmxvYXQgZ2V0SW5wdXRGbG9hdChpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW5kZXgsICR7c30sICR7dX0pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oWCwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGAsbT1cIm5lYXJlc3RcIj09PW4ubW9kZT9gXFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2Z9XSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtsfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBkLCBtO1xcbiAgICAgIGZvciAoaW50IGRpbSA9IDA7IGRpbSA8ICR7Zn07ICsrZGltKSB7XFxuICAgICAgICBkID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbZGltXTtcXG4gICAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBkICogb3V0cHV0X3BpdGNoZXNbZGltXTtcXG4gICAgICAgIG91dHB1dF9pbmRleCA9IG07XFxuXFxuICAgICAgICBpZiAoc2NhbGVzW2RpbV0gIT0gMSAmJiBkID4gMCkge1xcbiAgICAgICAgICBpbnQgZDIgPSBkIC8gc2NhbGVzW2RpbV07XFxuICAgICAgICAgIG0gPSBkIC0gZDIgKiBzY2FsZXNbZGltXTtcXG4gICAgICAgICAgZCA9IGQyO1xcbiAgICAgICAgfVxcbiAgICAgICAgaW5wdXRfaW5kZXggKz0gaW5wdXRfcGl0Y2hlc1tkaW1dICogZDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xcbiAgICB9YDo0PT09Zj9gXFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1s0XSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtsfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBtO1xcbiAgICAgIGludCBpbmRleF9vZl9kaW0wLCBpbmRleF9vZl9kaW0xLCBpbmRleF9vZl9kaW0yLCBpbmRleF9vZl9kaW0zO1xcbiAgICAgIGluZGV4X29mX2RpbTAgPSBvdXRwdXRfaW5kZXggLyBvdXRwdXRfcGl0Y2hlc1swXTtcXG4gICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2RpbTEgPSBtIC8gb3V0cHV0X3BpdGNoZXNbMV07XFxuICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0xICogb3V0cHV0X3BpdGNoZXNbMV07XFxuICAgICAgaW5kZXhfb2ZfZGltMiA9IG0gLyBvdXRwdXRfcGl0Y2hlc1syXTtcXG4gICAgICBtID0gbSAtIGluZGV4X29mX2RpbTIgKiBvdXRwdXRfcGl0Y2hlc1syXTtcXG4gICAgICBpbmRleF9vZl9kaW0zID0gbTtcXG5cXG4gICAgICBpbnQgaW5kZXhfb2ZfaW5wdXRfZGltMiwgaW5kZXhfb2ZfaW5wdXRfZGltMywgeF9vZmZzZXQsIHlfb2Zmc2V0O1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTIgPSBpbmRleF9vZl9kaW0yIC8gc2NhbGVzWzJdO1xcbiAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMiAtIGluZGV4X29mX2lucHV0X2RpbTIgKiBzY2FsZXNbMl07XFxuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMyA9IGluZGV4X29mX2RpbTMgLyBzY2FsZXNbM107XFxuICAgICAgeF9vZmZzZXQgPSBpbmRleF9vZl9kaW0zIC0gaW5kZXhfb2ZfaW5wdXRfZGltMyAqIHNjYWxlc1szXTtcXG5cXG4gICAgICBpbnB1dF9pbmRleCA9IGluZGV4X29mX2RpbTAgKiBpbnB1dF9waXRjaGVzWzBdICtcXG4gICAgICAgICAgICBpbmRleF9vZl9kaW0xICogaW5wdXRfcGl0Y2hlc1sxXSArXFxuICAgICAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMiAqIGlucHV0X3BpdGNoZXNbMl0gK1xcbiAgICAgICAgICAgIGluZGV4X29mX2lucHV0X2RpbTM7XFxuXFxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcXG5cXG4gICAgICBib29sIGVuZF9vZl9kaW0yID0gZmFsc2U7XFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTIgPT0gKCR7ZVswXS5kaW1zWzJdfSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDJcXG4gICAgICAgIHgwMSA9IHgwMDtcXG4gICAgICAgIGVuZF9vZl9kaW0yID0gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMl0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMyA9PSAoaW5wdXRfcGl0Y2hlc1syXSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDNcXG4gICAgICAgIHgxMCA9IHgwMDtcXG4gICAgICAgIHgxMSA9IHgwMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB4MTAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgMSk7XFxuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMiA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdICsgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xcbiAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1szXSk7XFxuICAgIH1gOmBcXG4gICAgJHtifVxcbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzJdKSB7XFxuICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcXG4gICAgICBpbnQgb3V0cHV0X2luZGV4ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2x9LCAke3B9KTtcXG5cXG4gICAgICAke2d9XFxuXFxuICAgICAgaW50IG07XFxuICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTE7XFxuICAgICAgaW5kZXhfb2ZfZGltMCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBpbmRleF9vZl9kaW0wICogb3V0cHV0X3BpdGNoZXNbMF07XFxuICAgICAgaW5kZXhfb2ZfZGltMSA9IG07XFxuXFxuICAgICAgaW50IGluZGV4X29mX2lucHV0X2RpbTAsIGluZGV4X29mX2lucHV0X2RpbTEsIHhfb2Zmc2V0LCB5X29mZnNldDtcXG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0wID0gaW5kZXhfb2ZfZGltMCAvIHNjYWxlc1swXTtcXG4gICAgICB5X29mZnNldCA9IGluZGV4X29mX2RpbTAgLSBpbmRleF9vZl9pbnB1dF9kaW0wICogc2NhbGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTEgPSBpbmRleF9vZl9kaW0xIC8gc2NhbGVzWzFdO1xcbiAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMSAtIGluZGV4X29mX2lucHV0X2RpbTEgKiBzY2FsZXNbMV07XFxuXFxuICAgICAgaW5wdXRfaW5kZXggPSBpbmRleF9vZl9pbnB1dF9kaW0wICogaW5wdXRfcGl0Y2hlc1swXSArIGluZGV4X29mX2lucHV0X2RpbTE7XFxuXFxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcXG5cXG4gICAgICBib29sIGVuZF9vZl9kaW0wID0gZmFsc2U7XFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTAgPT0gKCR7ZVswXS5kaW1zWzBdfSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDBcXG4gICAgICAgIHgwMSA9IHgwMDtcXG4gICAgICAgIGVuZF9vZl9kaW0wID0gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMF0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMSA9PSAoaW5wdXRfcGl0Y2hlc1swXSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDFcXG4gICAgICAgIHgxMCA9IHgwMDtcXG4gICAgICAgIHgxMSA9IHgwMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB4MTAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgMSk7XFxuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMCA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdICsgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xcbiAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1sxXSk7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczpjLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTptLHZhcmlhYmxlczpbe25hbWU6XCJzY2FsZXNcIix0eXBlOlwiaW50XCIsYXJyYXlMZW5ndGg6bi5zY2FsZXMubGVuZ3RoLGRhdGE6bi5zY2FsZXMubWFwKCh0PT5NYXRoLmNlaWwodCkpKX1dfSl9O2UudmFsaWRhdGVJbnB1dHM9KHQsZSk9PntpZighdHx8ZS5vcHNldDw5JiYxIT09dC5sZW5ndGh8fGUub3BzZXQ+PTkmJmUub3BzZXQ8MTEmJjIhPT10Lmxlbmd0aHx8ZS5vcHNldD49MTEmJnQubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dHMuXCIpO2lmKGUuc2NhbGVzLmxlbmd0aD4wJiZ0WzBdLmRpbXMubGVuZ3RoIT09ZS5zY2FsZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKFwic3RyaW5nXCI9PT10WzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxlLnNjYWxlc1ZhbGlkYXRpb249KHQsZSxuKT0+e2lmKG4pe2Zvcihjb25zdCBlIG9mIHQpaWYoZTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAuXCIpfWVsc2UgZm9yKGNvbnN0IGUgb2YgdClpZihlPDEpdGhyb3cgbmV3IEVycm9yKFwiU2NhbGUgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLlwiKTtpZighKFwibGluZWFyXCIhPT1lJiZcImN1YmljXCIhPT1lfHwyPT09dC5sZW5ndGh8fDQ9PT10Lmxlbmd0aCYmMT09PXRbMF0mJjE9PT10WzFdKSl0aHJvdyBuZXcgRXJyb3IoYCdMaW5lYXInIG1vZGUgYW5kICdDdWJpYycgbW9kZSBvbmx5IHN1cHBvcnQgMi1EIGlucHV0cyAoJ0JpbGluZWFyJywgJ0JpY3ViaWMnKSAgICAgICAgIG9yIDQtRCBpbnB1dHMgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBvdXRlcm1vc3QgMiBzY2FsZSB2YWx1ZXMgYmVpbmcgMSAgICAgICAgIGluIHRoZSAke24/XCJSZXNpemVcIjpcIlVwc2FtcGxlXCJ9IG9wZWFydG9yLmApfX0sMTk1ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5Qcm9ncmFtTWFuYWdlcj12b2lkIDA7Y29uc3Qgcj1uKDE2NzApLGk9big2MjMxKSxvPW4oODg3OSksYT1uKDUwNjApO2UuUHJvZ3JhbU1hbmFnZXI9Y2xhc3N7Y29uc3RydWN0b3IodCxlLG4pe3RoaXMucHJvZmlsZXI9dCx0aGlzLmdsQ29udGV4dD1lLHRoaXMudGV4dHVyZUxheW91dFN0cmF0ZWd5PW4sdGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxlKXt0aGlzLnJlcG8uc2V0KHQsZSl9cnVuKHQsZSxuKXt2YXIgcjt0aGlzLnByb2ZpbGVyLmV2ZW50KFwib3BcIixgUHJvZ3JhbU1hbmFnZXIucnVuICR7bnVsbCE9PShyPXQucHJvZ3JhbUluZm8ubmFtZSkmJnZvaWQgMCE9PXI/cjpcInVua25vd24ga2VybmVsXCJ9YCwoKCk9Pnt2YXIgcjtjb25zdCBvPXRoaXMuZ2xDb250ZXh0LmdsLGE9dC5wcm9ncmFtO28udXNlUHJvZ3JhbShhKTt0cnl7dGhpcy5iaW5kT3V0cHV0KG4pLHRoaXMuYXR0cmlidXRlc0JvdW5kfHx0aGlzLmJpbmRBdHRyaWJ1dGVzKHQuYXR0cmliTG9jYXRpb25zKSx0aGlzLmJpbmRVbmlmb3Jtcyh0LnVuaWZvcm1Mb2NhdGlvbnMsbnVsbCE9PShyPXQucHJvZ3JhbUluZm8udmFyaWFibGVzKSYmdm9pZCAwIT09cj9yOltdLGUpfWNhdGNoKGUpe3Rocm93IGkuTG9nZ2VyLmVycm9yKFwiUHJvZ3JhbU1hbmFnZXJcIix0LnByb2dyYW1JbmZvLnNoYWRlclNvdXJjZSksZX10aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiR2xDb250ZXh0LmRyYXcoKVwiLCgoKT0+e3RoaXMuZ2xDb250ZXh0LmRyYXcoKX0pKX0pLHRoaXMuZ2xDb250ZXh0KX1kaXNwb3NlKCl7dGhpcy52ZXJ0ZXhTaGFkZXImJnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlciksdGhpcy5yZXBvLmZvckVhY2goKHQ9PnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVByb2dyYW0odC5wcm9ncmFtKSkpfWJ1aWxkKHQsZSxuKXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlByb2dyYW1NYW5hZ2VyLmJ1aWxkXCIsKCgpPT57Y29uc3Qgcj1uZXcgby5HbHNsUHJlcHJvY2Vzc29yKHRoaXMuZ2xDb250ZXh0LHQsZSxuKSxpPXIucHJlcHJvY2VzcygpLGE9dGhpcy5jb21waWxlKGkpO3JldHVybntwcm9ncmFtSW5mbzp0LHByb2dyYW06YSx1bmlmb3JtTG9jYXRpb25zOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhhLHIuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLHIuY29udGV4dC5wcm9ncmFtSW5mby52YXJpYWJsZXMpLGF0dHJpYkxvY2F0aW9uczp0aGlzLmdldEF0dHJpYkxvY2F0aW9ucyhhKX19KSl9Y29tcGlsZSh0KXtpZighdGhpcy52ZXJ0ZXhTaGFkZXIpe2kuTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixcIkNvbXBpbGluZyBhbmQgY2FjaGluZyBWZXJ0ZXggc2hhZGVyIGZvciB0aGUgZmlyc3QgdGltZVwiKTtjb25zdCB0PSgwLGEuZ2V0VmVydGV4U2hhZGVyU291cmNlKSh0aGlzLmdsQ29udGV4dC52ZXJzaW9uKTt0aGlzLnZlcnRleFNoYWRlcj10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHQsdGhpcy5nbENvbnRleHQuZ2wuVkVSVEVYX1NIQURFUil9ci5lbnYuZGVidWcmJmkuTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixgRnJhZ1NoYWRlcjpcXG4ke3R9XFxuYCk7Y29uc3QgZT10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHQsdGhpcy5nbENvbnRleHQuZ2wuRlJBR01FTlRfU0hBREVSKSxuPXRoaXMuZ2xDb250ZXh0LmNyZWF0ZVByb2dyYW0odGhpcy52ZXJ0ZXhTaGFkZXIsZSk7cmV0dXJuIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcihlKSxufWJpbmRPdXRwdXQodCl7Y29uc3QgZT10LndpZHRoLG49dC5oZWlnaHQ7aS5Mb2dnZXIudmVyYm9zZShcIlByb3JncmFtTWFuYWdlclwiLGBCaW5kaW5nIG91dHB1dCB0ZXh0dXJlIHRvIEZyYW1lYnVmZmVyOiB3L2g9JHtlfS8ke259LCBzaGFwZT0ke3Quc2hhcGV9LCB0eXBlPSR7dC50ZW5zb3IudHlwZX1gKSx0aGlzLmdsQ29udGV4dC5hdHRhY2hGcmFtZWJ1ZmZlcih0LnRleHR1cmUsZSxuKX1iaW5kQXR0cmlidXRlcyh0KXtjb25zdCBlPXQucG9zaXRpb24sbj10LnRleHR1cmVDb29yZDt0aGlzLmdsQ29udGV4dC5zZXRWZXJ0ZXhBdHRyaWJ1dGVzKGUsbiksdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITB9YmluZFVuaWZvcm1zKHQsZSxuKXt2YXIgcjtjb25zdCBpPXRoaXMuZ2xDb250ZXh0LmdsO2xldCBvPTA7Zm9yKGNvbnN0e25hbWU6YSx0eXBlOnMsbG9jYXRpb246dSxhcnJheUxlbmd0aDpjfW9mIHQpe2NvbnN0IHQ9bnVsbD09PShyPWUuZmluZCgodD0+dC5uYW1lPT09YSkpKXx8dm9pZCAwPT09cj92b2lkIDA6ci5kYXRhO2lmKFwic2FtcGxlcjJEXCIhPT1zJiYhdCl0aHJvdyBuZXcgRXJyb3IoYHZhcmlhYmxlICcke2F9JyBkb2VzIG5vdCBoYXZlIGRhdGEgZGVmaW5lZCBpbiBwcm9ncmFtIGluZm9gKTtzd2l0Y2gocyl7Y2FzZVwic2FtcGxlcjJEXCI6dGhpcy5iaW5kVGV4dHVyZShuW29dLHUsbyksbysrO2JyZWFrO2Nhc2VcImZsb2F0XCI6Yz9pLnVuaWZvcm0xZnYodSx0KTppLnVuaWZvcm0xZih1LHQpO2JyZWFrO2Nhc2VcImludFwiOmM/aS51bmlmb3JtMWl2KHUsdCk6aS51bmlmb3JtMWkodSx0KTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5pZm9ybSBub3QgaW1wbGVtZW50ZWQ6ICR7c31gKX19fWJpbmRUZXh0dXJlKHQsZSxuKXt0aGlzLmdsQ29udGV4dC5iaW5kVGV4dHVyZVRvVW5pZm9ybSh0LnRleHR1cmUsbixlKX1nZXRBdHRyaWJMb2NhdGlvbnModCl7cmV0dXJue3Bvc2l0aW9uOnRoaXMuZ2V0QXR0cmliTG9jYXRpb24odCxcInBvc2l0aW9uXCIpLHRleHR1cmVDb29yZDp0aGlzLmdldEF0dHJpYkxvY2F0aW9uKHQsXCJ0ZXh0dXJlQ29vcmRcIil9fWdldFVuaWZvcm1Mb2NhdGlvbnModCxlLG4pe2NvbnN0IHI9W107aWYoZSlmb3IoY29uc3QgbiBvZiBlKXIucHVzaCh7bmFtZTpuLHR5cGU6XCJzYW1wbGVyMkRcIixsb2NhdGlvbjp0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbih0LG4pfSk7aWYobilmb3IoY29uc3QgZSBvZiBuKXIucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse2xvY2F0aW9uOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHQsZS5uYW1lKX0pKTtyZXR1cm4gcn1nZXRVbmlmb3JtTG9jYXRpb24odCxlKXtjb25zdCBuPXRoaXMuZ2xDb250ZXh0LmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0LGUpO2lmKG51bGw9PT1uKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSAke2V9IG5vdCBmb3VuZC5gKTtyZXR1cm4gbn1nZXRBdHRyaWJMb2NhdGlvbih0LGUpe3JldHVybiB0aGlzLmdsQ29udGV4dC5nbC5nZXRBdHRyaWJMb2NhdGlvbih0LGUpfX19LDY0MTY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuV2ViR0xTZXNzaW9uSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDYyMzEpLGk9bigxMDQ3KSxvPW4oODMxNiksYT1uKDE2NDApLHM9bigxOTU4KSx1PW4oNzg1OSksYz1uKDU3MDIpO2UuV2ViR0xTZXNzaW9uSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuYmFja2VuZD10LHRoaXMuY29udGV4dD1lLHRoaXMubGF5b3V0U3RyYXRlZ3k9bmV3IHUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5KHQuZ2xDb250ZXh0Lm1heFRleHR1cmVTaXplKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBzLlByb2dyYW1NYW5hZ2VyKHRoaXMuY29udGV4dC5wcm9maWxlcix0LmdsQ29udGV4dCx0aGlzLmxheW91dFN0cmF0ZWd5KSx0aGlzLnRleHR1cmVNYW5hZ2VyPW5ldyBjLlRleHR1cmVNYW5hZ2VyKHQuZ2xDb250ZXh0LHRoaXMubGF5b3V0U3RyYXRlZ3ksdGhpcy5jb250ZXh0LnByb2ZpbGVyLHtyZXVzZVRleHR1cmVzOlwiZnVsbFwiPT09dC50ZXh0dXJlQ2FjaGVNb2RlfSksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnBhY2s9dC5wYWNrLHRoaXMucGFjazJ1bnBhY2tNYXA9bmV3IE1hcCx0aGlzLnVucGFjazJwYWNrTWFwPW5ldyBNYXB9Y3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpe3JldHVybiBuZXcgby5XZWJHTEluZmVyZW5jZUhhbmRsZXIodGhpcyl9b25HcmFwaEluaXRpYWxpemVkKHQpe2NvbnN0IGU9dC5nZXRWYWx1ZXMoKS5maWx0ZXIoKHQ9Pi0xPT09dC5mcm9tJiZ0LnRlbnNvcikpLm1hcCgodD0+dC50ZW5zb3IuZGF0YUlkKSk7dGhpcy5pbml0aWFsaXplcnM9bmV3IFNldChlKX1pc0luaXRpYWxpemVyKHQpe3JldHVybiEhdGhpcy5pbml0aWFsaXplcnMmJnRoaXMuaW5pdGlhbGl6ZXJzLmhhcyh0KX1hZGRJbml0aWFsaXplcih0KXt0aGlzLmluaXRpYWxpemVycy5hZGQodCl9Z2V0VGV4dHVyZURhdGEodCxlKXtyZXR1cm4gZT90aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHQpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0KX1zZXRUZXh0dXJlRGF0YSh0LGUsbj0hMSl7ci5Mb2dnZXIudmVyYm9zZShcIldlYkdMU2Vzc2lvbkhhbmRsZXJcIixcIlN0b3JpbmcgVGV4dHVyZSBkYXRhIGluIGNhY2hlXCIpLG4/dGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0LGUpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0LGUpfWRpc3Bvc2UoKXt0aGlzLnByb2dyYW1NYW5hZ2VyLmRpc3Bvc2UoKSx0aGlzLnRleHR1cmVNYW5hZ2VyLmNsZWFyQWN0aXZlVGV4dHVyZXMoKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCgodD0+dGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0LCEwKSkpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKHQ9PnRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodCwhMCkpKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlc29sdmUodCxlLG4pe2NvbnN0IHI9KDAsaS5yZXNvbHZlT3BlcmF0b3IpKHQsZSxhLldFQkdMX09QX1JFU09MVkVfUlVMRVMpO3JldHVybntpbXBsOnIub3BJbXBsLGNvbnRleHQ6ci5vcEluaXQ/ci5vcEluaXQodCxuKTp0fX19fSw3NzY5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlVpbnQ4RGF0YUVuY29kZXI9ZS5SR0JBRmxvYXREYXRhRW5jb2Rlcj1lLlJlZEZsb2F0MzJEYXRhRW5jb2Rlcj12b2lkIDA7Y29uc3Qgcj1uKDYyMzEpO2UuUmVkRmxvYXQzMkRhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKHQsZT0xKXtpZigxPT09ZSl0aGlzLmludGVybmFsRm9ybWF0PXQuUjMyRix0aGlzLmZvcm1hdD10LlJFRCx0aGlzLnRleHR1cmVUeXBlPXQuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT1lO2Vsc2V7aWYoNCE9PWUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtlfWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9dC5SR0JBMzJGLHRoaXMuZm9ybWF0PXQuUkdCQSx0aGlzLnRleHR1cmVUeXBlPXQuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT1lfX1lbmNvZGUodCxlKXtsZXQgbixpO3JldHVybiB0LmNvbnN0cnVjdG9yIT09RmxvYXQzMkFycmF5JiYoci5Mb2dnZXIud2FybmluZyhcIkVuY29kZXJcIixcImRhdGEgd2FzIG5vdCBvZiB0eXBlIEZsb2F0MzI7IGNyZWF0aW5nIG5ldyBGbG9hdDMyQXJyYXlcIiksaT1uZXcgRmxvYXQzMkFycmF5KHQpKSxlKnRoaXMuY2hhbm5lbFNpemU+dC5sZW5ndGg/KHIuTG9nZ2VyLndhcm5pbmcoXCJFbmNvZGVyXCIsXCJTb3VyY2UgZGF0YSB0b28gc21hbGwuIEFsbG9jYXRpbmcgbGFyZ2VyIGFycmF5XCIpLGk9dCxuPXRoaXMuYWxsb2NhdGUoZSp0aGlzLmNoYW5uZWxTaXplKSxpLmZvckVhY2goKCh0LGUpPT5uW2VdPXQpKSk6KGk9dCxuPWkpLG59YWxsb2NhdGUodCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoNCp0KX1kZWNvZGUodCxlKXtyZXR1cm4gMT09PXRoaXMuY2hhbm5lbFNpemU/dC5maWx0ZXIoKCh0LGUpPT5lJTQ9PTApKS5zdWJhcnJheSgwLGUpOnQuc3ViYXJyYXkoMCxlKX19LGUuUkdCQUZsb2F0RGF0YUVuY29kZXI9Y2xhc3N7Y29uc3RydWN0b3IodCxlPTEsbil7aWYoMSE9PWUmJjQhPT1lKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7ZX1gKTt0aGlzLmludGVybmFsRm9ybWF0PXQuUkdCQSx0aGlzLmZvcm1hdD10LlJHQkEsdGhpcy5jaGFubmVsU2l6ZT1lLHRoaXMudGV4dHVyZVR5cGU9bnx8dC5GTE9BVH1lbmNvZGUodCxlKXtsZXQgbj10O3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZSYmKHIuTG9nZ2VyLnZlcmJvc2UoXCJFbmNvZGVyXCIsXCJFeHBsb2RpbmcgaW50byBhIGxhcmdlciBhcnJheVwiKSxuPXRoaXMuYWxsb2NhdGUoZSksdC5mb3JFYWNoKCgodCxlKT0+bls0KmVdPXQpKSksbn1hbGxvY2F0ZSh0KXtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0KnQpfWRlY29kZSh0LGUpe3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZT90LmZpbHRlcigoKHQsZSk9PmUlND09MCkpLnN1YmFycmF5KDAsZSk6dC5zdWJhcnJheSgwLGUpfX0sZS5VaW50OERhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKHQsZT0xKXtpZih0aGlzLmNoYW5uZWxTaXplPTQsMT09PWUpdGhpcy5pbnRlcm5hbEZvcm1hdD10LkFMUEhBLHRoaXMuZm9ybWF0PXQuQUxQSEEsdGhpcy50ZXh0dXJlVHlwZT10LlVOU0lHTkVEX0JZVEUsdGhpcy5jaGFubmVsU2l6ZT1lO2Vsc2V7aWYoNCE9PWUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtlfWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9dC5SR0JBLHRoaXMuZm9ybWF0PXQuUkdCQSx0aGlzLnRleHR1cmVUeXBlPXQuVU5TSUdORURfQllURSx0aGlzLmNoYW5uZWxTaXplPWV9fWVuY29kZSh0LGUpe3JldHVybiBuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKX1hbGxvY2F0ZSh0KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCp0aGlzLmNoYW5uZWxTaXplKX1kZWNvZGUodCxlKXtpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSlyZXR1cm4gdC5zdWJhcnJheSgwLGUpO3Rocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcnJheSB0eXBlOiAke3QuY29uc3RydWN0b3J9YCl9fX0sNzg1OToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5nZXRCYXRjaERpbT1lLnNpemVUb1NxdWFyaXNoU2hhcGU9ZS5nZXRSb3dzQ29scz1lLnNpemVGcm9tU2hhcGU9ZS5pc0ludD1lLnBhcnNlQXhpc1BhcmFtPWUuc3F1ZWV6ZVNoYXBlPWUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5PWUuQWx3YXlzS2VlcE9yaWdpbmFsU2l6ZVN0cmF0ZWd5PXZvaWQgMDtjb25zdCByPW4oNjIzMSksaT1uKDI1MTcpO2Z1bmN0aW9uIG8odCxlKXtjb25zdCBuPVtdLHI9W10saT1udWxsIT1lJiZBcnJheS5pc0FycmF5KGUpJiYwPT09ZS5sZW5ndGgsbz1udWxsPT1lfHxpP251bGw6YShlLHQpLnNvcnQoKTtsZXQgcz0wO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7KytlKXtpZihudWxsIT1vKXtpZihvW3NdPT09ZSYmMSE9PXRbZV0pdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzcXVlZXplIGF4aXMgJHtlfSBzaW5jZSBpdHMgZGltICcke3RbZV19JyBpcyBub3QgMWApOyhudWxsPT1vW3NdfHxvW3NdPmUpJiYxPT09dFtlXSYmKG4ucHVzaCh0W2VdKSxyLnB1c2goZSkpLG9bc108PWUmJnMrK30xIT09dFtlXSYmKG4ucHVzaCh0W2VdKSxyLnB1c2goZSkpfXJldHVybntuZXdTaGFwZTpuLGtlcHREaW1zOnJ9fWZ1bmN0aW9uIGEodCxlKXtjb25zdCBuPWUubGVuZ3RoO3JldHVybiB0PW51bGw9PXQ/ZS5tYXAoKCh0LGUpPT5lKSk6W10uY29uY2F0KHQpLCgwLGkuYXNzZXJ0KSh0LmV2ZXJ5KCh0PT50Pj0tbiYmdDxuKSksKCgpPT5gQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW4gcmFuZ2UgWy0ke259LCAke259KSBidXQgZ290IGF4aXMgJHt0fWApKSwoMCxpLmFzc2VydCkodC5ldmVyeShzKSwoKCk9PmBBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgZ290IGF4aXMgJHt0fWApKSx0Lm1hcCgodD0+dDwwP24rdDp0KSl9ZnVuY3Rpb24gcyh0KXtyZXR1cm4gdCUxPT0wfWZ1bmN0aW9uIHUodCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiAxO2xldCBlPXRbMF07Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspZSo9dFtuXTtyZXR1cm4gZX1mdW5jdGlvbiBjKHQpe2NvbnN0IGU9TWF0aC5jZWlsKE1hdGguc3FydCh0KSk7cmV0dXJuW2UsTWF0aC5jZWlsKHQvZSldfWUuQWx3YXlzS2VlcE9yaWdpbmFsU2l6ZVN0cmF0ZWd5PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubWF4VGV4dHVyZVNpemU9dH1jb21wdXRlVGV4dHVyZVdIKHQsZSl7aWYoMD09PXQubGVuZ3RoKXJldHVyblsxLDFdO2NvbnN0IG49dGhpcy5tYXhUZXh0dXJlU2l6ZTtpZihlJiZ2b2lkIDAhPT1lLmJyZWFrQXhpcyl7Y29uc3QgaT1lLmJyZWFrQXhpcz49dC5sZW5ndGg/MTp0LnNsaWNlKGUuYnJlYWtBeGlzKS5yZWR1Y2UoKCh0LGUpPT50KmUpKSxvPWUuYnJlYWtBeGlzPD0wPzE6dC5zbGljZSgwLGUuYnJlYWtBeGlzKS5yZWR1Y2UoKCh0LGUpPT50KmUpKTtpZighKGk+bnx8bz5uKSlyZXR1cm5baSxvXTtyLkxvZ2dlci52ZXJib3NlKFwiVGV4dHVyZUxheW91dFwiLGBHaXZlbiB3aWR0aC9oZWlnaHQgcHJlZmVyZW5jZXMgd2VyZSB1bmF0dGFpbmFibGU6IHNoYXBlOiR7dH0sIGJyZWFrQXhpczoke2UuYnJlYWtBeGlzfWApfWNvbnN0IGk9dC5yZWR1Y2UoKCh0LGUpPT50KmUpKTtsZXQgbz1NYXRoLmZsb29yKE1hdGguc3FydChpKSk7Zm9yKDtvPG4mJm88aSYmaSVvIT0wO28rKyk7aWYobz49bnx8aSVvIT0wKXRocm93IG5ldyBFcnJvcihgVGhlIGdpdmVuIGRpbWVuc2lvbnMgYXJlIG91dHNpZGUgdGhpcyBHUFUncyBib3VuZGFyaWVzOiAke3R9YCk7cmV0dXJuW28saS9vXX19LGUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5PWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubWF4VGV4dHVyZVNpemU9dH1jb21wdXRlVGV4dHVyZVdIKHQsZSl7Y29uc3Qgbj10aGlzLmNvbXB1dGVUZXh0dXJlKHQsZSk7cmV0dXJuIGUmJmUuaXNQYWNrZWQmJihuWzBdLz0yLG5bMV0vPTIpLGUmJmUucmV2ZXJzZVdIP1tuWzFdLG5bMF1dOm59Y29tcHV0ZVRleHR1cmUodCxlKXtjb25zdCBuPWUmJmUuaXNQYWNrZWQ7aWYoMD09PXQubGVuZ3RoKXJldHVybiBuP1syLDJdOlsxLDFdO2xldCBpPXRoaXMubWF4VGV4dHVyZVNpemU7aWYoZSYmdm9pZCAwIT09ZS5icmVha0F4aXMpe2NvbnN0IG49ZS5icmVha0F4aXM+PXQubGVuZ3RoPzE6dC5zbGljZShlLmJyZWFrQXhpcykucmVkdWNlKCgodCxlKT0+dCplKSksbz1lLmJyZWFrQXhpczw9MD8xOnQuc2xpY2UoMCxlLmJyZWFrQXhpcykucmVkdWNlKCgodCxlKT0+dCplKSk7aWYoIShuPml8fG8+aSkpcmV0dXJuW24sb107ci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVMYXlvdXRcIixgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke3R9LCBicmVha0F4aXM6JHtlLmJyZWFrQXhpc31gKX1sZXQgYT10LnNsaWNlKDApO2lmKG4mJihpKj0yLGE9YS5tYXAoKCh0LGUpPT5lPj1hLmxlbmd0aC0yP2FbZV0lMj09MD9hW2VdOmFbZV0rMTphW2VdKSksMT09PWEubGVuZ3RoJiYoYT1bMixhWzBdXSkpLDIhPT1hLmxlbmd0aCl7Y29uc3QgdD1vKGEpO2E9dC5uZXdTaGFwZX1jb25zdCBzPXUoYSk7cmV0dXJuIGEubGVuZ3RoPD0xJiZzPD1pP1sxLHNdOjI9PT1hLmxlbmd0aCYmYVswXTw9aSYmYVsxXTw9aT9hOjM9PT1hLmxlbmd0aCYmYVswXSphWzFdPD1pJiZhWzJdPD1pP1thWzBdKmFbMV0sYVsyXV06Mz09PWEubGVuZ3RoJiZhWzBdPD1pJiZhWzFdKmFbMl08PWk/W2FbMF0sYVsxXSphWzJdXTo0PT09YS5sZW5ndGgmJmFbMF0qYVsxXSphWzJdPD1pJiZhWzNdPD1pP1thWzBdKmFbMV0qYVsyXSxhWzNdXTo0PT09YS5sZW5ndGgmJmFbMF08PWkmJmFbMV0qYVsyXSphWzNdPD1pP1thWzBdLGFbMV0qYVsyXSphWzNdXTpuP2Mocy80KS5tYXAoKHQ9PjIqdCkpOmMocyl9fSxlLnNxdWVlemVTaGFwZT1vLGUucGFyc2VBeGlzUGFyYW09YSxlLmlzSW50PXMsZS5zaXplRnJvbVNoYXBlPXUsZS5nZXRSb3dzQ29scz1mdW5jdGlvbih0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuXCIpO3JldHVyblt0Lmxlbmd0aD4xP3RbdC5sZW5ndGgtMl06MSx0W3QubGVuZ3RoLTFdXX0sZS5zaXplVG9TcXVhcmlzaFNoYXBlPWMsZS5nZXRCYXRjaERpbT1mdW5jdGlvbih0LGU9Mil7cmV0dXJuIHUodC5zbGljZSgwLHQubGVuZ3RoLWUpKX19LDQwNTc6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodD1lLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tVGV4dHVyZVR5cGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KSxpPW4oMjAzOSk7ZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlPSh0LG4scik9Pntjb25zdCBvPXI9PT1pLlRleHR1cmVUeXBlLnVucGFja2VkfHxyPT09aS5UZXh0dXJlVHlwZS51bnBhY2tlZFJldmVyc2VkPzE6NCxhPXI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZCxzPXI9PT1pLlRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWR8fHI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZCx1PXI9PT1pLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24/bi5sZW5ndGgtMTp2b2lkIDAsYz1yPT09aS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uP24ubWFwKCgodCxlKT0+ZT09PW4ubGVuZ3RoLTE/NCp0OnQpKTp2b2lkIDA7cmV0dXJuKDAsZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKSh0LG4sbyxjLHtpc1BhY2tlZDphLHJldmVyc2VXSDpzLGJyZWFrQXhpczp1fSl9LGUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0PSh0LG4scik9Pntjb25zdCBpPSgwLGUuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodCxuLHIpO3JldHVybltpLndpZHRoLGkuaGVpZ2h0XX0sZS5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlPSh0LGUsbj0xLGksbyk9Pntjb25zdCBhPSEoIW98fCFvLmlzUGFja2VkKSxbcyx1XT10LmNvbXB1dGVUZXh0dXJlV0goYSYmaXx8ZSxvKSxjPWUubGVuZ3RoO2xldCBsPWUuc2xpY2UoMCk7aWYoMD09PWMmJihsPVsxXSksMT09PW4paT1lO2Vsc2UgaWYoYSl7aWYoNCE9PW4pdGhyb3cgbmV3IEVycm9yKFwiYSBwYWNrZWQgdGV4dHVyZSBtdXN0IGJlIDQtY2hhbm5lbFwiKTtpPWUsYz4wJiYobFtjLTFdPU1hdGguY2VpbChsW2MtMV0vMikpLGM+MSYmKGxbYy0yXT1NYXRoLmNlaWwobFtjLTJdLzIpKX1lbHNlIGlmKCFpKXRocm93IG5ldyBFcnJvcihcIlVucGFja2VkIHNoYXBlIGlzIG5lZWRlZCB3aGVuIHVzaW5nIGNoYW5uZWxzID4gMVwiKTtyZXR1cm57d2lkdGg6cyxoZWlnaHQ6dSxjaGFubmVsczpuLGlzUGFja2VkOmEsc2hhcGU6bCxzdHJpZGVzOnIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGwpLHVucGFja2VkU2hhcGU6aSxyZXZlcnNlZFdIOm8mJm8ucmV2ZXJzZVdIfX19LDU3MDI6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuVGV4dHVyZU1hbmFnZXI9dm9pZCAwO2NvbnN0IHI9big2MjMxKTtlLlRleHR1cmVNYW5hZ2VyPWNsYXNze2NvbnN0cnVjdG9yKHQsZSxuLHIpe3RoaXMuZ2xDb250ZXh0PXQsdGhpcy5sYXlvdXRTdHJhdGVneT1lLHRoaXMucHJvZmlsZXI9bix0aGlzLmNvbmZpZz1yLHRoaXMucGVuZGluZ1JlYWQ9bmV3IE1hcCxyLnJldXNlVGV4dHVyZXMmJih0aGlzLmluVXNlVGV4dHVyZXM9bmV3IE1hcCx0aGlzLmlkbGVUZXh0dXJlcz1uZXcgTWFwLHRoaXMudGV4dHVyZUxvb2t1cD1uZXcgTWFwKX1jcmVhdGVUZXh0dXJlRnJvbUxheW91dCh0LGUsbixpKXtjb25zdCBvPXRoaXMudG9FbmNvZGVyVHlwZSh0KSxhPXRoaXMuZ2xDb250ZXh0LmdldEVuY29kZXIobyxlLmNoYW5uZWxzfHwxLGkpO2lmKGUuaXNQYWNrZWQmJjE9PT1pKXRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjb25zdCBzPWUud2lkdGgsdT1lLmhlaWdodDtsZXQgYyxsO2lmKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpe2M9YCR7c314JHt1fV8ke2EuZm9ybWF0fV8ke2EuaW50ZXJuYWxGb3JtYXR9XyR7YS50ZXh0dXJlVHlwZX1gLGw9dGhpcy5pblVzZVRleHR1cmVzLmdldChjKSxsfHwobD1bXSx0aGlzLmluVXNlVGV4dHVyZXMuc2V0KGMsbCkpO2NvbnN0IGU9dGhpcy5pZGxlVGV4dHVyZXMuZ2V0KGMpO2lmKGUmJmUubGVuZ3RoPjApe2NvbnN0IHI9ZS5wb3AoKTtyZXR1cm4gbC5wdXNoKHIpLDE9PT1pJiZ0aGlzLmdsQ29udGV4dC51cGRhdGVUZXh0dXJlKHIscyx1LGEsdGhpcy50b1RleHR1cmVEYXRhKHQsbikpLHJ9fXIuTG9nZ2VyLnZlcmJvc2UoXCJUZXh0dXJlTWFuYWdlclwiLGBDcmVhdGluZyBuZXcgdGV4dHVyZSBvZiBzaXplICR7ZS53aWR0aH14JHtlLmhlaWdodH1gKTtjb25zdCBwPXRoaXMuZ2xDb250ZXh0LmFsbG9jYXRlVGV4dHVyZShzLHUsYSx0aGlzLnRvVGV4dHVyZURhdGEodCxuKSk7cmV0dXJuIHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMmJihsLnB1c2gocCksdGhpcy50ZXh0dXJlTG9va3VwLnNldChwLGMpKSxwfXJlYWRUZXh0dXJlKHQsZSxuKXtyZXR1cm4gbnx8KG49MSksdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlXCIsKCgpPT57Y29uc3Qgcj10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpKm4saT10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZSh0LnRleHR1cmUsdC53aWR0aCx0LmhlaWdodCxyLHRoaXMudG9FbmNvZGVyVHlwZShlKSxuKTtyZXR1cm4gdGhpcy50b1RlbnNvckRhdGEoZSxpKX0pKX1hc3luYyByZWFkVGV4dHVyZUFzeW5jKHQsZSxuKXtjb25zdCByPXQudGVuc29yLmRhdGFJZDtpZihufHwobj0xKSx0aGlzLnBlbmRpbmdSZWFkLmhhcyhyKSl7Y29uc3QgdD10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gbmV3IFByb21pc2UoKGU9Pm51bGw9PXQ/dm9pZCAwOnQucHVzaChlKSkpfXJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiVGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmVBc3luY1wiLChhc3luYygpPT57dGhpcy5wZW5kaW5nUmVhZC5zZXQocixbXSk7Y29uc3QgaT10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpKm47YXdhaXQgdGhpcy5nbENvbnRleHQuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCk7Y29uc3Qgbz10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZSh0LnRleHR1cmUsdC53aWR0aCx0LmhlaWdodCxpLHRoaXMudG9FbmNvZGVyVHlwZShlKSxuKSxhPXRoaXMudG9UZW5zb3JEYXRhKGUsbykscz10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gdGhpcy5wZW5kaW5nUmVhZC5kZWxldGUociksbnVsbD09c3x8cy5mb3JFYWNoKCh0PT50KGEpKSksYX0pKX1yZWFkVWludDhUZXh0dXJlQXNGbG9hdCh0KXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0XCIsKCgpPT57Y29uc3QgZT10LnNoYXBlLnJlZHVjZSgoKHQsZSk9PnQqZSkpLG49dGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUodC50ZXh0dXJlLHQud2lkdGgsdC5oZWlnaHQsNCplLFwiYnl0ZVwiLDQpO3JldHVybiBuZXcgRmxvYXQzMkFycmF5KG4uYnVmZmVyLG4uYnl0ZU9mZnNldCxlKX0pKX1yZWxlYXNlVGV4dHVyZSh0LGUpe2xldCBuO2lmKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMmJihuPXRoaXMudGV4dHVyZUxvb2t1cC5nZXQodC50ZXh0dXJlKSxuKSl7ZSYmdGhpcy50ZXh0dXJlTG9va3VwLmRlbGV0ZShuKTtjb25zdCByPXRoaXMuaW5Vc2VUZXh0dXJlcy5nZXQobik7aWYocil7Y29uc3QgZT1yLmluZGV4T2YodC50ZXh0dXJlKTtpZigtMSE9PWUpe3Iuc3BsaWNlKGUsMSk7bGV0IGk9dGhpcy5pZGxlVGV4dHVyZXMuZ2V0KG4pO2l8fChpPVtdLHRoaXMuaWRsZVRleHR1cmVzLnNldChuLGkpKSxpLnB1c2godC50ZXh0dXJlKX19fW4mJiFlfHwoci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVNYW5hZ2VyXCIsYERlbGV0aW5nIHRleHR1cmUgb2Ygc2l6ZSAke3Qud2lkdGh9eCR7dC5oZWlnaHR9YCksdGhpcy5nbENvbnRleHQuZGVsZXRlVGV4dHVyZSh0LnRleHR1cmUpKX10b1RlbnNvckRhdGEodCxlKXtzd2l0Y2godCl7Y2FzZVwiaW50MTZcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEludDE2QXJyYXk/ZTpJbnQxNkFycmF5LmZyb20oZSk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEludDMyQXJyYXk/ZTpJbnQzMkFycmF5LmZyb20oZSk7Y2FzZVwiaW50OFwiOnJldHVybiBlIGluc3RhbmNlb2YgSW50OEFycmF5P2U6SW50OEFycmF5LmZyb20oZSk7Y2FzZVwidWludDE2XCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50MTZBcnJheT9lOlVpbnQxNkFycmF5LmZyb20oZSk7Y2FzZVwidWludDMyXCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50MzJBcnJheT9lOlVpbnQzMkFycmF5LmZyb20oZSk7Y2FzZVwidWludDhcIjpjYXNlXCJib29sXCI6cmV0dXJuIGUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6VWludDhBcnJheS5mcm9tKGUpO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT9lOkZsb2F0MzJBcnJheS5mcm9tKGUpO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheT9lOkZsb2F0NjRBcnJheS5mcm9tKGUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBUZW5zb3JEYXRhIHR5cGUgJHt0fSBpcyBub3Qgc3VwcG9ydGVkYCl9fXRvVGV4dHVyZURhdGEodCxlKXtpZihlKXJldHVybiBlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P2U6bmV3IEZsb2F0MzJBcnJheShlKX10b0VuY29kZXJUeXBlKHQpe3JldHVyblwiZmxvYXRcIn1jbGVhckFjdGl2ZVRleHR1cmVzKCl7dGhpcy5nbENvbnRleHQuY2xlYXJBY3RpdmVUZXh0dXJlcygpfX19LDIwMzk6KHQsZSk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLlRleHR1cmVUeXBlPXZvaWQgMCwobj1lLlRleHR1cmVUeXBlfHwoZS5UZXh0dXJlVHlwZT17fSkpW24udW5wYWNrZWQ9MF09XCJ1bnBhY2tlZFwiLG5bbi51bnBhY2tlZFJldmVyc2VkPTFdPVwidW5wYWNrZWRSZXZlcnNlZFwiLG5bbi5wYWNrZWQ9Ml09XCJwYWNrZWRcIixuW24uZG93bmxvYWRVaW50OEFzRmxvYXQ9M109XCJkb3dubG9hZFVpbnQ4QXNGbG9hdFwiLG5bbi5wYWNrZWRMYXN0RGltZW5zaW9uPTRdPVwicGFja2VkTGFzdERpbWVuc2lvblwifSw5MzkwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmdldEdsQ2hhbm5lbHM9ZS5nZXRDb29yZHNEYXRhVHlwZT1lLmdldFNxdWVlemVkUGFyYW1zPWUuc3F1ZWV6ZUlucHV0U2hhcGU9ZS5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWVBdE91dENvb3Jkcz1lLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZT1lLnJlcGVhdGVkVHJ5PWUuZ2V0UGFja2VkU2hhcGU9dm9pZCAwO2NvbnN0IHI9bigyNTE3KTtlLmdldFBhY2tlZFNoYXBlPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5sZW5ndGg7cmV0dXJuIHQuc2xpY2UoMCxlLTEpLmNvbmNhdCh0W2UtMV0vNCl9LGUucmVwZWF0ZWRUcnk9YXN5bmMgZnVuY3Rpb24odCxlPSh0PT4wKSxuKXtyZXR1cm4gbmV3IFByb21pc2UoKChyLGkpPT57bGV0IG89MDtjb25zdCBhPSgpPT57aWYodCgpKXJldHVybiB2b2lkIHIoKTtvKys7Y29uc3Qgcz1lKG8pO251bGwhPW4mJm8+PW4/aSgpOnNldFRpbWVvdXQoYSxzKX07YSgpfSkpfSxlLmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZT1mdW5jdGlvbih0KXtyZXR1cm4oMCxyLmFzc2VydCkodm9pZCAwIT09dCYmMCE9PXQubGVuZ3RoLCgoKT0+XCJlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZVwiKSksXCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSl9LGUuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHM9ZnVuY3Rpb24odCl7cmV0dXJuKDAsci5hc3NlcnQpKHZvaWQgMCE9PXQmJjAhPT10Lmxlbmd0aCwoKCk9PlwiZW1wdHkgc3RyaW5nIGZvdW5kIGZvciBzYW1wbGVyIG5hbWVcIikpLFwiZ2V0XCIrdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpK1wiQXRPdXRDb29yZHNcIn0sZS5zcXVlZXplSW5wdXRTaGFwZT1mdW5jdGlvbih0LGUpe2xldCBuPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodCkpO3JldHVybiBuPWUsbn0sZS5nZXRTcXVlZXplZFBhcmFtcz1mdW5jdGlvbih0LGUpe3JldHVybiBlLm1hcCgoZT0+dFtlXSkpLmpvaW4oXCIsIFwiKX0sZS5nZXRDb29yZHNEYXRhVHlwZT1mdW5jdGlvbih0KXtpZih0PD0xKXJldHVyblwiaW50XCI7aWYoMj09PXQpcmV0dXJuXCJpdmVjMlwiO2lmKDM9PT10KXJldHVyblwiaXZlYzNcIjtpZig0PT09dClyZXR1cm5cIml2ZWM0XCI7aWYoNT09PXQpcmV0dXJuXCJpdmVjNVwiO2lmKDY9PT10KXJldHVyblwiaXZlYzZcIjt0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7dH0gaXMgbm90IHlldCBzdXBwb3J0ZWRgKX0sZS5nZXRHbENoYW5uZWxzPWZ1bmN0aW9uKHQ9Nil7cmV0dXJuW1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLHQpfX0sNzMwNToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jcmVhdGVOZXdXZWJHTENvbnRleHQ9ZS5jcmVhdGVXZWJHTENvbnRleHQ9dm9pZCAwO2NvbnN0IHI9big2MjMxKSxpPW4oMTcxMyksbz17fTtmdW5jdGlvbiBhKHQpe2NvbnN0IGU9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZG9jdW1lbnQpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBPZmZzY3JlZW5DYW52YXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcImZhaWxlZCB0byBjcmVhdGUgY2FudmFzOiBPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpfWNvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtyZXR1cm4gdC53aWR0aD0xLHQuaGVpZ2h0PTEsdH0oKTtsZXQgbjtjb25zdCBvPXthbHBoYTohMSxkZXB0aDohMSxhbnRpYWxpYXM6ITEsc3RlbmNpbDohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEscHJlbXVsdGlwbGllZEFscGhhOiExLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ITF9O2lmKCghdHx8XCJ3ZWJnbDJcIj09PXQpJiYobj1lLmdldENvbnRleHQoXCJ3ZWJnbDJcIixvKSxuKSl0cnl7cmV0dXJuIG5ldyBpLldlYkdMQ29udGV4dChuLDIpfWNhdGNoKHQpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wyJy4gRXJyb3I6ICR7dH1gKX1pZigoIXR8fFwid2ViZ2xcIj09PXQpJiYobj1lLmdldENvbnRleHQoXCJ3ZWJnbFwiLG8pfHxlLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIixvKSxuKSl0cnl7cmV0dXJuIG5ldyBpLldlYkdMQ29udGV4dChuLDEpfWNhdGNoKHQpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wnIG9yICdleHBlcmltZW50YWwtd2ViZ2wnLiBFcnJvcjogJHt0fWApfXRocm93IG5ldyBFcnJvcihcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWRcIil9ZS5jcmVhdGVXZWJHTENvbnRleHQ9ZnVuY3Rpb24gdChlKXtsZXQgbjtlJiZcIndlYmdsMlwiIT09ZXx8IShcIndlYmdsMlwiaW4gbyk/ZSYmXCJ3ZWJnbFwiIT09ZXx8IShcIndlYmdsXCJpbiBvKXx8KG49by53ZWJnbCk6bj1vLndlYmdsMixuPW58fGEoZSksZT1lfHwxPT09bi52ZXJzaW9uP1wid2ViZ2xcIjpcIndlYmdsMlwiO2NvbnN0IHI9bi5nbDtyZXR1cm4gb1tlXT1uLHIuaXNDb250ZXh0TG9zdCgpPyhkZWxldGUgb1tlXSx0KGUpKTooci5kaXNhYmxlKHIuREVQVEhfVEVTVCksci5kaXNhYmxlKHIuU1RFTkNJTF9URVNUKSxyLmRpc2FibGUoci5CTEVORCksci5kaXNhYmxlKHIuRElUSEVSKSxyLmRpc2FibGUoci5QT0xZR09OX09GRlNFVF9GSUxMKSxyLmRpc2FibGUoci5TQU1QTEVfQ09WRVJBR0UpLHIuZW5hYmxlKHIuU0NJU1NPUl9URVNUKSxyLmVuYWJsZShyLkNVTExfRkFDRSksci5jdWxsRmFjZShyLkJBQ0spLG4pfSxlLmNyZWF0ZU5ld1dlYkdMQ29udGV4dD1hfSwxNzEzOmZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmcihlLHQsbik7cmV0dXJuIGkoZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLldlYkdMQ29udGV4dD1lLmxpbmVhclNlYXJjaExhc3RUcnVlPXZvaWQgMDtjb25zdCBhPW4oMTY3MCkscz1vKG4oNzc2OSkpLHU9big5MzkwKTtmdW5jdGlvbiBjKHQpe2xldCBlPTA7Zm9yKDtlPHQubGVuZ3RoJiZ0W2VdKCk7KytlKTtyZXR1cm4gZS0xfWUubGluZWFyU2VhcmNoTGFzdFRydWU9YyxlLldlYkdMQ29udGV4dD1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuZnJhbWVCdWZmZXJCb3VuZD0hMSx0aGlzLml0ZW1zVG9Qb2xsPVtdLHRoaXMuZ2w9dCx0aGlzLnZlcnNpb249ZSx0aGlzLmdldEV4dGVuc2lvbnMoKSx0aGlzLnZlcnRleGJ1ZmZlcj10aGlzLmNyZWF0ZVZlcnRleGJ1ZmZlcigpLHRoaXMuZnJhbWVidWZmZXI9dGhpcy5jcmVhdGVGcmFtZWJ1ZmZlcigpLHRoaXMucXVlcnlWaXRhbFBhcmFtZXRlcnMoKX1hbGxvY2F0ZVRleHR1cmUodCxlLG4scil7Y29uc3QgaT10aGlzLmdsLG89aS5jcmVhdGVUZXh0dXJlKCk7aS5iaW5kVGV4dHVyZShpLlRFWFRVUkVfMkQsbyksaS50ZXhQYXJhbWV0ZXJpKGkuVEVYVFVSRV8yRCxpLlRFWFRVUkVfTUlOX0ZJTFRFUixpLk5FQVJFU1QpLGkudGV4UGFyYW1ldGVyaShpLlRFWFRVUkVfMkQsaS5URVhUVVJFX01BR19GSUxURVIsaS5ORUFSRVNUKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFXzJELGkuVEVYVFVSRV9XUkFQX1MsaS5DTEFNUF9UT19FREdFKSxpLnRleFBhcmFtZXRlcmkoaS5URVhUVVJFXzJELGkuVEVYVFVSRV9XUkFQX1QsaS5DTEFNUF9UT19FREdFKTtjb25zdCBhPXI/bi5lbmNvZGUocix0KmUpOm51bGw7cmV0dXJuIGkudGV4SW1hZ2UyRChpLlRFWFRVUkVfMkQsMCxuLmludGVybmFsRm9ybWF0LHQsZSwwLG4uZm9ybWF0LG4udGV4dHVyZVR5cGUsYSksdGhpcy5jaGVja0Vycm9yKCksb311cGRhdGVUZXh0dXJlKHQsZSxuLHIsaSl7Y29uc3Qgbz10aGlzLmdsO28uYmluZFRleHR1cmUoby5URVhUVVJFXzJELHQpO2NvbnN0IGE9ci5lbmNvZGUoaSxlKm4pO28udGV4U3ViSW1hZ2UyRChvLlRFWFRVUkVfMkQsMCwwLDAsZSxuLHIuZm9ybWF0LHIudGV4dHVyZVR5cGUsYSksdGhpcy5jaGVja0Vycm9yKCl9YXR0YWNoRnJhbWVidWZmZXIodCxlLG4pe2NvbnN0IHI9dGhpcy5nbDtyLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCx0KSxyLmJpbmRGcmFtZWJ1ZmZlcihyLkZSQU1FQlVGRkVSLHRoaXMuZnJhbWVidWZmZXIpLHIuZnJhbWVidWZmZXJUZXh0dXJlMkQoci5GUkFNRUJVRkZFUixyLkNPTE9SX0FUVEFDSE1FTlQwLHIuVEVYVFVSRV8yRCx0LDApLHRoaXMuY2hlY2tFcnJvcigpLHIudmlld3BvcnQoMCwwLGUsbiksci5zY2lzc29yKDAsMCxlLG4pfXJlYWRUZXh0dXJlKHQsZSxuLHIsaSxvKXtjb25zdCBhPXRoaXMuZ2w7b3x8KG89MSksdGhpcy5mcmFtZUJ1ZmZlckJvdW5kfHx0aGlzLmF0dGFjaEZyYW1lYnVmZmVyKHQsZSxuKTtjb25zdCBzPXRoaXMuZ2V0RW5jb2RlcihpLG8pLHU9cy5hbGxvY2F0ZShlKm4pO3JldHVybiBhLmJpbmRUZXh0dXJlKGEuVEVYVFVSRV8yRCx0KSxhLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGEuRlJBTUVCVUZGRVIsYS5DT0xPUl9BVFRBQ0hNRU5UMCxhLlRFWFRVUkVfMkQsdCwwKSxhLnJlYWRQaXhlbHMoMCwwLGUsbixhLlJHQkEscy50ZXh0dXJlVHlwZSx1KSx0aGlzLmNoZWNrRXJyb3IoKSxzLmRlY29kZSh1LHIpfWlzRnJhbWVidWZmZXJSZWFkeSgpe3JldHVybiEwfWdldEFjdGl2ZVRleHR1cmUoKXtjb25zdCB0PXRoaXMuZ2w7cmV0dXJuXCJURVhUVVJFXCIrKHQuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuQUNUSVZFX1RFWFRVUkUpLXQuVEVYVFVSRTApfWdldFRleHR1cmVCaW5kaW5nKCl7cmV0dXJuIHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuVEVYVFVSRV9CSU5ESU5HXzJEKX1nZXRGcmFtZWJ1ZmZlckJpbmRpbmcoKXtyZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5GUkFNRUJVRkZFUl9CSU5ESU5HKX1zZXRWZXJ0ZXhBdHRyaWJ1dGVzKHQsZSl7Y29uc3Qgbj10aGlzLmdsO24udmVydGV4QXR0cmliUG9pbnRlcih0LDMsbi5GTE9BVCwhMSwyMCwwKSxuLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHQpLC0xIT09ZSYmKG4udmVydGV4QXR0cmliUG9pbnRlcihlLDIsbi5GTE9BVCwhMSwyMCwxMiksbi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShlKSksdGhpcy5jaGVja0Vycm9yKCl9Y3JlYXRlUHJvZ3JhbSh0LGUpe2NvbnN0IG49dGhpcy5nbCxyPW4uY3JlYXRlUHJvZ3JhbSgpO3JldHVybiBuLmF0dGFjaFNoYWRlcihyLHQpLG4uYXR0YWNoU2hhZGVyKHIsZSksbi5saW5rUHJvZ3JhbShyKSxyfWNvbXBpbGVTaGFkZXIodCxlKXtjb25zdCBuPXRoaXMuZ2wscj1uLmNyZWF0ZVNoYWRlcihlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNyZWF0ZVNoYWRlcigpIHJldHVybmVkIG51bGwgd2l0aCB0eXBlICR7ZX1gKTtpZihuLnNoYWRlclNvdXJjZShyLHQpLG4uY29tcGlsZVNoYWRlcihyKSwhMT09PW4uZ2V0U2hhZGVyUGFyYW1ldGVyKHIsbi5DT01QSUxFX1NUQVRVUykpdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6ICR7bi5nZXRTaGFkZXJJbmZvTG9nKHIpfVxcblNoYWRlciBzb3VyY2U6XFxuJHt0fWApO3JldHVybiByfWRlbGV0ZVNoYWRlcih0KXt0aGlzLmdsLmRlbGV0ZVNoYWRlcih0KX1iaW5kVGV4dHVyZVRvVW5pZm9ybSh0LGUsbil7Y29uc3Qgcj10aGlzLmdsO3IuYWN0aXZlVGV4dHVyZShyLlRFWFRVUkUwK2UpLHRoaXMuY2hlY2tFcnJvcigpLHIuYmluZFRleHR1cmUoci5URVhUVVJFXzJELHQpLHRoaXMuY2hlY2tFcnJvcigpLHIudW5pZm9ybTFpKG4sZSksdGhpcy5jaGVja0Vycm9yKCl9ZHJhdygpe3RoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLDAsNCksdGhpcy5jaGVja0Vycm9yKCl9Y2hlY2tFcnJvcigpe2lmKGEuZW52LmRlYnVnKXtjb25zdCB0PXRoaXMuZ2wsZT10LmdldEVycm9yKCk7bGV0IG49XCJcIjtzd2l0Y2goZSl7Y2FzZSB0Lk5PX0VSUk9SOnJldHVybjtjYXNlIHQuSU5WQUxJRF9FTlVNOm49XCJJTlZBTElEX0VOVU1cIjticmVhaztjYXNlIHQuSU5WQUxJRF9WQUxVRTpuPVwiSU5WQUxJRF9WQUxVRVwiO2JyZWFrO2Nhc2UgdC5JTlZBTElEX09QRVJBVElPTjpuPVwiSU5WQUxJRF9PUEVSQVRJT05cIjticmVhaztjYXNlIHQuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046bj1cIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OXCI7YnJlYWs7Y2FzZSB0Lk9VVF9PRl9NRU1PUlk6bj1cIk9VVF9PRl9NRU1PUllcIjticmVhaztjYXNlIHQuQ09OVEVYVF9MT1NUX1dFQkdMOm49XCJDT05URVhUX0xPU1RfV0VCR0xcIjticmVhaztkZWZhdWx0Om49YFVua25vd24gV2ViR0wgRXJyb3I6ICR7ZS50b1N0cmluZygxNil9YH10aHJvdyBuZXcgRXJyb3Iobil9fWRlbGV0ZVRleHR1cmUodCl7dGhpcy5nbC5kZWxldGVUZXh0dXJlKHQpfWRlbGV0ZVByb2dyYW0odCl7dGhpcy5nbC5kZWxldGVQcm9ncmFtKHQpfWdldEVuY29kZXIodCxlLG49MCl7aWYoMj09PXRoaXMudmVyc2lvbilyZXR1cm4gbmV3IHMuUmVkRmxvYXQzMkRhdGFFbmNvZGVyKHRoaXMuZ2wsZSk7c3dpdGNoKHQpe2Nhc2VcImZsb2F0XCI6cmV0dXJuIDE9PT1ufHx0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZD9uZXcgcy5SR0JBRmxvYXREYXRhRW5jb2Rlcih0aGlzLmdsLGUpOm5ldyBzLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsZSx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24uSEFMRl9GTE9BVF9PRVMpO2Nhc2VcImludFwiOnRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjYXNlXCJieXRlXCI6cmV0dXJuIG5ldyBzLlVpbnQ4RGF0YUVuY29kZXIodGhpcy5nbCxlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhVHlwZTogJHt0fWApfX1jbGVhckFjdGl2ZVRleHR1cmVzKCl7Y29uc3QgdD10aGlzLmdsO2ZvcihsZXQgZT0wO2U8dGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0czsrK2UpdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTArZSksdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9ZGlzcG9zZSgpe2lmKHRoaXMuZGlzcG9zZWQpcmV0dXJuO2NvbnN0IHQ9dGhpcy5nbDt0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlciksdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLG51bGwpLHQuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4YnVmZmVyKSx0LmJpbmRCdWZmZXIodC5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKSx0LmZpbmlzaCgpLHRoaXMuZGlzcG9zZWQ9ITB9Y3JlYXRlRGVmYXVsdEdlb21ldHJ5KCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWy0xLDEsMCwwLDEsLTEsLTEsMCwwLDAsMSwxLDAsMSwxLDEsLTEsMCwxLDBdKX1jcmVhdGVWZXJ0ZXhidWZmZXIoKXtjb25zdCB0PXRoaXMuZ2wsZT10LmNyZWF0ZUJ1ZmZlcigpO2lmKCFlKXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUJ1ZmZlcigpIHJldHVybmVkIG51bGxcIik7Y29uc3Qgbj10aGlzLmNyZWF0ZURlZmF1bHRHZW9tZXRyeSgpO3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIsZSksdC5idWZmZXJEYXRhKHQuQVJSQVlfQlVGRkVSLG4sdC5TVEFUSUNfRFJBVyksdGhpcy5jaGVja0Vycm9yKCksZX1jcmVhdGVGcmFtZWJ1ZmZlcigpe2NvbnN0IHQ9dGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO2lmKCF0KXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUZyYW1lYnVmZmVyIHJldHVybmVkIG51bGxcIik7cmV0dXJuIHR9cXVlcnlWaXRhbFBhcmFtZXRlcnMoKXtjb25zdCB0PXRoaXMuZ2w7aWYodGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyPXRoaXMuY2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpLHRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkPXRoaXMuY2hlY2tSZW5kZXJGbG9hdDMyKCksdGhpcy5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD10aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCksMT09PXRoaXMudmVyc2lvbiYmIXRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiYmIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKXRocm93IG5ldyBFcnJvcihcImJvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZFwiKTt0aGlzLmlzQmxlbmRTdXBwb3J0ZWQ9IXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkfHx0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCksdGhpcy5tYXhUZXh0dXJlU2l6ZT10LmdldFBhcmFtZXRlcih0Lk1BWF9URVhUVVJFX1NJWkUpLHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHM9dC5nZXRQYXJhbWV0ZXIodC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksdGhpcy52ZXJzaW9ufWdldEV4dGVuc2lvbnMoKXsyPT09dGhpcy52ZXJzaW9uPyh0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSk6KHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIiksdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSl9Y2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpe2NvbnN0IHQ9dGhpcy5nbCxlPXQuY3JlYXRlVGV4dHVyZSgpO3QuYmluZFRleHR1cmUodC5URVhUVVJFXzJELGUpO2NvbnN0IG49Mj09PXRoaXMudmVyc2lvbj90LlJHQkEzMkY6dC5SR0JBO3QudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCxuLDEsMSwwLHQuUkdCQSx0LkZMT0FULG51bGwpO2NvbnN0IHI9dC5jcmVhdGVGcmFtZWJ1ZmZlcigpO3QuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsciksdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELGUsMCk7Y29uc3QgaT10LmNoZWNrRnJhbWVidWZmZXJTdGF0dXModC5GUkFNRUJVRkZFUik9PT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlVGV4dHVyZShlKSx0LmRlbGV0ZUZyYW1lYnVmZmVyKHIpLGl9Y2hlY2tSZW5kZXJGbG9hdDMyKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNlIGlmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtyZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyfWNoZWNrRmxvYXQzMkRvd25sb2FkKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNle2lmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtpZighdGhpcy5nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITF9cmV0dXJuIHRoaXMuaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcn1jaGVja0Zsb2F0MzJCbGVuZCgpe2NvbnN0IHQ9dGhpcy5nbDtsZXQgZSxuLHIsaSxvO3RyeXtlPXQuY3JlYXRlVGV4dHVyZSgpLG49dC5jcmVhdGVGcmFtZWJ1ZmZlcigpLHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELGUpO2NvbnN0IGE9Mj09PXRoaXMudmVyc2lvbj90LlJHQkEzMkY6dC5SR0JBO3JldHVybiB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsYSwxLDEsMCx0LlJHQkEsdC5GTE9BVCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG4pLHQuZnJhbWVidWZmZXJUZXh0dXJlMkQodC5GUkFNRUJVRkZFUix0LkNPTE9SX0FUVEFDSE1FTlQwLHQuVEVYVFVSRV8yRCxlLDApLHQuZW5hYmxlKHQuQkxFTkQpLHI9dC5jcmVhdGVTaGFkZXIodC5WRVJURVhfU0hBREVSKSwhIXImJih0LnNoYWRlclNvdXJjZShyLFwidm9pZCBtYWluKCl7fVwiKSx0LmNvbXBpbGVTaGFkZXIociksaT10LmNyZWF0ZVNoYWRlcih0LkZSQUdNRU5UX1NIQURFUiksISFpJiYodC5zaGFkZXJTb3VyY2UoaSxcInByZWNpc2lvbiBoaWdocCBmbG9hdDt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dmVjNCgwLjUpO31cIiksdC5jb21waWxlU2hhZGVyKGkpLG89dC5jcmVhdGVQcm9ncmFtKCksISFvJiYodC5hdHRhY2hTaGFkZXIobyxyKSx0LmF0dGFjaFNoYWRlcihvLGkpLHQubGlua1Byb2dyYW0obyksdC51c2VQcm9ncmFtKG8pLHQuZHJhd0FycmF5cyh0LlBPSU5UUywwLDEpLHQuZ2V0RXJyb3IoKT09PXQuTk9fRVJST1IpKSl9ZmluYWxseXt0LmRpc2FibGUodC5CTEVORCksbyYmdC5kZWxldGVQcm9ncmFtKG8pLHImJnQuZGVsZXRlU2hhZGVyKHIpLGkmJnQuZGVsZXRlU2hhZGVyKGkpLG4mJih0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlRnJhbWVidWZmZXIobikpLGUmJih0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmRlbGV0ZVRleHR1cmUoZSkpfX1iZWdpblRpbWVyKCl7aWYoMj09PXRoaXMudmVyc2lvbiYmdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pe2NvbnN0IHQ9dGhpcy5nbCxlPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uLG49dC5jcmVhdGVRdWVyeSgpO3JldHVybiB0LmJlZ2luUXVlcnkoZS5USU1FX0VMQVBTRURfRVhULG4pLG59dGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cIil9ZW5kVGltZXIoKXtpZigyIT09dGhpcy52ZXJzaW9ufHwhdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3QgdD10aGlzLmdsLGU9dGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247dC5lbmRRdWVyeShlLlRJTUVfRUxBUFNFRF9FWFQpfX1pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHQpe2xldCBlPSExLG49ITE7aWYoMiE9PXRoaXMudmVyc2lvbnx8IXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKXRocm93IG5ldyBFcnJvcihcIldlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIik7e2NvbnN0IHI9dGhpcy5nbCxpPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uO2U9ci5nZXRRdWVyeVBhcmFtZXRlcih0LHIuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSksbj1yLmdldFBhcmFtZXRlcihpLkdQVV9ESVNKT0lOVF9FWFQpfXJldHVybiBlJiYhbn1nZXRUaW1lclJlc3VsdCh0KXtsZXQgZT0wO2lmKDIhPT10aGlzLnZlcnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3Qgbj10aGlzLmdsO2U9bi5nZXRRdWVyeVBhcmFtZXRlcih0LG4uUVVFUllfUkVTVUxUKSxuLmRlbGV0ZVF1ZXJ5KHQpfXJldHVybiBlLzFlNn1hc3luYyB3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHQpe3JldHVybiBhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+dGhpcy5pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKHQpKSksdGhpcy5nZXRUaW1lclJlc3VsdCh0KX1hc3luYyBjcmVhdGVBbmRXYWl0Rm9yRmVuY2UoKXtjb25zdCB0PXRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7cmV0dXJuIHRoaXMucG9sbEZlbmNlKHQpfWNyZWF0ZUZlbmNlKHQpe2xldCBlO2NvbnN0IG49dCxyPW4uZmVuY2VTeW5jKG4uU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCk7cmV0dXJuIHQuZmx1c2goKSxlPW51bGw9PT1yPygpPT4hMDooKT0+e2NvbnN0IHQ9bi5jbGllbnRXYWl0U3luYyhyLDAsMCk7cmV0dXJuIHQ9PT1uLkFMUkVBRFlfU0lHTkFMRUR8fHQ9PT1uLkNPTkRJVElPTl9TQVRJU0ZJRUR9LHtxdWVyeTpyLGlzRmVuY2VQYXNzZWQ6ZX19YXN5bmMgcG9sbEZlbmNlKHQpe3JldHVybiBuZXcgUHJvbWlzZSgoZT0+e3RoaXMuYWRkSXRlbVRvUG9sbCgoKCk9PnQuaXNGZW5jZVBhc3NlZCgpKSwoKCk9PmUoKSkpfSkpfXBvbGxJdGVtcygpe2NvbnN0IHQ9Yyh0aGlzLml0ZW1zVG9Qb2xsLm1hcCgodD0+dC5pc0RvbmVGbikpKTtmb3IobGV0IGU9MDtlPD10OysrZSl7Y29uc3R7cmVzb2x2ZUZuOnR9PXRoaXMuaXRlbXNUb1BvbGxbZV07dCgpfXRoaXMuaXRlbXNUb1BvbGw9dGhpcy5pdGVtc1RvUG9sbC5zbGljZSh0KzEpfWFzeW5jIGFkZEl0ZW1Ub1BvbGwodCxlKXt0aGlzLml0ZW1zVG9Qb2xsLnB1c2goe2lzRG9uZUZuOnQscmVzb2x2ZUZuOmV9KSx0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aD4xfHxhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+KHRoaXMucG9sbEl0ZW1zKCksMD09PXRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoKSkpfX19LDEwMzY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuRXhlY3V0aW9uUGxhbj12b2lkIDA7Y29uc3Qgcj1uKDYyMzEpO2NsYXNzIGl7Y29uc3RydWN0b3IodCxlKXt0aGlzLm9wPXQsdGhpcy5ub2RlPWV9fWUuRXhlY3V0aW9uUGxhbj1jbGFzc3tjb25zdHJ1Y3Rvcih0LGUsbil7dGhpcy5ncmFwaD10LHRoaXMucHJvZmlsZXI9bix0aGlzLmluaXRpYWxpemUoZSl9aW5pdGlhbGl6ZSh0KXt0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiRXhlY3V0aW9uUGxhbi5pbml0aWFsaXplXCIsKCgpPT57Y29uc3QgZT10aGlzLmdyYXBoLmdldE5vZGVzKCk7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2l6ZSBvZiBub2RlcyBhbmQgT1BzIGRvIG5vdCBtYXRjaC5cIik7dGhpcy5fb3BzPXQubWFwKCgodCxuKT0+bmV3IGkodCxlW25dKSkpLHRoaXMucmVzZXQoKSx0aGlzLl9zdGFydGVyPVtdLHRoaXMuX29wcy5mb3JFYWNoKCgodCxlKT0+e2xldCBuPSEwO2Zvcihjb25zdCBlIG9mIHQubm9kZS5pbnB1dHMpaWYoIXRoaXMuX3ZhbHVlc1tlXSYmLTE9PT10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpLmluZGV4T2YoZSkpe249ITE7YnJlYWt9biYmdGhpcy5fc3RhcnRlci5wdXNoKGUpfSkpfSkpfXJlc2V0KCl7dGhpcy5fdmFsdWVzPXRoaXMuZ3JhcGguZ2V0VmFsdWVzKCkubWFwKCh0PT50LnRlbnNvcikpfWFzeW5jIGV4ZWN1dGUodCxlKXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIkV4ZWN1dGlvblBsYW4uZXhlY3V0ZVwiLChhc3luYygpPT57dGhpcy5yZXNldCgpO2NvbnN0IG49dC5jcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCksaT10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpO2lmKGUubGVuZ3RoIT09aS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBudW1iZXIgb2YgaW5wdXQgdGVuc29ycyBkb24ndCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyB0byB0aGUgbW9kZWw6IGFjdHVhbDogJHtlLmxlbmd0aH0gZXhwZWN0ZWQ6ICR7aS5sZW5ndGh9YCk7ZS5mb3JFYWNoKCgodCxlKT0+e2NvbnN0IG49aVtlXTt0aGlzLl92YWx1ZXNbbl09dH0pKTtjb25zdCBvPXRoaXMuX3N0YXJ0ZXIuc2xpY2UoMCksYT10aGlzLmdyYXBoLmdldFZhbHVlcygpLHM9dGhpcy5ncmFwaC5nZXROb2RlcygpO2xldCB1PTA7Zm9yKDt1PG8ubGVuZ3RoOyl7Y29uc3QgdD1vW3UrK10sZT10aGlzLl9vcHNbdF0saT1lLm5vZGUuaW5wdXRzLm1hcCgodD0+dGhpcy5fdmFsdWVzW3RdKSk7aWYoLTEhPT1pLmluZGV4T2Yodm9pZCAwKSl0aHJvdyBuZXcgRXJyb3IoYHVucmVzb2x2ZWQgaW5wdXQgZGV0ZWN0ZWQ6IG9wOiAke2Uubm9kZX1gKTtjb25zdCBjPWk7ci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsYFJ1bmluZyBvcDoke2Uubm9kZS5uYW1lfSAoJHtjLm1hcCgoKHQsbik9PmAnJHtlLm5vZGUuaW5wdXRzW25dfSc6ICR7dC50eXBlfVske3QuZGltcy5qb2luKFwiLFwiKX1dYCkpLmpvaW4oXCIsIFwiKX0pYCk7Y29uc3QgbD1hd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KFwibm9kZVwiLGUubm9kZS5uYW1lLChhc3luYygpPT5lLm9wLmltcGwobixjLGUub3AuY29udGV4dCkpKTtpZihsLmxlbmd0aCE9PWUubm9kZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgc2l6ZSBvZiBvdXRwdXQgZG9lcyBub3QgbWF0Y2ggbW9kZWwgZGVmaW5pdGlvbi5cIik7bC5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IHI9ZS5ub2RlLm91dHB1dHNbbl07aWYodGhpcy5fdmFsdWVzW3JdKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IFske3J9XSBhbHJlYWR5IGhhcyB2YWx1ZTogb3A6JHtlLm5vZGUubmFtZX1gKTt0aGlzLl92YWx1ZXNbcl09dH0pKTtjb25zdCBwPW5ldyBTZXQ7bC5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IHI9ZS5ub2RlLm91dHB1dHNbbl07Zm9yKGNvbnN0IHQgb2YgYVtyXS50byl7Y29uc3QgZT1zW3RdO2xldCBuPSEwO2Zvcihjb25zdCB0IG9mIGUuaW5wdXRzKWlmKCF0aGlzLl92YWx1ZXNbdF0pe249ITE7YnJlYWt9biYmcC5hZGQodCl9fSkpLG8ucHVzaCguLi5wKX1jb25zdCBjPVtdO2ZvcihsZXQgdD0wO3Q8dGhpcy5ncmFwaC5nZXRPdXRwdXRJbmRpY2VzKCkubGVuZ3RoO3QrKyl7Y29uc3QgZT10aGlzLmdyYXBoLmdldE91dHB1dEluZGljZXMoKVt0XSxuPXRoaXMuX3ZhbHVlc1tlXTtpZih2b2lkIDA9PT1uKXRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgb3V0cHV0IFske2V9XSBkb2VzIG5vdCBoYXZlIHZhbHVlYCk7MD09PWU/YXdhaXQgbi5nZXREYXRhKCk6bi5kYXRhLGMucHVzaChuKX1yZXR1cm4gci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsXCJkaXNwb3Npbmcgb2YgaW5mZXJlbmNlSGFuZGxlclwiKSxuLmRpc3Bvc2UoKSxjfSkpfX19LDcwNzA6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuR3JhcGg9dm9pZCAwO2NvbnN0IHI9bigxNDQ2KSxpPW4oNzc3OCksbz1uKDkzOTUpLGE9big5MTYyKSxzPW4oMjUxNyk7dmFyIHU9by5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2UuR3JhcGg9e2Zyb206KHQsZSk9Pm5ldyBwKHQsZSl9O2NsYXNzIGN7Y29uc3RydWN0b3IodCl7dGhpcy5fZnJvbT12b2lkIDAsdGhpcy5fdG89W10sdGhpcy50ZW5zb3I9dm9pZCAwLHRoaXMudHlwZT12b2lkIDAsdCYmKHRoaXMudHlwZT1zLlByb3RvVXRpbC50ZW5zb3JWYWx1ZVR5cGVGcm9tUHJvdG8odC50eXBlLnRlbnNvclR5cGUpKX1nZXQgZnJvbSgpe3JldHVybiB0aGlzLl9mcm9tfWdldCB0bygpe3JldHVybiB0aGlzLl90b319Y2xhc3MgbHtjb25zdHJ1Y3Rvcih0LGUpe3QgaW5zdGFuY2VvZiByLm9ubnguTm9kZVByb3RvPyh0aGlzLm5hbWU9dC5uYW1lLHRoaXMub3BUeXBlPXQub3BUeXBlLHRoaXMuYXR0cmlidXRlcz1uZXcgaS5BdHRyaWJ1dGUodC5hdHRyaWJ1dGUpKTp0IGluc3RhbmNlb2YgdS5Ob2RlJiYodGhpcy5uYW1lPW51bGwhPWU/ZTp0Lm5hbWUoKSx0aGlzLm9wVHlwZT10Lm9wVHlwZSgpLHRoaXMuYXR0cmlidXRlcz1uZXcgaS5BdHRyaWJ1dGUocy5Qcm90b1V0aWwudGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQodCkpKSx0aGlzLmlucHV0cz1bXSx0aGlzLm91dHB1dHM9W10sdGhpcy5leGVjdXRlTm9kZT0hMH19Y2xhc3MgcHtjb25zdHJ1Y3Rvcih0LGUpe2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJncmFwaCBpcyBlbXB0eVwiKTt0aGlzLmJ1aWxkR3JhcGgodCksdGhpcy50cmFuc2Zvcm1HcmFwaChlKSx0aGlzLmNoZWNrSXNBY3ljbGljKCl9Z2V0SW5wdXRJbmRpY2VzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0SW5kaWNlc31nZXRJbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXN9Z2V0T3V0cHV0SW5kaWNlcygpe3JldHVybiB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzfWdldE91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbE91dHB1dE5hbWVzfWdldFZhbHVlcygpe3JldHVybiB0aGlzLl9hbGxEYXRhfWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzfWJ1aWxkR3JhcGgodCl7aWYodCBpbnN0YW5jZW9mIHIub25ueC5HcmFwaFByb3RvKXRoaXMuYnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgdS5HcmFwaCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdyYXBoIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIik7dGhpcy5idWlsZEdyYXBoRnJvbU9ydEZvcm1hdCh0KX19YnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KHQpe2NvbnN0IGU9bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3Qgbj1uZXcgTWFwO2lmKCF0LmlucHV0KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGlucHV0XCIpO2NvbnN0IHI9W107Zm9yKGNvbnN0IG4gb2YgdC5pbnB1dCl7aWYoZS5oYXMobi5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHtuLm5hbWV9YCk7Y29uc3QgdD10aGlzLl9hbGxEYXRhLnB1c2gobmV3IGMobikpLTE7ZS5zZXQobi5uYW1lLHQpLHIucHVzaChuLm5hbWUpfWlmKCF0LmluaXRpYWxpemVyKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGluaXRpYWxpemVyXCIpO2Zvcihjb25zdCBuIG9mIHQuaW5pdGlhbGl6ZXIpe2xldCB0PWUuZ2V0KG4ubmFtZSk7aWYodm9pZCAwPT09dCl7Y29uc3Qgcj1uZXcgYztyLnR5cGU9e3NoYXBlOntkaW1zOnMuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8obi5kaW1zKX0sdGVuc29yVHlwZTpzLlByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhuLmRhdGFUeXBlKX0sdD10aGlzLl9hbGxEYXRhLnB1c2gociktMSxlLnNldChuLm5hbWUsdCl9dGhpcy5fYWxsRGF0YVt0XS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW3RdLnRlbnNvcj1hLlRlbnNvci5mcm9tUHJvdG8obil9Zm9yKGxldCB0PTA7dDx0aGlzLl9hbGxEYXRhLmxlbmd0aDt0KyspdGhpcy5fYWxsRGF0YVt0XS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaCh0KSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2goclt0XSkpO2lmKCF0Lm91dHB1dCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBvdXRwdXRcIik7Zm9yKGNvbnN0IG4gb2YgdC5vdXRwdXQpe2lmKGUuaGFzKG4ubmFtZSkpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke24ubmFtZX1gKTtjb25zdCB0PXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyhuKSktMTtlLnNldChuLm5hbWUsdCksdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKHQpLHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2gobi5uYW1lKX1pZighdC5ub2RlKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGNvbnN0IGUgb2YgdC5ub2RlKXtpZighZS5uYW1lKWZvcihsZXQgdD0wOzt0Kyspe2NvbnN0IHI9YHVubmFtZWRfJHtlLm9wVHlwZX1fJHt0fWA7aWYoIW4uaGFzKHIpKXtlLm5hbWU9cjticmVha319aWYobi5oYXMoZS5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgbm9kZSBuYW1lOiAke2UubmFtZX1gKTtjb25zdCB0PXRoaXMuX25vZGVzLnB1c2gobmV3IGwoZSkpLTE7bi5zZXQoZS5uYW1lLHQpfWZvcihsZXQgbj0wO248dGhpcy5fbm9kZXMubGVuZ3RoO24rKyl7Y29uc3Qgcj10aGlzLl9ub2Rlc1tuXSxpPXQubm9kZVtuXTtpZighaS5vdXRwdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIG91dHB1dCBmb3Igbm9kZTogJHtpLm5hbWV9YCk7Zm9yKGNvbnN0IHQgb2YgaS5vdXRwdXQpe2xldCBvPWUuZ2V0KHQpO2lmKHZvaWQgMD09PW8mJihvPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMSxlLnNldCh0LG8pKSxyLm91dHB1dHMucHVzaChvKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW29dLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke299YCk7aWYodGhpcy5fYWxsRGF0YVtvXS5fZnJvbT1uLFwiQ29uc3RhbnRcIj09PWkub3BUeXBlKXtpZighaS5hdHRyaWJ1dGV8fDEhPT1pLmF0dHJpYnV0ZS5sZW5ndGh8fCFpLmF0dHJpYnV0ZVswXS50KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgYXR0cmlidXRlcyBvciBtaXNzaW5nIHRlbnNvciB2YWx1ZSBpbiBhdHRyaWJ1dGVzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yXCIpO2lmKCFpLm91dHB1dHx8MSE9PWkub3V0cHV0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG91dHB1dCBvciBpbmNvcnJlY3QgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7ci5vdXRwdXRzLnBvcCgpLHIuZXhlY3V0ZU5vZGU9ITEsdGhpcy5fYWxsRGF0YVtvXS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW29dLnRlbnNvcj1hLlRlbnNvci5mcm9tUHJvdG8oaS5hdHRyaWJ1dGVbMF0udCl9fX1mb3IobGV0IG49MDtuPHRoaXMuX25vZGVzLmxlbmd0aDtuKyspe2NvbnN0IHI9dGhpcy5fbm9kZXNbbl0saT10Lm5vZGVbbl07aWYoIWkuaW5wdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IGZvciBub2RlOiAke2kubmFtZX1gKTtmb3IoY29uc3QgdCBvZiBpLmlucHV0KXtjb25zdCBvPWUuZ2V0KHQpO2lmKHZvaWQgMD09PW8pe2lmKFwiXCI9PT10JiYzPT09aS5pbnB1dC5sZW5ndGgmJlwiUmVzaXplXCI9PT1pLm9wVHlwZSljb250aW51ZTt0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBpbnB1dCAnJHt0fScgZm9yIG5vZGU6ICR7aS5uYW1lfWApfXIuaW5wdXRzLnB1c2gobyksdGhpcy5fYWxsRGF0YVtvXS5fdG8ucHVzaChuKX19cmV0dXJuITB9YnVpbGRHcmFwaEZyb21PcnRGb3JtYXQodCl7dmFyIGUsbixyO2NvbnN0IGk9bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3Qgbz1uZXcgTWFwLHA9W107Zm9yKGxldCBvPTA7bzx0LmlucHV0c0xlbmd0aCgpO28rKyl7Y29uc3QgYT10LmlucHV0cyhvKTtpZihpLmhhcyhhKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHthfWApO2ZvcihsZXQgbz0wO288dC5ub2RlQXJnc0xlbmd0aCgpO28rKylpZigobnVsbD09PShlPXQubm9kZUFyZ3MobykpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLm5hbWUoKSk9PT1hKXtjb25zdCBlPW5ldyBjO2lmKChudWxsPT09KHI9bnVsbD09PShuPXQubm9kZUFyZ3MobykpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLnR5cGUoKSl8fHZvaWQgMD09PXI/dm9pZCAwOnIudmFsdWVUeXBlKCkpIT09dS5UeXBlSW5mb1ZhbHVlLnRlbnNvcl90eXBlKXRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgdHlwZSBmb3IgdGhlIG5vZGVBcmcuXCIpO2NvbnN0IGw9dC5ub2RlQXJncyhvKS50eXBlKCkudmFsdWUobmV3IHUuVGVuc29yVHlwZUFuZFNoYXBlKSxmPXMuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGwuZWxlbVR5cGUoKSksZD1sLnNoYXBlKCksaD1bXTtmb3IobGV0IHQ9MDt0PGQuZGltTGVuZ3RoKCk7dCsrKWgucHVzaChzLkxvbmdVdGlsLmxvbmdUb051bWJlcihkLmRpbSh0KS52YWx1ZSgpLmRpbVZhbHVlKCkpKTtlLnR5cGU9e3NoYXBlOntkaW1zOmh9LHRlbnNvclR5cGU6Zn07Y29uc3QgZz10aGlzLl9hbGxEYXRhLnB1c2goZSktMTtpLnNldChhLGcpLHAucHVzaChhKX19Zm9yKGxldCBlPTA7ZTx0LmluaXRpYWxpemVyc0xlbmd0aCgpO2UrKyl7Y29uc3Qgbj10LmluaXRpYWxpemVycyhlKTtsZXQgcj1pLmdldChuLm5hbWUoKSk7aWYodm9pZCAwPT09cil7Y29uc3QgdD1uZXcgYyxlPXMuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KG4pLG89cy5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8obi5kYXRhVHlwZSgpKTt0LnR5cGU9e3NoYXBlOntkaW1zOmV9LHRlbnNvclR5cGU6b30scj10aGlzLl9hbGxEYXRhLnB1c2godCktMSxpLnNldChuLm5hbWUoKSxyKX10aGlzLl9hbGxEYXRhW3JdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbcl0udGVuc29yPWEuVGVuc29yLmZyb21PcnRUZW5zb3Iobil9Zm9yKGxldCB0PTA7dDx0aGlzLl9hbGxEYXRhLmxlbmd0aDt0KyspdGhpcy5fYWxsRGF0YVt0XS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaCh0KSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2gocFt0XSkpO2ZvcihsZXQgZT0wO2U8dC5vdXRwdXRzTGVuZ3RoKCk7ZSsrKXtjb25zdCBuPXQub3V0cHV0cyhlKTtpZihpLmhhcyhuKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgb3V0cHV0IG5hbWU6ICR7bn1gKTtjb25zdCByPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMTtpLnNldChuLHIpLHRoaXMuX2FsbE91dHB1dEluZGljZXMucHVzaChyKSx0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKG4pfWlmKCF0Lm5vZGVzKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGxldCBlPTA7ZTx0Lm5vZGVzTGVuZ3RoKCk7ZSsrKXtjb25zdCBuPXQubm9kZXMoZSk7bGV0IHI9bi5uYW1lKCk7aWYoIXIpZm9yKGxldCB0PTA7cj1gdW5uYW1lZF8ke24ub3BUeXBlKCl9XyR7dH1gLG8uaGFzKHIpO3QrKyk7aWYoby5oYXMocikpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtyfWApO2NvbnN0IGk9dGhpcy5fbm9kZXMucHVzaChuZXcgbChuLHIpKS0xO28uc2V0KHIsaSl9Zm9yKGxldCBlPTA7ZTx0aGlzLl9ub2Rlcy5sZW5ndGg7ZSsrKXtjb25zdCBuPXRoaXMuX25vZGVzW2VdLHI9dC5ub2RlcyhlKTtpZihudWxsPT1yKXRocm93IG5ldyBFcnJvcihgTm8gbm9kZSBleGlzdHMgYXQgaW5kZXggJHtlfWApO2lmKDA9PT0obnVsbD09cj92b2lkIDA6ci5vdXRwdXRzTGVuZ3RoKCkpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBvdXRwdXQgZm9yIG5vZGU6ICR7ci5uYW1lfWApO2ZvcihsZXQgdD0wO3Q8KG51bGw9PXI/dm9pZCAwOnIub3V0cHV0c0xlbmd0aCgpKTt0Kyspe2NvbnN0IG89bnVsbD09cj92b2lkIDA6ci5vdXRwdXRzKHQpO2xldCBzPWkuZ2V0KG8pO2lmKHZvaWQgMD09PXMmJihzPXRoaXMuX2FsbERhdGEucHVzaChuZXcgYyktMSxpLnNldChvLHMpKSxuLm91dHB1dHMucHVzaChzKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW3NdLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke3N9YCk7aWYodGhpcy5fYWxsRGF0YVtzXS5fZnJvbT1lLFwiQ29uc3RhbnRcIj09PXIub3BUeXBlKCkpe2lmKDEhPT1yLmF0dHJpYnV0ZXNMZW5ndGgoKXx8IXIuYXR0cmlidXRlcygwKS50KCkpdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7aWYoMSE9PXIub3V0cHV0c0xlbmd0aCgpKXRocm93IG5ldyBFcnJvcihcIm1pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvclwiKTtuLm91dHB1dHMucG9wKCksbi5leGVjdXRlTm9kZT0hMSx0aGlzLl9hbGxEYXRhW3NdLl9mcm9tPS0xLHRoaXMuX2FsbERhdGFbc10udGVuc29yPWEuVGVuc29yLmZyb21PcnRUZW5zb3Ioci5hdHRyaWJ1dGVzKDApLnQoKSl9fX1mb3IobGV0IGU9MDtlPHRoaXMuX25vZGVzLmxlbmd0aDtlKyspe2NvbnN0IG49dGhpcy5fbm9kZXNbZV0scj10Lm5vZGVzKGUpO2lmKDA9PT1yLmlucHV0c0xlbmd0aCgpKXRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtyLm5hbWV9YCk7Zm9yKGxldCB0PTA7dDxyLmlucHV0c0xlbmd0aCgpO3QrKyl7Y29uc3Qgbz1yLmlucHV0cyh0KSxhPWkuZ2V0KG8pO2lmKHZvaWQgMD09PWEpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgaW5wdXQgJyR7b30nIGZvciBub2RlOiAke3IubmFtZSgpfWApO24uaW5wdXRzLnB1c2goYSksdGhpcy5fYWxsRGF0YVthXS5fdG8ucHVzaChlKX19fWNoZWNrSXNBY3ljbGljKCl7Y29uc3QgdD1uZXcgU2V0O3RoaXMuX2FsbElucHV0SW5kaWNlcy5mb3JFYWNoKChlPT57dGhpcy5fYWxsRGF0YVtlXS5fdG8uZm9yRWFjaCgoZT0+e3QuYWRkKGUpfSkpfSkpO2NvbnN0IGU9QXJyYXkuZnJvbSh0KSxuPW5ldyBBcnJheSh0aGlzLl9ub2Rlcy5sZW5ndGgpLmZpbGwoXCJ3aGl0ZVwiKTtmb3IoO2UubGVuZ3RoPjA7KXtjb25zdCB0PWUucG9wKCk7XCJncmF5XCI9PT1uW3RdP25bdF09XCJibGFja1wiOihlLnB1c2godCksblt0XT1cImdyYXlcIix0aGlzLl9ub2Rlc1t0XS5vdXRwdXRzLmZvckVhY2goKHI9Pntjb25zdCBpPXRoaXMuX2FsbERhdGFbcl07aWYodm9pZCAwIT09aS50ZW5zb3IpdGhyb3cgbmV3IEVycm9yKFwibm9kZSBvdXRwdXRzIHNob3VsZCBub3QgYmUgaW5pdGlhbGl6ZWRcIik7aWYoaS5fZnJvbSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiZnJvbSBwcm9wZXJ0eSBvZiB0aGUgVmFsdWUgb2JqZWN0IGRvZXNuJ3QgbWF0Y2ggaW5kZXggb2YgTm9kZSBiZWluZyBwcm9jZXNzZWRcIik7aS5fdG8uZm9yRWFjaCgodD0+e2lmKFwiZ3JheVwiPT09blt0XSl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbCBncmFwaCBpcyBjeWNsaWNcIik7XCJ3aGl0ZVwiPT09blt0XSYmZS5wdXNoKHQpfSkpfSkpKX19dHJhbnNmb3JtR3JhcGgodCl7dGhpcy5yZW1vdmVBbGxJZGVudGl0eU5vZGVzKCksdGhpcy5yZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKSx0aGlzLmZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCksdCYmdC50cmFuc2Zvcm1HcmFwaCh0aGlzKSx0aGlzLmZpbmFsaXplR3JhcGgoKX1maW5hbGl6ZUdyYXBoKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX25vZGVzLmxlbmd0aDtlKyspdGhpcy5fbm9kZXNbZV0uZXhlY3V0ZU5vZGU/dD4wJiYodGhpcy5fbm9kZXNbZV0uaW5wdXRzLmZvckVhY2goKG49Pntjb25zdCByPXRoaXMuX2FsbERhdGFbbl0uX3RvLmluZGV4T2YoZSt0KTstMSE9PXImJih0aGlzLl9hbGxEYXRhW25dLl90b1tyXT1lKX0pKSx0aGlzLl9ub2Rlc1tlXS5vdXRwdXRzLmZvckVhY2goKG49Pnt0aGlzLl9hbGxEYXRhW25dLl9mcm9tJiZ0aGlzLl9hbGxEYXRhW25dLl9mcm9tPT09ZSt0JiYodGhpcy5fYWxsRGF0YVtuXS5fZnJvbT1lKX0pKSk6KHQrKyx0aGlzLl9ub2Rlc1tlXS5vdXRwdXRzLmZvckVhY2goKHQ9Pnt0aGlzLl9hbGxEYXRhW3RdLl9mcm9tPS0yfSkpLHRoaXMuX25vZGVzLnNwbGljZShlLDEpLGUtLSk7dD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fYWxsRGF0YS5sZW5ndGg7ZSsrKWlmKC0yIT09dGhpcy5fYWxsRGF0YVtlXS5mcm9tfHwtMSE9PXRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihlK3QpKXtpZih0PjApe2xldCBuPS0xO3ZvaWQgMCE9PXRoaXMuX2FsbERhdGFbZV0uZnJvbSYmLTEhPT10aGlzLl9hbGxEYXRhW2VdLmZyb20/KG49dGhpcy5fbm9kZXNbdGhpcy5fYWxsRGF0YVtlXS5mcm9tXS5vdXRwdXRzLmluZGV4T2YoZSt0KSwtMSE9PW4mJih0aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW2VdLmZyb21dLm91dHB1dHNbbl09ZSkpOihuPXRoaXMuX2FsbElucHV0SW5kaWNlcy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fYWxsSW5wdXRJbmRpY2VzW25dPWUpKSx0aGlzLl9hbGxEYXRhW2VdLnRvLmZvckVhY2goKHI9PntuPXRoaXMuX25vZGVzW3JdLmlucHV0cy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fbm9kZXNbcl0uaW5wdXRzW25dPWUpfSkpLDA9PT10aGlzLl9hbGxEYXRhW2VdLnRvLmxlbmd0aCYmKG49dGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKGUrdCksLTEhPT1uJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tuXT1lKSl9fWVsc2UgdCsrLHRoaXMuX2FsbERhdGEuc3BsaWNlKGUsMSksZS0tfWRlbGV0ZU5vZGUodCl7Y29uc3QgZT10aGlzLl9ub2Rlc1t0XTtpZihlLm91dHB1dHMubGVuZ3RoPjEpZm9yKGxldCB0PTE7dDxlLm91dHB1dHMubGVuZ3RoO3QrKylpZih0aGlzLl9hbGxEYXRhW2Uub3V0cHV0c1t0XV0udG8ubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBkZWxldGlvbiB3aXRoIG1vcmUgdGhhbiBvbmUgb3V0cHV0IGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyBpcyBub3Qgc3VwcG9ydGVkLiBcIik7ZS5leGVjdXRlTm9kZT0hMTtjb25zdCBuPWUuaW5wdXRzWzBdLHI9ZS5vdXRwdXRzWzBdLGk9dGhpcy5fYWxsRGF0YVtyXS50byxvPXRoaXMuX2FsbERhdGFbbl0udG8uaW5kZXhPZih0KTtpZigtMT09PW8pdGhyb3cgbmV3IEVycm9yKFwiVGhlIFZhbHVlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIGN1cnJlbnQgTm9kZSBpbiBpdCdzICd0bycgcHJvcGVydHkgXCIpO3RoaXMuX2FsbERhdGFbbl0udG8uc3BsaWNlKG8sMSksdGhpcy5fYWxsRGF0YVtyXS5fdG89W107Y29uc3QgYT10aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2Yocik7aWYoLTEhPT1hJiYodGhpcy5fYWxsT3V0cHV0SW5kaWNlc1thXT1uKSxpJiZpLmxlbmd0aD4wKWZvcihjb25zdCB0IG9mIGkpe2NvbnN0IGU9dGhpcy5fbm9kZXNbdF0uaW5wdXRzLmluZGV4T2Yocik7aWYoLTE9PT1lKXRocm93IG5ldyBFcnJvcihcIlRoZSBOb2RlIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhlIG91dHB1dCBWYWx1ZSBpbiBpdCdzICdpbnB1dHMnIHByb3BlcnR5IFwiKTt0aGlzLl9ub2Rlc1t0XS5pbnB1dHNbZV09bix0aGlzLl9hbGxEYXRhW25dLnRvLnB1c2godCl9fXJlbW92ZUFsbERyb3BvdXROb2Rlcygpe2xldCB0PTA7Zm9yKGNvbnN0IGUgb2YgdGhpcy5fbm9kZXMpe2lmKFwiRHJvcG91dFwiPT09ZS5vcFR5cGUpe2lmKDEhPT1lLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcyBzaG91bGQgb25seSBjb250YWluIG9uZSBpbnB1dC4gXCIpO2lmKDEhPT1lLm91dHB1dHMubGVuZ3RoJiYyIT09ZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEcm9wb3V0IG5vZGVzIHNob3VsZCBjb250YWluIGVpdGhlciAxIG9yIDIgb3V0cHV0KHMpXCIpO2lmKDI9PT1lLm91dHB1dHMubGVuZ3RoJiYwIT09dGhpcy5fYWxsRGF0YVtlLm91dHB1dHNbMV1dLl90by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRHJvcG91dCBub2RlcydzIHNlY29uZCBvdXRwdXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2VkIGJ5IG90aGVyIG5vZGVzXCIpO3RoaXMuZGVsZXRlTm9kZSh0KX10Kyt9fXJlbW92ZUFsbElkZW50aXR5Tm9kZXMoKXtsZXQgdD0wO2Zvcihjb25zdCBlIG9mIHRoaXMuX25vZGVzKVwiSWRlbnRpdHlcIj09PWUub3BUeXBlJiZ0aGlzLmRlbGV0ZU5vZGUodCksdCsrfWlzQWN0aXZhdGlvbih0KXtzd2l0Y2godC5vcFR5cGUpe2Nhc2VcIlJlbHVcIjpjYXNlXCJTaWdtb2lkXCI6Y2FzZVwiQ2xpcFwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fbm9kZXMpaWYoXCJDb252XCI9PT10Lm9wVHlwZSl7Y29uc3QgZT10aGlzLl9hbGxEYXRhW3Qub3V0cHV0c1swXV0uX3RvO2lmKDE9PT1lLmxlbmd0aCYmdGhpcy5pc0FjdGl2YXRpb24odGhpcy5fbm9kZXNbZVswXV0pKXtjb25zdCBuPXRoaXMuX25vZGVzW2VbMF1dO2lmKFwiQ2xpcFwiPT09bi5vcFR5cGUpaWYoMT09PW4uaW5wdXRzLmxlbmd0aCl0cnl7dC5hdHRyaWJ1dGVzLnNldChcImFjdGl2YXRpb25fcGFyYW1zXCIsXCJmbG9hdHNcIixbbi5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWluXCIpLG4uYXR0cmlidXRlcy5nZXRGbG9hdChcIm1heFwiKV0pfWNhdGNoKGUpe3QuYXR0cmlidXRlcy5zZXQoXCJhY3RpdmF0aW9uX3BhcmFtc1wiLFwiZmxvYXRzXCIsW3MuTUlOX0NMSVAscy5NQVhfQ0xJUF0pfWVsc2V7aWYoIShuLmlucHV0cy5sZW5ndGg+PTMmJnZvaWQgMCE9PXRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMV1dLnRlbnNvciYmdm9pZCAwIT09dGhpcy5fYWxsRGF0YVtuLmlucHV0c1syXV0udGVuc29yKSljb250aW51ZTt0LmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvbl9wYXJhbXNcIixcImZsb2F0c1wiLFt0aGlzLl9hbGxEYXRhW24uaW5wdXRzWzFdXS50ZW5zb3IuZmxvYXREYXRhWzBdLHRoaXMuX2FsbERhdGFbbi5pbnB1dHNbMl1dLnRlbnNvci5mbG9hdERhdGFbMF1dKX10LmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvblwiLFwic3RyaW5nXCIsbi5vcFR5cGUpLHRoaXMuZGVsZXRlTm9kZShlWzBdKX19fX19LDYyMzE6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLm5vdz1lLlByb2ZpbGVyPWUuTG9nZ2VyPXZvaWQgMDtjb25zdCBuPXt2ZXJib3NlOjFlMyxpbmZvOjJlMyx3YXJuaW5nOjRlMyxlcnJvcjo1ZTMsZmF0YWw6NmUzfSxyPXtub25lOm5ldyBjbGFzc3tsb2codCxlLG4pe319LGNvbnNvbGU6bmV3IGNsYXNze2xvZyh0LGUsbil7Y29uc29sZS5sb2coYCR7dGhpcy5jb2xvcih0KX0gJHtuP1wiXHUwMDFiWzM1bVwiK24rXCJcdTAwMWJbMG0gXCI6XCJcIn0ke2V9YCl9Y29sb3IodCl7c3dpdGNoKHQpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm5cIlx1MDAxYlszNDs0MG12XHUwMDFiWzBtXCI7Y2FzZVwiaW5mb1wiOnJldHVyblwiXHUwMDFiWzMybWlcdTAwMWJbMG1cIjtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuXCJcdTAwMWJbMzA7NDNtd1x1MDAxYlswbVwiO2Nhc2VcImVycm9yXCI6cmV0dXJuXCJcdTAwMWJbMzE7NDBtZVx1MDAxYlswbVwiO2Nhc2VcImZhdGFsXCI6cmV0dXJuXCJcdTAwMWJbMTAxbWZcdTAwMWJbMG1cIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgc2V2ZXJpdHk6ICR7dH1gKX19fX0saT17cHJvdmlkZXI6XCJjb25zb2xlXCIsbWluaW1hbFNldmVyaXR5Olwid2FybmluZ1wiLGxvZ0RhdGVUaW1lOiEwLGxvZ1NvdXJjZUxvY2F0aW9uOiExfTtsZXQgbz17XCJcIjppfTtmdW5jdGlvbiBhKHQsZSxuLHIpe2lmKHZvaWQgMD09PWUpcmV0dXJuIGk9dCx7dmVyYm9zZTphLnZlcmJvc2UuYmluZChudWxsLGkpLGluZm86YS5pbmZvLmJpbmQobnVsbCxpKSx3YXJuaW5nOmEud2FybmluZy5iaW5kKG51bGwsaSksZXJyb3I6YS5lcnJvci5iaW5kKG51bGwsaSksZmF0YWw6YS5mYXRhbC5iaW5kKG51bGwsaSl9O2lmKHZvaWQgMD09PW4pcyh0LGUpO2Vsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIG4mJnZvaWQgMD09PXIpcyh0LGUpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIG4mJnZvaWQgMD09PXIpcyh0LG4sMCxlKTtlbHNle2lmKFwic3RyaW5nXCIhPXR5cGVvZiBufHxcIm51bWJlclwiIT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXQgaXMgdmFsaWRcIik7cyh0LG4sMCxlKX12YXIgaX1mdW5jdGlvbiBzKHQsZSxpLGEpe2NvbnN0IHM9b1thfHxcIlwiXXx8b1tcIlwiXTtuW3RdPG5bcy5taW5pbWFsU2V2ZXJpdHldfHwocy5sb2dEYXRlVGltZSYmKGU9YCR7KG5ldyBEYXRlKS50b0lTT1N0cmluZygpfXwke2V9YCkscy5sb2dTb3VyY2VMb2NhdGlvbixyW3MucHJvdmlkZXJdLmxvZyh0LGUsYSkpfSFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe289e30sbihcIlwiLHR8fHt9KX1mdW5jdGlvbiBuKHQsbil7aWYoXCIqXCI9PT10KWUobik7ZWxzZXtjb25zdCBlPW9bdF18fGk7b1t0XT17cHJvdmlkZXI6bi5wcm92aWRlcnx8ZS5wcm92aWRlcixtaW5pbWFsU2V2ZXJpdHk6bi5taW5pbWFsU2V2ZXJpdHl8fGUubWluaW1hbFNldmVyaXR5LGxvZ0RhdGVUaW1lOnZvaWQgMD09PW4ubG9nRGF0ZVRpbWU/ZS5sb2dEYXRlVGltZTpuLmxvZ0RhdGVUaW1lLGxvZ1NvdXJjZUxvY2F0aW9uOnZvaWQgMD09PW4ubG9nU291cmNlTG9jYXRpb24/ZS5sb2dTb3VyY2VMb2NhdGlvbjpuLmxvZ1NvdXJjZUxvY2F0aW9ufX19dC52ZXJib3NlPWZ1bmN0aW9uKGUsbil7dChcInZlcmJvc2VcIixlLG4pfSx0LmluZm89ZnVuY3Rpb24oZSxuKXt0KFwiaW5mb1wiLGUsbil9LHQud2FybmluZz1mdW5jdGlvbihlLG4pe3QoXCJ3YXJuaW5nXCIsZSxuKX0sdC5lcnJvcj1mdW5jdGlvbihlLG4pe3QoXCJlcnJvclwiLGUsbil9LHQuZmF0YWw9ZnVuY3Rpb24oZSxuKXt0KFwiZmF0YWxcIixlLG4pfSx0LnJlc2V0PWUsdC5zZXQ9bix0LnNldFdpdGhFbnY9ZnVuY3Rpb24odCl7Y29uc3QgZT17fTt0LmxvZ0xldmVsJiYoZS5taW5pbWFsU2V2ZXJpdHk9dC5sb2dMZXZlbCksbihcIlwiLGUpfX0oYXx8KGE9e30pKSxlLkxvZ2dlcj1hO2NsYXNzIHV7Y29uc3RydWN0b3IodCxlLG4scixpLG8pe3RoaXMuY2F0ZWdvcnk9dCx0aGlzLm5hbWU9ZSx0aGlzLnN0YXJ0VGltZT1uLHRoaXMuZW5kQ2FsbGJhY2s9cix0aGlzLnRpbWVyPWksdGhpcy5jdHg9b31lbmQoKXtyZXR1cm4gdGhpcy5lbmRDYWxsYmFjayh0aGlzKX1hc3luYyBjaGVja1RpbWVyKCl7aWYodm9pZCAwPT09dGhpcy5jdHh8fHZvaWQgMD09PXRoaXMudGltZXIpdGhyb3cgbmV3IEVycm9yKFwiTm8gd2ViZ2wgdGltZXIgZm91bmRcIik7cmV0dXJuIHRoaXMuY3R4LmVuZFRpbWVyKCksdGhpcy5jdHgud2FpdEZvclF1ZXJ5QW5kR2V0VGltZSh0aGlzLnRpbWVyKX19Y2xhc3MgY3tjb25zdHJ1Y3Rvcih0LGUsbixyKXt0aGlzLmNhdGVnb3J5PXQsdGhpcy5uYW1lPWUsdGhpcy5zdGFydFRpbWU9bix0aGlzLmVuZFRpbWU9cn19ZS5Qcm9maWxlcj1jbGFzc3tzdGF0aWMgY3JlYXRlKHQpe3JldHVybiB2b2lkIDA9PT10P25ldyB0aGlzOm5ldyB0aGlzKHQubWF4TnVtYmVyRXZlbnRzLHQuZmx1c2hCYXRjaFNpemUsdC5mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMpfWNvbnN0cnVjdG9yKHQsZSxuKXt0aGlzLl9zdGFydGVkPSExLHRoaXMuX2ZsdXNoUG9pbnRlcj0wLHRoaXMuX3N0YXJ0ZWQ9ITEsdGhpcy5fbWF4TnVtYmVyRXZlbnRzPXZvaWQgMD09PXQ/MWU0OnQsdGhpcy5fZmx1c2hCYXRjaFNpemU9dm9pZCAwPT09ZT8xMDplLHRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcz12b2lkIDA9PT1uPzVlMzpufXN0YXJ0KCl7dGhpcy5fc3RhcnRlZD0hMCx0aGlzLl90aW1pbmdFdmVudHM9W10sdGhpcy5fZmx1c2hUaW1lPSgwLGUubm93KSgpLHRoaXMuX2ZsdXNoUG9pbnRlcj0wfXN0b3AoKXtmb3IodGhpcy5fc3RhcnRlZD0hMTt0aGlzLl9mbHVzaFBvaW50ZXI8dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDt0aGlzLl9mbHVzaFBvaW50ZXIrKyl0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKX1ldmVudCh0LGUsbixyKXtjb25zdCBpPXRoaXMuX3N0YXJ0ZWQ/dGhpcy5iZWdpbih0LGUscik6dm9pZCAwO2xldCBvPSExO2NvbnN0IGE9bigpO2lmKGEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEudGhlbilyZXR1cm4gbz0hMCxuZXcgUHJvbWlzZSgoKHQsZSk9PnthLnRoZW4oKGFzeW5jIGU9PntpJiZhd2FpdCBpLmVuZCgpLHQoZSl9KSwoYXN5bmMgdD0+e2kmJmF3YWl0IGkuZW5kKCksZSh0KX0pKX0pKTtpZighbyYmaSl7Y29uc3QgdD1pLmVuZCgpO2lmKHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGhlbilyZXR1cm4gbmV3IFByb21pc2UoKChlLG4pPT57dC50aGVuKCgoKT0+e2UoYSl9KSwodD0+e24odCl9KSl9KSl9cmV0dXJuIGF9YmVnaW4odCxuLHIpe2lmKCF0aGlzLl9zdGFydGVkKXRocm93IG5ldyBFcnJvcihcInByb2ZpbGVyIGlzIG5vdCBzdGFydGVkIHlldFwiKTtpZih2b2lkIDA9PT1yKXtjb25zdCByPSgwLGUubm93KSgpO3JldHVybiB0aGlzLmZsdXNoKHIpLG5ldyB1KHQsbixyLCh0PT50aGlzLmVuZFN5bmModCkpKX17Y29uc3QgZT1yLmJlZ2luVGltZXIoKTtyZXR1cm4gbmV3IHUodCxuLDAsKGFzeW5jIHQ9PnRoaXMuZW5kKHQpKSxlLHIpfX1hc3luYyBlbmQodCl7Y29uc3QgZT1hd2FpdCB0LmNoZWNrVGltZXIoKTt0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoPHRoaXMuX21heE51bWJlckV2ZW50cyYmKHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBjKHQuY2F0ZWdvcnksdC5uYW1lLHQuc3RhcnRUaW1lLGUpKSx0aGlzLmZsdXNoKGUpKX1lbmRTeW5jKHQpe2NvbnN0IG49KDAsZS5ub3cpKCk7dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDx0aGlzLl9tYXhOdW1iZXJFdmVudHMmJih0aGlzLl90aW1pbmdFdmVudHMucHVzaChuZXcgYyh0LmNhdGVnb3J5LHQubmFtZSx0LnN0YXJ0VGltZSxuKSksdGhpcy5mbHVzaChuKSl9bG9nT25lRXZlbnQodCl7ZS5Mb2dnZXIudmVyYm9zZShgUHJvZmlsZXIuJHt0LmNhdGVnb3J5fWAsYCR7KHQuZW5kVGltZS10LnN0YXJ0VGltZSkudG9GaXhlZCgyKX1tcyBvbiBldmVudCAnJHt0Lm5hbWV9JyBhdCAke3QuZW5kVGltZS50b0ZpeGVkKDIpfWApfWZsdXNoKHQpe2lmKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGgtdGhpcy5fZmx1c2hQb2ludGVyPj10aGlzLl9mbHVzaEJhdGNoU2l6ZXx8dC10aGlzLl9mbHVzaFRpbWU+PXRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyl7Zm9yKGNvbnN0IHQ9dGhpcy5fZmx1c2hQb2ludGVyO3RoaXMuX2ZsdXNoUG9pbnRlcjx0K3RoaXMuX2ZsdXNoQmF0Y2hTaXplJiZ0aGlzLl9mbHVzaFBvaW50ZXI8dGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDt0aGlzLl9mbHVzaFBvaW50ZXIrKyl0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKTt0aGlzLl9mbHVzaFRpbWU9KDAsZS5ub3cpKCl9fWdldCBzdGFydGVkKCl7cmV0dXJuIHRoaXMuX3N0YXJ0ZWR9fSxlLm5vdz1cInVuZGVmaW5lZFwiIT10eXBlb2YgcGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLm5vdz8oKT0+cGVyZm9ybWFuY2Uubm93KCk6RGF0ZS5ub3d9LDI2NDQ6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuTW9kZWw9dm9pZCAwO2NvbnN0IHI9big1Njg2KSxpPW4oMTQ0Niksbz1uKDcwNzApLGE9big5Mzk1KSxzPW4oMjUxNyk7dmFyIHU9YS5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2UuTW9kZWw9Y2xhc3N7Y29uc3RydWN0b3IoKXt9bG9hZCh0LGUsbil7aWYoIW4pdHJ5e3JldHVybiB2b2lkIHRoaXMubG9hZEZyb21Pbm54Rm9ybWF0KHQsZSl9Y2F0Y2godCl7aWYodm9pZCAwIT09bil0aHJvdyB0fXRoaXMubG9hZEZyb21PcnRGb3JtYXQodCxlKX1sb2FkRnJvbU9ubnhGb3JtYXQodCxlKXtjb25zdCBuPWkub25ueC5Nb2RlbFByb3RvLmRlY29kZSh0KTtpZihzLkxvbmdVdGlsLmxvbmdUb051bWJlcihuLmlyVmVyc2lvbik8Myl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTNcIik7dGhpcy5fb3BzZXRzPW4ub3BzZXRJbXBvcnQubWFwKCh0PT4oe2RvbWFpbjp0LmRvbWFpbix2ZXJzaW9uOnMuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHQudmVyc2lvbil9KSkpLHRoaXMuX2dyYXBoPW8uR3JhcGguZnJvbShuLmdyYXBoLGUpfWxvYWRGcm9tT3J0Rm9ybWF0KHQsZSl7Y29uc3Qgbj1uZXcgci5mbGF0YnVmZmVycy5CeXRlQnVmZmVyKHQpLGk9dS5JbmZlcmVuY2VTZXNzaW9uLmdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24obikubW9kZWwoKTtpZihzLkxvbmdVdGlsLmxvbmdUb051bWJlcihpLmlyVmVyc2lvbigpKTwzKXRocm93IG5ldyBFcnJvcihcIm9ubHkgc3VwcG9ydCBPTk5YIG1vZGVsIHdpdGggSVJfVkVSU0lPTj49M1wiKTt0aGlzLl9vcHNldHM9W107Zm9yKGxldCB0PTA7dDxpLm9wc2V0SW1wb3J0TGVuZ3RoKCk7dCsrKXtjb25zdCBlPWkub3BzZXRJbXBvcnQodCk7dGhpcy5fb3BzZXRzLnB1c2goe2RvbWFpbjpudWxsPT1lP3ZvaWQgMDplLmRvbWFpbigpLHZlcnNpb246cy5Mb25nVXRpbC5sb25nVG9OdW1iZXIoZS52ZXJzaW9uKCkpfSl9dGhpcy5fZ3JhcGg9by5HcmFwaC5mcm9tKGkuZ3JhcGgoKSxlKX1nZXQgZ3JhcGgoKXtyZXR1cm4gdGhpcy5fZ3JhcGh9Z2V0IG9wc2V0cygpe3JldHVybiB0aGlzLl9vcHNldHN9fX0sNzgyOih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5GTE9BVF9UWVBFUz1lLklOVF9UWVBFUz1lLk5VTUJFUl9UWVBFUz12b2lkIDAsZS5OVU1CRVJfVFlQRVM9W1wiZmxvYXQzMlwiLFwiZmxvYXQ2NFwiLFwiaW50MzJcIixcImludDE2XCIsXCJpbnQ4XCIsXCJ1aW50MTZcIixcInVpbnQzMlwiLFwidWludDhcIl0sZS5JTlRfVFlQRVM9W1wiaW50MzJcIixcImludDE2XCIsXCJpbnQ4XCIsXCJ1aW50MTZcIixcInVpbnQzMlwiLFwidWludDhcIl0sZS5GTE9BVF9UWVBFUz1bXCJmbG9hdDMyXCIsXCJmbG9hdDY0XCJdfSwxMDQ3Oih0LGUpPT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbih0LGUpe2lmKGUuZW5kc1dpdGgoXCIrXCIpKXtjb25zdCBuPU51bWJlci5wYXJzZUludChlLnN1YnN0cmluZygwLGUubGVuZ3RoLTEpLDEwKTtyZXR1cm4haXNOYU4obikmJm48PXR9aWYoMj09PWUuc3BsaXQoXCItXCIpLmxlbmd0aCl7Y29uc3Qgbj1lLnNwbGl0KFwiLVwiKSxyPU51bWJlci5wYXJzZUludChuWzBdLDEwKSxpPU51bWJlci5wYXJzZUludChuWzFdLDEwKTtyZXR1cm4haXNOYU4ocikmJiFpc05hTihpKSYmcjw9dCYmdDw9aX1yZXR1cm4gTnVtYmVyLnBhcnNlSW50KGUsMTApPT09dH1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnJlc29sdmVPcGVyYXRvcj12b2lkIDAsZS5yZXNvbHZlT3BlcmF0b3I9ZnVuY3Rpb24odCxlLHIpe2Zvcihjb25zdCBpIG9mIHIpe2NvbnN0IHI9aVswXSxvPWlbMV0sYT1pWzJdLHM9aVszXSx1PWlbNF07aWYodC5vcFR5cGU9PT1yKWZvcihjb25zdCB0IG9mIGUpaWYoKHQuZG9tYWluPT09b3x8XCJhaS5vbm54XCI9PT10LmRvbWFpbiYmXCJcIj09PW8pJiZuKHQudmVyc2lvbixhKSlyZXR1cm57b3BJbXBsOnMsb3BJbml0OnV9fXRocm93IG5ldyBUeXBlRXJyb3IoYGNhbm5vdCByZXNvbHZlIG9wZXJhdG9yICcke3Qub3BUeXBlfScgd2l0aCBvcHNldHM6ICR7ZS5tYXAoKHQ9PmAke3QuZG9tYWlufHxcImFpLm9ubnhcIn0gdiR7dC52ZXJzaW9ufWApKS5qb2luKFwiLCBcIil9YCl9fSw5Mzk1Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLm9ubnhydW50aW1lPXZvaWQgMDtjb25zdCByPW4oNTY4Nik7dmFyIGksbztpPWUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSxmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0LlVOREVGSU5FRD0wXT1cIlVOREVGSU5FRFwiLHRbdC5GTE9BVD0xXT1cIkZMT0FUXCIsdFt0LklOVD0yXT1cIklOVFwiLHRbdC5TVFJJTkc9M109XCJTVFJJTkdcIix0W3QuVEVOU09SPTRdPVwiVEVOU09SXCIsdFt0LkdSQVBIPTVdPVwiR1JBUEhcIix0W3QuRkxPQVRTPTZdPVwiRkxPQVRTXCIsdFt0LklOVFM9N109XCJJTlRTXCIsdFt0LlNUUklOR1M9OF09XCJTVFJJTkdTXCIsdFt0LlRFTlNPUlM9OV09XCJURU5TT1JTXCIsdFt0LkdSQVBIUz0xMF09XCJHUkFQSFNcIix0W3QuU1BBUlNFX1RFTlNPUj0xMV09XCJTUEFSU0VfVEVOU09SXCIsdFt0LlNQQVJTRV9URU5TT1JTPTEyXT1cIlNQQVJTRV9URU5TT1JTXCJ9KGU9dC5BdHRyaWJ1dGVUeXBlfHwodC5BdHRyaWJ1dGVUeXBlPXt9KSl9KChvPWkuZXhwZXJpbWVudGFsfHwoaS5leHBlcmltZW50YWw9e30pKS5mYnN8fChvLmZicz17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5VTktOT1dOPTBdPVwiVU5LTk9XTlwiLHRbdC5WQUxVRT0xXT1cIlZBTFVFXCIsdFt0LlBBUkFNPTJdPVwiUEFSQU1cIn0oZT10LkRpbWVuc2lvblZhbHVlVHlwZXx8KHQuRGltZW5zaW9uVmFsdWVUeXBlPXt9KSl9KHQuZmJzfHwodC5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5VTkRFRklORUQ9MF09XCJVTkRFRklORURcIix0W3QuRkxPQVQ9MV09XCJGTE9BVFwiLHRbdC5VSU5UOD0yXT1cIlVJTlQ4XCIsdFt0LklOVDg9M109XCJJTlQ4XCIsdFt0LlVJTlQxNj00XT1cIlVJTlQxNlwiLHRbdC5JTlQxNj01XT1cIklOVDE2XCIsdFt0LklOVDMyPTZdPVwiSU5UMzJcIix0W3QuSU5UNjQ9N109XCJJTlQ2NFwiLHRbdC5TVFJJTkc9OF09XCJTVFJJTkdcIix0W3QuQk9PTD05XT1cIkJPT0xcIix0W3QuRkxPQVQxNj0xMF09XCJGTE9BVDE2XCIsdFt0LkRPVUJMRT0xMV09XCJET1VCTEVcIix0W3QuVUlOVDMyPTEyXT1cIlVJTlQzMlwiLHRbdC5VSU5UNjQ9MTNdPVwiVUlOVDY0XCIsdFt0LkNPTVBMRVg2ND0xNF09XCJDT01QTEVYNjRcIix0W3QuQ09NUExFWDEyOD0xNV09XCJDT01QTEVYMTI4XCIsdFt0LkJGTE9BVDE2PTE2XT1cIkJGTE9BVDE2XCJ9KGU9dC5UZW5zb3JEYXRhVHlwZXx8KHQuVGVuc29yRGF0YVR5cGU9e30pKX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0LlByaW1pdGl2ZT0wXT1cIlByaW1pdGl2ZVwiLHRbdC5GdXNlZD0xXT1cIkZ1c2VkXCJ9KGU9dC5Ob2RlVHlwZXx8KHQuTm9kZVR5cGU9e30pKX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0Lk5PTkU9MF09XCJOT05FXCIsdFt0LnRlbnNvcl90eXBlPTFdPVwidGVuc29yX3R5cGVcIix0W3Quc2VxdWVuY2VfdHlwZT0yXT1cInNlcXVlbmNlX3R5cGVcIix0W3QubWFwX3R5cGU9M109XCJtYXBfdHlwZVwifShlPXQuVHlwZUluZm9WYWx1ZXx8KHQuVHlwZUluZm9WYWx1ZT17fSkpfSh0LmZic3x8KHQuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzU2hhcGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2hhcGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWRpbShlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfWRpbUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRTaGFwZSh0KXt0LnN0YXJ0T2JqZWN0KDEpfXN0YXRpYyBhZGREaW0odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgY3JlYXRlRGltVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbVZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRTaGFwZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU2hhcGUodCxlKXtyZXR1cm4gbi5zdGFydFNoYXBlKHQpLG4uYWRkRGltKHQsZSksbi5lbmRTaGFwZSh0KX19ZS5TaGFwZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0RpbWVuc2lvbih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9dmFsdWUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfWRlbm90YXRpb24odCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zdGF0aWMgc3RhcnREaW1lbnNpb24odCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkVmFsdWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRGVub3RhdGlvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBlbmREaW1lbnNpb24odCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZURpbWVuc2lvbih0LGUscil7cmV0dXJuIG4uc3RhcnREaW1lbnNpb24odCksbi5hZGRWYWx1ZSh0LGUpLG4uYWRkRGVub3RhdGlvbih0LHIpLG4uZW5kRGltZW5zaW9uKHQpfX1lLkRpbWVuc2lvbj1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uVmFsdWUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uVmFsdWUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWRpbVR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDgodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOfWRpbVZhbHVlKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3Bvcyt0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1QYXJhbSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXN0YXRpYyBzdGFydERpbWVuc2lvblZhbHVlKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZERpbVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50OCgwLG4sdC5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOKX1zdGF0aWMgYWRkRGltVmFsdWUodCxlKXt0LmFkZEZpZWxkSW50NjQoMSxlLHQuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkRGltUGFyYW0odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDIsZSwwKX1zdGF0aWMgZW5kRGltZW5zaW9uVmFsdWUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZURpbWVuc2lvblZhbHVlKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0RGltZW5zaW9uVmFsdWUodCksbi5hZGREaW1UeXBlKHQsZSksbi5hZGREaW1WYWx1ZSh0LHIpLG4uYWRkRGltUGFyYW0odCxpKSxuLmVuZERpbWVuc2lvblZhbHVlKHQpfX1lLkRpbWVuc2lvblZhbHVlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNUZW5zb3JUeXBlQW5kU2hhcGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1lbGVtVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRH1zaGFwZShlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBuPyhlfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlNoYXBlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKHQpe3Quc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEVsZW1UeXBlKGUsbil7ZS5hZGRGaWVsZEludDMyKDAsbix0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkU2hhcGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kVGVuc29yVHlwZUFuZFNoYXBlKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUZW5zb3JUeXBlQW5kU2hhcGUodCxlLHIpe3JldHVybiBuLnN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKHQpLG4uYWRkRWxlbVR5cGUodCxlKSxuLmFkZFNoYXBlKHQsciksbi5lbmRUZW5zb3JUeXBlQW5kU2hhcGUodCl9fWUuVGVuc29yVHlwZUFuZFNoYXBlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNNYXBUeXBlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc01hcFR5cGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWtleVR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2UpOnQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9dmFsdWVUeXBlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRNYXBUeXBlKHQpe3Quc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEtleVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50MzIoMCxuLHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRWYWx1ZVR5cGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kTWFwVHlwZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTWFwVHlwZSh0LGUscil7cmV0dXJuIG4uc3RhcnRNYXBUeXBlKHQpLG4uYWRkS2V5VHlwZSh0LGUpLG4uYWRkVmFsdWVUeXBlKHQsciksbi5lbmRNYXBUeXBlKHQpfX1lLk1hcFR5cGU9bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc1NlcXVlbmNlVHlwZSh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTZXF1ZW5jZVR5cGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWVsZW1UeXBlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRTZXF1ZW5jZVR5cGUodCl7dC5zdGFydE9iamVjdCgxKX1zdGF0aWMgYWRkRWxlbVR5cGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgZW5kU2VxdWVuY2VUeXBlKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVTZXF1ZW5jZVR5cGUodCxlKXtyZXR1cm4gbi5zdGFydFNlcXVlbmNlVHlwZSh0KSxuLmFkZEVsZW1UeXBlKHQsZSksbi5lbmRTZXF1ZW5jZVR5cGUodCl9fWUuU2VxdWVuY2VUeXBlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXsodC5mYnN8fCh0LmZicz17fSkpLkVkZ2VFbmQ9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31ub2RlSW5kZXgoKXtyZXR1cm4gdGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zKX1zcmNBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys0KX1kc3RBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys4KX1zdGF0aWMgY3JlYXRlRWRnZUVuZCh0LGUsbixyKXtyZXR1cm4gdC5wcmVwKDQsMTIpLHQud3JpdGVJbnQzMihyKSx0LndyaXRlSW50MzIobiksdC53cml0ZUludDMyKGUpLHQub2Zmc2V0KCl9fX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNOb2RlRWRnZSh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlRWRnZSh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bm9kZUluZGV4KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYl9wb3MrdCk6MH1pbnB1dEVkZ2VzKGUsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKS5fX2luaXQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSsxMiplLHRoaXMuYmIpOm51bGx9aW5wdXRFZGdlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1vdXRwdXRFZGdlcyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCkuX19pbml0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrMTIqZSx0aGlzLmJiKTpudWxsfW91dHB1dEVkZ2VzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydE5vZGVFZGdlKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE5vZGVJbmRleCh0LGUpe3QuYWRkRmllbGRJbnQzMigwLGUsMCl9c3RhdGljIGFkZElucHV0RWRnZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgc3RhcnRJbnB1dEVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3RvcigxMixlLDQpfXN0YXRpYyBhZGRPdXRwdXRFZGdlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBzdGFydE91dHB1dEVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3RvcigxMixlLDQpfXN0YXRpYyBlbmROb2RlRWRnZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2UodCxlLHIsaSl7cmV0dXJuIG4uc3RhcnROb2RlRWRnZSh0KSxuLmFkZE5vZGVJbmRleCh0LGUpLG4uYWRkSW5wdXRFZGdlcyh0LHIpLG4uYWRkT3V0cHV0RWRnZXModCxpKSxuLmVuZE5vZGVFZGdlKHQpfX1lLk5vZGVFZGdlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNOb2RlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc05vZGUodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfW5hbWUodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1kb2NTdHJpbmcodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1kb21haW4odCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zaW5jZVZlcnNpb24oKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcyt0KTowfWluZGV4KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zK3QpOjB9b3BUeXBlKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXR5cGUoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3BvcytlKTp0LmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlfWV4ZWN1dGlvblByb3ZpZGVyVHlwZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1pbnB1dHModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9aW5wdXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1vdXRwdXRzKHQsZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqdCxlKTpudWxsfW91dHB1dHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfWF0dHJpYnV0ZXMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9YXR0cmlidXRlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9aW5wdXRBcmdDb3VudHModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9aW5wdXRBcmdDb3VudHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfWlucHV0QXJnQ291bnRzQXJyYXkoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gdD9uZXcgSW50MzJBcnJheSh0aGlzLmJiLmJ5dGVzKCkuYnVmZmVyLHRoaXMuYmIuYnl0ZXMoKS5ieXRlT2Zmc2V0K3RoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCksdGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCkpOm51bGx9aW1wbGljaXRJbnB1dHModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9aW1wbGljaXRJbnB1dHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydE5vZGUodCl7dC5zdGFydE9iamVjdCgxMyl9c3RhdGljIGFkZE5hbWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxLGUsMCl9c3RhdGljIGFkZERvbWFpbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBhZGRTaW5jZVZlcnNpb24odCxlKXt0LmFkZEZpZWxkSW50MzIoMyxlLDApfXN0YXRpYyBhZGRJbmRleCh0LGUpe3QuYWRkRmllbGRJbnQzMig0LGUsMCl9c3RhdGljIGFkZE9wVHlwZSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNSxlLDApfXN0YXRpYyBhZGRUeXBlKGUsbil7ZS5hZGRGaWVsZEludDMyKDYsbix0LmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlKX1zdGF0aWMgYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg3LGUsMCl9c3RhdGljIGFkZElucHV0cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOCxlLDApfXN0YXRpYyBjcmVhdGVJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW5wdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZE91dHB1dHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDksZSwwKX1zdGF0aWMgY3JlYXRlT3V0cHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRPdXRwdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEF0dHJpYnV0ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEwLGUsMCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0QXR0cmlidXRlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbnB1dEFyZ0NvdW50cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTEsZSwwKX1zdGF0aWMgY3JlYXRlSW5wdXRBcmdDb3VudHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQzMihlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRJbnB1dEFyZ0NvdW50c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbXBsaWNpdElucHV0cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTIsZSwwKX1zdGF0aWMgY3JlYXRlSW1wbGljaXRJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW1wbGljaXRJbnB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgZW5kTm9kZSh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTm9kZSh0LGUscixpLG8sYSxzLHUsYyxsLHAsZixkLGgpe3JldHVybiBuLnN0YXJ0Tm9kZSh0KSxuLmFkZE5hbWUodCxlKSxuLmFkZERvY1N0cmluZyh0LHIpLG4uYWRkRG9tYWluKHQsaSksbi5hZGRTaW5jZVZlcnNpb24odCxvKSxuLmFkZEluZGV4KHQsYSksbi5hZGRPcFR5cGUodCxzKSxuLmFkZFR5cGUodCx1KSxuLmFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZSh0LGMpLG4uYWRkSW5wdXRzKHQsbCksbi5hZGRPdXRwdXRzKHQscCksbi5hZGRBdHRyaWJ1dGVzKHQsZiksbi5hZGRJbnB1dEFyZ0NvdW50cyh0LGQpLG4uYWRkSW1wbGljaXRJbnB1dHModCxoKSxuLmVuZE5vZGUodCl9fWUuTm9kZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVmFsdWVJbmZvKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1ZhbHVlSW5mbyh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bmFtZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXR5cGUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbykuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXN0YXRpYyBzdGFydFZhbHVlSW5mbyh0KXt0LnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGROYW1lKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgwLGUsMCl9c3RhdGljIGFkZERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBhZGRUeXBlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZFZhbHVlSW5mbyh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlVmFsdWVJbmZvKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0VmFsdWVJbmZvKHQpLG4uYWRkTmFtZSh0LGUpLG4uYWRkRG9jU3RyaW5nKHQsciksbi5hZGRUeXBlKHQsaSksbi5lbmRWYWx1ZUluZm8odCl9fWUuVmFsdWVJbmZvPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNUeXBlSW5mbyh0LGUpe3JldHVybihlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUeXBlSW5mbyh0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9ZGVub3RhdGlvbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfXZhbHVlVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkVWludDgodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORX12YWx1ZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIuX191bmlvbih0LHRoaXMuYmJfcG9zK2UpOm51bGx9c3RhdGljIHN0YXJ0VHlwZUluZm8odCl7dC5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkRGVub3RhdGlvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRWYWx1ZVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50OCgxLG4sdC5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORSl9c3RhdGljIGFkZFZhbHVlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZFR5cGVJbmZvKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUeXBlSW5mbyh0LGUscixpKXtyZXR1cm4gbi5zdGFydFR5cGVJbmZvKHQpLG4uYWRkRGVub3RhdGlvbih0LGUpLG4uYWRkVmFsdWVUeXBlKHQsciksbi5hZGRWYWx1ZSh0LGkpLG4uZW5kVHlwZUluZm8odCl9fWUuVHlwZUluZm89bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBle2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc09wZXJhdG9yU2V0SWQodCxuKXtyZXR1cm4obnx8bmV3IGUpLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzT3BlcmF0b3JTZXRJZCh0LG4pe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKG58fG5ldyBlKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9ZG9tYWluKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dmVyc2lvbigpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9c3RhdGljIHN0YXJ0T3BlcmF0b3JTZXRJZCh0KXt0LnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGREb21haW4odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkVmVyc2lvbih0LGUpe3QuYWRkRmllbGRJbnQ2NCgxLGUsdC5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBlbmRPcGVyYXRvclNldElkKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVPcGVyYXRvclNldElkKHQsbixyKXtyZXR1cm4gZS5zdGFydE9wZXJhdG9yU2V0SWQodCksZS5hZGREb21haW4odCxuKSxlLmFkZFZlcnNpb24odCxyKSxlLmVuZE9wZXJhdG9yU2V0SWQodCl9fXQuT3BlcmF0b3JTZXRJZD1lfSh0LmZic3x8KHQuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVGVuc29yKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvcih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bmFtZSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRpbXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpKzgqdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9ZGltc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1kYXRhVHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK2UpOnQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9cmF3RGF0YSh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50OCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpK3QpOjB9cmF3RGF0YUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9cmF3RGF0YUFycmF5KCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIHQ/bmV3IFVpbnQ4QXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpKTpudWxsfXN0cmluZ0RhdGEodCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9c3RyaW5nRGF0YUxlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9c3RhdGljIHN0YXJ0VGVuc29yKHQpe3Quc3RhcnRPYmplY3QoNil9c3RhdGljIGFkZE5hbWUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxLGUsMCl9c3RhdGljIGFkZERpbXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDIsZSwwKX1zdGF0aWMgY3JlYXRlRGltc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoOCxlLmxlbmd0aCw4KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZEludDY0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZSw4KX1zdGF0aWMgYWRkRGF0YVR5cGUoZSxuKXtlLmFkZEZpZWxkSW50MzIoMyxuLHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRSYXdEYXRhKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg0LGUsMCl9c3RhdGljIGNyZWF0ZVJhd0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDEsZS5sZW5ndGgsMSk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ4KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFJhd0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDEsZSwxKX1zdGF0aWMgYWRkU3RyaW5nRGF0YSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNSxlLDApfXN0YXRpYyBjcmVhdGVTdHJpbmdEYXRhVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ0RhdGFWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgZW5kVGVuc29yKHQpe3JldHVybiB0LmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUZW5zb3IodCxlLHIsaSxvLGEscyl7cmV0dXJuIG4uc3RhcnRUZW5zb3IodCksbi5hZGROYW1lKHQsZSksbi5hZGREb2NTdHJpbmcodCxyKSxuLmFkZERpbXModCxpKSxuLmFkZERhdGFUeXBlKHQsbyksbi5hZGRSYXdEYXRhKHQsYSksbi5hZGRTdHJpbmdEYXRhKHQscyksbi5lbmRUZW5zb3IodCl9fWUuVGVuc29yPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNTcGFyc2VUZW5zb3IodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3BhcnNlVGVuc29yKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX12YWx1ZXMoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1pbmRpY2VzKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZGltcyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrZSkrOCp0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1zTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydFNwYXJzZVRlbnNvcih0KXt0LnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGRWYWx1ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkSW5kaWNlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBhZGREaW1zKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGNyZWF0ZURpbXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZS5sZW5ndGgsOCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ2NChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnREaW1zVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig4LGUsOCl9c3RhdGljIGVuZFNwYXJzZVRlbnNvcih0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU3BhcnNlVGVuc29yKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0U3BhcnNlVGVuc29yKHQpLG4uYWRkVmFsdWVzKHQsZSksbi5hZGRJbmRpY2VzKHQsciksbi5hZGREaW1zKHQsaSksbi5lbmRTcGFyc2VUZW5zb3IodCl9fWUuU3BhcnNlVGVuc29yPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNBdHRyaWJ1dGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzQXR0cmlidXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1uYW1lKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9ZG9jU3RyaW5nKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dHlwZSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrZSk6dC5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEfWYoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zK3QpOjB9aSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zK3QpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9dChlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1nKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTgpO3JldHVybiBuPyhlfHxuZXcgdC5leHBlcmltZW50YWwuZmJzLkdyYXBoKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZmxvYXRzKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiBlP3RoaXMuYmIucmVhZEZsb2F0MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9ZmxvYXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1mbG9hdHNBcnJheSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiB0P25ldyBGbG9hdDMyQXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpKTpudWxsfWludHModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs4KnQpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWludHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0cmluZ3ModCxlKXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCp0LGUpOm51bGx9c3RyaW5nc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9dGVuc29ycyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqZSksdGhpcy5iYik6bnVsbH10ZW5zb3JzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1ncmFwaHMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5HcmFwaCkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqZSksdGhpcy5iYik6bnVsbH1ncmFwaHNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfXN0YXRpYyBzdGFydEF0dHJpYnV0ZSh0KXt0LnN0YXJ0T2JqZWN0KDEzKX1zdGF0aWMgYWRkTmFtZSh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGREb2NTdHJpbmcodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgYWRkVHlwZShlLG4pe2UuYWRkRmllbGRJbnQzMigyLG4sdC5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkRih0LGUpe3QuYWRkRmllbGRGbG9hdDMyKDMsZSwwKX1zdGF0aWMgYWRkSSh0LGUpe3QuYWRkRmllbGRJbnQ2NCg0LGUsdC5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBhZGRTKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg1LGUsMCl9c3RhdGljIGFkZFQodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDYsZSwwKX1zdGF0aWMgYWRkRyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNyxlLDApfXN0YXRpYyBhZGRGbG9hdHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDgsZSwwKX1zdGF0aWMgY3JlYXRlRmxvYXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkRmxvYXQzMihlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRGbG9hdHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkSW50cyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOSxlLDApfXN0YXRpYyBjcmVhdGVJbnRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig4LGUubGVuZ3RoLDgpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkSW50NjQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW50c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoOCxlLDgpfXN0YXRpYyBhZGRTdHJpbmdzKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgxMCxlLDApfXN0YXRpYyBjcmVhdGVTdHJpbmdzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ3NWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkVGVuc29ycyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTEsZSwwKX1zdGF0aWMgY3JlYXRlVGVuc29yc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRUZW5zb3JzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEdyYXBocyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMTIsZSwwKX1zdGF0aWMgY3JlYXRlR3JhcGhzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEdyYXBoc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRBdHRyaWJ1dGUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZSh0LGUscixpLG8sYSxzLHUsYyxsLHAsZixkLGgpe3JldHVybiBuLnN0YXJ0QXR0cmlidXRlKHQpLG4uYWRkTmFtZSh0LGUpLG4uYWRkRG9jU3RyaW5nKHQsciksbi5hZGRUeXBlKHQsaSksbi5hZGRGKHQsbyksbi5hZGRJKHQsYSksbi5hZGRTKHQscyksbi5hZGRUKHQsdSksbi5hZGRHKHQsYyksbi5hZGRGbG9hdHModCxsKSxuLmFkZEludHModCxwKSxuLmFkZFN0cmluZ3ModCxmKSxuLmFkZFRlbnNvcnModCxkKSxuLmFkZEdyYXBocyh0LGgpLG4uZW5kQXR0cmlidXRlKHQpfX1lLkF0dHJpYnV0ZT1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzR3JhcGgodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzR3JhcGgodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWluaXRpYWxpemVycyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfWluaXRpYWxpemVyc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1ub2RlQXJncyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHI/KG58fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVBcmdzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfW5vZGVzKGUsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5Ob2RlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KTowfW1heE5vZGVJbmRleCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiB0P3RoaXMuYmIucmVhZFVpbnQzMih0aGlzLmJiX3Bvcyt0KTowfW5vZGVFZGdlcyhlLG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfW5vZGVFZGdlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9aW5wdXRzKHQsZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqdCxlKTpudWxsfWlucHV0c0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9b3V0cHV0cyh0LGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTYpO3JldHVybiBuP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytuKSs0KnQsZSk6bnVsbH1vdXRwdXRzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zcGFyc2VJbml0aWFsaXplcnMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gcj8obnx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9c3BhcnNlSW5pdGlhbGl6ZXJzTGVuZ3RoKCl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRHcmFwaCh0KXt0LnN0YXJ0T2JqZWN0KDgpfXN0YXRpYyBhZGRJbml0aWFsaXplcnModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgY3JlYXRlSW5pdGlhbGl6ZXJzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEluaXRpYWxpemVyc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGROb2RlQXJncyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBjcmVhdGVOb2RlQXJnc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2RlQXJnc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGROb2Rlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMixlLDApfXN0YXRpYyBjcmVhdGVOb2Rlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZE9mZnNldChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2Rlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRNYXhOb2RlSW5kZXgodCxlKXt0LmFkZEZpZWxkSW50MzIoMyxlLDApfXN0YXRpYyBhZGROb2RlRWRnZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDQsZSwwKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVFZGdlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRJbnB1dHModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDUsZSwwKX1zdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydElucHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRPdXRwdXRzKHQsZSl7dC5hZGRGaWVsZE9mZnNldCg2LGUsMCl9c3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBhZGRTcGFyc2VJbml0aWFsaXplcnModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDcsZSwwKX1zdGF0aWMgY3JlYXRlU3BhcnNlSW5pdGlhbGl6ZXJzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFNwYXJzZUluaXRpYWxpemVyc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRHcmFwaCh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlR3JhcGgodCxlLHIsaSxvLGEscyx1LGMpe3JldHVybiBuLnN0YXJ0R3JhcGgodCksbi5hZGRJbml0aWFsaXplcnModCxlKSxuLmFkZE5vZGVBcmdzKHQsciksbi5hZGROb2Rlcyh0LGkpLG4uYWRkTWF4Tm9kZUluZGV4KHQsbyksbi5hZGROb2RlRWRnZXModCxhKSxuLmFkZElucHV0cyh0LHMpLG4uYWRkT3V0cHV0cyh0LHUpLG4uYWRkU3BhcnNlSW5pdGlhbGl6ZXJzKHQsYyksbi5lbmRHcmFwaCh0KX19ZS5HcmFwaD1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbih0KXshZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQodCxlKXtyZXR1cm4gdGhpcy5iYl9wb3M9dCx0aGlzLmJiPWUsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTW9kZWwodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTW9kZWwodCxlKXtyZXR1cm4gdC5zZXRQb3NpdGlvbih0LnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLChlfHxuZXcgbikuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfWlyVmVyc2lvbigpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrdCk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9b3BzZXRJbXBvcnQoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KmUpLHRoaXMuYmIpOm51bGx9b3BzZXRJbXBvcnRMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9cHJvZHVjZXJOYW1lKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9cHJvZHVjZXJWZXJzaW9uKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfWRvbWFpbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1tb2RlbFZlcnNpb24oKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3Bvcyt0KTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kb2NTdHJpbmcodCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9Z3JhcGgoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1ncmFwaERvY1N0cmluZyh0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gZT90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK2UsdCk6bnVsbH1zdGF0aWMgc3RhcnRNb2RlbCh0KXt0LnN0YXJ0T2JqZWN0KDkpfXN0YXRpYyBhZGRJclZlcnNpb24odCxlKXt0LmFkZEZpZWxkSW50NjQoMCxlLHQuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkT3BzZXRJbXBvcnQodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgY3JlYXRlT3BzZXRJbXBvcnRWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZS5sZW5ndGgsNCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRPZmZzZXQoZVtuXSk7cmV0dXJuIHQuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3BzZXRJbXBvcnRWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDQsZSw0KX1zdGF0aWMgYWRkUHJvZHVjZXJOYW1lKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGFkZFByb2R1Y2VyVmVyc2lvbih0LGUpe3QuYWRkRmllbGRPZmZzZXQoMyxlLDApfXN0YXRpYyBhZGREb21haW4odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDQsZSwwKX1zdGF0aWMgYWRkTW9kZWxWZXJzaW9uKHQsZSl7dC5hZGRGaWVsZEludDY0KDUsZSx0LmNyZWF0ZUxvbmcoMCwwKSl9c3RhdGljIGFkZERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNixlLDApfXN0YXRpYyBhZGRHcmFwaCh0LGUpe3QuYWRkRmllbGRPZmZzZXQoNyxlLDApfXN0YXRpYyBhZGRHcmFwaERvY1N0cmluZyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoOCxlLDApfXN0YXRpYyBlbmRNb2RlbCh0KXtyZXR1cm4gdC5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTW9kZWwodCxlLHIsaSxvLGEscyx1LGMsbCl7cmV0dXJuIG4uc3RhcnRNb2RlbCh0KSxuLmFkZElyVmVyc2lvbih0LGUpLG4uYWRkT3BzZXRJbXBvcnQodCxyKSxuLmFkZFByb2R1Y2VyTmFtZSh0LGkpLG4uYWRkUHJvZHVjZXJWZXJzaW9uKHQsbyksbi5hZGREb21haW4odCxhKSxuLmFkZE1vZGVsVmVyc2lvbih0LHMpLG4uYWRkRG9jU3RyaW5nKHQsdSksbi5hZGRHcmFwaCh0LGMpLG4uYWRkR3JhcGhEb2NTdHJpbmcodCxsKSxuLmVuZE1vZGVsKHQpfX1lLk1vZGVsPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3MgZXtjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyh0LG4pe3JldHVybihufHxuZXcgZSkuX19pbml0KHQucmVhZEludDMyKHQucG9zaXRpb24oKSkrdC5wb3NpdGlvbigpLHQpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyh0LG4pe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKG58fG5ldyBlKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9bm9kZUluZGljZXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs0KnQpOjB9bm9kZUluZGljZXNMZW5ndGgoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK3QpOjB9bm9kZUluZGljZXNBcnJheSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/bmV3IFVpbnQzMkFycmF5KHRoaXMuYmIuYnl0ZXMoKS5idWZmZXIsdGhpcy5iYi5ieXRlcygpLmJ5dGVPZmZzZXQrdGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KSx0aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3Bvcyt0KSk6bnVsbH1rZXJuZWxEZWZIYXNoZXModCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSs4KnQpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWtlcm5lbERlZkhhc2hlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyh0KXt0LnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGROb2RlSW5kaWNlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBjcmVhdGVOb2RlSW5kaWNlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLmxlbmd0aCw0KTtmb3IobGV0IG49ZS5sZW5ndGgtMTtuPj0wO24tLSl0LmFkZEludDMyKGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVJbmRpY2VzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUsNCl9c3RhdGljIGFkZEtlcm5lbERlZkhhc2hlcyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMSxlLDApfXN0YXRpYyBjcmVhdGVLZXJuZWxEZWZIYXNoZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZS5sZW5ndGgsOCk7Zm9yKGxldCBuPWUubGVuZ3RoLTE7bj49MDtuLS0pdC5hZGRJbnQ2NChlW25dKTtyZXR1cm4gdC5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRLZXJuZWxEZWZIYXNoZXNWZWN0b3IodCxlKXt0LnN0YXJ0VmVjdG9yKDgsZSw4KX1zdGF0aWMgZW5kS2VybmVsQ3JlYXRlSW5mb3ModCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUtlcm5lbENyZWF0ZUluZm9zKHQsbixyKXtyZXR1cm4gZS5zdGFydEtlcm5lbENyZWF0ZUluZm9zKHQpLGUuYWRkTm9kZUluZGljZXModCxuKSxlLmFkZEtlcm5lbERlZkhhc2hlcyh0LHIpLGUuZW5kS2VybmVsQ3JlYXRlSW5mb3ModCl9fXQuS2VybmVsQ3JlYXRlSW5mb3M9ZX0odC5mYnN8fCh0LmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1ncmFwaElkKHQpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3BvcytlLHQpOm51bGx9c2Vzc2lvblN0YXRlKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUodCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkR3JhcGhJZCh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRTZXNzaW9uU3RhdGUodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUodCl7bGV0IGU9dC5lbmRPYmplY3QoKTtyZXR1cm4gdC5yZXF1aXJlZEZpZWxkKGUsNCksZX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGUodCxlLHIpe3JldHVybiBuLnN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUodCksbi5hZGRHcmFwaElkKHQsZSksbi5hZGRTZXNzaW9uU3RhdGUodCxyKSxuLmVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlKHQpfX1lLlN1YkdyYXBoU2Vzc2lvblN0YXRlPW59KGUuZmJzfHwoZS5mYnM9e30pKX0odC5leHBlcmltZW50YWx8fCh0LmV4cGVyaW1lbnRhbD17fSkpfShlLm9ubnhydW50aW1lfHwoZS5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdCh0LGUpe3JldHVybiB0aGlzLmJiX3Bvcz10LHRoaXMuYmI9ZSx0aGlzfXN0YXRpYyBnZXRSb290QXNTZXNzaW9uU3RhdGUodCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2Vzc2lvblN0YXRlKHQsZSl7cmV0dXJuIHQuc2V0UG9zaXRpb24odC5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwoZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1rZXJuZWxzKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3MpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdWJHcmFwaFNlc3Npb25TdGF0ZXMoZSxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgdC5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCplKSx0aGlzLmJiKTpudWxsfXN1YkdyYXBoU2Vzc2lvblN0YXRlc0xlbmd0aCgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrdCk6MH1zdGF0aWMgc3RhcnRTZXNzaW9uU3RhdGUodCl7dC5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkS2VybmVscyh0LGUpe3QuYWRkRmllbGRPZmZzZXQoMCxlLDApfXN0YXRpYyBhZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXModCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKHQsZSl7dC5zdGFydFZlY3Rvcig0LGUubGVuZ3RoLDQpO2ZvcihsZXQgbj1lLmxlbmd0aC0xO24+PTA7bi0tKXQuYWRkT2Zmc2V0KGVbbl0pO3JldHVybiB0LmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlc1ZlY3Rvcih0LGUpe3Quc3RhcnRWZWN0b3IoNCxlLDQpfXN0YXRpYyBlbmRTZXNzaW9uU3RhdGUodCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVNlc3Npb25TdGF0ZSh0LGUscil7cmV0dXJuIG4uc3RhcnRTZXNzaW9uU3RhdGUodCksbi5hZGRLZXJuZWxzKHQsZSksbi5hZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXModCxyKSxuLmVuZFNlc3Npb25TdGF0ZSh0KX19ZS5TZXNzaW9uU3RhdGU9bn0oZS5mYnN8fChlLmZicz17fSkpfSh0LmV4cGVyaW1lbnRhbHx8KHQuZXhwZXJpbWVudGFsPXt9KSl9KGUub25ueHJ1bnRpbWV8fChlLm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24odCl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KHQsZSl7cmV0dXJuIHRoaXMuYmJfcG9zPXQsdGhpcy5iYj1lLHRoaXN9c3RhdGljIGdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24odCxlKXtyZXR1cm4oZXx8bmV3IG4pLl9faW5pdCh0LnJlYWRJbnQzMih0LnBvc2l0aW9uKCkpK3QucG9zaXRpb24oKSx0KX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzSW5mZXJlbmNlU2Vzc2lvbih0LGUpe3JldHVybiB0LnNldFBvc2l0aW9uKHQucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKGV8fG5ldyBuKS5fX2luaXQodC5yZWFkSW50MzIodC5wb3NpdGlvbigpKSt0LnBvc2l0aW9uKCksdCl9c3RhdGljIGJ1ZmZlckhhc0lkZW50aWZpZXIodCl7cmV0dXJuIHQuX19oYXNfaWRlbnRpZmllcihcIk9SVE1cIil9b3J0VmVyc2lvbih0KXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrZSx0KTpudWxsfW1vZGVsKGUpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KGV8fG5ldyB0LmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zZXNzaW9uU3RhdGUoZSl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbj8oZXx8bmV3IHQuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRJbmZlcmVuY2VTZXNzaW9uKHQpe3Quc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE9ydFZlcnNpb24odCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDAsZSwwKX1zdGF0aWMgYWRkTW9kZWwodCxlKXt0LmFkZEZpZWxkT2Zmc2V0KDEsZSwwKX1zdGF0aWMgYWRkU2Vzc2lvblN0YXRlKHQsZSl7dC5hZGRGaWVsZE9mZnNldCgyLGUsMCl9c3RhdGljIGVuZEluZmVyZW5jZVNlc3Npb24odCl7cmV0dXJuIHQuZW5kT2JqZWN0KCl9c3RhdGljIGZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIodCxlKXt0LmZpbmlzaChlLFwiT1JUTVwiKX1zdGF0aWMgZmluaXNoU2l6ZVByZWZpeGVkSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcih0LGUpe3QuZmluaXNoKGUsXCJPUlRNXCIsITApfXN0YXRpYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uKHQsZSxyLGkpe3JldHVybiBuLnN0YXJ0SW5mZXJlbmNlU2Vzc2lvbih0KSxuLmFkZE9ydFZlcnNpb24odCxlKSxuLmFkZE1vZGVsKHQsciksbi5hZGRTZXNzaW9uU3RhdGUodCxpKSxuLmVuZEluZmVyZW5jZVNlc3Npb24odCl9fWUuSW5mZXJlbmNlU2Vzc2lvbj1ufShlLmZic3x8KGUuZmJzPXt9KSl9KHQuZXhwZXJpbWVudGFsfHwodC5leHBlcmltZW50YWw9e30pKX0oZS5vbm54cnVudGltZXx8KGUub25ueHJ1bnRpbWU9e30pKX0sNzQ0ODoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5Pbm54anNTZXNzaW9uSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDE2NzApLGk9big5MTYyKTtlLk9ubnhqc1Nlc3Npb25IYW5kbGVyPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc2Vzc2lvbj10LHRoaXMuaW5wdXROYW1lcz10aGlzLnNlc3Npb24uaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzPXRoaXMuc2Vzc2lvbi5vdXRwdXROYW1lc31hc3luYyBkaXNwb3NlKCl7fWFzeW5jIHJ1bih0LGUsbil7Y29uc3Qgbz1uZXcgTWFwO2Zvcihjb25zdCBlIGluIHQpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxlKSl7Y29uc3Qgbj10W2VdO28uc2V0KGUsbmV3IGkuVGVuc29yKG4uZGltcyxuLnR5cGUsdm9pZCAwLHZvaWQgMCxuLmRhdGEpKX1jb25zdCBhPWF3YWl0IHRoaXMuc2Vzc2lvbi5ydW4obykscz17fTtyZXR1cm4gYS5mb3JFYWNoKCgodCxlKT0+e3NbZV09bmV3IHIuVGVuc29yKHQudHlwZSx0LmRhdGEsdC5kaW1zKX0pKSxzfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLnN0YXJ0UHJvZmlsaW5nKCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLmVuZFByb2ZpbGluZygpfX19LDY5MTk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuU2Vzc2lvbj12b2lkIDA7Y29uc3Qgcj1uKDcwNjcpLGk9bigxMjk2KSxvPW4oNzA5MSksYT1uKDEwMzYpLHM9big2MjMxKSx1PW4oMjY0NCk7ZS5TZXNzaW9uPWNsYXNze2NvbnN0cnVjdG9yKHQ9e30pe3RoaXMuX2luaXRpYWxpemVkPSExLHRoaXMuYmFja2VuZEhpbnQ9dC5iYWNrZW5kSGludCx0aGlzLnByb2ZpbGVyPXMuUHJvZmlsZXIuY3JlYXRlKHQucHJvZmlsZXIpLHRoaXMuY29udGV4dD17cHJvZmlsZXI6dGhpcy5wcm9maWxlcixncmFwaElucHV0VHlwZXM6W10sZ3JhcGhJbnB1dERpbXM6W119fWdldCBpbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0TmFtZXMoKX1nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0T3V0cHV0TmFtZXMoKX1zdGFydFByb2ZpbGluZygpe3RoaXMucHJvZmlsZXIuc3RhcnQoKX1lbmRQcm9maWxpbmcoKXt0aGlzLnByb2ZpbGVyLnN0b3AoKX1hc3luYyBsb2FkTW9kZWwodCxlLG4pe2F3YWl0IHRoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJTZXNzaW9uLmxvYWRNb2RlbFwiLChhc3luYygpPT57Y29uc3QgYT1hd2FpdCgwLG8ucmVzb2x2ZUJhY2tlbmQpKHRoaXMuYmFja2VuZEhpbnQpO2lmKHRoaXMuc2Vzc2lvbkhhbmRsZXI9YS5jcmVhdGVTZXNzaW9uSGFuZGxlcih0aGlzLmNvbnRleHQpLHRoaXMuX21vZGVsPW5ldyB1Lk1vZGVsLFwic3RyaW5nXCI9PXR5cGVvZiB0KXtjb25zdCBlPXQuZW5kc1dpdGgoXCIub3J0XCIpO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaCl7Y29uc3Qgbj1hd2FpdCgwLGkucHJvbWlzaWZ5KShyLnJlYWRGaWxlKSh0KTt0aGlzLmluaXRpYWxpemUobixlKX1lbHNle2NvbnN0IG49YXdhaXQgZmV0Y2godCkscj1hd2FpdCBuLmFycmF5QnVmZmVyKCk7dGhpcy5pbml0aWFsaXplKG5ldyBVaW50OEFycmF5KHIpLGUpfX1lbHNlIGlmKEFycmF5QnVmZmVyLmlzVmlldyh0KSl0aGlzLmluaXRpYWxpemUodCk7ZWxzZXtjb25zdCByPW5ldyBVaW50OEFycmF5KHQsZXx8MCxufHx0LmJ5dGVMZW5ndGgpO3RoaXMuaW5pdGlhbGl6ZShyKX19KSl9aW5pdGlhbGl6ZSh0LGUpe2lmKHRoaXMuX2luaXRpYWxpemVkKXRocm93IG5ldyBFcnJvcihcImFscmVhZHkgaW5pdGlhbGl6ZWRcIik7dGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIlNlc3Npb24uaW5pdGlhbGl6ZVwiLCgoKT0+e2NvbnN0IG49dGhpcy5zZXNzaW9uSGFuZGxlci50cmFuc2Zvcm1HcmFwaD90aGlzLnNlc3Npb25IYW5kbGVyOnZvaWQgMDt0aGlzLl9tb2RlbC5sb2FkKHQsbixlKSx0aGlzLnNlc3Npb25IYW5kbGVyLm9uR3JhcGhJbml0aWFsaXplZCYmdGhpcy5zZXNzaW9uSGFuZGxlci5vbkdyYXBoSW5pdGlhbGl6ZWQodGhpcy5fbW9kZWwuZ3JhcGgpLHRoaXMuaW5pdGlhbGl6ZU9wcyh0aGlzLl9tb2RlbC5ncmFwaCksdGhpcy5fZXhlY3V0aW9uUGxhbj1uZXcgYS5FeGVjdXRpb25QbGFuKHRoaXMuX21vZGVsLmdyYXBoLHRoaXMuX29wcyx0aGlzLnByb2ZpbGVyKX0pKSx0aGlzLl9pbml0aWFsaXplZD0hMH1hc3luYyBydW4odCl7aWYoIXRoaXMuX2luaXRpYWxpemVkKXRocm93IG5ldyBFcnJvcihcInNlc3Npb24gbm90IGluaXRpYWxpemVkIHlldFwiKTtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIlNlc3Npb24ucnVuXCIsKGFzeW5jKCk9Pntjb25zdCBlPXRoaXMubm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHModCksbj1hd2FpdCB0aGlzLl9leGVjdXRpb25QbGFuLmV4ZWN1dGUodGhpcy5zZXNzaW9uSGFuZGxlcixlKTtyZXR1cm4gdGhpcy5jcmVhdGVPdXRwdXQobil9KSl9bm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHModCl7Y29uc3QgZT10aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dE5hbWVzKCk7aWYoQXJyYXkuaXNBcnJheSh0KSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGluY29ycmVjdCBpbnB1dCBhcnJheSBsZW5ndGg6IGV4cGVjdGVkICR7ZS5sZW5ndGh9IGJ1dCBnb3QgJHt0Lmxlbmd0aH1gKX1lbHNle2lmKHQuc2l6ZSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5jb3JyZWN0IGlucHV0IG1hcCBzaXplOiBleHBlY3RlZCAke2UubGVuZ3RofSBidXQgZ290ICR7dC5zaXplfWApO2NvbnN0IG49bmV3IEFycmF5KHQuc2l6ZSk7bGV0IHI9MDtmb3IobGV0IGk9MDtpPGUubGVuZ3RoOysraSl7Y29uc3Qgbz10LmdldChlW2ldKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgdGVuc29yIGZvcjogJyR7bmFtZX0nYCk7bltyKytdPW99dD1ufWlmKHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMmJjAhPT10aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLmxlbmd0aCYmdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zJiYwIT09dGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLmxlbmd0aCl0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcyx0LCExKTtlbHNle2NvbnN0IGU9dGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXRJbmRpY2VzKCksbj10aGlzLl9tb2RlbC5ncmFwaC5nZXRWYWx1ZXMoKSxyPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDsrK2kpe2NvbnN0IG89bltlW2ldXTtyW2ldPW8udHlwZS5zaGFwZS5kaW1zLHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMucHVzaChvLnR5cGUudGVuc29yVHlwZSksdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLnB1c2godFtpXS5kaW1zKX10aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHIsdCwhMCl9cmV0dXJuIHRoaXMudmFsaWRhdGVJbnB1dFRlbnNvclR5cGVzKHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMsdCksdH12YWxpZGF0ZUlucHV0VGVuc29yVHlwZXModCxlKXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7Y29uc3Qgcj10W25dLGk9ZVtuXS50eXBlO2lmKHIhPT1pKXRocm93IG5ldyBFcnJvcihgaW5wdXQgdGVuc29yWyR7bn1dIGNoZWNrIGZhaWxlZDogZXhwZWN0ZWQgdHlwZSAnJHtyfScgYnV0IGdvdCAke2l9YCl9fXZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHQsZSxuKXtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7Y29uc3QgaT10W3JdLG89ZVtyXS5kaW1zO2lmKCF0aGlzLmNvbXBhcmVUZW5zb3JEaW1zKGksbyxuKSl0aHJvdyBuZXcgRXJyb3IoYGlucHV0IHRlbnNvclske3J9XSBjaGVjayBmYWlsZWQ6IGV4cGVjdGVkIHNoYXBlICdbJHtpLmpvaW4oXCIsXCIpfV0nIGJ1dCBnb3QgWyR7by5qb2luKFwiLFwiKX1dYCl9fWNvbXBhcmVUZW5zb3JEaW1zKHQsZSxuKXtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7KytyKWlmKHRbcl0hPT1lW3JdJiYoIW58fDAhPT10W3JdKSlyZXR1cm4hMTtyZXR1cm4hMH1jcmVhdGVPdXRwdXQodCl7Y29uc3QgZT10aGlzLl9tb2RlbC5ncmFwaC5nZXRPdXRwdXROYW1lcygpO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgbnVtYmVyIG9mIG91dHB1dHMgZG8gbm90IG1hdGNoIG51bWJlciBvZiBnZW5lcmF0ZWQgb3V0cHV0c1wiKTtjb25zdCBuPW5ldyBNYXA7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3Ipbi5zZXQoZVtyXSx0W3JdKTtyZXR1cm4gbn1pbml0aWFsaXplT3BzKHQpe2NvbnN0IGU9dC5nZXROb2RlcygpO3RoaXMuX29wcz1uZXcgQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXRoaXMuX29wc1tuXT10aGlzLnNlc3Npb25IYW5kbGVyLnJlc29sdmUoZVtuXSx0aGlzLl9tb2RlbC5vcHNldHMsdCl9fX0sOTE2MjpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGU/dDp7ZGVmYXVsdDp0fX07T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5UZW5zb3I9dm9pZCAwO2NvbnN0IGk9bigzNDQyKSxvPXIobigzNzIwKSksYT1uKDE0NDYpLHM9big5Mzk1KSx1PW4oMjUxNyk7dmFyIGM9cy5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO2NsYXNzIGx7Z2V0IGRhdGEoKXtpZih2b2lkIDA9PT10aGlzLmNhY2hlKXtjb25zdCB0PXRoaXMuZGF0YVByb3ZpZGVyKHRoaXMuZGF0YUlkKTtpZih0Lmxlbmd0aCE9PXRoaXMuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJMZW5ndGggb2YgZGF0YSBwcm92aWRlZCBieSB0aGUgRGF0YSBQcm92aWRlciBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgZGltcyBvZiB0aGlzIFRlbnNvci5cIik7dGhpcy5jYWNoZT10fXJldHVybiB0aGlzLmNhY2hlfWdldCBzdHJpbmdEYXRhKCl7aWYoXCJzdHJpbmdcIiE9PXRoaXMudHlwZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBzdHJpbmdcIik7cmV0dXJuIHRoaXMuZGF0YX1nZXQgaW50ZWdlckRhdGEoKXtzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJ1aW50OFwiOmNhc2VcImludDhcIjpjYXNlXCJ1aW50MTZcIjpjYXNlXCJpbnQxNlwiOmNhc2VcImludDMyXCI6Y2FzZVwidWludDMyXCI6Y2FzZVwiYm9vbFwiOnJldHVybiB0aGlzLmRhdGE7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBpbnRlZ2VyICh1aW50OCwgaW50OCwgdWludDE2LCBpbnQxNiwgaW50MzIsIHVpbnQzMiwgYm9vbClcIil9fWdldCBmbG9hdERhdGEoKXtzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJmbG9hdDMyXCI6Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiB0aGlzLmRhdGE7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGF0YSB0eXBlIGlzIG5vdCBmbG9hdCAoZmxvYXQzMiwgZmxvYXQ2NClcIil9fWdldCBudW1iZXJEYXRhKCl7aWYoXCJzdHJpbmdcIiE9PXRoaXMudHlwZSlyZXR1cm4gdGhpcy5kYXRhO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJ0eXBlIGNhbm5vdCBiZSBub24tbnVtYmVyIChzdHJpbmcpXCIpfWdldCh0KXtyZXR1cm4gdGhpcy5kYXRhW3UuU2hhcGVVdGlsLmluZGljZXNUb09mZnNldCh0LHRoaXMuc3RyaWRlcyldfXNldCh0LGUpe3RoaXMuZGF0YVt1LlNoYXBlVXRpbC5pbmRpY2VzVG9PZmZzZXQodCx0aGlzLnN0cmlkZXMpXT1lfWFzeW5jIGdldERhdGEoKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5jYWNoZSYmKHRoaXMuY2FjaGU9YXdhaXQgdGhpcy5hc3luY0RhdGFQcm92aWRlcih0aGlzLmRhdGFJZCkpLHRoaXMuY2FjaGV9Z2V0IHN0cmlkZXMoKXtyZXR1cm4gdGhpcy5fc3RyaWRlc3x8KHRoaXMuX3N0cmlkZXM9dS5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModGhpcy5kaW1zKSksdGhpcy5fc3RyaWRlc31jb25zdHJ1Y3Rvcih0LGUsbixyLG8sYT1pLkd1aWQuY3JlYXRlKCkpe3RoaXMuZGltcz10LHRoaXMudHlwZT1lLHRoaXMuZGF0YVByb3ZpZGVyPW4sdGhpcy5hc3luY0RhdGFQcm92aWRlcj1yLHRoaXMuY2FjaGU9byx0aGlzLmRhdGFJZD1hLHRoaXMuc2l6ZT11LlNoYXBlVXRpbC52YWxpZGF0ZURpbXNBbmRDYWxjU2l6ZSh0KTtjb25zdCBzPXRoaXMuc2l6ZSxjPXZvaWQgMD09PW4mJnZvaWQgMD09PXImJnZvaWQgMD09PW87aWYodm9pZCAwIT09byYmby5sZW5ndGghPT1zKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5wdXQgZGltcyBkb2Vzbid0IG1hdGNoIGRhdGEgbGVuZ3RoLlwiKTtpZihcInN0cmluZ1wiPT09ZSl7aWYoISh2b2lkIDA9PT1vfHxBcnJheS5pc0FycmF5KG8pJiZvLmV2ZXJ5KCh0PT5cInN0cmluZ1wiPT10eXBlb2YgdCkpKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FjaGUgc2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5XCIpO2MmJih0aGlzLmNhY2hlPW5ldyBBcnJheShzKSl9ZWxzZXtpZih2b2lkIDAhPT1vKXtjb25zdCB0PWYoZSk7aWYoIShvIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgY2FjaGUgc2hvdWxkIGJlIHR5cGUgJHt0Lm5hbWV9YCl9aWYoYyl7Y29uc3QgdD1uZXcgQXJyYXlCdWZmZXIocypmdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZVwiYm9vbFwiOmNhc2VcImludDhcIjpjYXNlXCJ1aW50OFwiOnJldHVybiAxO2Nhc2VcImludDE2XCI6Y2FzZVwidWludDE2XCI6cmV0dXJuIDI7Y2FzZVwiaW50MzJcIjpjYXNlXCJ1aW50MzJcIjpjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDQ7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiA4O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgY2FsY3VsYXRlIHNpemVvZigpIG9uIHR5cGUgJHt0fWApfX0oZSkpO3RoaXMuY2FjaGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3KGYoZSkpKHQpfSh0LGUpfX19c3RhdGljIGZyb21Qcm90byh0KXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yXCIpO2NvbnN0IGU9dS5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5kYXRhVHlwZSksbj11LlByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbVByb3RvKHQuZGltcykscj1uZXcgbChuLGUpO2lmKFwic3RyaW5nXCI9PT1lKXQuc3RyaW5nRGF0YS5mb3JFYWNoKCgodCxlKT0+e3IuZGF0YVtlXT0oMCx1LmRlY29kZVV0ZjhTdHJpbmcpKHQpfSkpO2Vsc2UgaWYodC5yYXdEYXRhJiZcIm51bWJlclwiPT10eXBlb2YgdC5yYXdEYXRhLmJ5dGVMZW5ndGgmJnQucmF3RGF0YS5ieXRlTGVuZ3RoPjApe2NvbnN0IGU9ci5kYXRhLG49bmV3IERhdGFWaWV3KHQucmF3RGF0YS5idWZmZXIsdC5yYXdEYXRhLmJ5dGVPZmZzZXQsdC5yYXdEYXRhLmJ5dGVMZW5ndGgpLGk9cCh0LmRhdGFUeXBlKSxvPXQucmF3RGF0YS5ieXRlTGVuZ3RoL2k7aWYodC5yYXdEYXRhLmJ5dGVMZW5ndGglaSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ1ZmZlciBsZW5ndGhcIik7aWYoZS5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihcImJ1ZmZlciBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxvO3IrKyl7Y29uc3Qgbz1oKG4sdC5kYXRhVHlwZSxyKmkpO2Vbcl09b319ZWxzZXtsZXQgZTtzd2l0Y2godC5kYXRhVHlwZSl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6ZT10LmZsb2F0RGF0YTticmVhaztjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOmU9dC5pbnQzMkRhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6ZT10LmludDY0RGF0YTticmVhaztjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6ZT10LmRvdWJsZURhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDplPXQudWludDY0RGF0YTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuc3BlY2lmaWMgZXJyb3JcIil9aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJmYWlsZWQgdG8gcG9wdWxhdGUgZGF0YSBmcm9tIGEgdGVuc29ycHJvdG8gdmFsdWVcIik7Y29uc3Qgbj1yLmRhdGE7aWYobi5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2NvbnN0IGk9ZVtyXTtvLmRlZmF1bHQuaXNMb25nKGkpP25bcl09ZChpLHQuZGF0YVR5cGUpOm5bcl09aX19cmV0dXJuIHJ9c3RhdGljIGZyb21EYXRhKHQsZSxuKXtyZXR1cm4gbmV3IGwoZSxuLHZvaWQgMCx2b2lkIDAsdCl9c3RhdGljIGZyb21PcnRUZW5zb3IodCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnN0cnVjdCBWYWx1ZSBmcm9tIGFuIGVtcHR5IHRlbnNvclwiKTtjb25zdCBlPXUuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KHQpLG49dS5Qcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odC5kYXRhVHlwZSgpKSxyPW5ldyBsKGUsbik7aWYoXCJzdHJpbmdcIj09PW4pZm9yKGxldCBlPTA7ZTx0LnN0cmluZ0RhdGFMZW5ndGgoKTtlKyspci5kYXRhW2VdPXQuc3RyaW5nRGF0YShlKTtlbHNlIGlmKHQucmF3RGF0YUFycmF5KCkmJlwibnVtYmVyXCI9PXR5cGVvZiB0LnJhd0RhdGFMZW5ndGgoKSYmdC5yYXdEYXRhTGVuZ3RoKCk+MCl7Y29uc3QgZT1yLmRhdGEsbj1uZXcgRGF0YVZpZXcodC5yYXdEYXRhQXJyYXkoKS5idWZmZXIsdC5yYXdEYXRhQXJyYXkoKS5ieXRlT2Zmc2V0LHQucmF3RGF0YUxlbmd0aCgpKSxpPXAodC5kYXRhVHlwZSgpKSxvPXQucmF3RGF0YUxlbmd0aCgpL2k7aWYodC5yYXdEYXRhTGVuZ3RoKCklaSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ1ZmZlciBsZW5ndGhcIik7aWYoZS5sZW5ndGghPT1vKXRocm93IG5ldyBFcnJvcihcImJ1ZmZlciBsZW5ndGggbWlzbWF0Y2hcIik7Zm9yKGxldCByPTA7cjxvO3IrKyl7Y29uc3Qgbz1oKG4sdC5kYXRhVHlwZSgpLHIqaSk7ZVtyXT1vfX1yZXR1cm4gcn19ZnVuY3Rpb24gcCh0KXtzd2l0Y2godCl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOnJldHVybiAxO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm4gMjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuIDQ7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm4gODtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApfX1mdW5jdGlvbiBmKHQpe3N3aXRjaCh0KXtjYXNlXCJib29sXCI6Y2FzZVwidWludDhcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuc3BlY2lmaWVkIGVycm9yXCIpfX1mdW5jdGlvbiBkKHQsZSl7aWYoZT09PWEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NHx8ZT09PWMuVGVuc29yRGF0YVR5cGUuSU5UNjQpe2lmKHQuZ3JlYXRlclRoYW5PckVxdWFsKDIxNDc0ODM2NDgpfHx0Lmxlc3NUaGFuKC0yMTQ3NDgzNjQ4KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW50NjQgaXMgbm90IHN1cHBvcnRlZFwiKX1lbHNle2lmKGUhPT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyJiZlIT09Yy5UZW5zb3JEYXRhVHlwZS5VSU5UMzImJmUhPT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0JiZlIT09Yy5UZW5zb3JEYXRhVHlwZS5VSU5UNjQpdGhyb3cgbmV3IFR5cGVFcnJvcihgbm90IGEgTE9ORyB0eXBlOiAke2Eub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVtlXX1gKTtpZih0LmdyZWF0ZXJUaGFuT3JFcXVhbCg0Mjk0OTY3Mjk2KXx8dC5sZXNzVGhhbigwKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwidWludDY0IGlzIG5vdCBzdXBwb3J0ZWRcIil9cmV0dXJuIHQudG9OdW1iZXIoKX1mdW5jdGlvbiBoKHQsZSxuKXtzd2l0Y2goZSl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpyZXR1cm4gdC5nZXRVaW50OChuKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OnJldHVybiB0LmdldEludDgobik7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OnJldHVybiB0LmdldFVpbnQxNihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm4gdC5nZXRJbnQxNihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm4gdC5nZXRGbG9hdDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOnJldHVybiB0LmdldEludDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpyZXR1cm4gdC5nZXRVaW50MzIobiwhMCk7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuIGQoby5kZWZhdWx0LmZyb21CaXRzKHQuZ2V0VWludDMyKG4sITApLHQuZ2V0VWludDMyKG4rNCwhMCksITEpLGUpO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpyZXR1cm4gdC5nZXRGbG9hdDY0KG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm4gZChvLmRlZmF1bHQuZnJvbUJpdHModC5nZXRVaW50MzIobiwhMCksdC5nZXRVaW50MzIobis0LCEwKSwhMCksZSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWFkIGZyb20gRGF0YVZpZXcgZm9yIHR5cGUgJHthLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbZV19YCl9fWUuVGVuc29yPWx9LDI1MTc6ZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbih0KXtyZXR1cm4gdCYmdC5fX2VzTW9kdWxlP3Q6e2RlZmF1bHQ6dH19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGVjb2RlVXRmOFN0cmluZz1lLk1BWF9DTElQPWUuTUlOX0NMSVA9ZS5Qb29sQ29udlV0aWw9ZS5SZWR1Y2VVdGlsPWUuU3BsaXRVdGlsPWUuTWF0aFV0aWw9ZS5TaGFwZVV0aWw9ZS5Mb25nVXRpbD1lLlByb3RvVXRpbD1lLkdlbW1VdGlsPWUuYXJyYXlDb3B5SGVscGVyPWUuQnJvYWRjYXN0VXRpbD1lLk1hdE11bFV0aWw9ZS5BcnJheVV0aWw9ZS5hc3NlcnQ9ZS5jaGVja0lucHV0c1NoYXBlPXZvaWQgMDtjb25zdCBpPW4oNTY4Niksbz1yKG4oMzcyMCkpLGE9bigxNDQ2KSxzPW4oOTE2Mik7ZS5jaGVja0lucHV0c1NoYXBlPWZ1bmN0aW9uKHQsLi4uZSl7aWYoIXR8fHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZGltc3x8dFtuXS5kaW1zLmxlbmd0aCE9PWVbbl0pcmV0dXJuITE7cmV0dXJuITB9LGUuYXNzZXJ0PWZ1bmN0aW9uKHQsZSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZSgpKX0sZS5BcnJheVV0aWw9Y2xhc3N7c3RhdGljIGFycmF5c0VxdWFsKHQsZSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKylpZih0W25dIT09ZVtuXSlyZXR1cm4hMTtyZXR1cm4hMH19O2NsYXNzIHV7c3RhdGljIHByZXByb2Nlc3NJbnB1dFNoYXBlcyh0LGUpe3JldHVyblsxPT09dC5sZW5ndGg/WzEsdFswXV06dCwxPT09ZS5sZW5ndGg/W2VbMF0sMV06ZV19c3RhdGljIHBvc3Rwcm9jZXNzT3V0cHV0U2hhcGUodCxlLG4pezE9PT1lJiZ0LnNwbGljZSh0Lmxlbmd0aC0yLDEpLDE9PT1uJiZ0LnBvcCgpfXN0YXRpYyBjYWxjTWF0TXVsU2hhcGUodCxlKXtyZXR1cm4gdFsxXSE9PWVbMF0/dm9pZCAwOlt0WzBdLGVbMV1dfX1lLk1hdE11bFV0aWw9dTtjbGFzcyBje3N0YXRpYyBjYWxjU2hhcGUodCxlLG49ITEpe2NvbnN0IHI9dC5sZW5ndGgsaT1lLmxlbmd0aDtpZigwPT09cilyZXR1cm4gZTtpZigwPT09aSlyZXR1cm4gdDtjb25zdCBvPU1hdGgubWF4KHQubGVuZ3RoLGUubGVuZ3RoKSxhPW5ldyBBcnJheShvKTtpZihuKXtpZihyPDJ8fGk8MilyZXR1cm47Y29uc3Qgbj11LmNhbGNNYXRNdWxTaGFwZShbdFtyLTJdLHRbci0xXV0sW2VbaS0yXSxlW2ktMV1dKTtpZih2b2lkIDA9PT1uKXJldHVybjtbYVtvLTJdLGFbby0xXV09bn1mb3IobGV0IHM9bj8zOjE7czw9bztzKyspe2NvbnN0IG49ci1zPDA/MTp0W3Itc10sdT1pLXM8MD8xOmVbaS1zXTtpZihuIT09dSYmbj4xJiZ1PjEpcmV0dXJuO2Fbby1zXT1NYXRoLm1heChuLHUpfXJldHVybiBhfXN0YXRpYyBpbmRleCh0LGUpe2NvbnN0IG49bmV3IEFycmF5KGUubGVuZ3RoKTtyZXR1cm4gYy5maWxsSW5kZXgodCxlLG4pLG59c3RhdGljIGZpbGxJbmRleCh0LGUsbil7Y29uc3Qgcj10Lmxlbmd0aC1lLmxlbmd0aDtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKyluW2ldPXRbcitpXSVlW2ldfXN0YXRpYyBjYWxjKHQsZSxuLHIsaSl7Y29uc3Qgbz1jLmNhbGNTaGFwZSh0LmRpbXMsZS5kaW1zKTtpZihvKXtpZihyJiYhZi5hcmVFcXVhbChvLHQuZGltcykpcmV0dXJuO2NvbnN0IGE9Zi5zaXplKG8pLHU9cj90Om5ldyBzLlRlbnNvcihvLGl8fHQudHlwZSk7aWYoMD09PW8ubGVuZ3RoKXUuc2V0KFtdLG4odC5nZXQoW10pLGUuZ2V0KFtdKSkpO2Vsc2V7Y29uc3Qgcj1uZXcgQXJyYXkoby5sZW5ndGgpLGk9bmV3IEFycmF5KHQuZGltcy5sZW5ndGgpLHM9bmV3IEFycmF5KGUuZGltcy5sZW5ndGgpO2xldCBsLHA9MCxmPTAsZD0hMSxoPSExOzA9PT10LmRpbXMubGVuZ3RoJiYocD10LmdldChbXSksZD0hMCksMD09PWUuZGltcy5sZW5ndGgmJihmPWUuZ2V0KFtdKSxoPSEwKTtmb3IobGV0IGc9MDtnPGE7ZysrKXtsPWc7Zm9yKGxldCB0PW8ubGVuZ3RoLTE7dD49MDt0LS0pclt0XT1sJW9bdF0sbD1NYXRoLmZsb29yKGwvb1t0XSk7ZHx8KGMuZmlsbEluZGV4KHIsdC5kaW1zLGkpLHA9dC5nZXQoaSkpLGh8fChjLmZpbGxJbmRleChyLGUuZGltcyxzKSxmPWUuZ2V0KHMpKSx1LnNldChyLG4ocCxmKSl9fXJldHVybiB1fX1zdGF0aWMgaXNWYWxpZEJyb2FkY2FzdCh0LGUpe2NvbnN0IG49dC5sZW5ndGgscj1lLmxlbmd0aDtpZihuPnIpcmV0dXJuITE7Zm9yKGxldCBpPTE7aTw9bjtpKyspaWYoMSE9PXRbbi1pXSYmdFtuLWldIT09ZVtyLWldKXJldHVybiExO3JldHVybiEwfXN0YXRpYyBnZXRCcm9hZGNhc3REaW1zKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aCxyPVtdO2ZvcihsZXQgaT0wO2k8bjtpKyspe2NvbnN0IG89bi0xLWksYT10W29dfHwxOyhlW2UubGVuZ3RoLTEtaV18fDEpPjEmJjE9PT1hJiZyLnVuc2hpZnQobyl9cmV0dXJuIHJ9fWUuQnJvYWRjYXN0VXRpbD1jLGUuYXJyYXlDb3B5SGVscGVyPWZ1bmN0aW9uKHQsZSxuLHIsaSl7aWYocjwwfHxyPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK2k+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK2k+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IG89MDtvPGk7bysrKXRbbitvXT1lW3Irb119LGUuR2VtbVV0aWw9Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KHQsZSxuLHIsaSl7aWYoMiE9PXQubGVuZ3RofHwyIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IG8sYSxzO2U/KG89dFsxXSxhPXRbMF0pOihvPXRbMF0sYT10WzFdKTtsZXQgdT0tMTtpZihyPyhzPW5bMF0sdT0xKToocz1uWzFdLHU9MCksblt1XSE9PWEpdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKG88PTB8fHM8PTB8fGE8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYoaSYmIWMuaXNWYWxpZEJyb2FkY2FzdChpLFtvLHNdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bbyxzLGFdfX07Y2xhc3MgbHtzdGF0aWMgdGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odCl7c3dpdGNoKHQpe2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6cmV0dXJuXCJpbnQ4XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6cmV0dXJuXCJib29sXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOnJldHVyblwiaW50MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HOnJldHVyblwic3RyaW5nXCI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm5cInVpbnQzMlwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7YS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3RdfWApfX1zdGF0aWMgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0odCl7c3dpdGNoKHQpe2Nhc2VcImludDhcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg7Y2FzZVwidWludDhcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4O2Nhc2VcImJvb2xcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w7Y2FzZVwiaW50MTZcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2O2Nhc2VcInVpbnQxNlwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2O2Nhc2VcImludDMyXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5TVFJJTkc7Y2FzZVwiaW50NjRcIjpyZXR1cm4gYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH1gKX19c3RhdGljIHRlbnNvckRpbXNGcm9tUHJvdG8odCl7cmV0dXJuIHQubWFwKCh0PT5vLmRlZmF1bHQuaXNMb25nKHQpP3QudG9OdW1iZXIoKTp0KSl9c3RhdGljIHRlbnNvclZhbHVlVHlwZUZyb21Qcm90byh0KXtyZXR1cm57dGVuc29yVHlwZTpsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKHQuZWxlbVR5cGUpLHNoYXBlOntkaW1zOmwudGVuc29yRGltc0Zyb21Qcm90byh0LnNoYXBlLmRpbS5tYXAoKHQ9PnQuZGltVmFsdWUpKSl9fX1zdGF0aWMgdGVuc29yRGltc0Zyb21PUlRGb3JtYXQodCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuZGltc0xlbmd0aCgpO24rKyllLnB1c2gocC5sb25nVG9OdW1iZXIodC5kaW1zKG4pKSk7cmV0dXJuIGV9c3RhdGljIHRlbnNvckF0dHJpYnV0ZXNGcm9tT1JURm9ybWF0KHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0LmF0dHJpYnV0ZXNMZW5ndGgoKTtuKyspZS5wdXNoKHQuYXR0cmlidXRlcyhuKSk7cmV0dXJuIGV9fWUuUHJvdG9VdGlsPWw7Y2xhc3MgcHtzdGF0aWMgbG9uZ1RvTnVtYmVyKHQsZSl7cmV0dXJuIG8uZGVmYXVsdC5pc0xvbmcodCk/dC50b051bWJlcigpOnQgaW5zdGFuY2VvZiBpLmZsYXRidWZmZXJzLkxvbmc/by5kZWZhdWx0LmZyb21WYWx1ZSh7bG93OnQubG93LGhpZ2g6dC5oaWdoLHVuc2lnbmVkOm51bGwhPWUmJmV9KS50b051bWJlcigpOnR9c3RhdGljIGlzTG9uZyh0KXtyZXR1cm4gby5kZWZhdWx0LmlzTG9uZyh0KXx8dCBpbnN0YW5jZW9mIGkuZmxhdGJ1ZmZlcnMuTG9uZ319ZS5Mb25nVXRpbD1wO2NsYXNzIGZ7c3RhdGljIHNpemUodCl7cmV0dXJuIGYuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbih0LGUpe2lmKGU8MHx8ZT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7ZX0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZi5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsZSx0Lmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbih0LGUpe2lmKGU8MHx8ZT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7ZX0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGYuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsZSl9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxlLG4pe2xldCByPTE7Zm9yKGxldCBpPWU7aTxuO2krKyl7aWYodFtpXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgMCBvciBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7cio9dFtpXX1yZXR1cm4gcn1zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7Y29uc3QgZT10Lmxlbmd0aDtpZigwPT09ZSlyZXR1cm5bXTtpZigxPT09ZSlyZXR1cm5bMV07Y29uc3Qgbj1uZXcgQXJyYXkoZSk7bltlLTFdPTEsbltlLTJdPXRbZS0xXTtmb3IobGV0IHI9ZS0zO3I+PTA7LS1yKW5bcl09bltyKzFdKnRbcisxXTtyZXR1cm4gbn1zdGF0aWMgdHJhbnNwb3NlKHQpe3JldHVybiB0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBpbmRpY2VzVG9PZmZzZXQodCxlLG4pe3ZvaWQgMD09PW4mJihuPXQubGVuZ3RoKTtsZXQgcj0wO2ZvcihsZXQgaT0wO2k8bjsrK2kpcis9ZVtpXSp0W2ldO3JldHVybiByfXN0YXRpYyBvZmZzZXRUb0luZGljZXModCxlKXtjb25zdCBuPWUubGVuZ3RoO2lmKDA9PT1uKXJldHVybltdO2lmKDE9PT1uKXJldHVyblt0KmVbMF1dO2NvbnN0IHI9bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IG49MDtuPHIubGVuZ3RoLTE7KytuKXJbbl09TWF0aC5mbG9vcih0L2Vbbl0pLHQtPXJbbl0qZVtuXTtyZXR1cm4gcltyLmxlbmd0aC0xXT10LHJ9c3RhdGljIG5vcm1hbGl6ZUF4aXModCxlKXtpZih0PC1lJiZ0Pj1lKXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLlwiKTtyZXR1cm4gdDwwP3QrZTp0fXN0YXRpYyBub3JtYWxpemVBeGVzKHQsZSl7cmV0dXJuIHQubWFwKCh0PT50aGlzLm5vcm1hbGl6ZUF4aXModCxlKSkpfXN0YXRpYyBpbmNyZW1lbnRJbmRleCh0LGUsbil7aWYoMD09PWUubGVuZ3RofHwwPT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggaW5jcmVtZW50aW5nIHVuc3VwcG9ydGVkIGZvciBzY2FsYXIgVGVuc29yXCIpO2lmKHZvaWQgMD09PW4pbj1lLmxlbmd0aDtlbHNlIGlmKG48PTB8fG4+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IGF4aXMgdG8gaW5jcmVtZW50IG9uXCIpO2ZvcihsZXQgcj1uLTE7cj49MCYmKHRbcl0rKywhKHRbcl08ZVtyXSkpOy0tcil0W3JdPTB9c3RhdGljIGNhbGN1bGF0ZVJlc2hhcGVkRGltcyh0LGUpe2lmKDA9PT1lLmxlbmd0aCl7aWYoMD09PXQubGVuZ3RofHwxPT09Zi5zaXplKHQpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcihcImNhbm5vdCByZXNoYXBlIHRvIGEgc2NhbGFyIFRlbnNvclwiKX1jb25zdCBuPWUubGVuZ3RoLHI9bmV3IEFycmF5KG4pO2xldCBpPS0xLG89MTtmb3IobGV0IGE9MDthPG47YSsrKXtpZihlW2FdPC0xKXRocm93IG5ldyBFcnJvcihcImEgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbm5vdCBiZSBsZXNzIHRoYW4gLTFcIik7aWYoLTE9PT1lW2FdKXtpZigtMSE9PWkpdGhyb3cgbmV3IEVycm9yKFwiYXQgbW9zdCBvbmUgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbiBiZSAtMVwiKTtpPWF9ZWxzZXtpZigwPT09ZVthXSl7aWYoYT49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGhlIGRpbWVuc2lvbiB3aXRoIHZhbHVlIHplcm8gZXhjZWVkcyB0aGUgZGltZW5zaW9uIHNpemUgb2YgdGhlIGlucHV0IHRlbnNvclwiKTtyW2FdPXRbYV19ZWxzZSByW2FdPWVbYV07byo9clthXX19Y29uc3QgYT1mLnNpemUodCk7aWYoLTEhPT1pKXtpZihhJW8hPTApdGhyb3cgbmV3IEVycm9yKGB0aGUgaW5wdXQgdGVuc29yIGNhbm5vdCBiZSByZXNoYXBlZCB0byB0aGUgcmVxdWVzdGVkIHNoYXBlLiBJbnB1dCBzaGFwZTogWyR7dH1dIE91dHB1dCBzaGFwZTogWyR7ZX1dYCk7cltpXT1hL299ZWxzZSBpZihvIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJyZXNoYXBlZERpbXMgYW5kIG9yaWdpbmFsRGltcyBkb24ndCBoYXZlIG1hdGNoaW5nIHNpemVzXCIpO3JldHVybiByfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxlKXtyZXR1cm4gZT9lLm1hcCgoZT0+dFtlXSkpOnQuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIHBhZFNoYXBlKHQsZSl7Y29uc3Qgbj10Lmxlbmd0aDtyZXR1cm4gdC5tYXAoKCh0LHIpPT50K2Vbcl0rZVtyK25dKSl9c3RhdGljIGFyZUVxdWFsKHQsZSl7cmV0dXJuIHQubGVuZ3RoPT09ZS5sZW5ndGgmJnQuZXZlcnkoKCh0LG4pPT50PT09ZVtuXSkpfXN0YXRpYyB2YWxpZGF0ZURpbXNBbmRDYWxjU2l6ZSh0KXtpZih0Lmxlbmd0aD42KXRocm93IG5ldyBUeXBlRXJyb3IoXCJPbmx5IHJhbmsgMCB0byA2IGlzIHN1cHBvcnRlZCBmb3IgdGVuc29yIHNoYXBlLlwiKTtsZXQgZT0xO2Zvcihjb25zdCBuIG9mIHQpe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6ICR7bn0gaXMgbm90IGFuIGludGVnZXJgKTtpZihuPDB8fG4+MjE0NzQ4MzY0Nyl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiBsZW5ndGggJHtufSBpcyBub3QgYWxsb3dlZGApO2UqPW59cmV0dXJuIGV9c3RhdGljIGZsYXR0ZW5TaGFwZSh0LGUpe2U8MCYmKGUrPXQubGVuZ3RoKTtjb25zdCBuPXQucmVkdWNlKCgodCxlKT0+dCplKSwxKSxyPXQuc2xpY2UoZSkucmVkdWNlKCgodCxlKT0+dCplKSwxKTtyZXR1cm5bbi9yLHJdfXN0YXRpYyBzcXVlZXplU2hhcGUodCxlKXtjb25zdCBuPW5ldyBBcnJheTtlPWYubm9ybWFsaXplQXhlcyhlLHQubGVuZ3RoKTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3QgaT1lLmluZGV4T2Yocik+PTA7aWYoaSYmMSE9PXRbcl0pdGhyb3cgbmV3IEVycm9yKFwic3F1ZWV6ZSBhbiBheGlzIG9mIHNpemUgZGlmZmVyZW50IHRoYW4gMVwiKTsoMD09PWUubGVuZ3RoJiZ0W3JdPjF8fGUubGVuZ3RoPjAmJiFpKSYmbi5wdXNoKHRbcl0pfXJldHVybiBufXN0YXRpYyB1bnNxdWVlemVTaGFwZSh0LGUpe2NvbnN0IG49bmV3IEFycmF5KHQubGVuZ3RoK2UubGVuZ3RoKTtuLmZpbGwoMCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IHI9Zi5ub3JtYWxpemVBeGlzKGVbdF0sbi5sZW5ndGgpO2lmKHI+PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIidheGVzJyBoYXMgYW4gb3V0IG9mIHJhbmdlIGF4aXNcIik7aWYoMCE9PW5bcl0pdGhyb3cgbmV3IEVycm9yKFwiJ2F4ZXMnIGhhcyBhIGR1cGxpY2F0ZSBheGlzXCIpO25bcl09MX1sZXQgcj0wO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKTA9PT1uW2VdJiYobltlXT10W3IrK10pO2lmKHIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgdW5zcXVlZXplZCBkaW1lbnNpb24gY291bGQgbm90IGJlIGVzdGFibGlzaGVkXCIpO3JldHVybiBufX1lLlNoYXBlVXRpbD1mLGUuTWF0aFV0aWw9Y2xhc3N7c3RhdGljIHNxcih0LGUsbixyLGkpe2lmKHI8MHx8cj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitpPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBvPTA7bzxpO28rKyl0W24rb10rPU1hdGgucG93KGVbcitvXSwyKX1zdGF0aWMgYXhweSh0LGUsbixyLGksbyl7aWYocjwwfHxyPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK2k+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK2k+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IGE9MDthPGk7YSsrKXRbbithXSs9byplW3IrYV19c3RhdGljIHBvd3godCxlLG4scixpLG8pe2lmKHI8MHx8cj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitpPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBhPTA7YTxpO2ErKyl0W24rYV09TWF0aC5wb3coZVtyK2FdLG8pfXN0YXRpYyBtdWwodCxlLG4scixpKXtpZihyPDB8fHI+PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZUluZGV4IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKHIraT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzXCIpO2lmKG4raT50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0XCIpO2ZvcihsZXQgbz0wO288aTtvKyspdFtuK29dPWVbcitvXSp0W24rb119fTtjbGFzcyBke3N0YXRpYyBzcGxpdFNoYXBlKHQsZSxuLHIpe2lmKDA9PT1uLmxlbmd0aCl7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwibmVlZCB0byBrbm93IG51bWJlciBvZiBvdXRwdXRzIHdoZW4gdGhlICdzcGxpdCcgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWRcIik7ZC5kZXRlcm1pbmVTcGxpdCh0W2VdLHIsbil9Y29uc3QgaT1bXSxvPVswXTtmb3IobGV0IHI9MDtyPG4ubGVuZ3RoOysrcil7MCE9PXImJm8ucHVzaChvW3ItMV0rbltyLTFdKTtjb25zdCBhPXQuc2xpY2UoKTthW2VdPW5bcl0saS5wdXNoKGEpfXJldHVybltpLG9dfXN0YXRpYyBkZXRlcm1pbmVTcGxpdCh0LGUsbil7aWYodCVlIT0wKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzcGxpdCB0ZW5zb3IgdG8gZXF1YWwgc2l6ZWQgcGFydHNcIik7Zm9yKGxldCByPTA7cjxlOysrciluLnB1c2godC9lKX19ZS5TcGxpdFV0aWw9ZDtjbGFzcyBoe3N0YXRpYyBjYWxjUmVkdWNlKHQsZSxuLHIsaSl7Y29uc3Qgbz10LmRpbXMuc2xpY2UoMCk7MD09PWUubGVuZ3RoJiZvLmZvckVhY2goKCh0LG4pPT5lLnB1c2gobikpKTtjb25zdCBhPWguY2FsY1JlZHVjZVNoYXBlKG8sZSwhMCksdT1mLnNpemUoYSksbD1uZXcgcy5UZW5zb3IoYSx0LnR5cGUpLHA9Zi5jb21wdXRlU3RyaWRlcyhhKSxkPWYuY29tcHV0ZVN0cmlkZXMobyksZz1uZXcgQXJyYXkoby5sZW5ndGgpO2ZvcihsZXQgbj0wO248dTtuKyspe2NvbnN0IGE9Zi5vZmZzZXRUb0luZGljZXMobixwKTtjLmZpbGxJbmRleChhLG8sZyksbC5zZXQoYSxoLmNhbGNSZWR1Y2VCeUF4aXModC5udW1iZXJEYXRhLGUsbywwLGYuaW5kaWNlc1RvT2Zmc2V0KGcsZCkscixpKSl9cmV0dXJuIG4/bDpuZXcgcy5UZW5zb3IoaC5jYWxjUmVkdWNlU2hhcGUobyxlLG4pLGwudHlwZSx2b2lkIDAsdm9pZCAwLGwuZGF0YSxsLmRhdGFJZCl9c3RhdGljIGNhbGNSZWR1Y2VCeUF4aXModCxlLG4scixpLG8sYSl7bGV0IHM9MDtpZihyPj1lLmxlbmd0aClyZXR1cm4gbyh0W2ldKTtjb25zdCB1PWVbcl0sYz11Pj1uLmxlbmd0aD8xOmYuc2l6ZShuLnNsaWNlKHUrMSkpO2ZvcihsZXQgbD0wO2w8blt1XTtsKyspcz0wPT09bD9oLmNhbGNSZWR1Y2VCeUF4aXModCxlLG4scisxLGksbyxhKTphKHMsaC5jYWxjUmVkdWNlQnlBeGlzKHQsZSxuLHIrMSxpLG8sYSkpLGkrPWM7cmV0dXJuIHN9c3RhdGljIGNhbGNSZWR1Y2VTaGFwZSh0LGUsbil7Y29uc3Qgcj10LnNsaWNlKCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0KyspcltlW3RdXT1uPzE6MDtyZXR1cm4gci5maWx0ZXIoKHQ9PjAhPT10KSl9fWUuUmVkdWNlVXRpbD1oO2NsYXNzIGd7c3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKHQsZSxuLHIsaSxvKXtpZighdCYmbi5sZW5ndGghPT1lLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnNcIik7aWYodClmb3IobGV0IHQ9MDt0PGUubGVuZ3RoLTI7dCsrKXQ+PW4ubGVuZ3RoP24ucHVzaChlW3QrMl0pOm5bdF09ZVt0KzJdO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWlmKHQ8ci5sZW5ndGgpe2lmKHJbdF08MCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIHIucHVzaCgxKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKylpZih0PGkubGVuZ3RoKXtpZihpW3RdPDApdGhyb3cgbmV3IEVycm9yKFwiZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGkucHVzaCgxKTtmb3IobGV0IHQ9MDt0PDIqbi5sZW5ndGg7dCsrKWlmKHQ8by5sZW5ndGgpe2lmKG9bdF08MCl0aHJvdyBuZXcgRXJyb3IoXCJwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugby5wdXNoKDApO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKXtpZihuW3RdPD0wKXRocm93IG5ldyBFcnJvcihcImtlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMFwiKTtpZihvW3RdPj1uW3RdfHxvW3Qrbi5sZW5ndGhdPj1uW3RdKXRocm93IG5ldyBFcnJvcihcInBhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWxcIil9fXN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodCxlLG4scixpLG8pe2lmKG8pe2lmKGkubGVuZ3RoIT09MioodC5sZW5ndGgtMikpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoci5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtmb3IobGV0IGE9MDthPHQubGVuZ3RoLTI7YSsrKWcuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodFthKzJdLGVbYV0sblthXSxyW2FdLGksYSxhK3QubGVuZ3RoLTIsbyl9fXN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKHQsZSxuLHIsaSxvLGEpe2lmKGUubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMFwiKTtjb25zdCBzPVtlWzBdLGVbMV1dO3JldHVybiBnLmNvbXB1dGVTaGFwZUhlbHBlcih0LGUscyxuLHIsaSxvLGEpLHN9c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUodCxlLG4scixpLG8sYSl7aWYodC5sZW5ndGg8PTB8fGUubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7Y29uc3Qgcz1bdFswXSxlWzBdXTtyZXR1cm4gZy5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCxzLG4scixpLG8sYSksc31zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQsZSxuLHIsaSxvLGEscyl7aWYodClmb3IobGV0IHQ9MDt0PGUubGVuZ3RoLTI7dCsrKW4ucHVzaCgxKTtlbHNlIGZvcihsZXQgdD0wO3Q8ZS5sZW5ndGgtMjt0Kyspbi5wdXNoKGcuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoZVt0KzJdLHJbdF0saVt0XSxvW3RdLGEsdCx0K2UubGVuZ3RoLTIscykpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LGUsbixyLGksbyxhLHMpe2NvbnN0IHU9biooci0xKSsxO2lmKCFzfHxcIk5PVFNFVFwiPT09cylyZXR1cm4gTWF0aC5mbG9vcigodCtpW29dK2lbYV0tdSkvZSsxKTtzd2l0Y2gocyl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gaVtvXT0wLGlbYV09MCxNYXRoLmZsb29yKCh0LXUpL2UrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZigxIT09bil0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2NvbnN0IG49KCh0K2UtMSkvZS0xKSplK3ItdDtyZXR1cm4gaVtvXT1cIlNBTUVfTE9XRVJcIj09PXM/TWF0aC5mbG9vcigobisxKS8yKTpNYXRoLmZsb29yKG4vMiksaVthXT1uLWlbb10sTWF0aC5mbG9vcigodCtuLXIpL2UrMSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGVcIil9fX1lLlBvb2xDb252VXRpbD1nLGUuTUlOX0NMSVA9LTM0MDI4MjM0NjYzODUyODg2ZTIyLGUuTUFYX0NMSVA9MzQwMjgyMzQ2NjM4NTI4ODZlMjIsZS5kZWNvZGVVdGY4U3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybihuZXcgVGV4dERlY29kZXIpLmRlY29kZSh0KX19LDc5Njc6KHQsZSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLml0ZXJhdGVFeHRyYU9wdGlvbnM9dm9pZCAwLGUuaXRlcmF0ZUV4dHJhT3B0aW9ucz0odCxuLHIsaSk9PntpZihcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQpe2lmKHIuaGFzKHQpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO3IuYWRkKHQpfU9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKChbdCxvXSk9Pntjb25zdCBhPW4/bit0OnQ7aWYoXCJvYmplY3RcIj09dHlwZW9mIG8pKDAsZS5pdGVyYXRlRXh0cmFPcHRpb25zKShvLGErXCIuXCIscixpKTtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBvfHxcIm51bWJlclwiPT10eXBlb2YgbylpKGEsby50b1N0cmluZygpKTtlbHNle2lmKFwiYm9vbGVhblwiIT10eXBlb2Ygbyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6IFwiK3R5cGVvZiBvKTtpKGEsbz9cIjFcIjpcIjBcIil9fSkpfX0sMjE1NzpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsaT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLG4pO2kmJiEoXCJnZXRcImluIGk/IWUuX19lc01vZHVsZTppLndyaXRhYmxlfHxpLmNvbmZpZ3VyYWJsZSl8fChpPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBlW25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsaSl9OmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pLHRbcl09ZVtuXX0pLG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pfTpmdW5jdGlvbih0LGUpe3QuZGVmYXVsdD1lfSksYT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBlPXt9O2lmKG51bGwhPXQpZm9yKHZhciBuIGluIHQpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmaShlLHQsbik7cmV0dXJuIG8oZSx0KSxlfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmVuZFByb2ZpbGluZz1lLnJ1bj1lLnJlbGVhc2VTZXNzaW9uPWUuY3JlYXRlU2Vzc2lvbj1lLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT1lLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZT1lLmluaXRPcnQ9ZS5pbml0V2FzbT12b2lkIDA7Y29uc3Qgcz1uKDE2NzApLHU9YShuKDM0OSkpLGM9big2MzYxKSxsPSgpPT4hIXMuZW52Lndhc20ucHJveHkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudDtsZXQgcCxmLGQsaD0hMSxnPSExLGI9ITE7Y29uc3QgbT1bXSx5PVtdLF89W10sdj1bXSx3PVtdLHg9W10sVD0oKT0+e2lmKGh8fCFnfHxifHwhcCl0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXIgbm90IHJlYWR5XCIpfSxTPXQ9Pntzd2l0Y2godC5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOmg9ITEsdC5kYXRhLmVycj8oYj0hMCxmWzFdKHQuZGF0YS5lcnIpKTooZz0hMCxmWzBdKCkpO2JyZWFrO2Nhc2VcImluaXQtb3J0XCI6dC5kYXRhLmVycj9kWzFdKHQuZGF0YS5lcnIpOmRbMF0oKTticmVhaztjYXNlXCJjcmVhdGVfYWxsb2NhdGVcIjp0LmRhdGEuZXJyP20uc2hpZnQoKVsxXSh0LmRhdGEuZXJyKTptLnNoaWZ0KClbMF0odC5kYXRhLm91dCk7YnJlYWs7Y2FzZVwiY3JlYXRlX2ZpbmFsaXplXCI6dC5kYXRhLmVycj95LnNoaWZ0KClbMV0odC5kYXRhLmVycik6eS5zaGlmdCgpWzBdKHQuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImNyZWF0ZVwiOnQuZGF0YS5lcnI/Xy5zaGlmdCgpWzFdKHQuZGF0YS5lcnIpOl8uc2hpZnQoKVswXSh0LmRhdGEub3V0KTticmVhaztjYXNlXCJyZWxlYXNlXCI6dC5kYXRhLmVycj92LnNoaWZ0KClbMV0odC5kYXRhLmVycik6di5zaGlmdCgpWzBdKCk7YnJlYWs7Y2FzZVwicnVuXCI6dC5kYXRhLmVycj93LnNoaWZ0KClbMV0odC5kYXRhLmVycik6dy5zaGlmdCgpWzBdKHQuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImVuZC1wcm9maWxpbmdcIjp0LmRhdGEuZXJyP3guc2hpZnQoKVsxXSh0LmRhdGEuZXJyKTp4LnNoaWZ0KClbMF0oKX19LE89XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50P251bGw9PT0ocj1udWxsPT09ZG9jdW1lbnR8fHZvaWQgMD09PWRvY3VtZW50P3ZvaWQgMDpkb2N1bWVudC5jdXJyZW50U2NyaXB0KXx8dm9pZCAwPT09cj92b2lkIDA6ci5zcmM6dm9pZCAwO2UuaW5pdFdhc209YXN5bmMoKT0+e2lmKGwoKSl7aWYoZylyZXR1cm47aWYoaCl0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKGIpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdFdhc20oKScgZmFpbGVkLlwiKTtyZXR1cm4gaD0hMCx2b2lkIDA9PT1zLmVudi53YXNtLndhc21QYXRocyYmTyYmMCE9PU8uaW5kZXhPZihcImJsb2I6XCIpJiYocy5lbnYud2FzbS53YXNtUGF0aHM9Ty5zdWJzdHIoMCwrTy5sYXN0SW5kZXhPZihcIi9cIikrMSkpLG5ldyBQcm9taXNlKCgodCxlKT0+e251bGw9PXB8fHAudGVybWluYXRlKCkscD1uKDk3MTApLlooKSxwLm9ubWVzc2FnZT1TLGY9W3QsZV07Y29uc3Qgcj17dHlwZTpcImluaXQtd2FzbVwiLGluOnMuZW52Lndhc219O3AucG9zdE1lc3NhZ2Uocil9KSl9cmV0dXJuKDAsYy5pbml0aWFsaXplV2ViQXNzZW1ibHkpKHMuZW52Lndhc20pfSxlLmluaXRPcnQ9YXN5bmModCxlKT0+e2lmKGwoKSlyZXR1cm4gVCgpLG5ldyBQcm9taXNlKCgobixyKT0+e2Q9W24scl07Y29uc3QgaT17dHlwZTpcImluaXQtb3J0XCIsaW46e251bVRocmVhZHM6dCxsb2dnaW5nTGV2ZWw6ZX19O3AucG9zdE1lc3NhZ2UoaSl9KSk7dS5pbml0T3J0KHQsZSl9LGUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWFzeW5jIHQ9PmwoKT8oVCgpLG5ldyBQcm9taXNlKCgoZSxuKT0+e20ucHVzaChbZSxuXSk7Y29uc3Qgcj17dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLGluOnttb2RlbDp0fX07cC5wb3N0TWVzc2FnZShyLFt0LmJ1ZmZlcl0pfSkpKTp1LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSh0KSxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT1hc3luYyh0LGUpPT5sKCk/KFQoKSxuZXcgUHJvbWlzZSgoKG4scik9Pnt5LnB1c2goW24scl0pO2NvbnN0IGk9e3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixpbjp7bW9kZWxkYXRhOnQsb3B0aW9uczplfX07cC5wb3N0TWVzc2FnZShpKX0pKSk6dS5jcmVhdGVTZXNzaW9uRmluYWxpemUodCxlKSxlLmNyZWF0ZVNlc3Npb249YXN5bmModCxlKT0+bCgpPyhUKCksbmV3IFByb21pc2UoKChuLHIpPT57Xy5wdXNoKFtuLHJdKTtjb25zdCBpPXt0eXBlOlwiY3JlYXRlXCIsaW46e21vZGVsOnQsb3B0aW9uczplfX07cC5wb3N0TWVzc2FnZShpLFt0LmJ1ZmZlcl0pfSkpKTp1LmNyZWF0ZVNlc3Npb24odCxlKSxlLnJlbGVhc2VTZXNzaW9uPWFzeW5jIHQ9PntpZihsKCkpcmV0dXJuIFQoKSxuZXcgUHJvbWlzZSgoKGUsbik9Pnt2LnB1c2goW2Usbl0pO2NvbnN0IHI9e3R5cGU6XCJyZWxlYXNlXCIsaW46dH07cC5wb3N0TWVzc2FnZShyKX0pKTt1LnJlbGVhc2VTZXNzaW9uKHQpfSxlLnJ1bj1hc3luYyh0LGUsbixyLGkpPT5sKCk/KFQoKSxuZXcgUHJvbWlzZSgoKG8sYSk9Pnt3LnB1c2goW28sYV0pO2NvbnN0IHM9e3R5cGU6XCJydW5cIixpbjp7c2Vzc2lvbklkOnQsaW5wdXRJbmRpY2VzOmUsaW5wdXRzOm4sb3V0cHV0SW5kaWNlczpyLG9wdGlvbnM6aX19O3AucG9zdE1lc3NhZ2Uocyx1LmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKG4pKX0pKSk6dS5ydW4odCxlLG4scixpKSxlLmVuZFByb2ZpbGluZz1hc3luYyB0PT57aWYobCgpKXJldHVybiBUKCksbmV3IFByb21pc2UoKChlLG4pPT57eC5wdXNoKFtlLG5dKTtjb25zdCByPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOnR9O3AucG9zdE1lc3NhZ2Uocil9KSk7dS5lbmRQcm9maWxpbmcodCl9fSw1ODY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuc2V0UnVuT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDc5NjcpLGk9big0OTgzKSxvPW4oNjM2MSk7ZS5zZXRSdW5PcHRpb25zPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IG49MDtjb25zdCBhPVtdLHM9dHx8e307dHJ5e2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1NldmVyaXR5TGV2ZWwpKXMubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQubG9nU2V2ZXJpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dTZXZlcml0eUxldmVsKXx8dC5sb2dTZXZlcml0eUxldmVsPDB8fHQubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7dC5sb2dTZXZlcml0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1ZlcmJvc2l0eUxldmVsKSlzLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dWZXJib3NpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1ZlcmJvc2l0eUxldmVsfWApO3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LnRlcm1pbmF0ZSkmJihzLnRlcm1pbmF0ZT0hMSk7bGV0IG89MDtpZih2b2lkIDAhPT0obnVsbD09dD92b2lkIDA6dC50YWcpJiYobz0oMCxpLmFsbG9jV2FzbVN0cmluZykodC50YWcsYSkpLG49ZS5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhzLmxvZ1NldmVyaXR5TGV2ZWwscy5sb2dWZXJib3NpdHlMZXZlbCwhIXMudGVybWluYXRlLG8pLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9uc1wiKTtyZXR1cm4gdm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQuZXh0cmEpJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKHQuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKHQscik9Pntjb25zdCBvPSgwLGkuYWxsb2NXYXNtU3RyaW5nKSh0LGEpLHM9KDAsaS5hbGxvY1dhc21TdHJpbmcpKHIsYSk7aWYoMCE9PWUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KG4sbyxzKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sYV19Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLGEuZm9yRWFjaChlLl9mcmVlKSx0fX19LDIzMDY6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyPXZvaWQgMDtjb25zdCByPW4oMjgwNiksaT1uKDE2NzApLG89bigyODUwKSxhPW4oMjE1Nyk7bGV0IHM7ZS5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI9Y2xhc3N7YXN5bmMgY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKHQpe2NvbnN0IGU9YXdhaXQgZmV0Y2godCksbj1hd2FpdCBlLmFycmF5QnVmZmVyKCk7cmV0dXJuKDAsYS5jcmVhdGVTZXNzaW9uQWxsb2NhdGUpKG5ldyBVaW50OEFycmF5KG4pKX1hc3luYyBsb2FkTW9kZWwodCxlKXtpZihzfHwoYXdhaXQoMCxhLmluaXRPcnQpKGkuZW52Lndhc20ubnVtVGhyZWFkcywodD0+e3N3aXRjaCh0KXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuIDA7Y2FzZVwiaW5mb1wiOnJldHVybiAxO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm4gMjtjYXNlXCJlcnJvclwiOnJldHVybiAzO2Nhc2VcImZhdGFsXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7dH1gKX19KShpLmVudi5sb2dMZXZlbCkpLHM9ITApLFwic3RyaW5nXCI9PXR5cGVvZiB0KWlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBmZXRjaCl7Y29uc3Qgbj1hd2FpdCgwLG8ucHJvbWlzaWZ5KShyLnJlYWRGaWxlKSh0KTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uKShuLGUpfWVsc2V7Y29uc3Qgbj1hd2FpdCB0aGlzLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSh0KTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAsYS5jcmVhdGVTZXNzaW9uRmluYWxpemUpKG4sZSl9ZWxzZVt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQoMCxhLmNyZWF0ZVNlc3Npb24pKHQsZSl9YXN5bmMgZGlzcG9zZSgpe3JldHVybigwLGEucmVsZWFzZVNlc3Npb24pKHRoaXMuc2Vzc2lvbklkKX1hc3luYyBydW4odCxlLG4pe2NvbnN0IHI9W10sbz1bXTtPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKCh0PT57Y29uc3QgZT10WzBdLG49dFsxXSxpPXRoaXMuaW5wdXROYW1lcy5pbmRleE9mKGUpO2lmKC0xPT09aSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7ZX0nYCk7ci5wdXNoKG4pLG8ucHVzaChpKX0pKTtjb25zdCBzPVtdO09iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKHQ9Pntjb25zdCBlPXRbMF0sbj10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YoZSk7aWYoLTE9PT1uKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7ZX0nYCk7cy5wdXNoKG4pfSkpO2NvbnN0IHU9YXdhaXQoMCxhLnJ1bikodGhpcy5zZXNzaW9uSWQsbyxyLm1hcCgodD0+W3QudHlwZSx0LmRpbXMsdC5kYXRhXSkpLHMsbiksYz17fTtmb3IobGV0IHQ9MDt0PHUubGVuZ3RoO3QrKyljW3RoaXMub3V0cHV0TmFtZXNbc1t0XV1dPW5ldyBpLlRlbnNvcih1W3RdWzBdLHVbdF1bMl0sdVt0XVsxXSk7cmV0dXJuIGN9c3RhcnRQcm9maWxpbmcoKXt9ZW5kUHJvZmlsaW5nKCl7KDAsYS5lbmRQcm9maWxpbmcpKHRoaXMuc2Vzc2lvbklkKX19fSw0OTE5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLnNldFNlc3Npb25PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oNzk2NyksaT1uKDQ5ODMpLG89big2MzYxKTtlLnNldFNlc3Npb25PcHRpb25zPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IG49MDtjb25zdCBhPVtdLHM9dHx8e307KHQ9Pnt0LmV4dHJhfHwodC5leHRyYT17fSksdC5leHRyYS5zZXNzaW9ufHwodC5leHRyYS5zZXNzaW9uPXt9KTtjb25zdCBlPXQuZXh0cmEuc2Vzc2lvbjtlLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fChlLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpfSkocyk7dHJ5e3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpJiYocy5ncmFwaE9wdGltaXphdGlvbkxldmVsPVwiYWxsXCIpO2NvbnN0IHU9KHQ9Pntzd2l0Y2godCl7Y2FzZVwiZGlzYWJsZWRcIjpyZXR1cm4gMDtjYXNlXCJiYXNpY1wiOnJldHVybiAxO2Nhc2VcImV4dGVuZGVkXCI6cmV0dXJuIDI7Y2FzZVwiYWxsXCI6cmV0dXJuIDk5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7dH1gKX19KShzLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpO3ZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZUNwdU1lbUFyZW5hKSYmKHMuZW5hYmxlQ3B1TWVtQXJlbmE9ITApLHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZU1lbVBhdHRlcm4pJiYocy5lbmFibGVNZW1QYXR0ZXJuPSEwKSx2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5leGVjdXRpb25Nb2RlKSYmKHMuZXhlY3V0aW9uTW9kZT1cInNlcXVlbnRpYWxcIik7Y29uc3QgYz0odD0+e3N3aXRjaCh0KXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7dH1gKX19KShzLmV4ZWN1dGlvbk1vZGUpO2xldCBsPTA7aWYodm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQubG9nSWQpJiYobD0oMCxpLmFsbG9jV2FzbVN0cmluZykodC5sb2dJZCxhKSksdm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nU2V2ZXJpdHlMZXZlbCkpcy5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dTZXZlcml0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1NldmVyaXR5TGV2ZWwpfHx0LmxvZ1NldmVyaXR5TGV2ZWw8MHx8dC5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nVmVyYm9zaXR5TGV2ZWwpKXMubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmxvZ1ZlcmJvc2l0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3QubG9nVmVyYm9zaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQuZW5hYmxlUHJvZmlsaW5nKSYmKHMuZW5hYmxlUHJvZmlsaW5nPSExKSxuPWUuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKHUsISFzLmVuYWJsZUNwdU1lbUFyZW5hLCEhcy5lbmFibGVNZW1QYXR0ZXJuLGMsISFzLmVuYWJsZVByb2ZpbGluZywwLGwscy5sb2dTZXZlcml0eUxldmVsLHMubG9nVmVyYm9zaXR5TGV2ZWwpLDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnNcIik7cmV0dXJuKG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uUHJvdmlkZXJzKSYmKCh0LGUsbik9Pntmb3IoY29uc3QgciBvZiBlKXtsZXQgZT1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIubmFtZTtzd2l0Y2goZSl7Y2FzZVwieG5ucGFja1wiOmU9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIEVQOiAke2V9YCl9Y29uc3QgYT0oMCxpLmFsbG9jV2FzbVN0cmluZykoZSxuKTtpZigwIT09KDAsby5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIodCxhKSl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZX1gKX19KShuLHQuZXhlY3V0aW9uUHJvdmlkZXJzLGEpLHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmV4dHJhKSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKSh0LmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKCh0LHIpPT57Y29uc3Qgbz0oMCxpLmFsbG9jV2FzbVN0cmluZykodCxhKSxzPSgwLGkuYWxsb2NXYXNtU3RyaW5nKShyLGEpO2lmKDAhPT1lLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkobixvLHMpKXRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sYV19Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhuKSxhLmZvckVhY2goZS5fZnJlZSksdH19fSw0OTgzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgcj1uKDYzNjEpO2UuYWxsb2NXYXNtU3RyaW5nPSh0LGUpPT57Y29uc3Qgbj0oMCxyLmdldEluc3RhbmNlKSgpLGk9bi5sZW5ndGhCeXRlc1VURjgodCkrMSxvPW4uX21hbGxvYyhpKTtyZXR1cm4gbi5zdHJpbmdUb1VURjgodCxvLGkpLGUucHVzaChvKSxvfX0sMzQ5Oih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzPWUuZW5kUHJvZmlsaW5nPWUucnVuPWUucmVsZWFzZVNlc3Npb249ZS5jcmVhdGVTZXNzaW9uPWUuY3JlYXRlU2Vzc2lvbkZpbmFsaXplPWUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWUuaW5pdE9ydD12b2lkIDA7Y29uc3Qgcj1uKDU4NiksaT1uKDQ5MTkpLG89big0OTgzKSxhPW4oNjM2MSk7ZS5pbml0T3J0PSh0LGUpPT57Y29uc3Qgbj0oMCxhLmdldEluc3RhbmNlKSgpLl9PcnRJbml0KHQsZSk7aWYoMCE9PW4pdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLiBlcnJvciBjb2RlID0gJHtufWApfTtjb25zdCBzPW5ldyBNYXA7ZS5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9dD0+e2NvbnN0IGU9KDAsYS5nZXRJbnN0YW5jZSkoKSxuPWUuX21hbGxvYyh0LmJ5dGVMZW5ndGgpO3JldHVybiBlLkhFQVBVOC5zZXQodCxuKSxbbix0LmJ5dGVMZW5ndGhdfSxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT0odCxlKT0+e2NvbnN0IG49KDAsYS5nZXRJbnN0YW5jZSkoKTtsZXQgcj0wLG89MCx1PVtdO3RyeXtpZihbbyx1XT0oMCxpLnNldFNlc3Npb25PcHRpb25zKShlKSxyPW4uX09ydENyZWF0ZVNlc3Npb24odFswXSx0WzFdLG8pLDA9PT1yKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb25cIil9ZmluYWxseXtuLl9mcmVlKHRbMF0pLG4uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhvKSx1LmZvckVhY2gobi5fZnJlZSl9Y29uc3QgYz1uLl9PcnRHZXRJbnB1dENvdW50KHIpLGw9bi5fT3J0R2V0T3V0cHV0Q291bnQocikscD1bXSxmPVtdLGQ9W10saD1bXTtmb3IobGV0IHQ9MDt0PGM7dCsrKXtjb25zdCBlPW4uX09ydEdldElucHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lXCIpO2YucHVzaChlKSxwLnB1c2gobi5VVEY4VG9TdHJpbmcoZSkpfWZvcihsZXQgdD0wO3Q8bDt0Kyspe2NvbnN0IGU9bi5fT3J0R2V0T3V0cHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbid0IGdldCBhbiBvdXRwdXQgbmFtZVwiKTtoLnB1c2goZSksZC5wdXNoKG4uVVRGOFRvU3RyaW5nKGUpKX1yZXR1cm4gcy5zZXQocixbcixmLGhdKSxbcixwLGRdfSxlLmNyZWF0ZVNlc3Npb249KHQsbik9Pntjb25zdCByPSgwLGUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKSh0KTtyZXR1cm4oMCxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZSkocixuKX0sZS5yZWxlYXNlU2Vzc2lvbj10PT57Y29uc3QgZT0oMCxhLmdldEluc3RhbmNlKSgpLG49cy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxpPW5bMV0sbz1uWzJdO2kuZm9yRWFjaChlLl9PcnRGcmVlKSxvLmZvckVhY2goZS5fT3J0RnJlZSksZS5fT3J0UmVsZWFzZVNlc3Npb24ocikscy5kZWxldGUodCl9O2NvbnN0IHU9dD0+e3N3aXRjaCh0KXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9YCl9fSxjPXQ9Pntzd2l0Y2godCl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgMTE6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSA4OnJldHVyblwic3RyaW5nXCI7Y2FzZSA3OnJldHVyblwiaW50NjRcIjtjYXNlIDEzOnJldHVyblwidWludDY0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fWApfX0sbD10PT57c3dpdGNoKHQpe2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke3R9YCl9fTtlLnJ1bj0odCxlLG4saSxwKT0+e2NvbnN0IGY9KDAsYS5nZXRJbnN0YW5jZSkoKSxkPXMuZ2V0KHQpO2lmKCFkKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtjb25zdCBoPWRbMF0sZz1kWzFdLGI9ZFsyXSxtPWUubGVuZ3RoLHk9aS5sZW5ndGg7bGV0IF89MCx2PVtdO2NvbnN0IHc9W10seD1bXTt0cnl7W18sdl09KDAsci5zZXRSdW5PcHRpb25zKShwKTtmb3IobGV0IHQ9MDt0PG07dCsrKXtjb25zdCBlPW5bdF1bMF0scj1uW3RdWzFdLGk9blt0XVsyXTtsZXQgYSxzO2lmKEFycmF5LmlzQXJyYXkoaSkpe3M9NCppLmxlbmd0aCxhPWYuX21hbGxvYyhzKSx4LnB1c2goYSk7bGV0IHQ9YS80O2ZvcihsZXQgZT0wO2U8aS5sZW5ndGg7ZSsrKXtpZihcInN0cmluZ1wiIT10eXBlb2YgaVtlXSl0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2V9IGlzIG5vdCBhIHN0cmluZ2ApO2YuSEVBUFUzMlt0KytdPSgwLG8uYWxsb2NXYXNtU3RyaW5nKShpW2VdLHgpfX1lbHNlIHM9aS5ieXRlTGVuZ3RoLGE9Zi5fbWFsbG9jKHMpLHgucHVzaChhKSxmLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoaS5idWZmZXIsaS5ieXRlT2Zmc2V0LHMpLGEpO2NvbnN0IGM9Zi5zdGFja1NhdmUoKSxsPWYuc3RhY2tBbGxvYyg0KnIubGVuZ3RoKTt0cnl7bGV0IHQ9bC80O3IuZm9yRWFjaCgoZT0+Zi5IRUFQMzJbdCsrXT1lKSk7Y29uc3Qgbj1mLl9PcnRDcmVhdGVUZW5zb3IodShlKSxhLHMsbCxyLmxlbmd0aCk7aWYoMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY3JlYXRlIGEgdGVuc29yXCIpO3cucHVzaChuKX1maW5hbGx5e2Yuc3RhY2tSZXN0b3JlKGMpfX1jb25zdCB0PWYuc3RhY2tTYXZlKCksYT1mLnN0YWNrQWxsb2MoNCptKSxzPWYuc3RhY2tBbGxvYyg0Km0pLGQ9Zi5zdGFja0FsbG9jKDQqeSksVD1mLnN0YWNrQWxsb2MoNCp5KTt0cnl7bGV0IG49YS80LHI9cy80LG89ZC80LHU9VC80O2ZvcihsZXQgdD0wO3Q8bTt0KyspZi5IRUFQVTMyW24rK109d1t0XSxmLkhFQVBVMzJbcisrXT1nW2VbdF1dO2ZvcihsZXQgdD0wO3Q8eTt0KyspZi5IRUFQVTMyW28rK109MCxmLkhFQVBVMzJbdSsrXT1iW2lbdF1dO2xldCBwPWYuX09ydFJ1bihoLHMsYSxtLFQseSxkLF8pO2NvbnN0IHY9W107aWYoMD09PXApZm9yKGxldCB0PTA7dDx5O3QrKyl7Y29uc3QgZT1mLkhFQVBVMzJbZC80K3RdLG49Zi5zdGFja1NhdmUoKSxyPWYuc3RhY2tBbGxvYygxNik7bGV0IGksbz0wO3RyeXtpZihwPWYuX09ydEdldFRlbnNvckRhdGEoZSxyLHIrNCxyKzgscisxMiksMCE9PXApdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhLiBlcnJvciBjb2RlID0gJHtwfWApO2xldCB0PXIvNDtjb25zdCBhPWYuSEVBUFUzMlt0KytdO289Zi5IRUFQVTMyW3QrK107Y29uc3Qgcz1mLkhFQVBVMzJbdCsrXSx1PWYuSEVBUFUzMlt0KytdLGQ9W107Zm9yKGxldCB0PTA7dDx1O3QrKylkLnB1c2goZi5IRUFQVTMyW3MvNCt0XSk7Zi5fT3J0RnJlZShzKTtjb25zdCBoPTA9PT1kLmxlbmd0aD8xOmQucmVkdWNlKCgodCxlKT0+dCplKSk7aWYoaT1jKGEpLFwic3RyaW5nXCI9PT1pKXtjb25zdCB0PVtdO2xldCBlPW8vNDtmb3IobGV0IG49MDtuPGg7bisrKXtjb25zdCByPWYuSEVBUFUzMltlKytdLGk9bj09PWgtMT92b2lkIDA6Zi5IRUFQVTMyW2VdLXI7dC5wdXNoKGYuVVRGOFRvU3RyaW5nKHIsaSkpfXYucHVzaChbaSxkLHRdKX1lbHNle2NvbnN0IHQ9bmV3KGwoaSkpKGgpO25ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpLnNldChmLkhFQVBVOC5zdWJhcnJheShvLG8rdC5ieXRlTGVuZ3RoKSksdi5wdXNoKFtpLGQsdF0pfX1maW5hbGx5e2Yuc3RhY2tSZXN0b3JlKG4pLFwic3RyaW5nXCI9PT1pJiZvJiZmLl9mcmVlKG8pLGYuX09ydFJlbGVhc2VUZW5zb3IoZSl9fWlmKDA9PT1wKXJldHVybiB2O3Rocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuIGVycm9yIGNvZGUgPSAke3B9LmApfWZpbmFsbHl7Zi5zdGFja1Jlc3RvcmUodCl9fWZpbmFsbHl7dy5mb3JFYWNoKGYuX09ydFJlbGVhc2VUZW5zb3IpLHguZm9yRWFjaChmLl9mcmVlKSxmLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhfKSx2LmZvckVhY2goZi5fZnJlZSl9fSxlLmVuZFByb2ZpbGluZz10PT57Y29uc3QgZT0oMCxhLmdldEluc3RhbmNlKSgpLG49cy5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxpPWUuX09ydEVuZFByb2ZpbGluZyhyKTtpZigwPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWVcIik7ZS5fT3J0RnJlZShpKX0sZS5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycz10PT57Y29uc3QgZT1bXTtmb3IoY29uc3QgbiBvZiB0KXtjb25zdCB0PW5bMl07IUFycmF5LmlzQXJyYXkodCkmJnQuYnVmZmVyJiZlLnB1c2godC5idWZmZXIpfXJldHVybiBlfX0sNjM2MTpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTtpJiYhKFwiZ2V0XCJpbiBpPyFlLl9fZXNNb2R1bGU6aS53cml0YWJsZXx8aS5jb25maWd1cmFibGUpfHwoaT17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLGkpfTpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKSx0W3JdPWVbbl19KSxpPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KX06ZnVuY3Rpb24odCxlKXt0LmRlZmF1bHQ9ZX0pLG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJnIoZSx0LG4pO3JldHVybiBpKGUsdCksZX0sYT10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRpc3Bvc2U9ZS5nZXRJbnN0YW5jZT1lLmluaXRpYWxpemVXZWJBc3NlbWJseT12b2lkIDA7Y29uc3Qgcz1vKG4oNjQ0OSkpLHU9YShuKDkzMikpLGM9bigzNDc0KTtsZXQgbCxwPSExLGY9ITEsZD0hMTtjb25zdCBoPSh0LGUpPT5lP3Q/XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc21cIjpcIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjp0P1wib3J0LXdhc20tc2ltZC53YXNtXCI6XCJvcnQtd2FzbS53YXNtXCI7ZS5pbml0aWFsaXplV2ViQXNzZW1ibHk9YXN5bmMgdD0+e2lmKHApcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKGYpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7aWYoZCl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtmPSEwO2NvbnN0IGU9dC5pbml0VGltZW91dCxyPXQubnVtVGhyZWFkcyxpPXQuc2ltZCxvPXI+MSYmKCgpPT57dHJ5e3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNZXNzYWdlQ2hhbm5lbCYmKG5ldyBNZXNzYWdlQ2hhbm5lbCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLGE9aSYmKCgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLGc9XCJzdHJpbmdcIj09dHlwZW9mIHQud2FzbVBhdGhzP3Qud2FzbVBhdGhzOnZvaWQgMCxiPWgoITEsbyksbT1oKGEsbykseT1cIm9iamVjdFwiPT10eXBlb2YgdC53YXNtUGF0aHM/dC53YXNtUGF0aHNbbV06dm9pZCAwO2xldCBfPSExO2NvbnN0IHY9W107aWYoZT4wJiZ2LnB1c2gobmV3IFByb21pc2UoKHQ9PntzZXRUaW1lb3V0KCgoKT0+e189ITAsdCgpfSksZSl9KSkpLHYucHVzaChuZXcgUHJvbWlzZSgoKHQsZSk9Pntjb25zdCByPW8/Yzp1LmRlZmF1bHQsaT17bG9jYXRlRmlsZToodCxlKT0+byYmdC5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBCbG9iP1VSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW24oNDE1NCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk6dD09PWI/bnVsbCE9eT95OihudWxsIT1nP2c6ZSkrbTplK3R9O2lmKG8paWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJsb2IpaS5tYWluU2NyaXB0VXJsT3JCbG9iPXMuam9pbihcIi9cIixcIm9ydC13YXNtLXRocmVhZGVkLmpzXCIpO2Vsc2V7Y29uc3QgdD1gdmFyIG9ydFdhc21UaHJlYWRlZD0oZnVuY3Rpb24oKXt2YXIgX3NjcmlwdERpcjtyZXR1cm4gJHtyLnRvU3RyaW5nKCl9fSkoKTtgO2kubWFpblNjcmlwdFVybE9yQmxvYj1uZXcgQmxvYihbdF0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pfXIoaSkudGhlbigoZT0+e2Y9ITEscD0hMCxsPWUsdCgpfSksKHQ9PntmPSExLGQ9ITAsZSh0KX0pKX0pKSksYXdhaXQgUHJvbWlzZS5yYWNlKHYpLF8pdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7ZX1tc2ApfSxlLmdldEluc3RhbmNlPSgpPT57aWYocCYmbClyZXR1cm4gbDt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX0sZS5kaXNwb3NlPSgpPT57dmFyIHQ7IXB8fGZ8fGR8fChmPSEwLG51bGw9PT0odD1sLlBUaHJlYWQpfHx2b2lkIDA9PT10fHx0LnRlcm1pbmF0ZUFsbFRocmVhZHMoKSxsPXZvaWQgMCxmPSExLHA9ITEsZD0hMCl9fSw5NzEwOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtuLmQoZSx7WjooKT0+b30pO3ZhciByPW4oNDc3KSxpPW4ubihyKTtmdW5jdGlvbiBvKCl7cmV0dXJuIGkoKSgnLyohXFxuKiBPTk5YIFJ1bnRpbWUgV2ViIHYxLjE0LjBcXG4qIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxcbiovXFxuKCgpPT57dmFyIHQ9ezQ3NDoodCxlLG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8XCIvaW5kZXguanNcIixmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIGouYnVmZmVyIT1EJiZOKGouYnVmZmVyKSxQfWZ1bmN0aW9uIHIoKXtyZXR1cm4gai5idWZmZXIhPUQmJk4oai5idWZmZXIpLFV9ZnVuY3Rpb24gYSgpe3JldHVybiBqLmJ1ZmZlciE9RCYmTihqLmJ1ZmZlciksRn1mdW5jdGlvbiBpKCl7cmV0dXJuIGouYnVmZmVyIT1EJiZOKGouYnVmZmVyKSxJfWZ1bmN0aW9uIG8oKXtyZXR1cm4gai5idWZmZXIhPUQmJk4oai5idWZmZXIpLFd9dmFyIHUsYyxzO3Q9dHx8e30sdXx8KHU9dm9pZCAwIT09dD90Ont9KSx1LnJlYWR5PW5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe2M9dCxzPWV9KSk7dmFyIGwsZixwLGgsZCx5LGI9T2JqZWN0LmFzc2lnbih7fSx1KSxtPVwiLi90aGlzLnByb2dyYW1cIixnPSh0LGUpPT57dGhyb3cgZX0sdj1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LHc9XCJmdW5jdGlvblwiPT10eXBlb2YgaW1wb3J0U2NyaXB0cyxfPVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSxPPXUuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRHx8ITEsQT1cIlwiO2Z1bmN0aW9uIFModCl7cmV0dXJuIHUubG9jYXRlRmlsZT91LmxvY2F0ZUZpbGUodCxBKTpBK3R9aWYoXyl7bGV0IGU7QT13P24oOTA4KS5kaXJuYW1lKEEpK1wiL1wiOlwiLy9cIix5PSgpPT57ZHx8KGg9bigzODQpLGQ9big5MDgpKX0sbD1mdW5jdGlvbih0LGUpe3JldHVybiB5KCksdD1kLm5vcm1hbGl6ZSh0KSxoLnJlYWRGaWxlU3luYyh0LGU/dm9pZCAwOlwidXRmOFwiKX0scD10PT4oKHQ9bCh0LCEwKSkuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksdCksZj0odCxlLG4pPT57eSgpLHQ9ZC5ub3JtYWxpemUodCksaC5yZWFkRmlsZSh0LChmdW5jdGlvbih0LHIpe3Q/bih0KTplKHIuYnVmZmVyKX0pKX0sMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYobT1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXFxcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwoZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgY3QpKXRocm93IHR9KSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLChmdW5jdGlvbih0KXt0aHJvdyB0fSkpLGc9KHQsZSk9PntpZihRKCkpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT10LGU7ZSBpbnN0YW5jZW9mIGN0fHx4KFwiZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiBcIitlKSxwcm9jZXNzLmV4aXQodCl9LHUuaW5zcGVjdD1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn07dHJ5e2U9big5MjUpfWNhdGNoKHQpe3Rocm93IGNvbnNvbGUuZXJyb3IoXFwnVGhlIFwid29ya2VyX3RocmVhZHNcIiBtb2R1bGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIG5vZGUuanMgYnVpbGQgLSBwZXJoYXBzIGEgbmV3ZXIgdmVyc2lvbiBpcyBuZWVkZWQ/XFwnKSx0fW4uZy5Xb3JrZXI9ZS5Xb3JrZXJ9ZWxzZSh2fHx3KSYmKHc/QT1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoQT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKEE9X3NjcmlwdERpciksQT0wIT09QS5pbmRleE9mKFwiYmxvYjpcIik/QS5zdWJzdHIoMCxBLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIsX3x8KGw9dD0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZS5vcGVuKFwiR0VUXCIsdCwhMSksZS5zZW5kKG51bGwpLGUucmVzcG9uc2VUZXh0fSx3JiYocD10PT57dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBlLm9wZW4oXCJHRVRcIix0LCExKSxlLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsZS5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGUucmVzcG9uc2UpfSksZj0odCxlLG4pPT57dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3Iub3BlbihcIkdFVFwiLHQsITApLHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixyLm9ubG9hZD0oKT0+ezIwMD09ci5zdGF0dXN8fDA9PXIuc3RhdHVzJiZyLnJlc3BvbnNlP2Uoci5yZXNwb25zZSk6bigpfSxyLm9uZXJyb3I9bixyLnNlbmQobnVsbCl9KSk7XyYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIHBlcmZvcm1hbmNlJiYobi5nLnBlcmZvcm1hbmNlPW4oOTUzKS5wZXJmb3JtYW5jZSk7dmFyIFQ9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxFPWNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO18mJih5KCksVD10PT5oLndyaXRlU3luYygxLHQrXCJcXFxcblwiKSxFPXQ9Pmgud3JpdGVTeW5jKDIsdCtcIlxcXFxuXCIpKTt2YXIgTSxDPXUucHJpbnR8fFQseD11LnByaW50RXJyfHxFO09iamVjdC5hc3NpZ24odSxiKSxiPW51bGwsdS50aGlzUHJvZ3JhbSYmKG09dS50aGlzUHJvZ3JhbSksdS5xdWl0JiYoZz11LnF1aXQpLHUud2FzbUJpbmFyeSYmKE09dS53YXNtQmluYXJ5KTt2YXIgUj11Lm5vRXhpdFJ1bnRpbWV8fCExO1wib2JqZWN0XCIhPXR5cGVvZiBXZWJBc3NlbWJseSYmYXQoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBqLGssRCxQLFUsRixJLFcsSD0hMSxMPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiB6KHQsZSxuKXt2YXIgcj0oZT4+Pj0wKStuO2ZvcihuPWU7dFtuXSYmIShuPj1yKTspKytuO2lmKDE2PG4tZSYmdC5idWZmZXImJkwpcmV0dXJuIEwuZGVjb2RlKHQuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXI/dC5zbGljZShlLG4pOnQuc3ViYXJyYXkoZSxuKSk7Zm9yKHI9XCJcIjtlPG47KXt2YXIgYT10W2UrK107aWYoMTI4JmEpe3ZhciBpPTYzJnRbZSsrXTtpZigxOTI9PSgyMjQmYSkpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmYSk8PDZ8aSk7ZWxzZXt2YXIgbz02MyZ0W2UrK107NjU1MzY+KGE9MjI0PT0oMjQwJmEpPygxNSZhKTw8MTJ8aTw8NnxvOig3JmEpPDwxOHxpPDwxMnxvPDw2fDYzJnRbZSsrXSk/cis9U3RyaW5nLmZyb21DaGFyQ29kZShhKTooYS09NjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxhPj4xMCw1NjMyMHwxMDIzJmEpKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpfXJldHVybiByfWZ1bmN0aW9uIFkodCxlKXtyZXR1cm4odD4+Pj0wKT96KHIoKSx0LGUpOlwiXCJ9ZnVuY3Rpb24gQih0LGUsbixyKXtpZighKDA8cikpcmV0dXJuIDA7dmFyIGE9bj4+Pj0wO3I9bityLTE7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDsrK2kpe3ZhciBvPXQuY2hhckNvZGVBdChpKTtpZig1NTI5Njw9byYmNTczNDM+PW8mJihvPTY1NTM2KygoMTAyMyZvKTw8MTApfDEwMjMmdC5jaGFyQ29kZUF0KCsraSkpLDEyNz49byl7aWYobj49cilicmVhaztlW24rKz4+PjBdPW99ZWxzZXtpZigyMDQ3Pj1vKXtpZihuKzE+PXIpYnJlYWs7ZVtuKys+Pj4wXT0xOTJ8bz4+Nn1lbHNle2lmKDY1NTM1Pj1vKXtpZihuKzI+PXIpYnJlYWs7ZVtuKys+Pj4wXT0yMjR8bz4+MTJ9ZWxzZXtpZihuKzM+PXIpYnJlYWs7ZVtuKys+Pj4wXT0yNDB8bz4+MTgsZVtuKys+Pj4wXT0xMjh8bz4+MTImNjN9ZVtuKys+Pj4wXT0xMjh8bz4+NiY2M31lW24rKz4+PjBdPTEyOHw2MyZvfX1yZXR1cm4gZVtuPj4+MF09MCxuLWF9ZnVuY3Rpb24gRyh0KXtmb3IodmFyIGU9MCxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciByPXQuY2hhckNvZGVBdChuKTsxMjc+PXI/ZSsrOjIwNDc+PXI/ZSs9Mjo1NTI5Njw9ciYmNTczNDM+PXI/KGUrPTQsKytuKTplKz0zfXJldHVybiBlfWZ1bmN0aW9uIE4odCl7RD10LHUuSEVBUDg9UD1uZXcgSW50OEFycmF5KHQpLHUuSEVBUDE2PW5ldyBJbnQxNkFycmF5KHQpLHUuSEVBUDMyPUY9bmV3IEludDMyQXJyYXkodCksdS5IRUFQVTg9VT1uZXcgVWludDhBcnJheSh0KSx1LkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHQpLHUuSEVBUFUzMj1JPW5ldyBVaW50MzJBcnJheSh0KSx1LkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheSh0KSx1LkhFQVBGNjQ9Vz1uZXcgRmxvYXQ2NEFycmF5KHQpfU8mJihEPXUuYnVmZmVyKTt2YXIgVj11LklOSVRJQUxfTUVNT1JZfHwxNjc3NzIxNjtpZihPKWo9dS53YXNtTWVtb3J5LEQ9dS5idWZmZXI7ZWxzZSBpZih1Lndhc21NZW1vcnkpaj11Lndhc21NZW1vcnk7ZWxzZSBpZighKChqPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6Vi82NTUzNixtYXhpbXVtOjY1NTM2LHNoYXJlZDohMH0pKS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpdGhyb3cgeChcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKSxfJiZjb25zb2xlLmxvZyhcIihvbiBub2RlIHlvdSBtYXkgbmVlZDogLS1leHBlcmltZW50YWwtd2FzbS10aHJlYWRzIC0tZXhwZXJpbWVudGFsLXdhc20tYnVsay1tZW1vcnkgYW5kIGFsc28gdXNlIGEgcmVjZW50IHZlcnNpb24pXCIpLEVycm9yKFwiYmFkIG1lbW9yeVwiKTtqJiYoRD1qLmJ1ZmZlciksVj1ELmJ5dGVMZW5ndGgsTihEKTt2YXIgJCxxPVtdLFg9W10sSj1bXSxaPVtdO2Z1bmN0aW9uIFEoKXtyZXR1cm4gUnx8ITF9ZnVuY3Rpb24gSygpe3ZhciB0PXUucHJlUnVuLnNoaWZ0KCk7cS51bnNoaWZ0KHQpfXZhciB0dCxldD0wLG50PW51bGwscnQ9bnVsbDtmdW5jdGlvbiBhdCh0KXt0aHJvdyBPP3Bvc3RNZXNzYWdlKHtjbWQ6XCJvbkFib3J0XCIsYXJnOnR9KTp1Lm9uQWJvcnQmJnUub25BYm9ydCh0KSx4KHQ9XCJBYm9ydGVkKFwiK3QrXCIpXCIpLEg9ITAsdD1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLHModCksdH1mdW5jdGlvbiBpdCgpe3JldHVybiB0dC5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX1mdW5jdGlvbiBvdCgpe3ZhciB0PXR0O3RyeXtpZih0PT10dCYmTSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoTSk7aWYocClyZXR1cm4gcCh0KTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaCh0KXthdCh0KX19dHQ9XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCIsaXQoKXx8KHR0PVModHQpKTt2YXIgdXQ9e307ZnVuY3Rpb24gY3QodCl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1cIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIrdCtcIilcIix0aGlzLnN0YXR1cz10fWZ1bmN0aW9uIHN0KHQpeyh0PWh0LlZiW3RdKXx8YXQoKSxodC5tYyh0KX1mdW5jdGlvbiBsdCh0KXt2YXIgZT1odC5DYygpO2lmKCFlKXJldHVybiA2O2h0LmFjLnB1c2goZSksaHQuVmJbdC5VYl09ZSxlLlViPXQuVWI7dmFyIG49e2NtZDpcInJ1blwiLHN0YXJ0X3JvdXRpbmU6dC5JYyxhcmc6dC56YyxwdGhyZWFkX3B0cjp0LlVifTtyZXR1cm4gZS4kYj0oKT0+e24udGltZT1wZXJmb3JtYW5jZS5ub3coKSxlLnBvc3RNZXNzYWdlKG4sdC5OYyl9LGUubG9hZGVkJiYoZS4kYigpLGRlbGV0ZSBlLiRiKSwwfWZ1bmN0aW9uIGZ0KHQpe2lmKE8pcmV0dXJuICR0KDEsMSx0KTtRKCl8fChodC5vYygpLHUub25FeGl0JiZ1Lm9uRXhpdCh0KSxIPSEwKSxnKHQsbmV3IGN0KHQpKX1mdW5jdGlvbiBwdCh0LGUpe2lmKCFlJiZPKXRocm93IGJ0KHQpLFwidW53aW5kXCI7USgpfHxPfHwobWUoKSxkdChKKSxiZSgwKSxyZVsxXS5sZW5ndGgmJmFlKDEsMTApLHJlWzJdLmxlbmd0aCYmYWUoMiwxMCksaHQub2MoKSksZnQodCl9dmFyIGh0PXtZYjpbXSxhYzpbXSxxYzpbXSxWYjp7fSxmYzpmdW5jdGlvbigpe08mJmh0LkVjKCl9LFBjOmZ1bmN0aW9uKCl7fSxFYzpmdW5jdGlvbigpe2h0LnJlY2VpdmVPYmplY3RUcmFuc2Zlcj1odC5HYyxodC50aHJlYWRJbml0VExTPWh0LnBjLGh0LnNldEV4aXRTdGF0dXM9aHQubmMsUj0hMX0sbmM6ZnVuY3Rpb24oKXt9LG9jOmZ1bmN0aW9uKCl7Zm9yKHZhciB0IG9mIE9iamVjdC52YWx1ZXMoaHQuVmIpKWh0Lm1jKHQpO2Zvcih0IG9mIGh0LlliKXQudGVybWluYXRlKCk7aHQuWWI9W119LG1jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuVWI7ZGVsZXRlIGh0LlZiW2VdLGh0LlliLnB1c2godCksaHQuYWMuc3BsaWNlKGh0LmFjLmluZGV4T2YodCksMSksdC5VYj0wLE9lKGUpfSxHYzpmdW5jdGlvbigpe30scGM6ZnVuY3Rpb24oKXtodC5xYy5mb3JFYWNoKCh0PT50KCkpKX0sRmM6ZnVuY3Rpb24odCxlKXt0Lm9ubWVzc2FnZT1uPT57dmFyIHI9KG49bi5kYXRhKS5jbWQ7aWYodC5VYiYmKGh0LkJjPXQuVWIpLG4udGFyZ2V0VGhyZWFkJiZuLnRhcmdldFRocmVhZCE9aGUoKSl7dmFyIGE9aHQuVmJbbi5RY107YT9hLnBvc3RNZXNzYWdlKG4sbi50cmFuc2Zlckxpc3QpOngoXFwnSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIlxcJytyK1xcJ1wiIHRvIHRhcmdldCBwdGhyZWFkIFxcJytuLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfWVsc2VcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCI9PT1yP3p0KG4ucXVldWUpOlwic3Bhd25UaHJlYWRcIj09PXI/bHQobik6XCJjbGVhbnVwVGhyZWFkXCI9PT1yP3N0KG4udGhyZWFkKTpcImtpbGxUaHJlYWRcIj09PXI/KG49bi50aHJlYWQscj1odC5WYltuXSxkZWxldGUgaHQuVmJbbl0sci50ZXJtaW5hdGUoKSxPZShuKSxodC5hYy5zcGxpY2UoaHQuYWMuaW5kZXhPZihyKSwxKSxyLlViPTApOlwiY2FuY2VsVGhyZWFkXCI9PT1yP2h0LlZiW24udGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTpcImxvYWRlZFwiPT09cj8odC5sb2FkZWQ9ITAsZSYmZSh0KSx0LiRiJiYodC4kYigpLGRlbGV0ZSB0LiRiKSk6XCJwcmludFwiPT09cj9DKFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJwcmludEVyclwiPT09cj94KFwiVGhyZWFkIFwiK24udGhyZWFkSWQrXCI6IFwiK24udGV4dCk6XCJhbGVydFwiPT09cj9hbGVydChcIlRocmVhZCBcIituLnRocmVhZElkK1wiOiBcIituLnRleHQpOlwic2V0aW1tZWRpYXRlXCI9PT1uLnRhcmdldD90LnBvc3RNZXNzYWdlKG4pOlwib25BYm9ydFwiPT09cj91Lm9uQWJvcnQmJnUub25BYm9ydChuLmFyZyk6ciYmeChcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIityKTtodC5CYz12b2lkIDB9LHQub25lcnJvcj10PT57dGhyb3cgeChcIndvcmtlciBzZW50IGFuIGVycm9yISBcIit0LmZpbGVuYW1lK1wiOlwiK3QubGluZW5vK1wiOiBcIit0Lm1lc3NhZ2UpLHR9LF8mJih0Lm9uKFwibWVzc2FnZVwiLChmdW5jdGlvbihlKXt0Lm9ubWVzc2FnZSh7ZGF0YTplfSl9KSksdC5vbihcImVycm9yXCIsKGZ1bmN0aW9uKGUpe3Qub25lcnJvcihlKX0pKSx0Lm9uKFwiZGV0YWNoZWRFeGl0XCIsKGZ1bmN0aW9uKCl7fSkpKSx0LnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsdXJsT3JCbG9iOnUubWFpblNjcmlwdFVybE9yQmxvYnx8X3NjcmlwdERpcix3YXNtTWVtb3J5Omosd2FzbU1vZHVsZTprfSl9LHljOmZ1bmN0aW9uKCl7dmFyIHQ9UyhcIm9ydC13YXNtLXRocmVhZGVkLndvcmtlci5qc1wiKTtodC5ZYi5wdXNoKG5ldyBXb3JrZXIodCkpfSxDYzpmdW5jdGlvbigpe3JldHVybiAwPT1odC5ZYi5sZW5ndGgmJihodC55YygpLGh0LkZjKGh0LlliWzBdKSksaHQuWWIucG9wKCl9fTtmdW5jdGlvbiBkdCh0KXtmb3IoOzA8dC5sZW5ndGg7KXQuc2hpZnQoKSh1KX1mdW5jdGlvbiB5dCh0KXt2YXIgZT1FZSgpO3JldHVybiB0PXQoKSxNZShlKSx0fWZ1bmN0aW9uIGJ0KHQpe2lmKE8pcmV0dXJuICR0KDIsMCx0KTt0cnl7cHQodCl9Y2F0Y2godCl7dCBpbnN0YW5jZW9mIGN0fHxcInVud2luZFwiPT10fHxnKDEsdCl9fXUuUFRocmVhZD1odCx1LmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgdD1oZSgpLGU9YSgpW3QrNDQ+PjI+Pj4wXTt0PWEoKVt0KzQ4Pj4yPj4+MF0sVGUoZSxlLXQpLE1lKGUpfTt2YXIgbXQ9W107ZnVuY3Rpb24gZ3QodCl7dmFyIGU9bXRbdF07cmV0dXJuIGV8fCh0Pj1tdC5sZW5ndGgmJihtdC5sZW5ndGg9dCsxKSxtdFt0XT1lPSQuZ2V0KHQpKSxlfXUuaW52b2tlRW50cnlQb2ludD1mdW5jdGlvbih0LGUpe3Q9Z3QodCkoZSksUSgpP2h0Lm5jKHQpOkFlKHQpfTt2YXIgdnQsd3QsX3Q9W10sT3Q9MCxBdD0wO2Z1bmN0aW9uIFN0KHQpe3RoaXMuWmI9dCx0aGlzLlNiPXQtMjQsdGhpcy54Yz1mdW5jdGlvbih0KXtpKClbdGhpcy5TYis0Pj4yPj4+MF09dH0sdGhpcy5iYz1mdW5jdGlvbigpe3JldHVybiBpKClbdGhpcy5TYis0Pj4yPj4+MF19LHRoaXMud2M9ZnVuY3Rpb24odCl7aSgpW3RoaXMuU2IrOD4+Mj4+PjBdPXR9LHRoaXMuRGM9ZnVuY3Rpb24oKXtyZXR1cm4gaSgpW3RoaXMuU2IrOD4+Mj4+PjBdfSx0aGlzLnJjPWZ1bmN0aW9uKCl7YSgpW3RoaXMuU2I+PjI+Pj4wXT0wfSx0aGlzLmhjPWZ1bmN0aW9uKHQpe3Q9dD8xOjAsZSgpW3RoaXMuU2IrMTI+PjA+Pj4wXT10fSx0aGlzLnVjPWZ1bmN0aW9uKCl7cmV0dXJuIDAhPWUoKVt0aGlzLlNiKzEyPj4wPj4+MF19LHRoaXMuaWM9ZnVuY3Rpb24odCl7dD10PzE6MCxlKClbdGhpcy5TYisxMz4+MD4+PjBdPXR9LHRoaXMua2M9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9ZSgpW3RoaXMuU2IrMTM+PjA+Pj4wXX0sdGhpcy5mYz1mdW5jdGlvbih0LGUpe3RoaXMuY2MoMCksdGhpcy54Yyh0KSx0aGlzLndjKGUpLHRoaXMucmMoKSx0aGlzLmhjKCExKSx0aGlzLmljKCExKX0sdGhpcy5zYz1mdW5jdGlvbigpe0F0b21pY3MuYWRkKGEoKSx0aGlzLlNiPj4yLDEpfSx0aGlzLkhjPWZ1bmN0aW9uKCl7cmV0dXJuIDE9PT1BdG9taWNzLnN1YihhKCksdGhpcy5TYj4+MiwxKX0sdGhpcy5jYz1mdW5jdGlvbih0KXtpKClbdGhpcy5TYisxNj4+Mj4+PjBdPXR9LHRoaXMudGM9ZnVuY3Rpb24oKXtyZXR1cm4gaSgpW3RoaXMuU2IrMTY+PjI+Pj4wXX0sdGhpcy52Yz1mdW5jdGlvbigpe2lmKFJlKHRoaXMuYmMoKSkpcmV0dXJuIGkoKVt0aGlzLlpiPj4yPj4+MF07dmFyIHQ9dGhpcy50YygpO3JldHVybiAwIT09dD90OnRoaXMuWmJ9fWZ1bmN0aW9uIFR0KHQpe3JldHVybiB5ZShuZXcgU3QodCkuU2IpfWZ1bmN0aW9uIEV0KHQsZSxuLHIpe3JldHVybiBPPyR0KDMsMSx0LGUsbixyKTpNdCh0LGUsbixyKX1mdW5jdGlvbiBNdCh0LGUsbixyKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIpcmV0dXJuIHgoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBhPVtdO3JldHVybiBPJiYwPT09YS5sZW5ndGg/RXQodCxlLG4scik6KHQ9e0ljOm4sVWI6dCx6YzpyLE5jOmF9LE8/KHQuT2M9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHQsYSksMCk6bHQodCkpfWZ1bmN0aW9uIEN0KHQsZSxuKXtyZXR1cm4gTz8kdCg0LDEsdCxlLG4pOjB9ZnVuY3Rpb24geHQodCxlKXtpZihPKXJldHVybiAkdCg1LDEsdCxlKX1mdW5jdGlvbiBSdCh0LGUpe2lmKE8pcmV0dXJuICR0KDYsMSx0LGUpfWZ1bmN0aW9uIGp0KHQsZSxuKXtpZihPKXJldHVybiAkdCg3LDEsdCxlLG4pfWZ1bmN0aW9uIGt0KHQsZSxuKXtyZXR1cm4gTz8kdCg4LDEsdCxlLG4pOjB9ZnVuY3Rpb24gRHQodCxlKXtpZihPKXJldHVybiAkdCg5LDEsdCxlKX1mdW5jdGlvbiBQdCh0LGUsbil7aWYoTylyZXR1cm4gJHQoMTAsMSx0LGUsbil9ZnVuY3Rpb24gVXQodCxlLG4scil7aWYoTylyZXR1cm4gJHQoMTEsMSx0LGUsbixyKX1mdW5jdGlvbiBGdCh0LGUsbixyKXtpZihPKXJldHVybiAkdCgxMiwxLHQsZSxuLHIpfWZ1bmN0aW9uIEl0KHQsZSxuLHIpe2lmKE8pcmV0dXJuICR0KDEzLDEsdCxlLG4scil9ZnVuY3Rpb24gV3QodCl7aWYoTylyZXR1cm4gJHQoMTQsMSx0KX1mdW5jdGlvbiBIdCh0LGUpe2lmKE8pcmV0dXJuICR0KDE1LDEsdCxlKX1mdW5jdGlvbiBMdCh0LGUsbil7aWYoTylyZXR1cm4gJHQoMTYsMSx0LGUsbil9ZnVuY3Rpb24genQodCl7QXRvbWljcy5zdG9yZShhKCksdD4+MiwxKSxoZSgpJiZfZSh0KSxBdG9taWNzLmNvbXBhcmVFeGNoYW5nZShhKCksdD4+MiwxLDApfWZ1bmN0aW9uIFl0KHQpe3JldHVybiBpKClbdD4+PjJdKzQyOTQ5NjcyOTYqYSgpW3QrND4+PjJdfWZ1bmN0aW9uIEJ0KHQsZSxuLHIsYSxpKXtyZXR1cm4gTz8kdCgxNywxLHQsZSxuLHIsYSxpKTotNTJ9ZnVuY3Rpb24gR3QodCxlLG4scixhLGkpe2lmKE8pcmV0dXJuICR0KDE4LDEsdCxlLG4scixhLGkpfWZ1bmN0aW9uIE50KHQpe3ZhciBuPUcodCkrMSxyPWRlKG4pO3JldHVybiByJiZCKHQsZSgpLHIsbikscn1mdW5jdGlvbiBWdCh0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXFxcKChbQS1aYS16IF0rKVxcXFwpJC8pKT90WzFdOlwiR01UXCJ9aWYoTylyZXR1cm4gJHQoMTksMSx0LGUsbik7dmFyIG89KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLHU9bmV3IERhdGUobywwLDEpLGM9bmV3IERhdGUobyw2LDEpO289dS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzPWMuZ2V0VGltZXpvbmVPZmZzZXQoKSxsPU1hdGgubWF4KG8scyk7YSgpW3Q+PjI+Pj4wXT02MCpsLGEoKVtlPj4yPj4+MF09TnVtYmVyKG8hPXMpLHQ9cih1KSxlPXIoYyksdD1OdCh0KSxlPU50KGUpLHM8bz8oaSgpW24+PjI+Pj4wXT10LGkoKVtuKzQ+PjI+Pj4wXT1lKTooaSgpW24+PjI+Pj4wXT1lLGkoKVtuKzQ+PjI+Pj4wXT10KX1mdW5jdGlvbiAkdCh0LGUpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGgtMixyPWFyZ3VtZW50cztyZXR1cm4geXQoKCgpPT57Zm9yKHZhciBhPUNlKDgqbiksaT1hPj4zLHU9MDt1PG47dSsrKXt2YXIgYz1yWzIrdV07bygpW2krdT4+PjBdPWN9cmV0dXJuIHdlKHQsbixhLGUpfSkpfXUuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZT16dCx3dD1fPygpPT57dmFyIHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKnRbMF0rdFsxXS8xZTZ9Ok8/KCk9PnBlcmZvcm1hbmNlLm5vdygpLXUuX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnQ6KCk9PnBlcmZvcm1hbmNlLm5vdygpO3ZhciBxdCxYdD1bXSxKdD17fTtmdW5jdGlvbiBadCgpe2lmKCFxdCl7dmFyIHQsZT17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzooXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzptfHxcIi4vdGhpcy5wcm9ncmFtXCJ9O2Zvcih0IGluIEp0KXZvaWQgMD09PUp0W3RdP2RlbGV0ZSBlW3RdOmVbdF09SnRbdF07dmFyIG49W107Zm9yKHQgaW4gZSluLnB1c2godCtcIj1cIitlW3RdKTtxdD1ufXJldHVybiBxdH1mdW5jdGlvbiBRdCh0LG4pe2lmKE8pcmV0dXJuICR0KDIwLDEsdCxuKTt2YXIgcj0wO3JldHVybiBadCgpLmZvckVhY2goKGZ1bmN0aW9uKGEsbyl7dmFyIHU9bityO2ZvcihvPWkoKVt0KzQqbz4+Mj4+PjBdPXUsdT0wO3U8YS5sZW5ndGg7Kyt1KWUoKVtvKys+PjA+Pj4wXT1hLmNoYXJDb2RlQXQodSk7ZSgpW28+PjA+Pj4wXT0wLHIrPWEubGVuZ3RoKzF9KSksMH1mdW5jdGlvbiBLdCh0LGUpe2lmKE8pcmV0dXJuICR0KDIxLDEsdCxlKTt2YXIgbj1adCgpO2koKVt0Pj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtyKz10Lmxlbmd0aCsxfSkpLGkoKVtlPj4yPj4+MF09ciwwfWZ1bmN0aW9uIHRlKHQpe3JldHVybiBPPyR0KDIyLDEsdCk6NTJ9ZnVuY3Rpb24gZWUodCxlLG4scil7cmV0dXJuIE8/JHQoMjMsMSx0LGUsbixyKTo1Mn1mdW5jdGlvbiBuZSh0LGUsbixyLGEpe3JldHVybiBPPyR0KDI0LDEsdCxlLG4scixhKTo3MH12YXIgcmU9W251bGwsW10sW11dO2Z1bmN0aW9uIGFlKHQsZSl7dmFyIG49cmVbdF07MD09PWV8fDEwPT09ZT8oKDE9PT10P0M6eCkoeihuLDApKSxuLmxlbmd0aD0wKTpuLnB1c2goZSl9ZnVuY3Rpb24gaWUodCxlLG4sYSl7aWYoTylyZXR1cm4gJHQoMjUsMSx0LGUsbixhKTtmb3IodmFyIG89MCx1PTA7dTxuO3UrKyl7dmFyIGM9aSgpW2U+PjI+Pj4wXSxzPWkoKVtlKzQ+PjI+Pj4wXTtlKz04O2Zvcih2YXIgbD0wO2w8cztsKyspYWUodCxyKClbYytsPj4+MF0pO28rPXN9cmV0dXJuIGkoKVthPj4yPj4+MF09bywwfXZhciBvZT0wO2Z1bmN0aW9uIHVlKHQpe3JldHVybiAwPT10JTQmJigwIT10JTEwMHx8MD09dCU0MDApfXZhciBjZT1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLHNlPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gbGUodCxuLHIsaSl7ZnVuY3Rpb24gbyh0LGUsbil7Zm9yKHQ9XCJudW1iZXJcIj09dHlwZW9mIHQ/dC50b1N0cmluZygpOnR8fFwiXCI7dC5sZW5ndGg8ZTspdD1uWzBdK3Q7cmV0dXJuIHR9ZnVuY3Rpb24gdSh0LGUpe3JldHVybiBvKHQsZSxcIjBcIil9ZnVuY3Rpb24gYyh0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIDA+dD8tMTowPHQ/MTowfXZhciByO3JldHVybiAwPT09KHI9bih0LmdldEZ1bGxZZWFyKCktZS5nZXRGdWxsWWVhcigpKSkmJjA9PT0ocj1uKHQuZ2V0TW9udGgoKS1lLmdldE1vbnRoKCkpKSYmKHI9bih0LmdldERhdGUoKS1lLmdldERhdGUoKSkpLHJ9ZnVuY3Rpb24gcyh0KXtzd2l0Y2godC5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiB0O2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBsKHQpe3ZhciBlPXQuV2I7Zm9yKHQ9bmV3IERhdGUobmV3IERhdGUodC5YYisxOTAwLDAsMSkuZ2V0VGltZSgpKTswPGU7KXt2YXIgbj10LmdldE1vbnRoKCkscj0odWUodC5nZXRGdWxsWWVhcigpKT9jZTpzZSlbbl07aWYoIShlPnItdC5nZXREYXRlKCkpKXt0LnNldERhdGUodC5nZXREYXRlKCkrZSk7YnJlYWt9ZS09ci10LmdldERhdGUoKSsxLHQuc2V0RGF0ZSgxKSwxMT5uP3Quc2V0TW9udGgobisxKToodC5zZXRNb250aCgwKSx0LnNldEZ1bGxZZWFyKHQuZ2V0RnVsbFllYXIoKSsxKSl9cmV0dXJuIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpKzEsMCw0KSxlPXMobmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsNCkpLG49cyhuKSwwPj1jKGUsdCk/MD49YyhuLHQpP3QuZ2V0RnVsbFllYXIoKSsxOnQuZ2V0RnVsbFllYXIoKTp0LmdldEZ1bGxZZWFyKCktMX12YXIgZj1hKClbaSs0MD4+Mj4+PjBdO2Zvcih2YXIgcCBpbiBpPXtMYzphKClbaT4+Mj4+PjBdLEtjOmEoKVtpKzQ+PjI+Pj4wXSxkYzphKClbaSs4Pj4yPj4+MF0samM6YSgpW2krMTI+PjI+Pj4wXSxlYzphKClbaSsxNj4+Mj4+PjBdLFhiOmEoKVtpKzIwPj4yPj4+MF0sVGI6YSgpW2krMjQ+PjI+Pj4wXSxXYjphKClbaSsyOD4+Mj4+PjBdLFJjOmEoKVtpKzMyPj4yPj4+MF0sSmM6YSgpW2krMzY+PjI+Pj4wXSxNYzpmP1koZik6XCJcIn0scj1ZKHIpLGY9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSlyPXIucmVwbGFjZShuZXcgUmVnRXhwKHAsXCJnXCIpLGZbcF0pO3ZhciBoPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksZD1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKHAgaW4gZj17XCIlYVwiOmZ1bmN0aW9uKHQpe3JldHVybiBoW3QuVGJdLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGhbdC5UYl19LFwiJWJcIjpmdW5jdGlvbih0KXtyZXR1cm4gZFt0LmVjXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKHQpe3JldHVybiBkW3QuZWNdfSxcIiVDXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUoKHQuWGIrMTkwMCkvMTAwfDAsMil9LFwiJWRcIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0LmpjLDIpfSxcIiVlXCI6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5qYywyLFwiIFwiKX0sXCIlZ1wiOmZ1bmN0aW9uKHQpe3JldHVybiBsKHQpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVHXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGwodCl9LFwiJUhcIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0LmRjLDIpfSxcIiVJXCI6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PSh0PXQuZGMpP3Q9MTI6MTI8dCYmKHQtPTEyKSx1KHQsMil9LFwiJWpcIjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjw9dC5lYy0xO2UrPSh1ZSh0LlhiKzE5MDApP2NlOnNlKVtuKytdKTtyZXR1cm4gdSh0LmpjK2UsMyl9LFwiJW1cIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0LmVjKzEsMil9LFwiJU1cIjpmdW5jdGlvbih0KXtyZXR1cm4gdSh0LktjLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbih0KXtyZXR1cm4gMDw9dC5kYyYmMTI+dC5kYz9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHUodC5MYywyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXFxcdFwifSxcIiV1XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuVGJ8fDd9LFwiJVVcIjpmdW5jdGlvbih0KXtyZXR1cm4gdShNYXRoLmZsb29yKCh0LldiKzctdC5UYikvNyksMil9LFwiJVZcIjpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLmZsb29yKCh0LldiKzctKHQuVGIrNiklNykvNyk7aWYoMj49KHQuVGIrMzcxLXQuV2ItMiklNyYmZSsrLGUpNTM9PWUmJig0PT0obj0odC5UYiszNzEtdC5XYiklNyl8fDM9PW4mJnVlKHQuWGIpfHwoZT0xKSk7ZWxzZXtlPTUyO3ZhciBuPSh0LlRiKzctdC5XYi0xKSU3Oyg0PT1ufHw1PT1uJiZ1ZSh0LlhiJTQwMC0xKSkmJmUrK31yZXR1cm4gdShlLDIpfSxcIiV3XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuVGJ9LFwiJVdcIjpmdW5jdGlvbih0KXtyZXR1cm4gdShNYXRoLmZsb29yKCh0LldiKzctKHQuVGIrNiklNykvNyksMil9LFwiJXlcIjpmdW5jdGlvbih0KXtyZXR1cm4odC5YYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlWVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LlhiKzE5MDB9LFwiJXpcIjpmdW5jdGlvbih0KXt2YXIgZT0wPD0odD10LkpjKTtyZXR1cm4gdD1NYXRoLmFicyh0KS82MCwoZT9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiKyh0LzYwKjEwMCt0JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuTWN9LFwiJSVcIjpmdW5jdGlvbigpe3JldHVyblwiJVwifX0scj1yLnJlcGxhY2UoLyUlL2csXCJcXFxcMFxcXFwwXCIpLGYpci5pbmNsdWRlcyhwKSYmKHI9ci5yZXBsYWNlKG5ldyBSZWdFeHAocCxcImdcIiksZltwXShpKSkpO3JldHVybiBwPWZ1bmN0aW9uKHQpe3ZhciBlPUFycmF5KEcodCkrMSk7cmV0dXJuIEIodCxlLDAsZS5sZW5ndGgpLGV9KHI9ci5yZXBsYWNlKC9cXFxcMFxcXFwwL2csXCIlXCIpKSxwLmxlbmd0aD5uPzA6KGZ1bmN0aW9uKHQsbil7ZSgpLnNldCh0LG4+Pj4wKX0ocCx0KSxwLmxlbmd0aC0xKX1odC5mYygpO3ZhciBmZT1bbnVsbCxmdCxidCxFdCxDdCx4dCxSdCxqdCxrdCxEdCxQdCxVdCxGdCxJdCxXdCxIdCxMdCxCdCxHdCxWdCxRdCxLdCx0ZSxlZSxuZSxpZV0scGU9e2I6ZnVuY3Rpb24odCl7cmV0dXJuIGRlKHQrMjQpKzI0fSxuOmZ1bmN0aW9uKHQpe3JldHVybih0PW5ldyBTdCh0KSkudWMoKXx8KHQuaGMoITApLE90LS0pLHQuaWMoITEpLF90LnB1c2godCksdC5zYygpLHQudmMoKX0sbWE6ZnVuY3Rpb24odCl7dGhyb3cgeChcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIHRocm93biwgdGhpcyBpcyBub3QgcHJvcGVybHkgc3VwcG9ydGVkIC0gYWJvcnRpbmdcIiksSD0hMCx0fSx4OmZ1bmN0aW9uKCl7U2UoMCk7dmFyIHQ9X3QucG9wKCk7aWYodC5IYygpJiYhdC5rYygpKXt2YXIgZT10LkRjKCk7ZSYmZ3QoZSkodC5aYiksVHQodC5aYil9QXQ9MH0sZTpmdW5jdGlvbigpe3ZhciB0PUF0O2lmKCF0KXJldHVybiBvZT0wO3ZhciBlPW5ldyBTdCh0KTtlLmNjKHQpO3ZhciBuPWUuYmMoKTtpZighbilyZXR1cm4gb2U9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGE9MDthPHIubGVuZ3RoO2ErKyl7dmFyIGk9clthXTtpZigwPT09aXx8aT09PW4pYnJlYWs7aWYoeGUoaSxuLGUuU2IrMTYpKXJldHVybiBvZT1pLHR9cmV0dXJuIG9lPW4sdH0sbDpmdW5jdGlvbigpe3ZhciB0PUF0O2lmKCF0KXJldHVybiBvZT0wO3ZhciBlPW5ldyBTdCh0KTtlLmNjKHQpO3ZhciBuPWUuYmMoKTtpZighbilyZXR1cm4gb2U9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGE9MDthPHIubGVuZ3RoO2ErKyl7dmFyIGk9clthXTtpZigwPT09aXx8aT09PW4pYnJlYWs7aWYoeGUoaSxuLGUuU2IrMTYpKXJldHVybiBvZT1pLHR9cmV0dXJuIG9lPW4sdH0saDpmdW5jdGlvbigpe3ZhciB0PUF0O2lmKCF0KXJldHVybiBvZT0wO3ZhciBlPW5ldyBTdCh0KTtlLmNjKHQpO3ZhciBuPWUuYmMoKTtpZighbilyZXR1cm4gb2U9MCx0O2Zvcih2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGE9MDthPHIubGVuZ3RoO2ErKyl7dmFyIGk9clthXTtpZigwPT09aXx8aT09PW4pYnJlYWs7aWYoeGUoaSxuLGUuU2IrMTYpKXJldHVybiBvZT1pLHR9cmV0dXJuIG9lPW4sdH0sdDpUdCxNOmZ1bmN0aW9uKCl7dmFyIHQ9X3QucG9wKCk7dHx8YXQoXCJubyBleGNlcHRpb24gdG8gdGhyb3dcIik7dmFyIGU9dC5aYjt0aHJvdyB0LmtjKCl8fChfdC5wdXNoKHQpLHQuaWMoITApLHQuaGMoITEpLE90KyspLEF0PWUsZX0sYzpmdW5jdGlvbih0LGUsbil7dGhyb3cgbmV3IFN0KHQpLmZjKGUsbiksQXQ9dCxPdCsrLHR9LHBhOmZ1bmN0aW9uKCl7cmV0dXJuIE90fSxGYTpmdW5jdGlvbih0KXtnZSh0LCF3LDEsIXYpLGh0LnBjKCl9LFQ6ZnVuY3Rpb24odCl7Tz9wb3N0TWVzc2FnZSh7Y21kOlwiY2xlYW51cFRocmVhZFwiLHRocmVhZDp0fSk6c3QodCl9LHhhOk10LGo6ZnVuY3Rpb24odCl7dGhyb3cgQXR8fChBdD10KSx0fSxIOkN0LE1hOnh0LHVhOlJ0LHdhOmp0LG9hOmt0LEthOkR0LENhOlB0LEphOlV0LFY6RnQsdmE6SXQsc2E6V3QsTGE6SHQsdGE6THQsVGE6ZnVuY3Rpb24oKXt9LFg6ZnVuY3Rpb24oKXthdChcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxVYTpmdW5jdGlvbigpe2F0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LFc6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0seWE6ZnVuY3Rpb24oKXtyZXR1cm4gMjA5NzE1Mn0sT2E6ZnVuY3Rpb24oKXtyZXR1cm4hMH0semE6ZnVuY3Rpb24odCxlLG4scil7aWYodD09ZSlzZXRUaW1lb3V0KCgoKT0+enQocikpKTtlbHNlIGlmKE8pcG9zdE1lc3NhZ2Uoe3RhcmdldFRocmVhZDp0LGNtZDpcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCIscXVldWU6cn0pO2Vsc2V7aWYoISh0PWh0LlZiW3RdKSlyZXR1cm47dC5wb3N0TWVzc2FnZSh7Y21kOlwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIixxdWV1ZTpyfSl9cmV0dXJuIDF9LEVhOmZ1bmN0aW9uKCl7cmV0dXJuLTF9LFBhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqWXQodCkpLGEoKVtlPj4yPj4+MF09dC5nZXRVVENTZWNvbmRzKCksYSgpW2UrND4+Mj4+PjBdPXQuZ2V0VVRDTWludXRlcygpLGEoKVtlKzg+PjI+Pj4wXT10LmdldFVUQ0hvdXJzKCksYSgpW2UrMTI+PjI+Pj4wXT10LmdldFVUQ0RhdGUoKSxhKClbZSsxNj4+Mj4+PjBdPXQuZ2V0VVRDTW9udGgoKSxhKClbZSsyMD4+Mj4+PjBdPXQuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLGEoKVtlKzI0Pj4yPj4+MF09dC5nZXRVVENEYXkoKSx0PSh0LmdldFRpbWUoKS1EYXRlLlVUQyh0LmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLGEoKVtlKzI4Pj4yPj4+MF09dH0sUWE6ZnVuY3Rpb24odCxlKXt0PW5ldyBEYXRlKDFlMypZdCh0KSksYSgpW2U+PjI+Pj4wXT10LmdldFNlY29uZHMoKSxhKClbZSs0Pj4yPj4+MF09dC5nZXRNaW51dGVzKCksYSgpW2UrOD4+Mj4+PjBdPXQuZ2V0SG91cnMoKSxhKClbZSsxMj4+Mj4+PjBdPXQuZ2V0RGF0ZSgpLGEoKVtlKzE2Pj4yPj4+MF09dC5nZXRNb250aCgpLGEoKVtlKzIwPj4yPj4+MF09dC5nZXRGdWxsWWVhcigpLTE5MDAsYSgpW2UrMjQ+PjI+Pj4wXT10LmdldERheSgpO3ZhciBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpLHI9KHQuZ2V0VGltZSgpLW4uZ2V0VGltZSgpKS84NjRlNXwwO2EoKVtlKzI4Pj4yPj4+MF09cixhKClbZSszNj4+Mj4+PjBdPS02MCp0LmdldFRpbWV6b25lT2Zmc2V0KCkscj1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLHQ9MHwociE9KG49bi5nZXRUaW1lem9uZU9mZnNldCgpKSYmdC5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihuLHIpKSxhKClbZSszMj4+Mj4+PjBdPXR9LFJhOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBEYXRlKGEoKVt0KzIwPj4yPj4+MF0rMTkwMCxhKClbdCsxNj4+Mj4+PjBdLGEoKVt0KzEyPj4yPj4+MF0sYSgpW3QrOD4+Mj4+PjBdLGEoKVt0KzQ+PjI+Pj4wXSxhKClbdD4+Mj4+PjBdLDApLG49YSgpW3QrMzI+PjI+Pj4wXSxyPWUuZ2V0VGltZXpvbmVPZmZzZXQoKSxpPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpLG89bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSx1PWkuZ2V0VGltZXpvbmVPZmZzZXQoKSxjPU1hdGgubWluKHUsbyk7cmV0dXJuIDA+bj9hKClbdCszMj4+Mj4+PjBdPU51bWJlcihvIT11JiZjPT1yKTowPG4hPShjPT1yKSYmKG89TWF0aC5tYXgodSxvKSxlLnNldFRpbWUoZS5nZXRUaW1lKCkrNmU0KigoMDxuP2M6byktcikpKSxhKClbdCsyND4+Mj4+PjBdPWUuZ2V0RGF5KCksbj0oZS5nZXRUaW1lKCktaS5nZXRUaW1lKCkpLzg2NGU1fDAsYSgpW3QrMjg+PjI+Pj4wXT1uLGEoKVt0Pj4yPj4+MF09ZS5nZXRTZWNvbmRzKCksYSgpW3QrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLGEoKVt0Kzg+PjI+Pj4wXT1lLmdldEhvdXJzKCksYSgpW3QrMTI+PjI+Pj4wXT1lLmdldERhdGUoKSxhKClbdCsxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxlLmdldFRpbWUoKS8xZTN8MH0sQWE6QnQsQmE6R3QsU2E6ZnVuY3Rpb24gdChlLG4scil7dC5BY3x8KHQuQWM9ITAsVnQoZSxuLHIpKX0seTpmdW5jdGlvbigpe2F0KFwiXCIpfSxVOmZ1bmN0aW9uKCl7aWYoIV8mJiF3KXt2YXIgdD1cIkJsb2NraW5nIG9uIHRoZSBtYWluIHRocmVhZCBpcyB2ZXJ5IGRhbmdlcm91cywgc2VlIGh0dHBzOi8vZW1zY3JpcHRlbi5vcmcvZG9jcy9wb3J0aW5nL3B0aHJlYWRzLmh0bWwjYmxvY2tpbmctb24tdGhlLW1haW4tYnJvd3Nlci10aHJlYWRcIjt2dHx8KHZ0PXt9KSx2dFt0XXx8KHZ0W3RdPTEsXyYmKHQ9XCJ3YXJuaW5nOiBcIit0KSx4KHQpKX19LHJhOmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5MDE3NjB9LEI6d3QsSWE6ZnVuY3Rpb24odCxlLG4pe3IoKS5jb3B5V2l0aGluKHQ+Pj4wLGU+Pj4wLGUrbj4+PjApfSxGOmZ1bmN0aW9uKCl7cmV0dXJuIF8/big5OTMpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9LERhOmZ1bmN0aW9uKHQsZSxuKXtYdC5sZW5ndGg9ZSxuPj49Mztmb3IodmFyIHI9MDtyPGU7cisrKVh0W3JdPW8oKVtuK3I+Pj4wXTtyZXR1cm4oMD50P3V0Wy10LTFdOmZlW3RdKS5hcHBseShudWxsLFh0KX0scWE6ZnVuY3Rpb24odCl7dmFyIGU9cigpLmxlbmd0aDtpZigodD4+Pj0wKTw9ZXx8NDI5NDkwMTc2MDx0KXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIGE9ZSooMSsuMi9uKTthPU1hdGgubWluKGEsdCsxMDA2NjMyOTYpO3ZhciBpPU1hdGg7YT1NYXRoLm1heCh0LGEpLGk9aS5taW4uY2FsbChpLDQyOTQ5MDE3NjAsYSsoNjU1MzYtYSU2NTUzNiklNjU1MzYpO3Q6e3RyeXtqLmdyb3coaS1ELmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksTihqLmJ1ZmZlcik7dmFyIG89MTticmVhayB0fWNhdGNoKHQpe31vPXZvaWQgMH1pZihvKXJldHVybiEwfXJldHVybiExfSxOYTpmdW5jdGlvbigpe3Rocm93XCJ1bndpbmRcIn0sR2E6UXQsSGE6S3QsSjpwdCxJOnRlLFM6ZWUsZ2E6bmUsUjppZSxkOmZ1bmN0aW9uKCl7cmV0dXJuIG9lfSxuYTpmdW5jdGlvbiB0KHIsYSl7dC5sY3x8KHQubGM9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYoXyl0cnl7dmFyIGU9bihPYmplY3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgXFwnY3J5cHRvXFwnXCIpO3Rocm93IHQuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIix0fSgpKSk7cmV0dXJuKCk9PmUucmFuZG9tQnl0ZXMoMSlbMF19Y2F0Y2godCl7fXJldHVybigpPT5hdChcInJhbmRvbURldmljZVwiKX0oKSk7Zm9yKHZhciBpPTA7aTxhO2krKyllKClbcitpPj4wPj4+MF09dC5sYygpO3JldHVybiAwfSxpYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxqYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxLOmZ1bmN0aW9uKHQpe3ZhciBlPUVlKCk7dHJ5e3JldHVybiBndCh0KSgpfWNhdGNoKHQpe2lmKE1lKGUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZjpmdW5jdGlvbih0LGUpe3ZhciBuPUVlKCk7dHJ5e3JldHVybiBndCh0KShlKX1jYXRjaCh0KXtpZihNZShuKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LFA6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4pfWNhdGNoKHQpe2lmKE1lKHIpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sUTpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxrOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuKX1jYXRjaCh0KXtpZihNZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHA6ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9RWUoKTt0cnl7cmV0dXJuIGd0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihNZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHE6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSl9Y2F0Y2godCl7aWYoTWUoaSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxOOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihNZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHM6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4scixhLGkpfWNhdGNoKHQpe2lmKE1lKG8pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sdzpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1FZSgpO3RyeXtyZXR1cm4gZ3QodCkoZSxuLHIsYSxpLG8pfWNhdGNoKHQpe2lmKE1lKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sTDpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihNZShjKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEU6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LGMscyxsLGYpe3ZhciBwPUVlKCk7dHJ5e3JldHVybiBndCh0KShlLG4scixhLGksbyx1LGMscyxsLGYpfWNhdGNoKHQpe2lmKE1lKHApLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sYWE6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgYz1FZSgpO3RyeXtyZXR1cm4gSGUodCxlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihNZShjKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LF86ZnVuY3Rpb24odCxlLG4scixhLGksbyl7dmFyIHU9RWUoKTt0cnl7cmV0dXJuIGtlKHQsZSxuLHIsYSxpLG8pfWNhdGNoKHQpe2lmKE1lKHUpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sWjpmdW5jdGlvbih0LGUsbixyLGEpe3ZhciBpPUVlKCk7dHJ5e3JldHVybiBMZSh0LGUsbixyLGEpfWNhdGNoKHQpe2lmKE1lKGkpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sY2E6ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9RWUoKTt0cnl7cmV0dXJuIEllKHQsZSxuLHIpfWNhdGNoKHQpe2lmKE1lKGEpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sJDpmdW5jdGlvbih0KXt2YXIgZT1FZSgpO3RyeXtyZXR1cm4gamUodCl9Y2F0Y2godCl7aWYoTWUoZSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxiYTpmdW5jdGlvbih0LGUpe3ZhciBuPUVlKCk7dHJ5e3JldHVybiBXZSh0LGUpfWNhdGNoKHQpe2lmKE1lKG4pLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sWTpmdW5jdGlvbih0LGUsbil7dmFyIHI9RWUoKTt0cnl7cmV0dXJuIERlKHQsZSxuKX1jYXRjaCh0KXtpZihNZShyKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGc6ZnVuY3Rpb24odCl7dmFyIGU9RWUoKTt0cnl7Z3QodCkoKX1jYXRjaCh0KXtpZihNZShlKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHI6ZnVuY3Rpb24odCxlKXt2YXIgbj1FZSgpO3RyeXtndCh0KShlKX1jYXRjaCh0KXtpZihNZShuKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGk6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUVlKCk7dHJ5e2d0KHQpKGUsbil9Y2F0Y2godCl7aWYoTWUociksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxoYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgYT1FZSgpO3RyeXtndCh0KShlLG4scil9Y2F0Y2godCl7aWYoTWUoYSksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxtOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUVlKCk7dHJ5e2d0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihNZShhKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHY6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1FZSgpO3RyeXtndCh0KShlLG4scixhKX1jYXRjaCh0KXtpZihNZShpKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LHU6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUVlKCk7dHJ5e2d0KHQpKGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoTWUobyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxPOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8pe3ZhciB1PUVlKCk7dHJ5e2d0KHQpKGUsbixyLGEsaSxvKX1jYXRjaCh0KXtpZihNZSh1KSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LEE6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgYz1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihNZShjKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LGthOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxjKXt2YXIgcz1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyx1LGMpfWNhdGNoKHQpe2lmKE1lKHMpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sQzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwpe3ZhciBmPUVlKCk7dHJ5e2d0KHQpKGUsbixyLGEsaSxvLHUsYyxzLGwpfWNhdGNoKHQpe2lmKE1lKGYpLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sRDpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwsZixwLGgsZCx5KXt2YXIgYj1FZSgpO3RyeXtndCh0KShlLG4scixhLGksbyx1LGMscyxsLGYscCxoLGQseSl9Y2F0Y2godCl7aWYoTWUoYiksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxmYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUVlKCk7dHJ5e1BlKHQsZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoTWUoYyksdCE9PXQrMCl0aHJvdyB0O1NlKDEsMCl9fSxkYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwsZil7dmFyIHA9RWUoKTt0cnl7RmUodCxlLG4scixhLGksbyx1LGMscyxsLGYpfWNhdGNoKHQpe2lmKE1lKHApLHQhPT10KzApdGhyb3cgdDtTZSgxLDApfX0sZWE6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUVlKCk7dHJ5e1VlKHQsZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihNZShvKSx0IT09dCswKXRocm93IHQ7U2UoMSwwKX19LG86ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGE6anx8dS53YXNtTWVtb3J5LEc6ZnVuY3Rpb24odCl7b2U9dH0sbGE6bGUsejpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gbGUodCxlLG4scil9fTshZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dS5hc209dC5leHBvcnRzLGh0LnFjLnB1c2godS5hc20uc2IpLCQ9dS5hc20udWIsWC51bnNoaWZ0KHUuYXNtLlZhKSxrPWUsT3x8KGV0LS0sdS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZ1Lm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoZXQpLDA9PWV0JiYobnVsbCE9PW50JiYoY2xlYXJJbnRlcnZhbChudCksbnQ9bnVsbCkscnQmJih0PXJ0LHJ0PW51bGwsdCgpKSkpfWZ1bmN0aW9uIGUoZSl7dChlLmluc3RhbmNlLGUubW9kdWxlKX1mdW5jdGlvbiBuKHQpe3JldHVybiBmdW5jdGlvbigpe2lmKCFNJiYodnx8dykpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoJiYhdHQuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKHR0LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtpZighdC5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIit0dCtcIlxcJ1wiO3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIG90KCl9KSk7aWYoZilyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7Zih0dCwoZnVuY3Rpb24oZSl7dChuZXcgVWludDhBcnJheShlKSl9KSxlKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gb3QoKX0pKX0oKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodCxyKX0pKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKS50aGVuKHQsKGZ1bmN0aW9uKHQpe3goXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIit0KSxhdCh0KX0pKX12YXIgcj17YTpwZX07aWYoT3x8KGV0KyssdS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZ1Lm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoZXQpKSx1Lmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIHUuaW5zdGFudGlhdGVXYXNtKHIsdCl9Y2F0Y2godCl7cmV0dXJuIHgoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIit0KSwhMX0oTXx8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fGl0KCl8fHR0LnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfHxffHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD9uKGUpOmZldGNoKHR0LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcodCxyKS50aGVuKGUsKGZ1bmN0aW9uKHQpe3JldHVybiB4KFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3QpLHgoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxuKGUpfSkpfSkpKS5jYXRjaChzKX0oKSx1Ll9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybih1Ll9fX3dhc21fY2FsbF9jdG9ycz11LmFzbS5WYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEluaXQ9dS5hc20uV2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9dS5hc20uWGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9dS5hc20uWWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT11LmFzbS5aYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPXUuYXNtLl9hKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0Q3JlYXRlU2Vzc2lvbj11LmFzbS4kYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRSZWxlYXNlU2Vzc2lvbj11LmFzbS5hYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEdldElucHV0Q291bnQ9dS5hc20uYmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0R2V0T3V0cHV0Q291bnQ9dS5hc20uY2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEdldElucHV0TmFtZT11LmFzbS5kYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydEdldE91dHB1dE5hbWU9dS5hc20uZWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRGcmVlPXUuYXNtLmZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRDcmVhdGVUZW5zb3I9dS5hc20uZ2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybih1Ll9PcnRHZXRUZW5zb3JEYXRhPXUuYXNtLmhiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHUuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0UmVsZWFzZVRlbnNvcj11LmFzbS5pYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydENyZWF0ZVJ1bk9wdGlvbnM9dS5hc20uamIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9dS5hc20ua2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9dS5hc20ubGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdS5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKHUuX09ydFJ1bj11LmFzbS5tYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Ll9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4odS5fT3J0RW5kUHJvZmlsaW5nPXUuYXNtLm5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBoZT11Ll9wdGhyZWFkX3NlbGY9ZnVuY3Rpb24oKXtyZXR1cm4oaGU9dS5fcHRocmVhZF9zZWxmPXUuYXNtLm9iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGRlPXUuX21hbGxvYz1mdW5jdGlvbigpe3JldHVybihkZT11Ll9tYWxsb2M9dS5hc20ucGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seWU9dS5fZnJlZT1mdW5jdGlvbigpe3JldHVybih5ZT11Ll9mcmVlPXUuYXNtLnFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGJlPXUuX2ZmbHVzaD1mdW5jdGlvbigpe3JldHVybihiZT11Ll9mZmx1c2g9dS5hc20ucmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dS5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4odS5fX2Vtc2NyaXB0ZW5fdGxzX2luaXQ9dS5hc20uc2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIG1lPXUuX19fZnVuY3Nfb25fZXhpdD1mdW5jdGlvbigpe3JldHVybihtZT11Ll9fX2Z1bmNzX29uX2V4aXQ9dS5hc20udGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZ2U9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oZ2U9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9dS5hc20udmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9ZnVuY3Rpb24oKXtyZXR1cm4odS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9dS5hc20ud2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIHZlLHdlPXUuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9ZnVuY3Rpb24oKXtyZXR1cm4od2U9dS5fZW1zY3JpcHRlbl9ydW5faW5fbWFpbl9ydW50aW1lX3RocmVhZF9qcz11LmFzbS54YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfZT11Ll9fZW1zY3JpcHRlbl9wcm94eV9leGVjdXRlX3Rhc2tfcXVldWU9ZnVuY3Rpb24oKXtyZXR1cm4oX2U9dS5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPXUuYXNtLnliKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE9lPXUuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9ZnVuY3Rpb24oKXtyZXR1cm4oT2U9dS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2ZyZWVfZGF0YT11LmFzbS56YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBZT11Ll9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1mdW5jdGlvbigpe3JldHVybihBZT11Ll9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD11LmFzbS5BYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxTZT11Ll9zZXRUaHJldz1mdW5jdGlvbigpe3JldHVybihTZT11Ll9zZXRUaHJldz11LmFzbS5CYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxUZT11Ll9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHM9ZnVuY3Rpb24oKXtyZXR1cm4oVGU9dS5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPXUuYXNtLkNiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEVlPXUuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKEVlPXUuc3RhY2tTYXZlPXUuYXNtLkRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE1lPXUuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKE1lPXUuc3RhY2tSZXN0b3JlPXUuYXNtLkViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LENlPXUuc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihDZT11LnN0YWNrQWxsb2M9dS5hc20uRmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seGU9dS5fX19jeGFfY2FuX2NhdGNoPWZ1bmN0aW9uKCl7cmV0dXJuKHhlPXUuX19fY3hhX2Nhbl9jYXRjaD11LmFzbS5HYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxSZT11Ll9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4oUmU9dS5fX19jeGFfaXNfcG9pbnRlcl90eXBlPXUuYXNtLkhiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGplPXUuZHluQ2FsbF9qPWZ1bmN0aW9uKCl7cmV0dXJuKGplPXUuZHluQ2FsbF9qPXUuYXNtLkliKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGtlPXUuZHluQ2FsbF9paWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oa2U9dS5keW5DYWxsX2lpaWlpaj11LmFzbS5KYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxEZT11LmR5bkNhbGxfamlpPWZ1bmN0aW9uKCl7cmV0dXJuKERlPXUuZHluQ2FsbF9qaWk9dS5hc20uS2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUGU9dS5keW5DYWxsX3ZpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oUGU9dS5keW5DYWxsX3ZpaWlpaWo9dS5hc20uTGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVWU9dS5keW5DYWxsX3Zqamk9ZnVuY3Rpb24oKXtyZXR1cm4oVWU9dS5keW5DYWxsX3Zqamk9dS5hc20uTWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRmU9dS5keW5DYWxsX3ZpaWlqamppaT1mdW5jdGlvbigpe3JldHVybihGZT11LmR5bkNhbGxfdmlpaWpqamlpPXUuYXNtLk5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEllPXUuZHluQ2FsbF9paWo9ZnVuY3Rpb24oKXtyZXR1cm4oSWU9dS5keW5DYWxsX2lpaj11LmFzbS5PYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxXZT11LmR5bkNhbGxfamk9ZnVuY3Rpb24oKXtyZXR1cm4oV2U9dS5keW5DYWxsX2ppPXUuYXNtLlBiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhlPXUuZHluQ2FsbF9paWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKEhlPXUuZHluQ2FsbF9paWlpaWlqPXUuYXNtLlFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LExlPXUuZHluQ2FsbF9paWlqPWZ1bmN0aW9uKCl7cmV0dXJuKExlPXUuZHluQ2FsbF9paWlqPXUuYXNtLlJiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIHplKCl7ZnVuY3Rpb24gdCgpe2lmKCF2ZSYmKHZlPSEwLHUuY2FsbGVkUnVuPSEwLCFIKSYmKE98fGR0KFgpLGModSksdS5vblJ1bnRpbWVJbml0aWFsaXplZCYmdS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLCFPKSl7aWYodS5wb3N0UnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LnBvc3RSdW4mJih1LnBvc3RSdW49W3UucG9zdFJ1bl0pO3UucG9zdFJ1bi5sZW5ndGg7KXt2YXIgdD11LnBvc3RSdW4uc2hpZnQoKTtaLnVuc2hpZnQodCl9ZHQoWil9fWlmKCEoMDxldCkpaWYoTyljKHUpLE98fGR0KFgpLHBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkZWRcIn0pO2Vsc2V7aWYodS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIHUucHJlUnVuJiYodS5wcmVSdW49W3UucHJlUnVuXSk7dS5wcmVSdW4ubGVuZ3RoOylLKCk7ZHQocSksMDxldHx8KHUuc2V0U3RhdHVzPyh1LnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe3Uuc2V0U3RhdHVzKFwiXCIpfSksMSksdCgpfSksMSkpOnQoKSl9fWlmKHUuVVRGOFRvU3RyaW5nPVksdS5zdHJpbmdUb1VURjg9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBCKHQscigpLGUsbil9LHUubGVuZ3RoQnl0ZXNVVEY4PUcsdS5rZWVwUnVudGltZUFsaXZlPVEsdS53YXNtTWVtb3J5PWosdS5zdGFja1NhdmU9RWUsdS5zdGFja1Jlc3RvcmU9TWUsdS5zdGFja0FsbG9jPUNlLHUuRXhpdFN0YXR1cz1jdCx1LlBUaHJlYWQ9aHQscnQ9ZnVuY3Rpb24gdCgpe3ZlfHx6ZSgpLHZlfHwocnQ9dCl9LHUucHJlSW5pdClmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgdS5wcmVJbml0JiYodS5wcmVJbml0PVt1LnByZUluaXRdKTswPHUucHJlSW5pdC5sZW5ndGg7KXUucHJlSW5pdC5wb3AoKSgpO3JldHVybiB6ZSgpLHQucmVhZHl9KTt0LmV4cG9ydHM9cn0sOTMyOih0LGUsbik9Pnt2YXIgX3NjcmlwdERpcixyPShfc2NyaXB0RGlyPShfc2NyaXB0RGlyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDApfHxcIi9pbmRleC5qc1wiLGZ1bmN0aW9uKHQpe3ZhciBlLHIsYTt0PXR8fHt9LGV8fChlPXZvaWQgMCE9PXQ/dDp7fSksZS5yZWFkeT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxlKXtyPXQsYT1lfSkpO3ZhciBpLG8sdSxjLHMsbCxmPU9iamVjdC5hc3NpZ24oe30sZSkscD1cIi4vdGhpcy5wcm9ncmFtXCIsaD0odCxlKT0+e3Rocm93IGV9LGQ9XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyx5PVwiZnVuY3Rpb25cIj09dHlwZW9mIGltcG9ydFNjcmlwdHMsYj1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUsbT1cIlwiO2I/KG09eT9uKDkwOCkuZGlybmFtZShtKStcIi9cIjpcIi8vXCIsbD0oKT0+e3N8fChjPW4oMzg0KSxzPW4oOTA4KSl9LGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbCgpLHQ9cy5ub3JtYWxpemUodCksYy5yZWFkRmlsZVN5bmModCxlP3ZvaWQgMDpcInV0ZjhcIil9LHU9dD0+KCh0PWkodCwhMCkpLmJ1ZmZlcnx8KHQ9bmV3IFVpbnQ4QXJyYXkodCkpLHQpLG89KHQsZSxuKT0+e2woKSx0PXMubm9ybWFsaXplKHQpLGMucmVhZEZpbGUodCwoZnVuY3Rpb24odCxyKXt0P24odCk6ZShyLmJ1ZmZlcil9KSl9LDE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKHA9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFxcXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMikscHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIsKGZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIEopKXRocm93IHR9KSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLChmdW5jdGlvbih0KXt0aHJvdyB0fSkpLGg9KHQsZSk9PntpZihffHwwPEwpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT10LGU7ZSBpbnN0YW5jZW9mIEp8fHcoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK2UpLHByb2Nlc3MuZXhpdCh0KX0sZS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifSk6KGR8fHkpJiYoeT9tPXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihtPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYobT1fc2NyaXB0RGlyKSxtPTAhPT1tLmluZGV4T2YoXCJibG9iOlwiKT9tLnN1YnN0cigwLG0ucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIixpPXQ9Pnt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGUub3BlbihcIkdFVFwiLHQsITEpLGUuc2VuZChudWxsKSxlLnJlc3BvbnNlVGV4dH0seSYmKHU9dD0+e3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gZS5vcGVuKFwiR0VUXCIsdCwhMSksZS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGUuc2VuZChudWxsKSxuZXcgVWludDhBcnJheShlLnJlc3BvbnNlKX0pLG89KHQsZSxuKT0+e3ZhciByPW5ldyBYTUxIdHRwUmVxdWVzdDtyLm9wZW4oXCJHRVRcIix0LCEwKSxyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsci5vbmxvYWQ9KCk9PnsyMDA9PXIuc3RhdHVzfHwwPT1yLnN0YXR1cyYmci5yZXNwb25zZT9lKHIucmVzcG9uc2UpOm4oKX0sci5vbmVycm9yPW4sci5zZW5kKG51bGwpfSk7dmFyIGcsdj1lLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLHc9ZS5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihlLGYpLGY9bnVsbCxlLnRoaXNQcm9ncmFtJiYocD1lLnRoaXNQcm9ncmFtKSxlLnF1aXQmJihoPWUucXVpdCksZS53YXNtQmluYXJ5JiYoZz1lLndhc21CaW5hcnkpO3ZhciBfPWUubm9FeGl0UnVudGltZXx8ITE7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZWKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgTyxBLFMsVCxFLE0sQz0hMSx4PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiBSKHQsZSxuKXt2YXIgcj0oZT4+Pj0wKStuO2ZvcihuPWU7dFtuXSYmIShuPj1yKTspKytuO2lmKDE2PG4tZSYmdC5idWZmZXImJngpcmV0dXJuIHguZGVjb2RlKHQuc3ViYXJyYXkoZSxuKSk7Zm9yKHI9XCJcIjtlPG47KXt2YXIgYT10W2UrK107aWYoMTI4JmEpe3ZhciBpPTYzJnRbZSsrXTtpZigxOTI9PSgyMjQmYSkpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmYSk8PDZ8aSk7ZWxzZXt2YXIgbz02MyZ0W2UrK107NjU1MzY+KGE9MjI0PT0oMjQwJmEpPygxNSZhKTw8MTJ8aTw8NnxvOig3JmEpPDwxOHxpPDwxMnxvPDw2fDYzJnRbZSsrXSk/cis9U3RyaW5nLmZyb21DaGFyQ29kZShhKTooYS09NjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxhPj4xMCw1NjMyMHwxMDIzJmEpKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpfXJldHVybiByfWZ1bmN0aW9uIGoodCxlKXtyZXR1cm4odD4+Pj0wKT9SKFQsdCxlKTpcIlwifWZ1bmN0aW9uIGsodCxlLG4scil7aWYoISgwPHIpKXJldHVybiAwO3ZhciBhPW4+Pj49MDtyPW4rci0xO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7KytpKXt2YXIgbz10LmNoYXJDb2RlQXQoaSk7aWYoNTUyOTY8PW8mJjU3MzQzPj1vJiYobz02NTUzNisoKDEwMjMmbyk8PDEwKXwxMDIzJnQuY2hhckNvZGVBdCgrK2kpKSwxMjc+PW8pe2lmKG4+PXIpYnJlYWs7ZVtuKys+Pj4wXT1vfWVsc2V7aWYoMjA0Nz49byl7aWYobisxPj1yKWJyZWFrO2VbbisrPj4+MF09MTkyfG8+PjZ9ZWxzZXtpZig2NTUzNT49byl7aWYobisyPj1yKWJyZWFrO2VbbisrPj4+MF09MjI0fG8+PjEyfWVsc2V7aWYobiszPj1yKWJyZWFrO2VbbisrPj4+MF09MjQwfG8+PjE4LGVbbisrPj4+MF09MTI4fG8+PjEyJjYzfWVbbisrPj4+MF09MTI4fG8+PjYmNjN9ZVtuKys+Pj4wXT0xMjh8NjMmb319cmV0dXJuIGVbbj4+PjBdPTAsbi1hfWZ1bmN0aW9uIEQodCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGg7KytuKXt2YXIgcj10LmNoYXJDb2RlQXQobik7MTI3Pj1yP2UrKzoyMDQ3Pj1yP2UrPTI6NTUyOTY8PXImJjU3MzQzPj1yPyhlKz00LCsrbik6ZSs9M31yZXR1cm4gZX1mdW5jdGlvbiBQKCl7dmFyIHQ9Ty5idWZmZXI7QT10LGUuSEVBUDg9Uz1uZXcgSW50OEFycmF5KHQpLGUuSEVBUDE2PW5ldyBJbnQxNkFycmF5KHQpLGUuSEVBUDMyPUU9bmV3IEludDMyQXJyYXkodCksZS5IRUFQVTg9VD1uZXcgVWludDhBcnJheSh0KSxlLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHQpLGUuSEVBUFUzMj1NPW5ldyBVaW50MzJBcnJheSh0KSxlLkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheSh0KSxlLkhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheSh0KX12YXIgVSxGPVtdLEk9W10sVz1bXSxIPVtdLEw9MDtmdW5jdGlvbiB6KCl7dmFyIHQ9ZS5wcmVSdW4uc2hpZnQoKTtGLnVuc2hpZnQodCl9dmFyIFksQj0wLEc9bnVsbCxOPW51bGw7ZnVuY3Rpb24gVih0KXt0aHJvdyBlLm9uQWJvcnQmJmUub25BYm9ydCh0KSx3KHQ9XCJBYm9ydGVkKFwiK3QrXCIpXCIpLEM9ITAsdD1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLGEodCksdH1mdW5jdGlvbiAkKCl7cmV0dXJuIFkuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9aWYoWT1cIm9ydC13YXNtLndhc21cIiwhJCgpKXt2YXIgcT1ZO1k9ZS5sb2NhdGVGaWxlP2UubG9jYXRlRmlsZShxLG0pOm0rcX1mdW5jdGlvbiBYKCl7dmFyIHQ9WTt0cnl7aWYodD09WSYmZylyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZyk7aWYodSlyZXR1cm4gdSh0KTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaCh0KXtWKHQpfX1mdW5jdGlvbiBKKHQpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK3QrXCIpXCIsdGhpcy5zdGF0dXM9dH1mdW5jdGlvbiBaKHQpe2Zvcig7MDx0Lmxlbmd0aDspdC5zaGlmdCgpKGUpfXZhciBRPVtdLEs9MCx0dD0wO2Z1bmN0aW9uIGV0KHQpe3RoaXMuRGI9dCx0aGlzLnpiPXQtMjQsdGhpcy5VYj1mdW5jdGlvbih0KXtNW3RoaXMuemIrND4+Mj4+PjBdPXR9LHRoaXMuRWI9ZnVuY3Rpb24oKXtyZXR1cm4gTVt0aGlzLnpiKzQ+PjI+Pj4wXX0sdGhpcy5TYj1mdW5jdGlvbih0KXtNW3RoaXMuemIrOD4+Mj4+PjBdPXR9LHRoaXMuV2I9ZnVuY3Rpb24oKXtyZXR1cm4gTVt0aGlzLnpiKzg+PjI+Pj4wXX0sdGhpcy5UYj1mdW5jdGlvbigpe0VbdGhpcy56Yj4+Mj4+PjBdPTB9LHRoaXMuSWI9ZnVuY3Rpb24odCl7U1t0aGlzLnpiKzEyPj4wPj4+MF09dD8xOjB9LHRoaXMuUGI9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9U1t0aGlzLnpiKzEyPj4wPj4+MF19LHRoaXMuSmI9ZnVuY3Rpb24odCl7U1t0aGlzLnpiKzEzPj4wPj4+MF09dD8xOjB9LHRoaXMuTGI9ZnVuY3Rpb24oKXtyZXR1cm4gMCE9U1t0aGlzLnpiKzEzPj4wPj4+MF19LHRoaXMuUmI9ZnVuY3Rpb24odCxlKXt0aGlzLkZiKDApLHRoaXMuVWIodCksdGhpcy5TYihlKSx0aGlzLlRiKCksdGhpcy5JYighMSksdGhpcy5KYighMSl9LHRoaXMuTmI9ZnVuY3Rpb24oKXtFW3RoaXMuemI+PjI+Pj4wXSs9MX0sdGhpcy5YYj1mdW5jdGlvbigpe3ZhciB0PUVbdGhpcy56Yj4+Mj4+PjBdO3JldHVybiBFW3RoaXMuemI+PjI+Pj4wXT10LTEsMT09PXR9LHRoaXMuRmI9ZnVuY3Rpb24odCl7TVt0aGlzLnpiKzE2Pj4yPj4+MF09dH0sdGhpcy5PYj1mdW5jdGlvbigpe3JldHVybiBNW3RoaXMuemIrMTY+PjI+Pj4wXX0sdGhpcy5RYj1mdW5jdGlvbigpe2lmKE10KHRoaXMuRWIoKSkpcmV0dXJuIE1bdGhpcy5EYj4+Mj4+PjBdO3ZhciB0PXRoaXMuT2IoKTtyZXR1cm4gMCE9PXQ/dDp0aGlzLkRifX1mdW5jdGlvbiBudCh0KXtyZXR1cm4gdnQobmV3IGV0KHQpLnpiKX12YXIgcnQ9W107ZnVuY3Rpb24gYXQodCl7dmFyIGU9cnRbdF07cmV0dXJuIGV8fCh0Pj1ydC5sZW5ndGgmJihydC5sZW5ndGg9dCsxKSxydFt0XT1lPVUuZ2V0KHQpKSxlfWZ1bmN0aW9uIGl0KHQpe3ZhciBlPUQodCkrMSxuPWd0KGUpO3JldHVybiBuJiZrKHQsUyxuLGUpLG59dmFyIG90PXt9O2Z1bmN0aW9uIHV0KCl7aWYoIWN0KXt2YXIgdCxlPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOnB8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHQgaW4gb3Qpdm9pZCAwPT09b3RbdF0/ZGVsZXRlIGVbdF06ZVt0XT1vdFt0XTt2YXIgbj1bXTtmb3IodCBpbiBlKW4ucHVzaCh0K1wiPVwiK2VbdF0pO2N0PW59cmV0dXJuIGN0fXZhciBjdCxzdD1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gbHQodCxlKXt2YXIgbj1zdFt0XTswPT09ZXx8MTA9PT1lPygoMT09PXQ/djp3KShSKG4sMCkpLG4ubGVuZ3RoPTApOm4ucHVzaChlKX12YXIgZnQ9MDtmdW5jdGlvbiBwdCh0KXtyZXR1cm4gMD09dCU0JiYoMCE9dCUxMDB8fDA9PXQlNDAwKX12YXIgaHQ9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxkdD1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIHl0KHQsZSxuLHIpe2Z1bmN0aW9uIGEodCxlLG4pe2Zvcih0PVwibnVtYmVyXCI9PXR5cGVvZiB0P3QudG9TdHJpbmcoKTp0fHxcIlwiO3QubGVuZ3RoPGU7KXQ9blswXSt0O3JldHVybiB0fWZ1bmN0aW9uIGkodCxlKXtyZXR1cm4gYSh0LGUsXCIwXCIpfWZ1bmN0aW9uIG8odCxlKXtmdW5jdGlvbiBuKHQpe3JldHVybiAwPnQ/LTE6MDx0PzE6MH12YXIgcjtyZXR1cm4gMD09PShyPW4odC5nZXRGdWxsWWVhcigpLWUuZ2V0RnVsbFllYXIoKSkpJiYwPT09KHI9bih0LmdldE1vbnRoKCktZS5nZXRNb250aCgpKSkmJihyPW4odC5nZXREYXRlKCktZS5nZXREYXRlKCkpKSxyfWZ1bmN0aW9uIHUodCl7c3dpdGNoKHQuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gdDtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gYyh0KXt2YXIgZT10LkJiO2Zvcih0PW5ldyBEYXRlKG5ldyBEYXRlKHQuQ2IrMTkwMCwwLDEpLmdldFRpbWUoKSk7MDxlOyl7dmFyIG49dC5nZXRNb250aCgpLHI9KHB0KHQuZ2V0RnVsbFllYXIoKSk/aHQ6ZHQpW25dO2lmKCEoZT5yLXQuZ2V0RGF0ZSgpKSl7dC5zZXREYXRlKHQuZ2V0RGF0ZSgpK2UpO2JyZWFrfWUtPXItdC5nZXREYXRlKCkrMSx0LnNldERhdGUoMSksMTE+bj90LnNldE1vbnRoKG4rMSk6KHQuc2V0TW9udGgoMCksdC5zZXRGdWxsWWVhcih0LmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSsxLDAsNCksZT11KG5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDQpKSxuPXUobiksMD49byhlLHQpPzA+PW8obix0KT90LmdldEZ1bGxZZWFyKCkrMTp0LmdldEZ1bGxZZWFyKCk6dC5nZXRGdWxsWWVhcigpLTF9dmFyIHM9RVtyKzQwPj4yPj4+MF07Zm9yKHZhciBsIGluIHI9eyRiOkVbcj4+Mj4+PjBdLFpiOkVbcis0Pj4yPj4+MF0sR2I6RVtyKzg+PjI+Pj4wXSxLYjpFW3IrMTI+PjI+Pj4wXSxIYjpFW3IrMTY+PjI+Pj4wXSxDYjpFW3IrMjA+PjI+Pj4wXSxBYjpFW3IrMjQ+PjI+Pj4wXSxCYjpFW3IrMjg+PjI+Pj4wXSxiYzpFW3IrMzI+PjI+Pj4wXSxZYjpFW3IrMzY+PjI+Pj4wXSxhYzpzP2oocyk6XCJcIn0sbj1qKG4pLHM9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSluPW4ucmVwbGFjZShuZXcgUmVnRXhwKGwsXCJnXCIpLHNbbF0pO3ZhciBmPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIikscD1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKGwgaW4gcz17XCIlYVwiOmZ1bmN0aW9uKHQpe3JldHVybiBmW3QuQWJdLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGZbdC5BYl19LFwiJWJcIjpmdW5jdGlvbih0KXtyZXR1cm4gcFt0LkhiXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKHQpe3JldHVybiBwW3QuSGJdfSxcIiVDXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGkoKHQuQ2IrMTkwMCkvMTAwfDAsMil9LFwiJWRcIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LktiLDIpfSxcIiVlXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGEodC5LYiwyLFwiIFwiKX0sXCIlZ1wiOmZ1bmN0aW9uKHQpe3JldHVybiBjKHQpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVHXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGModCl9LFwiJUhcIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LkdiLDIpfSxcIiVJXCI6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PSh0PXQuR2IpP3Q9MTI6MTI8dCYmKHQtPTEyKSxpKHQsMil9LFwiJWpcIjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjw9dC5IYi0xO2UrPShwdCh0LkNiKzE5MDApP2h0OmR0KVtuKytdKTtyZXR1cm4gaSh0LktiK2UsMyl9LFwiJW1cIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LkhiKzEsMil9LFwiJU1cIjpmdW5jdGlvbih0KXtyZXR1cm4gaSh0LlpiLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcXFxuXCJ9LFwiJXBcIjpmdW5jdGlvbih0KXtyZXR1cm4gMDw9dC5HYiYmMTI+dC5HYj9cIkFNXCI6XCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24odCl7cmV0dXJuIGkodC4kYiwyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXFxcdFwifSxcIiV1XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQWJ8fDd9LFwiJVVcIjpmdW5jdGlvbih0KXtyZXR1cm4gaShNYXRoLmZsb29yKCh0LkJiKzctdC5BYikvNyksMil9LFwiJVZcIjpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLmZsb29yKCh0LkJiKzctKHQuQWIrNiklNykvNyk7aWYoMj49KHQuQWIrMzcxLXQuQmItMiklNyYmZSsrLGUpNTM9PWUmJig0PT0obj0odC5BYiszNzEtdC5CYiklNyl8fDM9PW4mJnB0KHQuQ2IpfHwoZT0xKSk7ZWxzZXtlPTUyO3ZhciBuPSh0LkFiKzctdC5CYi0xKSU3Oyg0PT1ufHw1PT1uJiZwdCh0LkNiJTQwMC0xKSkmJmUrK31yZXR1cm4gaShlLDIpfSxcIiV3XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuQWJ9LFwiJVdcIjpmdW5jdGlvbih0KXtyZXR1cm4gaShNYXRoLmZsb29yKCh0LkJiKzctKHQuQWIrNiklNykvNyksMil9LFwiJXlcIjpmdW5jdGlvbih0KXtyZXR1cm4odC5DYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlWVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LkNiKzE5MDB9LFwiJXpcIjpmdW5jdGlvbih0KXt2YXIgZT0wPD0odD10LlliKTtyZXR1cm4gdD1NYXRoLmFicyh0KS82MCwoZT9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiKyh0LzYwKjEwMCt0JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuYWN9LFwiJSVcIjpmdW5jdGlvbigpe3JldHVyblwiJVwifX0sbj1uLnJlcGxhY2UoLyUlL2csXCJcXFxcMFxcXFwwXCIpLHMpbi5pbmNsdWRlcyhsKSYmKG49bi5yZXBsYWNlKG5ldyBSZWdFeHAobCxcImdcIiksc1tsXShyKSkpO3JldHVybiBsPWZ1bmN0aW9uKHQpe3ZhciBlPUFycmF5KEQodCkrMSk7cmV0dXJuIGsodCxlLDAsZS5sZW5ndGgpLGV9KG49bi5yZXBsYWNlKC9cXFxcMFxcXFwwL2csXCIlXCIpKSxsLmxlbmd0aD5lPzA6KFMuc2V0KGwsdD4+PjApLGwubGVuZ3RoLTEpfXZhciBidD17YTpmdW5jdGlvbih0KXtyZXR1cm4gZ3QodCsyNCkrMjR9LG06ZnVuY3Rpb24odCl7cmV0dXJuKHQ9bmV3IGV0KHQpKS5QYigpfHwodC5JYighMCksSy0tKSx0LkpiKCExKSxRLnB1c2godCksdC5OYigpLHQuUWIoKX0saWE6ZnVuY3Rpb24odCl7dGhyb3cgdyhcIlVuZXhwZWN0ZWQgZXhjZXB0aW9uIHRocm93biwgdGhpcyBpcyBub3QgcHJvcGVybHkgc3VwcG9ydGVkIC0gYWJvcnRpbmdcIiksQz0hMCx0fSx3OmZ1bmN0aW9uKCl7T3QoMCk7dmFyIHQ9US5wb3AoKTtpZih0LlhiKCkmJiF0LkxiKCkpe3ZhciBlPXQuV2IoKTtlJiZhdChlKSh0LkRiKSxudCh0LkRiKX10dD0wfSxkOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIGZ0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBmdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksYT0wO2E8ci5sZW5ndGg7YSsrKXt2YXIgaT1yW2FdO2lmKDA9PT1pfHxpPT09bilicmVhaztpZihFdChpLG4sZS56YisxNikpcmV0dXJuIGZ0PWksdH1yZXR1cm4gZnQ9bix0fSxrOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIGZ0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBmdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksYT0wO2E8ci5sZW5ndGg7YSsrKXt2YXIgaT1yW2FdO2lmKDA9PT1pfHxpPT09bilicmVhaztpZihFdChpLG4sZS56YisxNikpcmV0dXJuIGZ0PWksdH1yZXR1cm4gZnQ9bix0fSxnOmZ1bmN0aW9uKCl7dmFyIHQ9dHQ7aWYoIXQpcmV0dXJuIGZ0PTA7dmFyIGU9bmV3IGV0KHQpO2UuRmIodCk7dmFyIG49ZS5FYigpO2lmKCFuKXJldHVybiBmdD0wLHQ7Zm9yKHZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksYT0wO2E8ci5sZW5ndGg7YSsrKXt2YXIgaT1yW2FdO2lmKDA9PT1pfHxpPT09bilicmVhaztpZihFdChpLG4sZS56YisxNikpcmV0dXJuIGZ0PWksdH1yZXR1cm4gZnQ9bix0fSxzOm50LEw6ZnVuY3Rpb24oKXt2YXIgdD1RLnBvcCgpO3R8fFYoXCJubyBleGNlcHRpb24gdG8gdGhyb3dcIik7dmFyIGU9dC5EYjt0aHJvdyB0LkxiKCl8fChRLnB1c2godCksdC5KYighMCksdC5JYighMSksSysrKSx0dD1lLGV9LGI6ZnVuY3Rpb24odCxlLG4pe3Rocm93IG5ldyBldCh0KS5SYihlLG4pLHR0PXQsSysrLHR9LGxhOmZ1bmN0aW9uKCl7cmV0dXJuIEt9LGk6ZnVuY3Rpb24odCl7dGhyb3cgdHR8fCh0dD10KSx0fSxIOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEJhOmZ1bmN0aW9uKCl7fSxwYTpmdW5jdGlvbigpe30scmE6ZnVuY3Rpb24oKXt9LGthOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LHphOmZ1bmN0aW9uKCl7fSx1YTpmdW5jdGlvbigpe30seWE6ZnVuY3Rpb24oKXt9LFI6ZnVuY3Rpb24oKXt9LHFhOmZ1bmN0aW9uKCl7fSxuYTpmdW5jdGlvbigpe30sQWE6ZnVuY3Rpb24oKXt9LG9hOmZ1bmN0aW9uKCl7fSxIYTpmdW5jdGlvbigpe30sSmE6ZnVuY3Rpb24oKXtWKFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgZW5hYmxlIGR5bmFtaWMgbGlua2luZywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9LElhOmZ1bmN0aW9uKCl7VihcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfSxTOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LENhOmZ1bmN0aW9uKCl7cmV0dXJuITB9LERhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqKE1bdD4+PjJdKzQyOTQ5NjcyOTYqRVt0KzQ+Pj4yXSkpLEVbZT4+Mj4+PjBdPXQuZ2V0VVRDU2Vjb25kcygpLEVbZSs0Pj4yPj4+MF09dC5nZXRVVENNaW51dGVzKCksRVtlKzg+PjI+Pj4wXT10LmdldFVUQ0hvdXJzKCksRVtlKzEyPj4yPj4+MF09dC5nZXRVVENEYXRlKCksRVtlKzE2Pj4yPj4+MF09dC5nZXRVVENNb250aCgpLEVbZSsyMD4+Mj4+PjBdPXQuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLEVbZSsyND4+Mj4+PjBdPXQuZ2V0VVRDRGF5KCksRVtlKzI4Pj4yPj4+MF09KHQuZ2V0VGltZSgpLURhdGUuVVRDKHQuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDB9LEVhOmZ1bmN0aW9uKHQsZSl7dD1uZXcgRGF0ZSgxZTMqKE1bdD4+PjJdKzQyOTQ5NjcyOTYqRVt0KzQ+Pj4yXSkpLEVbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLEVbZSs0Pj4yPj4+MF09dC5nZXRNaW51dGVzKCksRVtlKzg+PjI+Pj4wXT10LmdldEhvdXJzKCksRVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksRVtlKzE2Pj4yPj4+MF09dC5nZXRNb250aCgpLEVbZSsyMD4+Mj4+PjBdPXQuZ2V0RnVsbFllYXIoKS0xOTAwLEVbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCk7dmFyIG49bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSk7RVtlKzI4Pj4yPj4+MF09KHQuZ2V0VGltZSgpLW4uZ2V0VGltZSgpKS84NjRlNXwwLEVbZSszNj4+Mj4+PjBdPS02MCp0LmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHI9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtuPW4uZ2V0VGltZXpvbmVPZmZzZXQoKSxFW2UrMzI+PjI+Pj4wXT0wfChyIT1uJiZ0LmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4scikpfSxGYTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgRGF0ZShFW3QrMjA+PjI+Pj4wXSsxOTAwLEVbdCsxNj4+Mj4+PjBdLEVbdCsxMj4+Mj4+PjBdLEVbdCs4Pj4yPj4+MF0sRVt0KzQ+PjI+Pj4wXSxFW3Q+PjI+Pj4wXSwwKSxuPUVbdCszMj4+Mj4+PjBdLHI9ZS5nZXRUaW1lem9uZU9mZnNldCgpLGE9bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSksaT1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLG89YS5nZXRUaW1lem9uZU9mZnNldCgpLHU9TWF0aC5taW4obyxpKTtyZXR1cm4gMD5uP0VbdCszMj4+Mj4+PjBdPU51bWJlcihpIT1vJiZ1PT1yKTowPG4hPSh1PT1yKSYmKGk9TWF0aC5tYXgobyxpKSxlLnNldFRpbWUoZS5nZXRUaW1lKCkrNmU0KigoMDxuP3U6aSktcikpKSxFW3QrMjQ+PjI+Pj4wXT1lLmdldERheSgpLEVbdCsyOD4+Mj4+PjBdPShlLmdldFRpbWUoKS1hLmdldFRpbWUoKSkvODY0ZTV8MCxFW3Q+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxFW3QrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLEVbdCs4Pj4yPj4+MF09ZS5nZXRIb3VycygpLEVbdCsxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLEVbdCsxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxlLmdldFRpbWUoKS8xZTN8MH0sc2E6ZnVuY3Rpb24oKXtyZXR1cm4tNTJ9LHRhOmZ1bmN0aW9uKCl7fSxHYTpmdW5jdGlvbiB0KGUsbixyKXt0LlZifHwodC5WYj0hMCxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtyZXR1cm4odD10LnRvVGltZVN0cmluZygpLm1hdGNoKC9cXFxcKChbQS1aYS16IF0rKVxcXFwpJC8pKT90WzFdOlwiR01UXCJ9dmFyIGE9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLGk9bmV3IERhdGUoYSwwLDEpLG89bmV3IERhdGUoYSw2LDEpO2E9aS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciB1PW8uZ2V0VGltZXpvbmVPZmZzZXQoKTtFW3Q+PjI+Pj4wXT02MCpNYXRoLm1heChhLHUpLEVbZT4+Mj4+PjBdPU51bWJlcihhIT11KSx0PXIoaSksZT1yKG8pLHQ9aXQodCksZT1pdChlKSx1PGE/KE1bbj4+Mj4+PjBdPXQsTVtuKzQ+PjI+Pj4wXT1lKTooTVtuPj4yPj4+MF09ZSxNW24rND4+Mj4+PjBdPXQpfShlLG4scikpfSxCOmZ1bmN0aW9uKCl7VihcIlwiKX0sbWE6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sSTpiPygpPT57dmFyIHQ9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gMWUzKnRbMF0rdFsxXS8xZTZ9OigpPT5wZXJmb3JtYW5jZS5ub3coKSx4YTpmdW5jdGlvbih0LGUsbil7VC5jb3B5V2l0aGluKHQ+Pj4wLGU+Pj4wLGUrbj4+PjApfSxHOmZ1bmN0aW9uKHQpe3ZhciBlPVQubGVuZ3RoO2lmKDQyOTQ5MDE3NjA8KHQ+Pj49MCkpcmV0dXJuITE7Zm9yKHZhciBuPTE7ND49bjtuKj0yKXt2YXIgcj1lKigxKy4yL24pO3I9TWF0aC5taW4ocix0KzEwMDY2MzI5Nik7dmFyIGE9TWF0aDtyPU1hdGgubWF4KHQsciksYT1hLm1pbi5jYWxsKGEsNDI5NDkwMTc2MCxyKyg2NTUzNi1yJTY1NTM2KSU2NTUzNik7dDp7dHJ5e08uZ3JvdyhhLUEuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2KSxQKCk7dmFyIGk9MTticmVhayB0fWNhdGNoKHQpe31pPXZvaWQgMH1pZihpKXJldHVybiEwfXJldHVybiExfSx2YTpmdW5jdGlvbih0LGUpe3ZhciBuPTA7cmV0dXJuIHV0KCkuZm9yRWFjaCgoZnVuY3Rpb24ocixhKXt2YXIgaT1lK247Zm9yKGE9TVt0KzQqYT4+Mj4+PjBdPWksaT0wO2k8ci5sZW5ndGg7KytpKVNbYSsrPj4wPj4+MF09ci5jaGFyQ29kZUF0KGkpO1NbYT4+MD4+PjBdPTAsbis9ci5sZW5ndGgrMX0pKSwwfSx3YTpmdW5jdGlvbih0LGUpe3ZhciBuPXV0KCk7TVt0Pj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbih0KXtyKz10Lmxlbmd0aCsxfSkpLE1bZT4+Mj4+PjBdPXIsMH0sYmE6ZnVuY3Rpb24odCl7X3x8MDxMfHwoX3QoKSxaKFcpLHd0KDApLHN0WzFdLmxlbmd0aCYmbHQoMSwxMCksc3RbMl0ubGVuZ3RoJiZsdCgyLDEwKSksX3x8MDxMfHwoZS5vbkV4aXQmJmUub25FeGl0KHQpLEM9ITApLGgodCxuZXcgSih0KSl9LEU6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LFE6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LGNhOmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxQOmZ1bmN0aW9uKHQsZSxuLHIpe2Zvcih2YXIgYT0wLGk9MDtpPG47aSsrKXt2YXIgbz1NW2U+PjI+Pj4wXSx1PU1bZSs0Pj4yPj4+MF07ZSs9ODtmb3IodmFyIGM9MDtjPHU7YysrKWx0KHQsVFtvK2M+Pj4wXSk7YSs9dX1yZXR1cm4gTVtyPj4yPj4+MF09YSwwfSxjOmZ1bmN0aW9uKCl7cmV0dXJuIGZ0fSxqYTpmdW5jdGlvbiB0KGUscil7dC5NYnx8KHQuTWI9ZnVuY3Rpb24oKXtpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+KGNyeXB0by5nZXRSYW5kb21WYWx1ZXModCksdFswXSl9aWYoYil0cnl7dmFyIGU9bihPYmplY3QoZnVuY3Rpb24oKXt2YXIgdD1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgXFwnY3J5cHRvXFwnXCIpO3Rocm93IHQuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIix0fSgpKSk7cmV0dXJuKCk9PmUucmFuZG9tQnl0ZXMoMSlbMF19Y2F0Y2godCl7fXJldHVybigpPT5WKFwicmFuZG9tRGV2aWNlXCIpfSgpKTtmb3IodmFyIGE9MDthPHI7YSsrKVNbZSthPj4wPj4+MF09dC5NYigpO3JldHVybiAwfSxlYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxmYTpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxKOmZ1bmN0aW9uKHQpe3ZhciBlPUF0KCk7dHJ5e3JldHVybiBhdCh0KSgpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sZTpmdW5jdGlvbih0LGUpe3ZhciBuPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlKX1jYXRjaCh0KXtpZihTdChuKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LE46ZnVuY3Rpb24odCxlLG4pe3ZhciByPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4pfWNhdGNoKHQpe2lmKFN0KHIpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sTzpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxqOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LG86ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9QXQoKTt0cnl7cmV0dXJuIGF0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHA6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSl9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxNOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSxpKX1jYXRjaCh0KXtpZihTdChvKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHI6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGkpfWNhdGNoKHQpe2lmKFN0KG8pLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sdjpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1BdCgpO3RyeXtyZXR1cm4gYXQodCkoZSxuLHIsYSxpLG8pfWNhdGNoKHQpe2lmKFN0KHUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sSzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihTdChjKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LEQ6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1LGMscyxsLGYpe3ZhciBwPUF0KCk7dHJ5e3JldHVybiBhdCh0KShlLG4scixhLGksbyx1LGMscyxsLGYpfWNhdGNoKHQpe2lmKFN0KHApLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sWDpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUF0KCk7dHJ5e3JldHVybiBGdCh0LGUsbixyLGEsaSxvLHUpfWNhdGNoKHQpe2lmKFN0KGMpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sVjpmdW5jdGlvbih0LGUsbixyLGEsaSxvKXt2YXIgdT1BdCgpO3RyeXtyZXR1cm4geHQodCxlLG4scixhLGksbyl9Y2F0Y2godCl7aWYoU3QodSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxVOmZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIGk9QXQoKTt0cnl7cmV0dXJuIEl0KHQsZSxuLHIsYSl9Y2F0Y2godCl7aWYoU3QoaSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxaOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUF0KCk7dHJ5e3JldHVybiBQdCh0LGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LFc6ZnVuY3Rpb24odCl7dmFyIGU9QXQoKTt0cnl7cmV0dXJuIEN0KHQpfWNhdGNoKHQpe2lmKFN0KGUpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sWTpmdW5jdGlvbih0LGUpe3ZhciBuPUF0KCk7dHJ5e3JldHVybiBVdCh0LGUpfWNhdGNoKHQpe2lmKFN0KG4pLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sVDpmdW5jdGlvbih0LGUsbil7dmFyIHI9QXQoKTt0cnl7cmV0dXJuIFJ0KHQsZSxuKX1jYXRjaCh0KXtpZihTdChyKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGY6ZnVuY3Rpb24odCl7dmFyIGU9QXQoKTt0cnl7YXQodCkoKX1jYXRjaCh0KXtpZihTdChlKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHE6ZnVuY3Rpb24odCxlKXt2YXIgbj1BdCgpO3RyeXthdCh0KShlKX1jYXRjaCh0KXtpZihTdChuKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGg6ZnVuY3Rpb24odCxlLG4pe3ZhciByPUF0KCk7dHJ5e2F0KHQpKGUsbil9Y2F0Y2godCl7aWYoU3QociksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxkYTpmdW5jdGlvbih0LGUsbixyKXt2YXIgYT1BdCgpO3RyeXthdCh0KShlLG4scil9Y2F0Y2godCl7aWYoU3QoYSksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxsOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPUF0KCk7dHJ5e2F0KHQpKGUsbixyKX1jYXRjaCh0KXtpZihTdChhKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHQ6ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgaT1BdCgpO3RyeXthdCh0KShlLG4scixhKX1jYXRjaCh0KXtpZihTdChpKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHU6ZnVuY3Rpb24odCxlLG4scixhLGkpe3ZhciBvPUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoU3QobyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSx4OmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8pe3ZhciB1PUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSxvKX1jYXRjaCh0KXtpZihTdCh1KSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LHo6ZnVuY3Rpb24odCxlLG4scixhLGksbyx1KXt2YXIgYz1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1KX1jYXRjaCh0KXtpZihTdChjKSx0IT09dCswKXRocm93IHQ7T3QoMSwwKX19LGdhOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxjKXt2YXIgcz1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1LGMpfWNhdGNoKHQpe2lmKFN0KHMpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sQTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwpe3ZhciBmPUF0KCk7dHJ5e2F0KHQpKGUsbixyLGEsaSxvLHUsYyxzLGwpfWNhdGNoKHQpe2lmKFN0KGYpLHQhPT10KzApdGhyb3cgdDtPdCgxLDApfX0sQzpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUsYyxzLGwsZixwLGgsZCx5KXt2YXIgYj1BdCgpO3RyeXthdCh0KShlLG4scixhLGksbyx1LGMscyxsLGYscCxoLGQseSl9Y2F0Y2godCl7aWYoU3QoYiksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxhYTpmdW5jdGlvbih0LGUsbixyLGEsaSxvLHUpe3ZhciBjPUF0KCk7dHJ5e2p0KHQsZSxuLHIsYSxpLG8sdSl9Y2F0Y2godCl7aWYoU3QoYyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxfOmZ1bmN0aW9uKHQsZSxuLHIsYSxpLG8sdSxjLHMsbCxmKXt2YXIgcD1BdCgpO3RyeXtEdCh0LGUsbixyLGEsaSxvLHUsYyxzLGwsZil9Y2F0Y2godCl7aWYoU3QocCksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSwkOmZ1bmN0aW9uKHQsZSxuLHIsYSxpKXt2YXIgbz1BdCgpO3RyeXtrdCh0LGUsbixyLGEsaSl9Y2F0Y2godCl7aWYoU3QobyksdCE9PXQrMCl0aHJvdyB0O090KDEsMCl9fSxuOmZ1bmN0aW9uKHQpe3JldHVybiB0fSxGOmZ1bmN0aW9uKHQpe2Z0PXR9LGhhOnl0LHk6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHl0KHQsZSxuLHIpfX07IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtlLmFzbT10LmV4cG9ydHMsTz1lLmFzbS5LYSxQKCksVT1lLmFzbS5pYixJLnVuc2hpZnQoZS5hc20uTGEpLEItLSxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhCKSwwPT1CJiYobnVsbCE9PUcmJihjbGVhckludGVydmFsKEcpLEc9bnVsbCksTiYmKHQ9TixOPW51bGwsdCgpKSl9ZnVuY3Rpb24gbihlKXt0KGUuaW5zdGFuY2UpfWZ1bmN0aW9uIHIodCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIWcmJihkfHx5KSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJiFZLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaChZLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtpZighdC5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIitZK1wiXFwnXCI7cmV0dXJuIHQuYXJyYXlCdWZmZXIoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gWCgpfSkpO2lmKG8pcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe28oWSwoZnVuY3Rpb24oZSl7dChuZXcgVWludDhBcnJheShlKSl9KSxlKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gWCgpfSkpfSgpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh0LGkpfSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpLnRoZW4odCwoZnVuY3Rpb24odCl7dyhcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK3QpLFYodCl9KSl9dmFyIGk9e2E6YnR9O2lmKEIrKyxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhCKSxlLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGUuaW5zdGFudGlhdGVXYXNtKGksdCl9Y2F0Y2godCl7cmV0dXJuIHcoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIit0KSwhMX0oZ3x8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fCQoKXx8WS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKXx8Ynx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/cihuKTpmZXRjaChZLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcodCxpKS50aGVuKG4sKGZ1bmN0aW9uKHQpe3JldHVybiB3KFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3QpLHcoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxyKG4pfSkpfSkpKS5jYXRjaChhKX0oKSxlLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihlLl9fX3dhc21fY2FsbF9jdG9ycz1lLmFzbS5MYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRJbml0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEluaXQ9ZS5hc20uTWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9ZS5hc20uTmEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9ZS5hc20uT2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1lLmFzbS5QYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWUuYXNtLlFhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVNlc3Npb249ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0Q3JlYXRlU2Vzc2lvbj1lLmFzbS5SYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRSZWxlYXNlU2Vzc2lvbj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRSZWxlYXNlU2Vzc2lvbj1lLmFzbS5TYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRJbnB1dENvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0Q291bnQ9ZS5hc20uVGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0R2V0T3V0cHV0Q291bnQ9ZS5hc20uVWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0SW5wdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldElucHV0TmFtZT1lLmFzbS5WYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRHZXRPdXRwdXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydEdldE91dHB1dE5hbWU9ZS5hc20uV2EpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0RnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRGcmVlPWUuYXNtLlhhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydENyZWF0ZVRlbnNvcj1mdW5jdGlvbigpe3JldHVybihlLl9PcnRDcmVhdGVUZW5zb3I9ZS5hc20uWWEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0R2V0VGVuc29yRGF0YT1mdW5jdGlvbigpe3JldHVybihlLl9PcnRHZXRUZW5zb3JEYXRhPWUuYXNtLlphKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX09ydFJlbGVhc2VUZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVRlbnNvcj1lLmFzbS5fYSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRDcmVhdGVSdW5PcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydENyZWF0ZVJ1bk9wdGlvbnM9ZS5hc20uJGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9ZS5hc20uYWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9ZS5hc20uYmIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fT3J0UnVuPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX09ydFJ1bj1lLmFzbS5jYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9PcnRFbmRQcm9maWxpbmc9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fT3J0RW5kUHJvZmlsaW5nPWUuYXNtLmRiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtdCxndD1lLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oZ3Q9ZS5fbWFsbG9jPWUuYXNtLmViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHZ0PWUuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4odnQ9ZS5fZnJlZT1lLmFzbS5mYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx3dD1lLl9mZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4od3Q9ZS5fZmZsdXNoPWUuYXNtLmdiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF90PWUuX19fZnVuY3Nfb25fZXhpdD1mdW5jdGlvbigpe3JldHVybihfdD1lLl9fX2Z1bmNzX29uX2V4aXQ9ZS5hc20uaGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT3Q9ZS5fc2V0VGhyZXc9ZnVuY3Rpb24oKXtyZXR1cm4oT3Q9ZS5fc2V0VGhyZXc9ZS5hc20uamIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQXQ9ZS5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4oQXQ9ZS5zdGFja1NhdmU9ZS5hc20ua2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU3Q9ZS5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4oU3Q9ZS5zdGFja1Jlc3RvcmU9ZS5hc20ubGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVHQ9ZS5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKFR0PWUuc3RhY2tBbGxvYz1lLmFzbS5tYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFdD1lLl9fX2N4YV9jYW5fY2F0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4oRXQ9ZS5fX19jeGFfY2FuX2NhdGNoPWUuYXNtLm5iKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE10PWUuX19fY3hhX2lzX3BvaW50ZXJfdHlwZT1mdW5jdGlvbigpe3JldHVybihNdD1lLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZS5hc20ub2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ3Q9ZS5keW5DYWxsX2o9ZnVuY3Rpb24oKXtyZXR1cm4oQ3Q9ZS5keW5DYWxsX2o9ZS5hc20ucGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seHQ9ZS5keW5DYWxsX2lpaWlpaj1mdW5jdGlvbigpe3JldHVybih4dD1lLmR5bkNhbGxfaWlpaWlqPWUuYXNtLnFiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJ0PWUuZHluQ2FsbF9qaWk9ZnVuY3Rpb24oKXtyZXR1cm4oUnQ9ZS5keW5DYWxsX2ppaT1lLmFzbS5yYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxqdD1lLmR5bkNhbGxfdmlpaWlpaj1mdW5jdGlvbigpe3JldHVybihqdD1lLmR5bkNhbGxfdmlpaWlpaj1lLmFzbS5zYikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrdD1lLmR5bkNhbGxfdmpqaT1mdW5jdGlvbigpe3JldHVybihrdD1lLmR5bkNhbGxfdmpqaT1lLmFzbS50YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxEdD1lLmR5bkNhbGxfdmlpaWpqamlpPWZ1bmN0aW9uKCl7cmV0dXJuKER0PWUuZHluQ2FsbF92aWlpampqaWk9ZS5hc20udWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUHQ9ZS5keW5DYWxsX2lpaj1mdW5jdGlvbigpe3JldHVybihQdD1lLmR5bkNhbGxfaWlqPWUuYXNtLnZiKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFV0PWUuZHluQ2FsbF9qaT1mdW5jdGlvbigpe3JldHVybihVdD1lLmR5bkNhbGxfamk9ZS5hc20ud2IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oRnQ9ZS5keW5DYWxsX2lpaWlpaWo9ZS5hc20ueGIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSXQ9ZS5keW5DYWxsX2lpaWo9ZnVuY3Rpb24oKXtyZXR1cm4oSXQ9ZS5keW5DYWxsX2lpaWo9ZS5hc20ueWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07ZnVuY3Rpb24gV3QoKXtmdW5jdGlvbiB0KCl7aWYoIW10JiYobXQ9ITAsZS5jYWxsZWRSdW49ITAsIUMpKXtpZihaKEkpLHIoZSksZS5vblJ1bnRpbWVJbml0aWFsaXplZCYmZS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLGUucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5wb3N0UnVuJiYoZS5wb3N0UnVuPVtlLnBvc3RSdW5dKTtlLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIHQ9ZS5wb3N0UnVuLnNoaWZ0KCk7SC51bnNoaWZ0KHQpfVooSCl9fWlmKCEoMDxCKSl7aWYoZS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlUnVuJiYoZS5wcmVSdW49W2UucHJlUnVuXSk7ZS5wcmVSdW4ubGVuZ3RoOyl6KCk7WihGKSwwPEJ8fChlLnNldFN0YXR1cz8oZS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnNldFN0YXR1cyhcIlwiKX0pLDEpLHQoKX0pLDEpKTp0KCkpfX1pZihlLlVURjhUb1N0cmluZz1qLGUuc3RyaW5nVG9VVEY4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gayh0LFQsZSxuKX0sZS5sZW5ndGhCeXRlc1VURjg9RCxlLnN0YWNrU2F2ZT1BdCxlLnN0YWNrUmVzdG9yZT1TdCxlLnN0YWNrQWxsb2M9VHQsTj1mdW5jdGlvbiB0KCl7bXR8fFd0KCksbXR8fChOPXQpfSxlLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJlSW5pdCYmKGUucHJlSW5pdD1bZS5wcmVJbml0XSk7MDxlLnByZUluaXQubGVuZ3RoOyllLnByZUluaXQucG9wKCkoKTtyZXR1cm4gV3QoKSx0LnJlYWR5fSk7dC5leHBvcnRzPXJ9LDk2NzoodCxlKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuaXRlcmF0ZUV4dHJhT3B0aW9ucz12b2lkIDAsZS5pdGVyYXRlRXh0cmFPcHRpb25zPSh0LG4scixhKT0+e2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dCl7aWYoci5oYXModCkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7ci5hZGQodCl9T2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCgoKFt0LGldKT0+e2NvbnN0IG89bj9uK3Q6dDtpZihcIm9iamVjdFwiPT10eXBlb2YgaSkoMCxlLml0ZXJhdGVFeHRyYU9wdGlvbnMpKGksbytcIi5cIixyLGEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGl8fFwibnVtYmVyXCI9PXR5cGVvZiBpKWEobyxpLnRvU3RyaW5nKCkpO2Vsc2V7aWYoXCJib29sZWFuXCIhPXR5cGVvZiBpKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiBcIit0eXBlb2YgaSk7YShvLGk/XCIxXCI6XCIwXCIpfX0pKX19LDU4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zZXRSdW5PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oOTY3KSxhPW4oOTgzKSxpPW4oMzYxKTtlLnNldFJ1bk9wdGlvbnM9dD0+e2NvbnN0IGU9KDAsaS5nZXRJbnN0YW5jZSkoKTtsZXQgbj0wO2NvbnN0IG89W10sdT10fHx7fTt0cnl7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nU2V2ZXJpdHlMZXZlbCkpdS5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dTZXZlcml0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1NldmVyaXR5TGV2ZWwpfHx0LmxvZ1NldmVyaXR5TGV2ZWw8MHx8dC5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYodm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQubG9nVmVyYm9zaXR5TGV2ZWwpKXUubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiB0LmxvZ1ZlcmJvc2l0eUxldmVsfHwhTnVtYmVyLmlzSW50ZWdlcih0LmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3QubG9nVmVyYm9zaXR5TGV2ZWx9YCk7dm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQudGVybWluYXRlKSYmKHUudGVybWluYXRlPSExKTtsZXQgaT0wO2lmKHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LnRhZykmJihpPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LnRhZyxvKSksbj1lLl9PcnRDcmVhdGVSdW5PcHRpb25zKHUubG9nU2V2ZXJpdHlMZXZlbCx1LmxvZ1ZlcmJvc2l0eUxldmVsLCEhdS50ZXJtaW5hdGUsaSksMD09PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBjcmVhdGUgcnVuIG9wdGlvbnNcIik7cmV0dXJuIHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmV4dHJhKSYmKDAsci5pdGVyYXRlRXh0cmFPcHRpb25zKSh0LmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKCh0LHIpPT57Y29uc3QgaT0oMCxhLmFsbG9jV2FzbVN0cmluZykodCxvKSx1PSgwLGEuYWxsb2NXYXNtU3RyaW5nKShyLG8pO2lmKDAhPT1lLl9PcnRBZGRSdW5Db25maWdFbnRyeShuLGksdSkpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7dH0gLSAke3J9YCl9KSksW24sb119Y2F0Y2godCl7dGhyb3cgMCE9PW4mJmUuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLG8uZm9yRWFjaChlLl9mcmVlKSx0fX19LDkxOToodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5zZXRTZXNzaW9uT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDk2NyksYT1uKDk4MyksaT1uKDM2MSk7ZS5zZXRTZXNzaW9uT3B0aW9ucz10PT57Y29uc3QgZT0oMCxpLmdldEluc3RhbmNlKSgpO2xldCBuPTA7Y29uc3Qgbz1bXSx1PXR8fHt9Oyh0PT57dC5leHRyYXx8KHQuZXh0cmE9e30pLHQuZXh0cmEuc2Vzc2lvbnx8KHQuZXh0cmEuc2Vzc2lvbj17fSk7Y29uc3QgZT10LmV4dHJhLnNlc3Npb247ZS51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwoZS51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKX0pKHUpO3RyeXt2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5ncmFwaE9wdGltaXphdGlvbkxldmVsKSYmKHUuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD1cImFsbFwiKTtjb25zdCBjPSh0PT57c3dpdGNoKHQpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke3R9YCl9fSkodS5ncmFwaE9wdGltaXphdGlvbkxldmVsKTt2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5lbmFibGVDcHVNZW1BcmVuYSkmJih1LmVuYWJsZUNwdU1lbUFyZW5hPSEwKSx2b2lkIDA9PT0obnVsbD09dD92b2lkIDA6dC5lbmFibGVNZW1QYXR0ZXJuKSYmKHUuZW5hYmxlTWVtUGF0dGVybj0hMCksdm9pZCAwPT09KG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uTW9kZSkmJih1LmV4ZWN1dGlvbk1vZGU9XCJzZXF1ZW50aWFsXCIpO2NvbnN0IHM9KHQ9Pntzd2l0Y2godCl7Y2FzZVwic2VxdWVudGlhbFwiOnJldHVybiAwO2Nhc2VcInBhcmFsbGVsXCI6cmV0dXJuIDE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4ZWN1dGlvbiBtb2RlOiAke3R9YCl9fSkodS5leGVjdXRpb25Nb2RlKTtsZXQgbD0wO2lmKHZvaWQgMCE9PShudWxsPT10P3ZvaWQgMDp0LmxvZ0lkKSYmKGw9KDAsYS5hbGxvY1dhc21TdHJpbmcpKHQubG9nSWQsbykpLHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1NldmVyaXR5TGV2ZWwpKXUubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIHQubG9nU2V2ZXJpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dTZXZlcml0eUxldmVsKXx8dC5sb2dTZXZlcml0eUxldmVsPDB8fHQubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7dC5sb2dTZXZlcml0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmxvZ1ZlcmJvc2l0eUxldmVsKSl1LmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgdC5sb2dWZXJib3NpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIodC5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHt0LmxvZ1ZlcmJvc2l0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT10P3ZvaWQgMDp0LmVuYWJsZVByb2ZpbGluZykmJih1LmVuYWJsZVByb2ZpbGluZz0hMSksbj1lLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhjLCEhdS5lbmFibGVDcHVNZW1BcmVuYSwhIXUuZW5hYmxlTWVtUGF0dGVybixzLCEhdS5lbmFibGVQcm9maWxpbmcsMCxsLHUubG9nU2V2ZXJpdHlMZXZlbCx1LmxvZ1ZlcmJvc2l0eUxldmVsKSwwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnNcIik7cmV0dXJuKG51bGw9PXQ/dm9pZCAwOnQuZXhlY3V0aW9uUHJvdmlkZXJzKSYmKCh0LGUsbik9Pntmb3IoY29uc3QgciBvZiBlKXtsZXQgZT1cInN0cmluZ1wiPT10eXBlb2Ygcj9yOnIubmFtZTtzd2l0Y2goZSl7Y2FzZVwieG5ucGFja1wiOmU9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIEVQOiAke2V9YCl9Y29uc3Qgbz0oMCxhLmFsbG9jV2FzbVN0cmluZykoZSxuKTtpZigwIT09KDAsaS5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIodCxvKSl0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtlfWApfX0pKG4sdC5leGVjdXRpb25Qcm92aWRlcnMsbyksdm9pZCAwIT09KG51bGw9PXQ/dm9pZCAwOnQuZXh0cmEpJiYoMCxyLml0ZXJhdGVFeHRyYU9wdGlvbnMpKHQuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKHQscik9Pntjb25zdCBpPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LG8pLHU9KDAsYS5hbGxvY1dhc21TdHJpbmcpKHIsbyk7aWYoMCE9PWUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShuLGksdSkpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke3R9IC0gJHtyfWApfSkpLFtuLG9dfWNhdGNoKHQpe3Rocm93IDAhPT1uJiZlLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobiksby5mb3JFYWNoKGUuX2ZyZWUpLHR9fX0sOTgzOih0LGUsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgcj1uKDM2MSk7ZS5hbGxvY1dhc21TdHJpbmc9KHQsZSk9Pntjb25zdCBuPSgwLHIuZ2V0SW5zdGFuY2UpKCksYT1uLmxlbmd0aEJ5dGVzVVRGOCh0KSsxLGk9bi5fbWFsbG9jKGEpO3JldHVybiBuLnN0cmluZ1RvVVRGOCh0LGksYSksZS5wdXNoKGkpLGl9fSwzNDk6KHQsZSxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9ZS5lbmRQcm9maWxpbmc9ZS5ydW49ZS5yZWxlYXNlU2Vzc2lvbj1lLmNyZWF0ZVNlc3Npb249ZS5jcmVhdGVTZXNzaW9uRmluYWxpemU9ZS5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9ZS5pbml0T3J0PXZvaWQgMDtjb25zdCByPW4oNTg2KSxhPW4oOTE5KSxpPW4oOTgzKSxvPW4oMzYxKTtlLmluaXRPcnQ9KHQsZSk9Pntjb25zdCBuPSgwLG8uZ2V0SW5zdGFuY2UpKCkuX09ydEluaXQodCxlKTtpZigwIT09bil0aHJvdyBuZXcgRXJyb3IoYENhblxcJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS4gZXJyb3IgY29kZSA9ICR7bn1gKX07Y29uc3QgdT1uZXcgTWFwO2UuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCksbj1lLl9tYWxsb2ModC5ieXRlTGVuZ3RoKTtyZXR1cm4gZS5IRUFQVTguc2V0KHQsbiksW24sdC5ieXRlTGVuZ3RoXX0sZS5jcmVhdGVTZXNzaW9uRmluYWxpemU9KHQsZSk9Pntjb25zdCBuPSgwLG8uZ2V0SW5zdGFuY2UpKCk7bGV0IHI9MCxpPTAsYz1bXTt0cnl7aWYoW2ksY109KDAsYS5zZXRTZXNzaW9uT3B0aW9ucykoZSkscj1uLl9PcnRDcmVhdGVTZXNzaW9uKHRbMF0sdFsxXSxpKSwwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGNyZWF0ZSBhIHNlc3Npb25cIil9ZmluYWxseXtuLl9mcmVlKHRbMF0pLG4uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhpKSxjLmZvckVhY2gobi5fZnJlZSl9Y29uc3Qgcz1uLl9PcnRHZXRJbnB1dENvdW50KHIpLGw9bi5fT3J0R2V0T3V0cHV0Q291bnQociksZj1bXSxwPVtdLGg9W10sZD1bXTtmb3IobGV0IHQ9MDt0PHM7dCsrKXtjb25zdCBlPW4uX09ydEdldElucHV0TmFtZShyLHQpO2lmKDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgZ2V0IGFuIGlucHV0IG5hbWVcIik7cC5wdXNoKGUpLGYucHVzaChuLlVURjhUb1N0cmluZyhlKSl9Zm9yKGxldCB0PTA7dDxsO3QrKyl7Y29uc3QgZT1uLl9PcnRHZXRPdXRwdXROYW1lKHIsdCk7aWYoMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBnZXQgYW4gb3V0cHV0IG5hbWVcIik7ZC5wdXNoKGUpLGgucHVzaChuLlVURjhUb1N0cmluZyhlKSl9cmV0dXJuIHUuc2V0KHIsW3IscCxkXSksW3IsZixoXX0sZS5jcmVhdGVTZXNzaW9uPSh0LG4pPT57Y29uc3Qgcj0oMCxlLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSkodCk7cmV0dXJuKDAsZS5jcmVhdGVTZXNzaW9uRmluYWxpemUpKHIsbil9LGUucmVsZWFzZVNlc3Npb249dD0+e2NvbnN0IGU9KDAsby5nZXRJbnN0YW5jZSkoKSxuPXUuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtjb25zdCByPW5bMF0sYT1uWzFdLGk9blsyXTthLmZvckVhY2goZS5fT3J0RnJlZSksaS5mb3JFYWNoKGUuX09ydEZyZWUpLGUuX09ydFJlbGVhc2VTZXNzaW9uKHIpLHUuZGVsZXRlKHQpfTtjb25zdCBjPXQ9Pntzd2l0Y2godCl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fWApfX0scz10PT57c3dpdGNoKHQpe2Nhc2UgMzpyZXR1cm5cImludDhcIjtjYXNlIDI6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgOTpyZXR1cm5cImJvb2xcIjtjYXNlIDU6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgNDpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgNjpyZXR1cm5cImludDMyXCI7Y2FzZSAxMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH1gKX19LGw9dD0+e3N3aXRjaCh0KXtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOmNhc2VcImJvb2xcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHt0fWApfX07ZS5ydW49KHQsZSxuLGEsZik9Pntjb25zdCBwPSgwLG8uZ2V0SW5zdGFuY2UpKCksaD11LmdldCh0KTtpZighaCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3QgZD1oWzBdLHk9aFsxXSxiPWhbMl0sbT1lLmxlbmd0aCxnPWEubGVuZ3RoO2xldCB2PTAsdz1bXTtjb25zdCBfPVtdLE89W107dHJ5e1t2LHddPSgwLHIuc2V0UnVuT3B0aW9ucykoZik7Zm9yKGxldCB0PTA7dDxtO3QrKyl7Y29uc3QgZT1uW3RdWzBdLHI9blt0XVsxXSxhPW5bdF1bMl07bGV0IG8sdTtpZihBcnJheS5pc0FycmF5KGEpKXt1PTQqYS5sZW5ndGgsbz1wLl9tYWxsb2ModSksTy5wdXNoKG8pO2xldCB0PW8vNDtmb3IobGV0IGU9MDtlPGEubGVuZ3RoO2UrKyl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGFbZV0pdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHtlfSBpcyBub3QgYSBzdHJpbmdgKTtwLkhFQVBVMzJbdCsrXT0oMCxpLmFsbG9jV2FzbVN0cmluZykoYVtlXSxPKX19ZWxzZSB1PWEuYnl0ZUxlbmd0aCxvPXAuX21hbGxvYyh1KSxPLnB1c2gobykscC5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLGEuYnl0ZU9mZnNldCx1KSxvKTtjb25zdCBzPXAuc3RhY2tTYXZlKCksbD1wLnN0YWNrQWxsb2MoNCpyLmxlbmd0aCk7dHJ5e2xldCB0PWwvNDtyLmZvckVhY2goKGU9PnAuSEVBUDMyW3QrK109ZSkpO2NvbnN0IG49cC5fT3J0Q3JlYXRlVGVuc29yKGMoZSksbyx1LGwsci5sZW5ndGgpO2lmKDA9PT1uKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgY3JlYXRlIGEgdGVuc29yXCIpO18ucHVzaChuKX1maW5hbGx5e3Auc3RhY2tSZXN0b3JlKHMpfX1jb25zdCB0PXAuc3RhY2tTYXZlKCksbz1wLnN0YWNrQWxsb2MoNCptKSx1PXAuc3RhY2tBbGxvYyg0Km0pLGg9cC5zdGFja0FsbG9jKDQqZyksQT1wLnN0YWNrQWxsb2MoNCpnKTt0cnl7bGV0IG49by80LHI9dS80LGk9aC80LGM9QS80O2ZvcihsZXQgdD0wO3Q8bTt0KyspcC5IRUFQVTMyW24rK109X1t0XSxwLkhFQVBVMzJbcisrXT15W2VbdF1dO2ZvcihsZXQgdD0wO3Q8Zzt0KyspcC5IRUFQVTMyW2krK109MCxwLkhFQVBVMzJbYysrXT1iW2FbdF1dO2xldCBmPXAuX09ydFJ1bihkLHUsbyxtLEEsZyxoLHYpO2NvbnN0IHc9W107aWYoMD09PWYpZm9yKGxldCB0PTA7dDxnO3QrKyl7Y29uc3QgZT1wLkhFQVBVMzJbaC80K3RdLG49cC5zdGFja1NhdmUoKSxyPXAuc3RhY2tBbGxvYygxNik7bGV0IGEsaT0wO3RyeXtpZihmPXAuX09ydEdldFRlbnNvckRhdGEoZSxyLHIrNCxyKzgscisxMiksMCE9PWYpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEuIGVycm9yIGNvZGUgPSAke2Z9YCk7bGV0IHQ9ci80O2NvbnN0IG89cC5IRUFQVTMyW3QrK107aT1wLkhFQVBVMzJbdCsrXTtjb25zdCB1PXAuSEVBUFUzMlt0KytdLGM9cC5IRUFQVTMyW3QrK10saD1bXTtmb3IobGV0IHQ9MDt0PGM7dCsrKWgucHVzaChwLkhFQVBVMzJbdS80K3RdKTtwLl9PcnRGcmVlKHUpO2NvbnN0IGQ9MD09PWgubGVuZ3RoPzE6aC5yZWR1Y2UoKCh0LGUpPT50KmUpKTtpZihhPXMobyksXCJzdHJpbmdcIj09PWEpe2NvbnN0IHQ9W107bGV0IGU9aS80O2ZvcihsZXQgbj0wO248ZDtuKyspe2NvbnN0IHI9cC5IRUFQVTMyW2UrK10sYT1uPT09ZC0xP3ZvaWQgMDpwLkhFQVBVMzJbZV0tcjt0LnB1c2gocC5VVEY4VG9TdHJpbmcocixhKSl9dy5wdXNoKFthLGgsdF0pfWVsc2V7Y29uc3QgdD1uZXcobChhKSkoZCk7bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCkuc2V0KHAuSEVBUFU4LnN1YmFycmF5KGksaSt0LmJ5dGVMZW5ndGgpKSx3LnB1c2goW2EsaCx0XSl9fWZpbmFsbHl7cC5zdGFja1Jlc3RvcmUobiksXCJzdHJpbmdcIj09PWEmJmkmJnAuX2ZyZWUoaSkscC5fT3J0UmVsZWFzZVRlbnNvcihlKX19aWYoMD09PWYpcmV0dXJuIHc7dGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS4gZXJyb3IgY29kZSA9ICR7Zn0uYCl9ZmluYWxseXtwLnN0YWNrUmVzdG9yZSh0KX19ZmluYWxseXtfLmZvckVhY2gocC5fT3J0UmVsZWFzZVRlbnNvciksTy5mb3JFYWNoKHAuX2ZyZWUpLHAuX09ydFJlbGVhc2VSdW5PcHRpb25zKHYpLHcuZm9yRWFjaChwLl9mcmVlKX19LGUuZW5kUHJvZmlsaW5nPXQ9Pntjb25zdCBlPSgwLG8uZ2V0SW5zdGFuY2UpKCksbj11LmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7Y29uc3Qgcj1uWzBdLGE9ZS5fT3J0RW5kUHJvZmlsaW5nKHIpO2lmKDA9PT1hKXRocm93IG5ldyBFcnJvcihcIkNhblxcJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lXCIpO2UuX09ydEZyZWUoYSl9LGUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9dD0+e2NvbnN0IGU9W107Zm9yKGNvbnN0IG4gb2YgdCl7Y29uc3QgdD1uWzJdOyFBcnJheS5pc0FycmF5KHQpJiZ0LmJ1ZmZlciYmZS5wdXNoKHQuYnVmZmVyKX1yZXR1cm4gZX19LDM2MTpmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTthJiYhKFwiZ2V0XCJpbiBhPyFlLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpfHwoYT17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLGEpfTpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1uKSx0W3JdPWVbbl19KSxhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbih0LGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KX06ZnVuY3Rpb24odCxlKXt0LmRlZmF1bHQ9ZX0pLGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgZT17fTtpZihudWxsIT10KWZvcih2YXIgbiBpbiB0KVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJnIoZSx0LG4pO3JldHVybiBhKGUsdCksZX0sbz10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZT90OntkZWZhdWx0OnR9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRpc3Bvc2U9ZS5nZXRJbnN0YW5jZT1lLmluaXRpYWxpemVXZWJBc3NlbWJseT12b2lkIDA7Y29uc3QgdT1pKG4oNDQ5KSksYz1vKG4oOTMyKSkscz1uKDQ3NCk7bGV0IGwsZj0hMSxwPSExLGg9ITE7Y29uc3QgZD0odCxlKT0+ZT90P1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCI6XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCI6dD9cIm9ydC13YXNtLXNpbWQud2FzbVwiOlwib3J0LXdhc20ud2FzbVwiO2UuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5PWFzeW5jIHQ9PntpZihmKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZihwKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvIFxcJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpXFwnIGRldGVjdGVkLlwiKTtpZihoKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZmFpbGVkLlwiKTtwPSEwO2NvbnN0IGU9dC5pbml0VGltZW91dCxyPXQubnVtVGhyZWFkcyxhPXQuc2ltZCxpPXI+MSYmKCgpPT57dHJ5e3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNZXNzYWdlQ2hhbm5lbCYmKG5ldyBNZXNzYWdlQ2hhbm5lbCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLG89YSYmKCgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaCh0KXtyZXR1cm4hMX19KSgpLHk9XCJzdHJpbmdcIj09dHlwZW9mIHQud2FzbVBhdGhzP3Qud2FzbVBhdGhzOnZvaWQgMCxiPWQoITEsaSksbT1kKG8saSksZz1cIm9iamVjdFwiPT10eXBlb2YgdC53YXNtUGF0aHM/dC53YXNtUGF0aHNbbV06dm9pZCAwO2xldCB2PSExO2NvbnN0IHc9W107aWYoZT4wJiZ3LnB1c2gobmV3IFByb21pc2UoKHQ9PntzZXRUaW1lb3V0KCgoKT0+e3Y9ITAsdCgpfSksZSl9KSkpLHcucHVzaChuZXcgUHJvbWlzZSgoKHQsZSk9Pntjb25zdCByPWk/czpjLmRlZmF1bHQsYT17bG9jYXRlRmlsZToodCxlKT0+aSYmdC5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBCbG9iP1VSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW24oMTU0KV0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKTp0PT09Yj9udWxsIT1nP2c6KG51bGwhPXk/eTplKSttOmUrdH07aWYoaSlpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgQmxvYilhLm1haW5TY3JpcHRVcmxPckJsb2I9dS5qb2luKFwiL1wiLFwib3J0LXdhc20tdGhyZWFkZWQuanNcIik7ZWxzZXtjb25zdCB0PWB2YXIgb3J0V2FzbVRocmVhZGVkPShmdW5jdGlvbigpe3ZhciBfc2NyaXB0RGlyO3JldHVybiAke3IudG9TdHJpbmcoKX19KSgpO2A7YS5tYWluU2NyaXB0VXJsT3JCbG9iPW5ldyBCbG9iKFt0XSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSl9cihhKS50aGVuKChlPT57cD0hMSxmPSEwLGw9ZSx0KCl9KSwodD0+e3A9ITEsaD0hMCxlKHQpfSkpfSkpKSxhd2FpdCBQcm9taXNlLnJhY2Uodyksdil0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHtlfW1zYCl9LGUuZ2V0SW5zdGFuY2U9KCk9PntpZihmJiZsKXJldHVybiBsO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfSxlLmRpc3Bvc2U9KCk9Pnt2YXIgdDshZnx8cHx8aHx8KHA9ITAsbnVsbD09PSh0PWwuUFRocmVhZCl8fHZvaWQgMD09PXR8fHQudGVybWluYXRlQWxsVGhyZWFkcygpLGw9dm9pZCAwLHA9ITEsZj0hMSxoPSEwKX19LDE1NDp0PT57XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPVxcJ1widXNlIHN0cmljdFwiO3ZhciBlPXt9LHQ9XCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MmJlwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiZcInN0cmluZ1wiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO2lmKHQpe3ZhciByPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKSxhPXIucGFyZW50UG9ydDthLm9uKFwibWVzc2FnZVwiLChlPT5vbm1lc3NhZ2Uoe2RhdGE6ZX0pKSk7dmFyIG89cmVxdWlyZShcImZzXCIpO09iamVjdC5hc3NpZ24oZ2xvYmFsLHtzZWxmOmdsb2JhbCxyZXF1aXJlOnJlcXVpcmUsTW9kdWxlOmUsbG9jYXRpb246e2hyZWY6X19maWxlbmFtZX0sV29ya2VyOnIuV29ya2VyLGltcG9ydFNjcmlwdHM6ZnVuY3Rpb24oZSl7KDAsZXZhbCkoby5yZWFkRmlsZVN5bmMoZSxcInV0ZjhcIikpfSxwb3N0TWVzc2FnZTpmdW5jdGlvbihlKXthLnBvc3RNZXNzYWdlKGUpfSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX19fSl9dmFyIHM9ITEsbj1bXSxpPWZ1bmN0aW9uKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTt0P28ud3JpdGVTeW5jKDIsZStcIlxcXFxcXFxcblwiKTpjb25zb2xlLmVycm9yKGUpfTtzZWxmLmFsZXJ0PWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OnQsdGhyZWFkSWQ6ZS5fcHRocmVhZF9zZWxmKCl9KX0sZS5pbnN0YW50aWF0ZVdhc209KHQscik9Pnt2YXIgYT1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoZS53YXNtTW9kdWxlLHQpO3JldHVybiByKGEpLGUud2FzbU1vZHVsZT1udWxsLGEuZXhwb3J0c30sc2VsZi5vbnVuaGFuZGxlZHJlamVjdGlvbj1lPT57dGhyb3cgZS5yZWFzb24/P2V9LHNlbGYub25tZXNzYWdlPXQ9Pnt0cnl7aWYoXCJsb2FkXCI9PT10LmRhdGEuY21kKXtpZihlLndhc21Nb2R1bGU9dC5kYXRhLndhc21Nb2R1bGUsZS53YXNtTWVtb3J5PXQuZGF0YS53YXNtTWVtb3J5LGUuYnVmZmVyPWUud2FzbU1lbW9yeS5idWZmZXIsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLFwic3RyaW5nXCI9PXR5cGVvZiB0LmRhdGEudXJsT3JCbG9iKWltcG9ydFNjcmlwdHModC5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgcj1VUkwuY3JlYXRlT2JqZWN0VVJMKHQuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHMociksVVJMLnJldm9rZU9iamVjdFVSTChyKX1vcnRXYXNtVGhyZWFkZWQoZSkudGhlbigoZnVuY3Rpb24odCl7ZT10fSkpfWVsc2UgaWYoXCJydW5cIj09PXQuZGF0YS5jbWQpe2UuX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnQ9cGVyZm9ybWFuY2Uubm93KCktdC5kYXRhLnRpbWUsZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQodC5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxlLmVzdGFibGlzaFN0YWNrU3BhY2UoKSxlLlBUaHJlYWQucmVjZWl2ZU9iamVjdFRyYW5zZmVyKHQuZGF0YSksZS5QVGhyZWFkLnRocmVhZEluaXRUTFMoKSxzfHwobi5mb3JFYWNoKCh0PT57ZS5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlKHQpfSkpLG49W10scz0hMCk7dHJ5e2UuaW52b2tlRW50cnlQb2ludCh0LmRhdGEuc3RhcnRfcm91dGluZSx0LmRhdGEuYXJnKX1jYXRjaCh0KXtpZihcInVud2luZFwiIT10KXtpZighKHQgaW5zdGFuY2VvZiBlLkV4aXRTdGF0dXMpKXRocm93IHQ7ZS5rZWVwUnVudGltZUFsaXZlKCl8fGUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KHQuc3RhdHVzKX19fWVsc2VcImNhbmNlbFwiPT09dC5kYXRhLmNtZD9lLl9wdGhyZWFkX3NlbGYoKSYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQoLTEpOlwic2V0aW1tZWRpYXRlXCI9PT10LmRhdGEudGFyZ2V0fHwoXCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiPT09dC5kYXRhLmNtZD9zP2UuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSh0LmRhdGEucXVldWUpOm4ucHVzaCh0LmRhdGEucXVldWUpOihpKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIit0LmRhdGEuY21kKSxpKHQuZGF0YSkpKX1jYXRjaCh0KXt0aHJvdyBpKFwid29ya2VyLmpzIG9ubWVzc2FnZSgpIGNhcHR1cmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbjogXCIrdCksdCYmdC5zdGFjayYmaSh0LnN0YWNrKSxlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQoKSx0fX07XFxcXG5cXCd9LDM4NDooKT0+e30sOTkzOigpPT57fSw5MDg6KCk9Pnt9LDk1MzooKT0+e30sOTI1OigpPT57fSw0NDk6KCk9Pnt9fSxlPXt9O2Z1bmN0aW9uIG4ocil7dmFyIGE9ZVtyXTtpZih2b2lkIDAhPT1hKXJldHVybiBhLmV4cG9ydHM7dmFyIGk9ZVtyXT17ZXhwb3J0czp7fX07cmV0dXJuIHRbcl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsbiksaS5leHBvcnRzfW4uZz1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWxUaGlzKXJldHVybiBnbG9iYWxUaGlzO3RyeXtyZXR1cm4gdGhpc3x8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaCh0KXtpZihcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93KXJldHVybiB3aW5kb3d9fSgpLCgoKT0+e1widXNlIHN0cmljdFwiO2NvbnN0IHQ9bigzNDkpLGU9bigzNjEpO3NlbGYub25tZXNzYWdlPW49Pntzd2l0Y2gobi5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOigwLGUuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KShuLmRhdGEuaW4pLnRoZW4oKCgpPT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtd2FzbVwifSkpLCh0PT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtd2FzbVwiLGVycjp0fSkpKTticmVhaztjYXNlXCJpbml0LW9ydFwiOnRyeXtjb25zdHtudW1UaHJlYWRzOmUsbG9nZ2luZ0xldmVsOnJ9PW4uZGF0YS5pbjsoMCx0LmluaXRPcnQpKGUscikscG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LW9ydFwifSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LW9ydFwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiY3JlYXRlX2FsbG9jYXRlXCI6dHJ5e2NvbnN0e21vZGVsOmV9PW4uZGF0YS5pbixyPSgwLHQuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKShlKTtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9hbGxvY2F0ZVwiLG91dDpyfSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfYWxsb2NhdGVcIixlcnI6dH0pfWJyZWFrO2Nhc2VcImNyZWF0ZV9maW5hbGl6ZVwiOnRyeXtjb25zdHttb2RlbGRhdGE6ZSxvcHRpb25zOnJ9PW4uZGF0YS5pbixhPSgwLHQuY3JlYXRlU2Vzc2lvbkZpbmFsaXplKShlLHIpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2ZpbmFsaXplXCIsb3V0OmF9KX1jYXRjaCh0KXtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9maW5hbGl6ZVwiLGVycjp0fSl9YnJlYWs7Y2FzZVwiY3JlYXRlXCI6dHJ5e2NvbnN0e21vZGVsOmUsb3B0aW9uczpyfT1uLmRhdGEuaW4sYT0oMCx0LmNyZWF0ZVNlc3Npb24pKGUscik7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVcIixvdXQ6YX0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlXCIsZXJyOnR9KX1icmVhaztjYXNlXCJyZWxlYXNlXCI6dHJ5e2NvbnN0IGU9bi5kYXRhLmluOygwLHQucmVsZWFzZVNlc3Npb24pKGUpLHBvc3RNZXNzYWdlKHt0eXBlOlwicmVsZWFzZVwifSl9Y2F0Y2godCl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJyZWxlYXNlXCIsZXJyOnR9KX1icmVhaztjYXNlXCJydW5cIjp0cnl7Y29uc3R7c2Vzc2lvbklkOmUsaW5wdXRJbmRpY2VzOnIsaW5wdXRzOmEsb3V0cHV0SW5kaWNlczppLG9wdGlvbnM6b309bi5kYXRhLmluLHU9KDAsdC5ydW4pKGUscixhLGksbyk7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixvdXQ6dX0sKDAsdC5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycykodSkpfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwicnVuXCIsZXJyOnR9KX1icmVhaztjYXNlXCJlbmQtcHJvZmlsaW5nXCI6dHJ5e2NvbnN0IGU9bi5kYXRhLmluOygwLHQuZW5kUHJvZmlsaW5nKShlKSxwb3N0TWVzc2FnZSh7dHlwZTpcImVuZC1wcm9maWxpbmdcIn0pfWNhdGNoKHQpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGVycjp0fSl9fX19KSgpfSkoKTtcXG4nLFwiV29ya2VyXCIsdm9pZCAwLHZvaWQgMCl9fSw0Nzc6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbixyKXt2YXIgaT1zZWxmfHx3aW5kb3c7dHJ5e3RyeXt2YXIgbzt0cnl7bz1uZXcgaS5CbG9iKFt0XSl9Y2F0Y2goZSl7KG89bmV3KGkuQmxvYkJ1aWxkZXJ8fGkuV2ViS2l0QmxvYkJ1aWxkZXJ8fGkuTW96QmxvYkJ1aWxkZXJ8fGkuTVNCbG9iQnVpbGRlcikpLmFwcGVuZCh0KSxvPW8uZ2V0QmxvYigpfXZhciBhPWkuVVJMfHxpLndlYmtpdFVSTCxzPWEuY3JlYXRlT2JqZWN0VVJMKG8pLHU9bmV3IGlbZV0ocyxuKTtyZXR1cm4gYS5yZXZva2VPYmplY3RVUkwocyksdX1jYXRjaChyKXtyZXR1cm4gbmV3IGlbZV0oXCJkYXRhOmFwcGxpY2F0aW9uL2phdmFzY3JpcHQsXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudCh0KSksbil9fWNhdGNoKHQpe2lmKCFyKXRocm93IEVycm9yKFwiSW5saW5lIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBuZXcgaVtlXShyLG4pfX19LDQxNTQ6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz0nXCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e30sdD1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7aWYodCl7dmFyIHI9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpLGE9ci5wYXJlbnRQb3J0O2Eub24oXCJtZXNzYWdlXCIsKGU9Pm9ubWVzc2FnZSh7ZGF0YTplfSkpKTt2YXIgbz1yZXF1aXJlKFwiZnNcIik7T2JqZWN0LmFzc2lnbihnbG9iYWwse3NlbGY6Z2xvYmFsLHJlcXVpcmU6cmVxdWlyZSxNb2R1bGU6ZSxsb2NhdGlvbjp7aHJlZjpfX2ZpbGVuYW1lfSxXb3JrZXI6ci5Xb3JrZXIsaW1wb3J0U2NyaXB0czpmdW5jdGlvbihlKXsoMCxldmFsKShvLnJlYWRGaWxlU3luYyhlLFwidXRmOFwiKSl9LHBvc3RNZXNzYWdlOmZ1bmN0aW9uKGUpe2EucG9zdE1lc3NhZ2UoZSl9LHBlcmZvcm1hbmNlOmdsb2JhbC5wZXJmb3JtYW5jZXx8e25vdzpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfX19KX12YXIgcz0hMSxuPVtdLGk9ZnVuY3Rpb24oKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Q/by53cml0ZVN5bmMoMixlK1wiXFxcXG5cIik6Y29uc29sZS5lcnJvcihlKX07c2VsZi5hbGVydD1mdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7cG9zdE1lc3NhZ2Uoe2NtZDpcImFsZXJ0XCIsdGV4dDp0LHRocmVhZElkOmUuX3B0aHJlYWRfc2VsZigpfSl9LGUuaW5zdGFudGlhdGVXYXNtPSh0LHIpPT57dmFyIGE9bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKGUud2FzbU1vZHVsZSx0KTtyZXR1cm4gcihhKSxlLndhc21Nb2R1bGU9bnVsbCxhLmV4cG9ydHN9LHNlbGYub251bmhhbmRsZWRyZWplY3Rpb249ZT0+e3Rocm93IGUucmVhc29uPz9lfSxzZWxmLm9ubWVzc2FnZT10PT57dHJ5e2lmKFwibG9hZFwiPT09dC5kYXRhLmNtZCl7aWYoZS53YXNtTW9kdWxlPXQuZGF0YS53YXNtTW9kdWxlLGUud2FzbU1lbW9yeT10LmRhdGEud2FzbU1lbW9yeSxlLmJ1ZmZlcj1lLndhc21NZW1vcnkuYnVmZmVyLGUuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRD0hMCxcInN0cmluZ1wiPT10eXBlb2YgdC5kYXRhLnVybE9yQmxvYilpbXBvcnRTY3JpcHRzKHQuZGF0YS51cmxPckJsb2IpO2Vsc2V7dmFyIHI9VVJMLmNyZWF0ZU9iamVjdFVSTCh0LmRhdGEudXJsT3JCbG9iKTtpbXBvcnRTY3JpcHRzKHIpLFVSTC5yZXZva2VPYmplY3RVUkwocil9b3J0V2FzbVRocmVhZGVkKGUpLnRoZW4oKGZ1bmN0aW9uKHQpe2U9dH0pKX1lbHNlIGlmKFwicnVuXCI9PT10LmRhdGEuY21kKXtlLl9fcGVyZm9ybWFuY2Vfbm93X2Nsb2NrX2RyaWZ0PXBlcmZvcm1hbmNlLm5vdygpLXQuZGF0YS50aW1lLGUuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0KHQuZGF0YS5wdGhyZWFkX3B0ciwwLDAsMSksZS5lc3RhYmxpc2hTdGFja1NwYWNlKCksZS5QVGhyZWFkLnJlY2VpdmVPYmplY3RUcmFuc2Zlcih0LmRhdGEpLGUuUFRocmVhZC50aHJlYWRJbml0VExTKCksc3x8KG4uZm9yRWFjaCgodD0+e2UuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZSh0KX0pKSxuPVtdLHM9ITApO3RyeXtlLmludm9rZUVudHJ5UG9pbnQodC5kYXRhLnN0YXJ0X3JvdXRpbmUsdC5kYXRhLmFyZyl9Y2F0Y2godCl7aWYoXCJ1bndpbmRcIiE9dCl7aWYoISh0IGluc3RhbmNlb2YgZS5FeGl0U3RhdHVzKSl0aHJvdyB0O2Uua2VlcFJ1bnRpbWVBbGl2ZSgpfHxlLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCh0LnN0YXR1cyl9fX1lbHNlXCJjYW5jZWxcIj09PXQuZGF0YS5jbWQ/ZS5fcHRocmVhZF9zZWxmKCkmJmUuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0KC0xKTpcInNldGltbWVkaWF0ZVwiPT09dC5kYXRhLnRhcmdldHx8KFwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIj09PXQuZGF0YS5jbWQ/cz9lLmV4ZWN1dGVOb3RpZmllZFByb3h5aW5nUXVldWUodC5kYXRhLnF1ZXVlKTpuLnB1c2godC5kYXRhLnF1ZXVlKTooaShcIndvcmtlci5qcyByZWNlaXZlZCB1bmtub3duIGNvbW1hbmQgXCIrdC5kYXRhLmNtZCksaSh0LmRhdGEpKSl9Y2F0Y2godCl7dGhyb3cgaShcIndvcmtlci5qcyBvbm1lc3NhZ2UoKSBjYXB0dXJlZCBhbiB1bmNhdWdodCBleGNlcHRpb246IFwiK3QpLHQmJnQuc3RhY2smJmkodC5zdGFjayksZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQmJmUuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkKCksdH19O1xcbid9LDE2NzA6dD0+e1widXNlIHN0cmljdFwiO3QuZXhwb3J0cz1fX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNjcwX199LDcwNjc6KCk9Pnt9LDEyOTY6KCk9Pnt9LDEzODQ6KCk9Pnt9LDM5OTM6KCk9Pnt9LDkwODooKT0+e30sNjk1MzooKT0+e30sOTkyNTooKT0+e30sMjgwNjooKT0+e30sNjQ0OTooKT0+e30sMjg1MDooKT0+e30sNTM4MTooKT0+e30sNTY4NjoodCxlLG4pPT57XCJ1c2Ugc3RyaWN0XCI7bi5yKGUpLG4uZChlLHtmbGF0YnVmZmVyczooKT0+cn0pO3ZhciByPXt9O3IuT2Zmc2V0LHIuVGFibGUsci5TSVpFT0ZfU0hPUlQ9MixyLlNJWkVPRl9JTlQ9NCxyLkZJTEVfSURFTlRJRklFUl9MRU5HVEg9NCxyLlNJWkVfUFJFRklYX0xFTkdUSD00LHIuRW5jb2Rpbmc9e1VURjhfQllURVM6MSxVVEYxNl9TVFJJTkc6Mn0sci5pbnQzMj1uZXcgSW50MzJBcnJheSgyKSxyLmZsb2F0MzI9bmV3IEZsb2F0MzJBcnJheShyLmludDMyLmJ1ZmZlciksci5mbG9hdDY0PW5ldyBGbG9hdDY0QXJyYXkoci5pbnQzMi5idWZmZXIpLHIuaXNMaXR0bGVFbmRpYW49MT09PW5ldyBVaW50MTZBcnJheShuZXcgVWludDhBcnJheShbMSwwXSkuYnVmZmVyKVswXSxyLkxvbmc9ZnVuY3Rpb24odCxlKXt0aGlzLmxvdz0wfHQsdGhpcy5oaWdoPTB8ZX0sci5Mb25nLmNyZWF0ZT1mdW5jdGlvbih0LGUpe3JldHVybiAwPT10JiYwPT1lP3IuTG9uZy5aRVJPOm5ldyByLkxvbmcodCxlKX0sci5Mb25nLnByb3RvdHlwZS50b0Zsb2F0NjQ9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5sb3c+Pj4wKSs0Mjk0OTY3Mjk2KnRoaXMuaGlnaH0sci5Mb25nLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubG93PT10LmxvdyYmdGhpcy5oaWdoPT10LmhpZ2h9LHIuTG9uZy5aRVJPPW5ldyByLkxvbmcoMCwwKSxyLkJ1aWxkZXI9ZnVuY3Rpb24odCl7aWYodCllPXQ7ZWxzZSB2YXIgZT0xMDI0O3RoaXMuYmI9ci5CeXRlQnVmZmVyLmFsbG9jYXRlKGUpLHRoaXMuc3BhY2U9ZSx0aGlzLm1pbmFsaWduPTEsdGhpcy52dGFibGU9bnVsbCx0aGlzLnZ0YWJsZV9pbl91c2U9MCx0aGlzLmlzTmVzdGVkPSExLHRoaXMub2JqZWN0X3N0YXJ0PTAsdGhpcy52dGFibGVzPVtdLHRoaXMudmVjdG9yX251bV9lbGVtcz0wLHRoaXMuZm9yY2VfZGVmYXVsdHM9ITF9LHIuQnVpbGRlci5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmJiLmNsZWFyKCksdGhpcy5zcGFjZT10aGlzLmJiLmNhcGFjaXR5KCksdGhpcy5taW5hbGlnbj0xLHRoaXMudnRhYmxlPW51bGwsdGhpcy52dGFibGVfaW5fdXNlPTAsdGhpcy5pc05lc3RlZD0hMSx0aGlzLm9iamVjdF9zdGFydD0wLHRoaXMudnRhYmxlcz1bXSx0aGlzLnZlY3Rvcl9udW1fZWxlbXM9MCx0aGlzLmZvcmNlX2RlZmF1bHRzPSExfSxyLkJ1aWxkZXIucHJvdG90eXBlLmZvcmNlRGVmYXVsdHM9ZnVuY3Rpb24odCl7dGhpcy5mb3JjZV9kZWZhdWx0cz10fSxyLkJ1aWxkZXIucHJvdG90eXBlLmRhdGFCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYn0sci5CdWlsZGVyLnByb3RvdHlwZS5hc1VpbnQ4QXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYi5ieXRlcygpLnN1YmFycmF5KHRoaXMuYmIucG9zaXRpb24oKSx0aGlzLmJiLnBvc2l0aW9uKCkrdGhpcy5vZmZzZXQoKSl9LHIuQnVpbGRlci5wcm90b3R5cGUucHJlcD1mdW5jdGlvbih0LGUpe3Q+dGhpcy5taW5hbGlnbiYmKHRoaXMubWluYWxpZ249dCk7Zm9yKHZhciBuPTErfih0aGlzLmJiLmNhcGFjaXR5KCktdGhpcy5zcGFjZStlKSZ0LTE7dGhpcy5zcGFjZTxuK3QrZTspe3ZhciBpPXRoaXMuYmIuY2FwYWNpdHkoKTt0aGlzLmJiPXIuQnVpbGRlci5ncm93Qnl0ZUJ1ZmZlcih0aGlzLmJiKSx0aGlzLnNwYWNlKz10aGlzLmJiLmNhcGFjaXR5KCktaX10aGlzLnBhZChuKX0sci5CdWlsZGVyLnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0O2UrKyl0aGlzLmJiLndyaXRlSW50OCgtLXRoaXMuc3BhY2UsMCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVJbnQ4KHRoaXMuc3BhY2UtPTEsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQxNj1mdW5jdGlvbih0KXt0aGlzLmJiLndyaXRlSW50MTYodGhpcy5zcGFjZS09Mix0KX0sci5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDMyPWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLT00LHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50NjQ9ZnVuY3Rpb24odCl7dGhpcy5iYi53cml0ZUludDY0KHRoaXMuc3BhY2UtPTgsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyPWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVGbG9hdDMyKHRoaXMuc3BhY2UtPTQsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDY0PWZ1bmN0aW9uKHQpe3RoaXMuYmIud3JpdGVGbG9hdDY0KHRoaXMuc3BhY2UtPTgsdCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50OD1mdW5jdGlvbih0KXt0aGlzLnByZXAoMSwwKSx0aGlzLndyaXRlSW50OCh0KX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQxNj1mdW5jdGlvbih0KXt0aGlzLnByZXAoMiwwKSx0aGlzLndyaXRlSW50MTYodCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MzI9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKDQsMCksdGhpcy53cml0ZUludDMyKHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDY0PWZ1bmN0aW9uKHQpe3RoaXMucHJlcCg4LDApLHRoaXMud3JpdGVJbnQ2NCh0KX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDMyPWZ1bmN0aW9uKHQpe3RoaXMucHJlcCg0LDApLHRoaXMud3JpdGVGbG9hdDMyKHQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZsb2F0NjQ9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKDgsMCksdGhpcy53cml0ZUZsb2F0NjQodCl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQ4PWZ1bmN0aW9uKHQsZSxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8ZSE9bikmJih0aGlzLmFkZEludDgoZSksdGhpcy5zbG90KHQpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDE2PWZ1bmN0aW9uKHQsZSxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8ZSE9bikmJih0aGlzLmFkZEludDE2KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQzMj1mdW5jdGlvbih0LGUsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fGUhPW4pJiYodGhpcy5hZGRJbnQzMihlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50NjQ9ZnVuY3Rpb24odCxlLG4peyF0aGlzLmZvcmNlX2RlZmF1bHRzJiZlLmVxdWFscyhuKXx8KHRoaXMuYWRkSW50NjQoZSksdGhpcy5zbG90KHQpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEZsb2F0MzI9ZnVuY3Rpb24odCxlLG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHxlIT1uKSYmKHRoaXMuYWRkRmxvYXQzMihlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkRmxvYXQ2ND1mdW5jdGlvbih0LGUsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fGUhPW4pJiYodGhpcy5hZGRGbG9hdDY0KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRPZmZzZXQ9ZnVuY3Rpb24odCxlLG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHxlIT1uKSYmKHRoaXMuYWRkT2Zmc2V0KGUpLHRoaXMuc2xvdCh0KSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRTdHJ1Y3Q9ZnVuY3Rpb24odCxlLG4pe2UhPW4mJih0aGlzLm5lc3RlZChlKSx0aGlzLnNsb3QodCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLm5lc3RlZD1mdW5jdGlvbih0KXtpZih0IT10aGlzLm9mZnNldCgpKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBzdHJ1Y3QgbXVzdCBiZSBzZXJpYWxpemVkIGlubGluZS5cIil9LHIuQnVpbGRlci5wcm90b3R5cGUubm90TmVzdGVkPWZ1bmN0aW9uKCl7aWYodGhpcy5pc05lc3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogb2JqZWN0IHNlcmlhbGl6YXRpb24gbXVzdCBub3QgYmUgbmVzdGVkLlwiKX0sci5CdWlsZGVyLnByb3RvdHlwZS5zbG90PWZ1bmN0aW9uKHQpe3RoaXMudnRhYmxlW3RdPXRoaXMub2Zmc2V0KCl9LHIuQnVpbGRlci5wcm90b3R5cGUub2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmIuY2FwYWNpdHkoKS10aGlzLnNwYWNlfSxyLkJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXI9ZnVuY3Rpb24odCl7dmFyIGU9dC5jYXBhY2l0eSgpO2lmKDMyMjEyMjU0NzImZSl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogY2Fubm90IGdyb3cgYnVmZmVyIGJleW9uZCAyIGdpZ2FieXRlcy5cIik7dmFyIG49ZTw8MSxpPXIuQnl0ZUJ1ZmZlci5hbGxvY2F0ZShuKTtyZXR1cm4gaS5zZXRQb3NpdGlvbihuLWUpLGkuYnl0ZXMoKS5zZXQodC5ieXRlcygpLG4tZSksaX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRPZmZzZXQ9ZnVuY3Rpb24odCl7dGhpcy5wcmVwKHIuU0laRU9GX0lOVCwwKSx0aGlzLndyaXRlSW50MzIodGhpcy5vZmZzZXQoKS10K3IuU0laRU9GX0lOVCl9LHIuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRPYmplY3Q9ZnVuY3Rpb24odCl7dGhpcy5ub3ROZXN0ZWQoKSxudWxsPT10aGlzLnZ0YWJsZSYmKHRoaXMudnRhYmxlPVtdKSx0aGlzLnZ0YWJsZV9pbl91c2U9dDtmb3IodmFyIGU9MDtlPHQ7ZSsrKXRoaXMudnRhYmxlW2VdPTA7dGhpcy5pc05lc3RlZD0hMCx0aGlzLm9iamVjdF9zdGFydD10aGlzLm9mZnNldCgpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmVuZE9iamVjdD1mdW5jdGlvbigpe2lmKG51bGw9PXRoaXMudnRhYmxlfHwhdGhpcy5pc05lc3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZW5kT2JqZWN0IGNhbGxlZCB3aXRob3V0IHN0YXJ0T2JqZWN0XCIpO3RoaXMuYWRkSW50MzIoMCk7Zm9yKHZhciB0PXRoaXMub2Zmc2V0KCksZT10aGlzLnZ0YWJsZV9pbl91c2UtMTtlPj0wJiYwPT10aGlzLnZ0YWJsZVtlXTtlLS0pO2Zvcih2YXIgbj1lKzE7ZT49MDtlLS0pdGhpcy5hZGRJbnQxNigwIT10aGlzLnZ0YWJsZVtlXT90LXRoaXMudnRhYmxlW2VdOjApO3RoaXMuYWRkSW50MTYodC10aGlzLm9iamVjdF9zdGFydCk7dmFyIGk9KG4rMikqci5TSVpFT0ZfU0hPUlQ7dGhpcy5hZGRJbnQxNihpKTt2YXIgbz0wLGE9dGhpcy5zcGFjZTt0OmZvcihlPTA7ZTx0aGlzLnZ0YWJsZXMubGVuZ3RoO2UrKyl7dmFyIHM9dGhpcy5iYi5jYXBhY2l0eSgpLXRoaXMudnRhYmxlc1tlXTtpZihpPT10aGlzLmJiLnJlYWRJbnQxNihzKSl7Zm9yKHZhciB1PXIuU0laRU9GX1NIT1JUO3U8aTt1Kz1yLlNJWkVPRl9TSE9SVClpZih0aGlzLmJiLnJlYWRJbnQxNihhK3UpIT10aGlzLmJiLnJlYWRJbnQxNihzK3UpKWNvbnRpbnVlIHQ7bz10aGlzLnZ0YWJsZXNbZV07YnJlYWt9fXJldHVybiBvPyh0aGlzLnNwYWNlPXRoaXMuYmIuY2FwYWNpdHkoKS10LHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLG8tdCkpOih0aGlzLnZ0YWJsZXMucHVzaCh0aGlzLm9mZnNldCgpKSx0aGlzLmJiLndyaXRlSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpLXQsdGhpcy5vZmZzZXQoKS10KSksdGhpcy5pc05lc3RlZD0hMSx0fSxyLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaD1mdW5jdGlvbih0LGUsbil7dmFyIGk9bj9yLlNJWkVfUFJFRklYX0xFTkdUSDowO2lmKGUpe3ZhciBvPWU7aWYodGhpcy5wcmVwKHRoaXMubWluYWxpZ24sci5TSVpFT0ZfSU5UK3IuRklMRV9JREVOVElGSUVSX0xFTkdUSCtpKSxvLmxlbmd0aCE9ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggXCIrci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtmb3IodmFyIGE9ci5GSUxFX0lERU5USUZJRVJfTEVOR1RILTE7YT49MDthLS0pdGhpcy53cml0ZUludDgoby5jaGFyQ29kZUF0KGEpKX10aGlzLnByZXAodGhpcy5taW5hbGlnbixyLlNJWkVPRl9JTlQraSksdGhpcy5hZGRPZmZzZXQodCksaSYmdGhpcy5hZGRJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCktdGhpcy5zcGFjZSksdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlKX0sci5CdWlsZGVyLnByb3RvdHlwZS5maW5pc2hTaXplUHJlZml4ZWQ9ZnVuY3Rpb24odCxlKXt0aGlzLmZpbmlzaCh0LGUsITApfSxyLkJ1aWxkZXIucHJvdG90eXBlLnJlcXVpcmVkRmllbGQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmJiLmNhcGFjaXR5KCktdCxyPW4tdGhpcy5iYi5yZWFkSW50MzIobik7aWYoMD09dGhpcy5iYi5yZWFkSW50MTYocitlKSl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZmllbGQgXCIrZStcIiBtdXN0IGJlIHNldFwiKX0sci5CdWlsZGVyLnByb3RvdHlwZS5zdGFydFZlY3Rvcj1mdW5jdGlvbih0LGUsbil7dGhpcy5ub3ROZXN0ZWQoKSx0aGlzLnZlY3Rvcl9udW1fZWxlbXM9ZSx0aGlzLnByZXAoci5TSVpFT0ZfSU5ULHQqZSksdGhpcy5wcmVwKG4sdCplKX0sci5CdWlsZGVyLnByb3RvdHlwZS5lbmRWZWN0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53cml0ZUludDMyKHRoaXMudmVjdG9yX251bV9lbGVtcyksdGhpcy5vZmZzZXQoKX0sci5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVTdHJpbmc9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpdmFyIGU9dDtlbHNle2U9W107Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDspe3ZhciByLGk9dC5jaGFyQ29kZUF0KG4rKyk7KHI9aTw1NTI5Nnx8aT49NTYzMjA/aTooaTw8MTApK3QuY2hhckNvZGVBdChuKyspKy01NjYxMzg4OCk8MTI4P2UucHVzaChyKToocjwyMDQ4P2UucHVzaChyPj42JjMxfDE5Mik6KHI8NjU1MzY/ZS5wdXNoKHI+PjEyJjE1fDIyNCk6ZS5wdXNoKHI+PjE4Jjd8MjQwLHI+PjEyJjYzfDEyOCksZS5wdXNoKHI+PjYmNjN8MTI4KSksZS5wdXNoKDYzJnJ8MTI4KSl9fXRoaXMuYWRkSW50OCgwKSx0aGlzLnN0YXJ0VmVjdG9yKDEsZS5sZW5ndGgsMSksdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlLT1lLmxlbmd0aCksbj0wO2Zvcih2YXIgbz10aGlzLnNwYWNlLGE9dGhpcy5iYi5ieXRlcygpO248ZS5sZW5ndGg7bisrKWFbbysrXT1lW25dO3JldHVybiB0aGlzLmVuZFZlY3RvcigpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmNyZWF0ZUxvbmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gci5Mb25nLmNyZWF0ZSh0LGUpfSxyLkJ5dGVCdWZmZXI9ZnVuY3Rpb24odCl7dGhpcy5ieXRlc189dCx0aGlzLnBvc2l0aW9uXz0wfSxyLkJ5dGVCdWZmZXIuYWxsb2NhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyByLkJ5dGVCdWZmZXIobmV3IFVpbnQ4QXJyYXkodCkpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5wb3NpdGlvbl89MH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ5dGVzX30sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5wb3NpdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uX30sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbj1mdW5jdGlvbih0KXt0aGlzLnBvc2l0aW9uXz10fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmNhcGFjaXR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnl0ZXNfLmxlbmd0aH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkVWludDgodCk8PDI0Pj4yNH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDg9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYnl0ZXNfW3RdfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkVWludDE2KHQpPDwxNj4+MTZ9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ieXRlc19bdF18dGhpcy5ieXRlc19bdCsxXTw8OH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYnl0ZXNfW3RdfHRoaXMuYnl0ZXNfW3QrMV08PDh8dGhpcy5ieXRlc19bdCsyXTw8MTZ8dGhpcy5ieXRlc19bdCszXTw8MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkSW50MzIodCk+Pj4wfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ2ND1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IHIuTG9uZyh0aGlzLnJlYWRJbnQzMih0KSx0aGlzLnJlYWRJbnQzMih0KzQpKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDY0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgci5Mb25nKHRoaXMucmVhZFVpbnQzMih0KSx0aGlzLnJlYWRVaW50MzIodCs0KSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHIuaW50MzJbMF09dGhpcy5yZWFkSW50MzIodCksci5mbG9hdDMyWzBdfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDY0PWZ1bmN0aW9uKHQpe3JldHVybiByLmludDMyW3IuaXNMaXR0bGVFbmRpYW4/MDoxXT10aGlzLnJlYWRJbnQzMih0KSxyLmludDMyW3IuaXNMaXR0bGVFbmRpYW4/MTowXT10aGlzLnJlYWRJbnQzMih0KzQpLHIuZmxvYXQ2NFswXX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDg9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTY9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lLHRoaXMuYnl0ZXNfW3QrMV09ZT4+OH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNj1mdW5jdGlvbih0LGUpe3RoaXMuYnl0ZXNfW3RdPWUsdGhpcy5ieXRlc19bdCsxXT1lPj44fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzI9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lLHRoaXMuYnl0ZXNfW3QrMV09ZT4+OCx0aGlzLmJ5dGVzX1t0KzJdPWU+PjE2LHRoaXMuYnl0ZXNfW3QrM109ZT4+MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzI9ZnVuY3Rpb24odCxlKXt0aGlzLmJ5dGVzX1t0XT1lLHRoaXMuYnl0ZXNfW3QrMV09ZT4+OCx0aGlzLmJ5dGVzX1t0KzJdPWU+PjE2LHRoaXMuYnl0ZXNfW3QrM109ZT4+MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ2ND1mdW5jdGlvbih0LGUpe3RoaXMud3JpdGVJbnQzMih0LGUubG93KSx0aGlzLndyaXRlSW50MzIodCs0LGUuaGlnaCl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50NjQ9ZnVuY3Rpb24odCxlKXt0aGlzLndyaXRlVWludDMyKHQsZS5sb3cpLHRoaXMud3JpdGVVaW50MzIodCs0LGUuaGlnaCl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyPWZ1bmN0aW9uKHQsZSl7ci5mbG9hdDMyWzBdPWUsdGhpcy53cml0ZUludDMyKHQsci5pbnQzMlswXSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdDY0PWZ1bmN0aW9uKHQsZSl7ci5mbG9hdDY0WzBdPWUsdGhpcy53cml0ZUludDMyKHQsci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzA6MV0pLHRoaXMud3JpdGVJbnQzMih0KzQsci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzE6MF0pfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmdldEJ1ZmZlcklkZW50aWZpZXI9ZnVuY3Rpb24oKXtpZih0aGlzLmJ5dGVzXy5sZW5ndGg8dGhpcy5wb3NpdGlvbl8rci5TSVpFT0ZfSU5UK3IuRklMRV9JREVOVElGSUVSX0xFTkdUSCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogQnl0ZUJ1ZmZlciBpcyB0b28gc2hvcnQgdG8gY29udGFpbiBhbiBpZGVudGlmaWVyLlwiKTtmb3IodmFyIHQ9XCJcIixlPTA7ZTxyLkZJTEVfSURFTlRJRklFUl9MRU5HVEg7ZSsrKXQrPVN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uXytyLlNJWkVPRl9JTlQrZSkpO3JldHVybiB0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fb2Zmc2V0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dC10aGlzLnJlYWRJbnQzMih0KTtyZXR1cm4gZTx0aGlzLnJlYWRJbnQxNihuKT90aGlzLnJlYWRJbnQxNihuK2UpOjB9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX191bmlvbj1mdW5jdGlvbih0LGUpe3JldHVybiB0LmJiX3Bvcz1lK3RoaXMucmVhZEludDMyKGUpLHQuYmI9dGhpcyx0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fc3RyaW5nPWZ1bmN0aW9uKHQsZSl7dCs9dGhpcy5yZWFkSW50MzIodCk7dmFyIG49dGhpcy5yZWFkSW50MzIodCksaT1cIlwiLG89MDtpZih0Kz1yLlNJWkVPRl9JTlQsZT09PXIuRW5jb2RpbmcuVVRGOF9CWVRFUylyZXR1cm4gdGhpcy5ieXRlc18uc3ViYXJyYXkodCx0K24pO2Zvcig7bzxuOyl7dmFyIGEscz10aGlzLnJlYWRVaW50OCh0K28rKyk7aWYoczwxOTIpYT1zO2Vsc2V7dmFyIHU9dGhpcy5yZWFkVWludDgodCtvKyspO2lmKHM8MjI0KWE9KDMxJnMpPDw2fDYzJnU7ZWxzZXt2YXIgYz10aGlzLnJlYWRVaW50OCh0K28rKyk7YT1zPDI0MD8oMTUmcyk8PDEyfCg2MyZ1KTw8Nnw2MyZjOig3JnMpPDwxOHwoNjMmdSk8PDEyfCg2MyZjKTw8Nnw2MyZ0aGlzLnJlYWRVaW50OCh0K28rKyl9fWE8NjU1MzY/aSs9U3RyaW5nLmZyb21DaGFyQ29kZShhKTooYS09NjU1MzYsaSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NisoYT4+MTApLDU2MzIwKygxMDIzJmEpKSl9cmV0dXJuIGl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19pbmRpcmVjdD1mdW5jdGlvbih0KXtyZXR1cm4gdCt0aGlzLnJlYWRJbnQzMih0KX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3ZlY3Rvcj1mdW5jdGlvbih0KXtyZXR1cm4gdCt0aGlzLnJlYWRJbnQzMih0KStyLlNJWkVPRl9JTlR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX192ZWN0b3JfbGVuPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJlYWRJbnQzMih0K3RoaXMucmVhZEludDMyKHQpKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX2hhc19pZGVudGlmaWVyPWZ1bmN0aW9uKHQpe2lmKHQubGVuZ3RoIT1yLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCBcIityLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpO2Zvcih2YXIgZT0wO2U8ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIO2UrKylpZih0LmNoYXJDb2RlQXQoZSkhPXRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8rci5TSVpFT0ZfSU5UK2UpKXJldHVybiExO3JldHVybiEwfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLmNyZWF0ZUxvbmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gci5Mb25nLmNyZWF0ZSh0LGUpfX19LF9fd2VicGFja19tb2R1bGVfY2FjaGVfXz17fTtmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKHQpe3ZhciBlPV9fd2VicGFja19tb2R1bGVfY2FjaGVfX1t0XTtpZih2b2lkIDAhPT1lKXJldHVybiBlLmV4cG9ydHM7dmFyIG49X193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW3RdPXtleHBvcnRzOnt9fTtyZXR1cm4gX193ZWJwYWNrX21vZHVsZXNfX1t0XS5jYWxsKG4uZXhwb3J0cyxuLG4uZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKSxuLmV4cG9ydHN9X193ZWJwYWNrX3JlcXVpcmVfXy5uPXQ9Pnt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/KCk9PnQuZGVmYXVsdDooKT0+dDtyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5kKGUse2E6ZX0pLGV9LF9fd2VicGFja19yZXF1aXJlX18uZD0odCxlKT0+e2Zvcih2YXIgbiBpbiBlKV9fd2VicGFja19yZXF1aXJlX18ubyhlLG4pJiYhX193ZWJwYWNrX3JlcXVpcmVfXy5vKHQsbikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsZ2V0OmVbbl19KX0sX193ZWJwYWNrX3JlcXVpcmVfXy5nPWZ1bmN0aW9uKCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXMpcmV0dXJuIGdsb2JhbFRoaXM7dHJ5e3JldHVybiB0aGlzfHxuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfWNhdGNoKHQpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cpcmV0dXJuIHdpbmRvd319KCksX193ZWJwYWNrX3JlcXVpcmVfXy5vPSh0LGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSxfX3dlYnBhY2tfcmVxdWlyZV9fLnI9dD0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9O3ZhciBfX3dlYnBhY2tfZXhwb3J0c19fPV9fd2VicGFja19yZXF1aXJlX18oNjAxOCk7cmV0dXJuIF9fd2VicGFja19leHBvcnRzX199KSgpKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQtd2ViLm1pbi5qcy5tYXAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC90eXBlcy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gcmVxdWlyZSgnaXMtYXJndW1lbnRzJyk7XG52YXIgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWdlbmVyYXRvci1mdW5jdGlvbicpO1xudmFyIHdoaWNoVHlwZWRBcnJheSA9IHJlcXVpcmUoJ3doaWNoLXR5cGVkLWFycmF5Jyk7XG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnNsaWNlKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSByZXF1aXJlKCcuL3N1cHBvcnQvdHlwZXMnKTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgcmV0KSkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwsIHJlaiwgY2IpKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCdnb3BkJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbnZhciBjYWNoZSA9IHsgX19wcm90b19fOiBudWxsIH07XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0Y2FjaGVbJyQnICsgdHlwZWRBcnJheV0gPSBjYWxsQmluZChkZXNjcmlwdG9yLmdldCk7XG5cdFx0fVxuXHR9KTtcbn0gZWxzZSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0Y2FjaGVbJyQnICsgdHlwZWRBcnJheV0gPSBjYWxsQmluZChhcnIuc2xpY2UpO1xuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdGZvckVhY2goY2FjaGUsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoJyQnICsgZ2V0dGVyKHZhbHVlKSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdGZvdW5kID0gJHNsaWNlKHR5cGVkQXJyYXksIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZDtcbn07XG5cbnZhciB0cnlTbGljZXMgPSBmdW5jdGlvbiB0cnlBbGxTbGljZXModmFsdWUpIHtcblx0dmFyIGZvdW5kID0gZmFsc2U7XG5cdGZvckVhY2goY2FjaGUsIGZ1bmN0aW9uIChnZXR0ZXIsIG5hbWUpIHtcblx0XHRpZiAoIWZvdW5kKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRnZXR0ZXIodmFsdWUpO1xuXHRcdFx0XHRmb3VuZCA9ICRzbGljZShuYW1lLCAxKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG5cdFx0aWYgKCRpbmRleE9mKHR5cGVkQXJyYXlzLCB0YWcpID4gLTEpIHtcblx0XHRcdHJldHVybiB0YWc7XG5cdFx0fVxuXHRcdGlmICh0YWcgIT09ICdPYmplY3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdC8vIG5vZGUgPCAwLjYgaGl0cyBoZXJlIG9uIHJlYWwgVHlwZWQgQXJyYXlzXG5cdFx0cmV0dXJuIHRyeVNsaWNlcyh2YWx1ZSk7XG5cdH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBudWxsOyB9IC8vIHVua25vd24gZW5naW5lXG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcG9zc2libGVOYW1lcyA9IFtcblx0J0JpZ0ludDY0QXJyYXknLFxuXHQnQmlnVWludDY0QXJyYXknLFxuXHQnRmxvYXQzMkFycmF5Jyxcblx0J0Zsb2F0NjRBcnJheScsXG5cdCdJbnQxNkFycmF5Jyxcblx0J0ludDMyQXJyYXknLFxuXHQnSW50OEFycmF5Jyxcblx0J1VpbnQxNkFycmF5Jyxcblx0J1VpbnQzMkFycmF5Jyxcblx0J1VpbnQ4QXJyYXknLFxuXHQnVWludDhDbGFtcGVkQXJyYXknXG5dO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IGdsb2JhbFRoaXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKSB7XG5cdHZhciBvdXQgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBnW3Bvc3NpYmxlTmFtZXNbaV1dID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvdXRbb3V0Lmxlbmd0aF0gPSBwb3NzaWJsZU5hbWVzW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0O1xufTtcbiIsIi8qKlxuICogQGZpbGUgSGFuZGxlciBmaWxlIGZvciBjaG9vc2luZyB0aGUgY29ycmVjdCB2ZXJzaW9uIG9mIE9OTlggUnVudGltZSwgYmFzZWQgb24gdGhlIGVudmlyb25tZW50LlxuICogSWRlYWxseSwgd2UgY291bGQgaW1wb3J0IHRoZSBgb25ueHJ1bnRpbWUtd2ViYCBhbmQgYG9ubnhydW50aW1lLW5vZGVgIHBhY2thZ2VzIG9ubHkgd2hlbiBuZWVkZWQsXG4gKiBidXQgZHluYW1pYyBpbXBvcnRzIGRvbid0IHNlZW0gdG8gd29yayB3aXRoIHRoZSBjdXJyZW50IHdlYnBhY2sgdmVyc2lvbiBhbmQvb3IgY29uZmlndXJhdGlvbi5cbiAqIFRoaXMgaXMgcG9zc2libHkgZHVlIHRvIHRoZSBleHBlcmltZW50YWwgbmF0dXJlIG9mIHRvcC1sZXZlbCBhd2FpdCBzdGF0ZW1lbnRzLlxuICogU28sIHdlIGp1c3QgaW1wb3J0IGJvdGggcGFja2FnZXMsIGFuZCB1c2UgdGhlIGFwcHJvcHJpYXRlIG9uZSBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQ6XG4gKiAgIC0gV2hlbiBydW5uaW5nIGluIG5vZGUsIHdlIHVzZSBgb25ueHJ1bnRpbWUtbm9kZWAuXG4gKiAgIC0gV2hlbiBydW5uaW5nIGluIHRoZSBicm93c2VyLCB3ZSB1c2UgYG9ubnhydW50aW1lLXdlYmAgKGBvbm54cnVudGltZS1ub2RlYCBpcyBub3QgYnVuZGxlZCkuXG4gKiBcbiAqIFRoaXMgbW9kdWxlIGlzIG5vdCBkaXJlY3RseSBleHBvcnRlZCwgYnV0IGNhbiBiZSBhY2Nlc3NlZCB0aHJvdWdoIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXM6XG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBlbnYgfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKiBjb25zb2xlLmxvZyhlbnYuYmFja2VuZHMub25ueCk7XG4gKiBgYGBcbiAqIFxuICogQG1vZHVsZSBiYWNrZW5kcy9vbm54XG4gKi9cblxuLy8gTk9URTogSW1wb3J0IG9yZGVyIG1hdHRlcnMgaGVyZS4gV2UgbmVlZCB0byBpbXBvcnQgYG9ubnhydW50aW1lLW5vZGVgIGJlZm9yZSBgb25ueHJ1bnRpbWUtd2ViYC5cbi8vIEluIGVpdGhlciBjYXNlLCB3ZSBzZWxlY3QgdGhlIGRlZmF1bHQgZXhwb3J0IGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHdlIHVzZSB0aGUgbmFtZWQgZXhwb3J0LlxuaW1wb3J0ICogYXMgT05OWF9OT0RFIGZyb20gJ29ubnhydW50aW1lLW5vZGUnO1xuaW1wb3J0ICogYXMgT05OWF9XRUIgZnJvbSAnb25ueHJ1bnRpbWUtd2ViJztcblxuLyoqIEB0eXBlIHttb2R1bGV9IFRoZSBPTk5YIHJ1bnRpbWUgbW9kdWxlLiAqL1xuZXhwb3J0IGxldCBPTk5YO1xuXG5leHBvcnQgY29uc3QgZXhlY3V0aW9uUHJvdmlkZXJzID0gW1xuICAgIC8vICd3ZWJncHUnLFxuICAgICd3YXNtJ1xuXTtcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzPy5yZWxlYXNlPy5uYW1lID09PSAnbm9kZScpIHtcbiAgICAvLyBSdW5uaW5nIGluIGEgbm9kZS1saWtlIGVudmlyb25tZW50LlxuICAgIE9OTlggPSBPTk5YX05PREUuZGVmYXVsdCA/PyBPTk5YX05PREU7XG5cbiAgICAvLyBBZGQgYGNwdWAgZXhlY3V0aW9uIHByb3ZpZGVyLCB3aXRoIGhpZ2hlciBwcmVjZWRlbmNlIHRoYXQgYHdhc21gLlxuICAgIGV4ZWN1dGlvblByb3ZpZGVycy51bnNoaWZ0KCdjcHUnKTtcblxufSBlbHNlIHtcbiAgICAvLyBSdW5uaW5nIGluIGEgYnJvd3Nlci1lbnZpcm9ubWVudFxuICAgIE9OTlggPSBPTk5YX1dFQi5kZWZhdWx0ID8/IE9OTlhfV0VCO1xuXG4gICAgLy8gU0lNRCBmb3IgV2ViQXNzZW1ibHkgZG9lcyBub3Qgb3BlcmF0ZSBjb3JyZWN0bHkgaW4gc29tZSByZWNlbnQgdmVyc2lvbnMgb2YgaU9TICgxNi40LngpLlxuICAgIC8vIEFzIGEgdGVtcG9yYXJ5IGZpeCwgd2UgZGlzYWJsZSBpdCBmb3Igbm93LlxuICAgIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvaXNzdWVzLzE1NjQ0XG4gICAgY29uc3QgaXNJT1MgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvaVAoaG9uZXxvZHxhZCkuKzE2XzQuK0FwcGxlV2ViS2l0Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGlmIChpc0lPUykge1xuICAgICAgICBPTk5YLmVudi53YXNtLnNpbWQgPSBmYWxzZTtcbiAgICB9XG59XG4iLCJcbi8qKlxuICogQGZpbGUgSGVscGVyIG1vZHVsZSBmb3IgdXNpbmcgbW9kZWwgY29uZmlncy4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgY29ycmVzcG9uZGluZ1xuICogW1B5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RvY3MvdHJhbnNmb3JtZXJzL21haW4vZW4vbW9kZWxfZG9jL2F1dG8jdHJhbnNmb3JtZXJzLkF1dG9Db25maWcpLlxuICogXG4gKiAqKkV4YW1wbGU6KiogTG9hZCBhbiBgQXV0b0NvbmZpZ2AuXG4gKiBcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IEF1dG9Db25maWcgfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKiBsZXQgY29uZmlnID0gYXdhaXQgQXV0b0NvbmZpZy5mcm9tX3ByZXRyYWluZWQoJ2JlcnQtYmFzZS11bmNhc2VkJyk7XG4gKiBjb25zb2xlLmxvZyhjb25maWcpO1xuICogLy8gUHJldHJhaW5lZENvbmZpZyB7XG4gKiAvLyAgIFwibW9kZWxfdHlwZVwiOiBcImJlcnRcIixcbiAqIC8vICAgXCJpc19lbmNvZGVyX2RlY29kZXJcIjogZmFsc2UsXG4gKiAvLyAgIFwiYXJjaGl0ZWN0dXJlc1wiOiBbXG4gKiAvLyAgICAgICBcIkJlcnRGb3JNYXNrZWRMTVwiXG4gKiAvLyAgIF0sXG4gKiAvLyAgIFwidm9jYWJfc2l6ZVwiOiAzMDUyMlxuICogLy8gICBcIm51bV9hdHRlbnRpb25faGVhZHNcIjogMTIsXG4gKiAvLyAgIFwibnVtX2hpZGRlbl9sYXllcnNcIjogMTIsXG4gKiAvLyAgIFwiaGlkZGVuX3NpemVcIjogNzY4LFxuICogLy8gICBcIm1heF9wb3NpdGlvbl9lbWJlZGRpbmdzXCI6IDUxMixcbiAqIC8vICAgLi4uXG4gKiAvLyB9XG4gKiBgYGBcbiAqIFxuICogQG1vZHVsZSBjb25maWdzXG4gKi9cblxuaW1wb3J0IHtcbiAgICBnZXRNb2RlbEpTT04sXG59IGZyb20gJy4vdXRpbHMvaHViLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3V0aWxzL2h1Yi5qcycpLlByZXRyYWluZWRPcHRpb25zfSBQcmV0cmFpbmVkT3B0aW9uc1xuICovXG5cblxuLyoqXG4gKiBMb2FkcyBhIGNvbmZpZyBmcm9tIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCBUaGUgcGF0aCB0byB0aGUgY29uZmlnIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7UHJldHJhaW5lZE9wdGlvbnN9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciBsb2FkaW5nIHRoZSBjb25maWcuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxvYWRlZCBjb25maWcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRDb25maWcocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW5mbyA9IGF3YWl0IGdldE1vZGVsSlNPTihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ2NvbmZpZy5qc29uJywgdHJ1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGNvbmZpZ3VyYXRpb24gY2xhc3Nlcy4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgY29ycmVzcG9uZGluZ1xuICogW1B5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RvY3MvdHJhbnNmb3JtZXJzL21haW4vZW4vbWFpbl9jbGFzc2VzL2NvbmZpZ3VyYXRpb24jdHJhbnNmb3JtZXJzLlByZXRyYWluZWRDb25maWcpLlxuICovXG5leHBvcnQgY2xhc3MgUHJldHJhaW5lZENvbmZpZyB7XG4gICAgLy8gTk9URTogVHlwbyBpbiBvcmlnaW5hbFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFByZVRyYWluZWRUb2tlbml6ZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ0pTT04gVGhlIEpTT04gb2YgdGhlIGNvbmZpZy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWdKU09OKSB7XG4gICAgICAgIHRoaXMubW9kZWxfdHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNfZW5jb2Rlcl9kZWNvZGVyID0gZmFsc2U7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWdKU09OKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHByZS10cmFpbmVkIGNvbmZpZyBmcm9tIHRoZSBnaXZlbiBgcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGhgLiBcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGggVGhlIHBhdGggdG8gdGhlIHByZS10cmFpbmVkIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0ge1ByZXRyYWluZWRPcHRpb25zfSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgY29uZmlnLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGNvbmZpZy5qc29uIGlzIG5vdCBmb3VuZCBpbiB0aGUgYHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoYC5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcmV0cmFpbmVkQ29uZmlnPn0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcmV0cmFpbmVkQ29uZmlnYCBjbGFzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCB7XG4gICAgICAgIHByb2dyZXNzX2NhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgY29uZmlnID0gbnVsbCxcbiAgICAgICAgY2FjaGVfZGlyID0gbnVsbCxcbiAgICAgICAgbG9jYWxfZmlsZXNfb25seSA9IGZhbHNlLFxuICAgICAgICByZXZpc2lvbiA9ICdtYWluJyxcbiAgICB9ID0ge30pIHtcblxuICAgICAgICBsZXQgZGF0YSA9IGNvbmZpZyA/PyBhd2FpdCBsb2FkQ29uZmlnKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCB7XG4gICAgICAgICAgICBwcm9ncmVzc19jYWxsYmFjayxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGNhY2hlX2RpcixcbiAgICAgICAgICAgIGxvY2FsX2ZpbGVzX29ubHksXG4gICAgICAgICAgICByZXZpc2lvbixcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGRhdGEpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIGNvbmZpZ3Mgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgY29uZmlnID0gYXdhaXQgQXV0b0NvbmZpZy5mcm9tX3ByZXRyYWluZWQoJ2JlcnQtYmFzZS11bmNhc2VkJyk7IFxuICovXG5leHBvcnQgY2xhc3MgQXV0b0NvbmZpZyB7XG4gICAgLyoqIEB0eXBlIHtQcmV0cmFpbmVkQ29uZmlnLmZyb21fcHJldHJhaW5lZH0gKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbV9wcmV0cmFpbmVkKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIFByZXRyYWluZWRDb25maWcuZnJvbV9wcmV0cmFpbmVkKC4uLmFyZ3MpO1xuICAgIH1cbn1cbiIsIi8qKlxuICogQGZpbGUgTW9kdWxlIHVzZWQgdG8gY29uZmlndXJlIFRyYW5zZm9ybWVycy5qcy5cbiAqIFxuICogKipFeGFtcGxlOioqIERpc2FibGUgcmVtb3RlIG1vZGVscy5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IGVudiB9IGZyb20gJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJztcbiAqIGVudi5hbGxvd1JlbW90ZU1vZGVscyA9IGZhbHNlO1xuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBTZXQgbG9jYWwgbW9kZWwgcGF0aC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IGVudiB9IGZyb20gJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJztcbiAqIGVudi5sb2NhbE1vZGVsUGF0aCA9ICcvcGF0aC90by9sb2NhbC9tb2RlbHMvJztcbiAqIGBgYFxuICogXG4gKiAqKkV4YW1wbGU6KiogU2V0IGNhY2hlIGRpcmVjdG9yeS5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IGVudiB9IGZyb20gJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJztcbiAqIGVudi5jYWNoZURpciA9ICcvcGF0aC90by9jYWNoZS9kaXJlY3RvcnkvJztcbiAqIGBgYFxuICogXG4gKiBAbW9kdWxlIGVudlxuICovXG5cbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB1cmwgZnJvbSAndXJsJztcblxuaW1wb3J0IHsgT05OWCB9IGZyb20gJy4vYmFja2VuZHMvb25ueC5qcyc7XG5jb25zdCB7IGVudjogb25ueF9lbnYgfSA9IE9OTlg7XG5cbmNvbnN0IFZFUlNJT04gPSAnMi41LjAnO1xuXG4vLyBDaGVjayBpZiB2YXJpb3VzIEFQSXMgYXJlIGF2YWlsYWJsZSAoZGVwZW5kcyBvbiBlbnZpcm9ubWVudClcbmNvbnN0IFdFQl9DQUNIRV9BVkFJTEFCTEUgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2NhY2hlcycgaW4gc2VsZjtcbmNvbnN0IEZTX0FWQUlMQUJMRSA9ICFpc0VtcHR5KGZzKTsgLy8gY2hlY2sgaWYgZmlsZSBzeXN0ZW0gaXMgYXZhaWxhYmxlXG5jb25zdCBQQVRIX0FWQUlMQUJMRSA9ICFpc0VtcHR5KHBhdGgpOyAvLyBjaGVjayBpZiBwYXRoIGlzIGF2YWlsYWJsZVxuXG5jb25zdCBSVU5OSU5HX0xPQ0FMTFkgPSBGU19BVkFJTEFCTEUgJiYgUEFUSF9BVkFJTEFCTEU7XG5cbmNvbnN0IF9fZGlybmFtZSA9IFJVTk5JTkdfTE9DQUxMWVxuICAgID8gcGF0aC5kaXJuYW1lKHBhdGguZGlybmFtZSh1cmwuZmlsZVVSTFRvUGF0aChpbXBvcnQubWV0YS51cmwpKSlcbiAgICA6ICcuLyc7XG5cbi8vIE9ubHkgdXNlZCBmb3IgZW52aXJvbm1lbnRzIHdpdGggYWNjZXNzIHRvIGZpbGUgc3lzdGVtXG5jb25zdCBERUZBVUxUX0NBQ0hFX0RJUiA9IFJVTk5JTkdfTE9DQUxMWVxuICAgID8gcGF0aC5qb2luKF9fZGlybmFtZSwgJy8uY2FjaGUvJylcbiAgICA6IG51bGw7XG5cbi8vIFNldCBsb2NhbCBtb2RlbCBwYXRoLCBiYXNlZCBvbiBhdmFpbGFibGUgQVBJc1xuY29uc3QgREVGQVVMVF9MT0NBTF9NT0RFTF9QQVRIID0gJy9tb2RlbHMvJztcbmNvbnN0IGxvY2FsTW9kZWxQYXRoID0gUlVOTklOR19MT0NBTExZXG4gICAgPyBwYXRoLmpvaW4oX19kaXJuYW1lLCBERUZBVUxUX0xPQ0FMX01PREVMX1BBVEgpXG4gICAgOiBERUZBVUxUX0xPQ0FMX01PREVMX1BBVEg7XG5cbi8vIFNldCBwYXRoIHRvIHdhc20gZmlsZXMuIFRoaXMgaXMgbmVlZGVkIHdoZW4gcnVubmluZyBpbiBhIHdlYiB3b3JrZXIuXG4vLyBodHRwczovL29ubnhydW50aW1lLmFpL2RvY3MvYXBpL2pzL2ludGVyZmFjZXMvRW52LldlYkFzc2VtYmx5RmxhZ3MuaHRtbCN3YXNtUGF0aHNcbi8vIFdlIHVzZSByZW1vdGUgd2FzbSBmaWxlcyBieSBkZWZhdWx0IHRvIG1ha2UgaXQgZWFzaWVyIGZvciBuZXdlciB1c2Vycy5cbi8vIEluIHByYWN0aWNlLCB1c2VycyBzaG91bGQgcHJvYmFibHkgc2VsZi1ob3N0IHRoZSBuZWNlc3NhcnkgLndhc20gZmlsZXMuXG5vbm54X2Vudi53YXNtLndhc21QYXRocyA9IFJVTk5JTkdfTE9DQUxMWVxuICAgID8gcGF0aC5qb2luKF9fZGlybmFtZSwgJy9kaXN0LycpXG4gICAgOiBgaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AeGVub3ZhL3RyYW5zZm9ybWVyc0Ake1ZFUlNJT059L2Rpc3QvYDtcblxuXG4vKipcbiAqIEdsb2JhbCB2YXJpYWJsZSB1c2VkIHRvIGNvbnRyb2wgZXhlY3V0aW9uLiBUaGlzIHByb3ZpZGVzIHVzZXJzIGEgc2ltcGxlIHdheSB0byBjb25maWd1cmUgVHJhbnNmb3JtZXJzLmpzLlxuICogQHByb3BlcnR5IHtPYmplY3R9IGJhY2tlbmRzIEV4cG9zZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb2YgZGlmZmVyZW50IGJhY2tlbmRzLFxuICogYWxsb3dpbmcgdXNlcnMgdG8gc2V0IHRoZXNlIHZhcmlhYmxlcyBpZiB0aGV5IHdhbnQgdG8uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gX19kaXJuYW1lIERpcmVjdG9yeSBuYW1lIG9mIG1vZHVsZS4gVXNlZnVsIGZvciByZXNvbHZpbmcgbG9jYWwgcGF0aHMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmVyc2lvbiBUaGlzIHZlcnNpb24gb2YgVHJhbnNmb3JtZXJzLmpzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBhbGxvd1JlbW90ZU1vZGVscyBXaGV0aGVyIHRvIGFsbG93IGxvYWRpbmcgb2YgcmVtb3RlIGZpbGVzLCBkZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBJZiBzZXQgdG8gYGZhbHNlYCwgaXQgd2lsbCBoYXZlIHRoZSBzYW1lIGVmZmVjdCBhcyBzZXR0aW5nIGBsb2NhbF9maWxlc19vbmx5PXRydWVgIHdoZW4gbG9hZGluZyBwaXBlbGluZXMsIG1vZGVscywgdG9rZW5pemVycywgcHJvY2Vzc29ycywgZXRjLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlbW90ZUhvc3QgSG9zdCBVUkwgdG8gbG9hZCBtb2RlbHMgZnJvbS4gRGVmYXVsdHMgdG8gdGhlIEh1Z2dpbmcgRmFjZSBIdWIuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVtb3RlUGF0aFRlbXBsYXRlIFBhdGggdGVtcGxhdGUgdG8gZmlsbCBpbiBhbmQgYXBwZW5kIHRvIGByZW1vdGVIb3N0YCB3aGVuIGxvYWRpbmcgbW9kZWxzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBhbGxvd0xvY2FsTW9kZWxzIFdoZXRoZXIgdG8gYWxsb3cgbG9hZGluZyBvZiBsb2NhbCBmaWxlcywgZGVmYXVsdHMgdG8gYHRydWVgLlxuICogSWYgc2V0IHRvIGBmYWxzZWAsIGl0IHdpbGwgc2tpcCB0aGUgbG9jYWwgZmlsZSBjaGVjayBhbmQgdHJ5IHRvIGxvYWQgdGhlIG1vZGVsIGZyb20gdGhlIHJlbW90ZSBob3N0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxvY2FsTW9kZWxQYXRoIFBhdGggdG8gbG9hZCBsb2NhbCBtb2RlbHMgZnJvbS4gRGVmYXVsdHMgdG8gYC9tb2RlbHMvYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdXNlRlMgV2hldGhlciB0byB1c2UgdGhlIGZpbGUgc3lzdGVtIHRvIGxvYWQgZmlsZXMuIEJ5IGRlZmF1bHQsIGl0IGlzIGB0cnVlYCBpZiBhdmFpbGFibGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVzZUJyb3dzZXJDYWNoZSBXaGV0aGVyIHRvIHVzZSBDYWNoZSBBUEkgdG8gY2FjaGUgbW9kZWxzLiBCeSBkZWZhdWx0LCBpdCBpcyBgdHJ1ZWAgaWYgYXZhaWxhYmxlLlxuICogQHByb3BlcnR5IHtib29sZWFufSB1c2VGU0NhY2hlIFdoZXRoZXIgdG8gdXNlIHRoZSBmaWxlIHN5c3RlbSB0byBjYWNoZSBmaWxlcy4gQnkgZGVmYXVsdCwgaXQgaXMgYHRydWVgIGlmIGF2YWlsYWJsZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjYWNoZURpciBUaGUgZGlyZWN0b3J5IHRvIHVzZSBmb3IgY2FjaGluZyBmaWxlcyB3aXRoIHRoZSBmaWxlIHN5c3RlbS4gQnkgZGVmYXVsdCwgaXQgaXMgYC4vLmNhY2hlYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdXNlQ3VzdG9tQ2FjaGUgV2hldGhlciB0byB1c2UgYSBjdXN0b20gY2FjaGUgc3lzdGVtIChkZWZpbmVkIGJ5IGBjdXN0b21DYWNoZWApLCBkZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtPYmplY3R9IGN1c3RvbUNhY2hlIFRoZSBjdXN0b20gY2FjaGUgdG8gdXNlLiBEZWZhdWx0cyB0byBgbnVsbGAuIE5vdGU6IHRoaXMgbXVzdCBiZSBhbiBvYmplY3Qgd2hpY2hcbiAqIGltcGxlbWVudHMgdGhlIGBtYXRjaGAgYW5kIGBwdXRgIGZ1bmN0aW9ucyBvZiB0aGUgV2ViIENhY2hlIEFQSS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FjaGVcbiAqL1xuZXhwb3J0IGNvbnN0IGVudiA9IHtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vIEJhY2tlbmRzIHNldHRpbmdzIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBiYWNrZW5kczoge1xuICAgICAgICAvLyBvbm54cnVudGltZS13ZWIvb25ueHJ1bnRpbWUtbm9kZVxuICAgICAgICBvbm54OiBvbm54X2VudixcblxuICAgICAgICAvLyBUZW5zb3JGbG93LmpzXG4gICAgICAgIHRmanM6IHt9LFxuICAgIH0sXG5cbiAgICBfX2Rpcm5hbWUsXG4gICAgdmVyc2lvbjogVkVSU0lPTixcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8gTW9kZWwgc2V0dGluZ3MgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGFsbG93UmVtb3RlTW9kZWxzOiB0cnVlLFxuICAgIHJlbW90ZUhvc3Q6ICdodHRwczovL2h1Z2dpbmdmYWNlLmNvLycsXG4gICAgcmVtb3RlUGF0aFRlbXBsYXRlOiAne21vZGVsfS9yZXNvbHZlL3tyZXZpc2lvbn0vJyxcblxuICAgIGFsbG93TG9jYWxNb2RlbHM6IHRydWUsXG4gICAgbG9jYWxNb2RlbFBhdGg6IGxvY2FsTW9kZWxQYXRoLFxuICAgIHVzZUZTOiBGU19BVkFJTEFCTEUsXG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vIENhY2hlIHNldHRpbmdzIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICB1c2VCcm93c2VyQ2FjaGU6IFdFQl9DQUNIRV9BVkFJTEFCTEUsXG5cbiAgICB1c2VGU0NhY2hlOiBGU19BVkFJTEFCTEUsXG4gICAgY2FjaGVEaXI6IERFRkFVTFRfQ0FDSEVfRElSLFxuXG4gICAgdXNlQ3VzdG9tQ2FjaGU6IGZhbHNlLFxuICAgIGN1c3RvbUNhY2hlOiBudWxsLFxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5cbiIsIlxuLyoqXG4gKiBAZmlsZSBEZWZpbml0aW9ucyBvZiBhbGwgbW9kZWxzIGF2YWlsYWJsZSBpbiBUcmFuc2Zvcm1lcnMuanMuXG4gKiBcbiAqICoqRXhhbXBsZToqKiBMb2FkIGFuZCBydW4gYW4gYEF1dG9Nb2RlbGAuXG4gKiBcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IEF1dG9Nb2RlbCwgQXV0b1Rva2VuaXplciB9IGZyb20gJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJztcbiAqXG4gKiBsZXQgdG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQoJ1hlbm92YS9iZXJ0LWJhc2UtdW5jYXNlZCcpO1xuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsLmZyb21fcHJldHJhaW5lZCgnWGVub3ZhL2JlcnQtYmFzZS11bmNhc2VkJyk7XG4gKlxuICogbGV0IGlucHV0cyA9IGF3YWl0IHRva2VuaXplcignSSBsb3ZlIHRyYW5zZm9ybWVycyEnKTtcbiAqIGxldCB7IGxvZ2l0cyB9ID0gYXdhaXQgbW9kZWwoaW5wdXRzKTtcbiAqIC8vIFRlbnNvciB7XG4gKiAvLyAgICAgZGF0YTogRmxvYXQzMkFycmF5KDE4MzEzMikgWy03LjExNzQ0MzA4NDcxNjc5NywgLTcuMTA3ODEyODgxNDY5NzI3LCAtNy4wOTIxMDQ5MTE4MDQxOTksIC4uLl1cbiAqIC8vICAgICBkaW1zOiAoMykgWzEsIDYsIDMwNTIyXSxcbiAqIC8vICAgICB0eXBlOiBcImZsb2F0MzJcIixcbiAqIC8vICAgICBzaXplOiAxODMxMzIsXG4gKiAvLyB9XG4gKiBgYGBcbiAqIFxuICogV2UgYWxzbyBwcm92aWRlIG90aGVyIGBBdXRvTW9kZWxgcyAobGlzdGVkIGJlbG93KSwgd2hpY2ggeW91IGNhbiB1c2UgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBQeXRob24gbGlicmFyeS4gRm9yIGV4YW1wbGU6XG4gKiBcbiAqICoqRXhhbXBsZToqKiBMb2FkIGFuZCBydW4gYSBgQXV0b01vZGVsRm9yU2VxMlNlcUxNYC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IEF1dG9Nb2RlbEZvclNlcTJTZXFMTSwgQXV0b1Rva2VuaXplciB9IGZyb20gJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJztcbiAqIFxuICogbGV0IHRva2VuaXplciA9IGF3YWl0IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKCdYZW5vdmEvdDUtc21hbGwnKTtcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbEZvclNlcTJTZXFMTS5mcm9tX3ByZXRyYWluZWQoJ1hlbm92YS90NS1zbWFsbCcpO1xuICpcbiAqIGxldCB7IGlucHV0X2lkcyB9ID0gYXdhaXQgdG9rZW5pemVyKCd0cmFuc2xhdGUgRW5nbGlzaCB0byBHZXJtYW46IEkgbG92ZSB0cmFuc2Zvcm1lcnMhJyk7XG4gKiBsZXQgb3V0cHV0cyA9IGF3YWl0IG1vZGVsLmdlbmVyYXRlKGlucHV0X2lkcyk7XG4gKiBsZXQgZGVjb2RlZCA9IHRva2VuaXplci5kZWNvZGUob3V0cHV0c1swXSwgeyBza2lwX3NwZWNpYWxfdG9rZW5zOiB0cnVlIH0pO1xuICogLy8gJ0ljaCBsaWViZSBUcmFuc2Zvcm1hdG9yZW4hJ1xuICogYGBgXG4gKiBcbiAqIEBtb2R1bGUgbW9kZWxzXG4gKi9cblxuaW1wb3J0IHtcbiAgICBBdXRvQ29uZmlnLFxufSBmcm9tICcuL2NvbmZpZ3MuanMnO1xuXG5pbXBvcnQge1xuICAgIENhbGxhYmxlLFxuICAgIGlzSW50ZWdyYWxOdW1iZXIsXG4gICAgaXNUeXBlZEFycmF5LFxuICAgIG1lcmdlQXJyYXlzLFxufSBmcm9tICcuL3V0aWxzL2NvcmUuanMnO1xuXG5pbXBvcnQge1xuICAgIGdldE1vZGVsRmlsZSxcbiAgICBnZXRNb2RlbEpTT04sXG59IGZyb20gJy4vdXRpbHMvaHViLmpzJztcblxuaW1wb3J0IHtcbiAgICBMb2dpdHNQcm9jZXNzb3JMaXN0LFxuICAgIEdlbmVyYXRpb25Db25maWcsXG4gICAgRm9yY2VUb2tlbnNMb2dpdHNQcm9jZXNzb3IsXG4gICAgRm9yY2VkQk9TVG9rZW5Mb2dpdHNQcm9jZXNzb3IsXG4gICAgRm9yY2VkRU9TVG9rZW5Mb2dpdHNQcm9jZXNzb3IsXG4gICAgU3VwcHJlc3NUb2tlbnNBdEJlZ2luTG9naXRzUHJvY2Vzc29yLFxuICAgIFdoaXNwZXJUaW1lU3RhbXBMb2dpdHNQcm9jZXNzb3IsXG4gICAgTm9SZXBlYXROR3JhbUxvZ2l0c1Byb2Nlc3NvcixcbiAgICBSZXBldGl0aW9uUGVuYWx0eUxvZ2l0c1Byb2Nlc3NvcixcblxuICAgIFNhbXBsZXIsXG59IGZyb20gJy4vdXRpbHMvZ2VuZXJhdGlvbi5qcyc7XG5cbmltcG9ydCB7XG4gICAgY2F0LFxuICAgIGR5bmFtaWNUaW1lV2FycGluZyxcbiAgICBtZWFuLFxuICAgIHN0YWNrLFxuICAgIHN0ZF9tZWFuLFxuICAgIFRlbnNvcixcbn0gZnJvbSAnLi91dGlscy90ZW5zb3IuanMnO1xuXG5pbXBvcnQgeyBleGVjdXRpb25Qcm92aWRlcnMsIE9OTlggfSBmcm9tICcuL2JhY2tlbmRzL29ubnguanMnO1xuaW1wb3J0IHsgbWVkaWFuRmlsdGVyLCByb3VuZCB9IGZyb20gJy4vdHJhbnNmb3JtZXJzLmpzJztcbmNvbnN0IHsgSW5mZXJlbmNlU2Vzc2lvbiwgVGVuc29yOiBPTk5YVGVuc29yIH0gPSBPTk5YO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdXRpbHMvaHViLmpzJykuUHJldHJhaW5lZE9wdGlvbnN9IFByZXRyYWluZWRPcHRpb25zXG4gKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTW9kZWwgdHlwZXM6IHVzZWQgaW50ZXJuYWxseVxuY2xhc3MgTW9kZWxUeXBlIHsgfTtcblxuLy8gRWl0aGVyIGVuY29kZXItb25seSBvciBlbmNvZGVyLWRlY29kZXIgKGFuZCB3aWxsIGJlIGRlY2lkZWQgYnkgYG1vZGVsLmNvbmZpZy5pc19lbmNvZGVyX2RlY29kZXJgKVxuY2xhc3MgRW5jb2Rlck9ubHlNb2RlbFR5cGUgZXh0ZW5kcyBNb2RlbFR5cGUgeyB9O1xuY2xhc3MgRW5jb2RlckRlY29kZXJNb2RlbFR5cGUgZXh0ZW5kcyBNb2RlbFR5cGUgeyB9O1xuY2xhc3MgU2VxMlNlcU1vZGVsVHlwZSBleHRlbmRzIEVuY29kZXJEZWNvZGVyTW9kZWxUeXBlIHsgfTtcbmNsYXNzIERlY29kZXJPbmx5TW9kZWxUeXBlIGV4dGVuZHMgTW9kZWxUeXBlIHsgfTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlciBmdW5jdGlvbnNcblxuLy8gV2lsbCBiZSBwb3B1bGF0ZWQgZnVsbHkgbGF0ZXJcbmNvbnN0IE1PREVMX1RZUEVfTUFQUElORyA9IG5ldyBNYXAoW1xuICAgIFsnQ0xJUFRleHRNb2RlbFdpdGhQcm9qZWN0aW9uJywgRW5jb2Rlck9ubHlNb2RlbFR5cGVdLFxuICAgIFsnQ0xJUFZpc2lvbk1vZGVsV2l0aFByb2plY3Rpb24nLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG5dKTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGBmb3J3YXJkYCBtZXRob2QgdG8gcnVuIGZvciBhIHNwZWNpZmljIG1vZGVsLlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgVGhlIGNhbGxpbmcgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gYmUgc2VudCB0byB0aGUgbW9kZWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSBtb2RlbCBvdXRwdXRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZm9yd2FyZChzZWxmLCBtb2RlbF9pbnB1dHMpIHtcbiAgICBpZiAoTU9ERUxfVFlQRV9NQVBQSU5HLmdldChzZWxmLmNvbnN0cnVjdG9yLm5hbWUpID09PSBEZWNvZGVyT25seU1vZGVsVHlwZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZGVjb2RlckZvcndhcmQoc2VsZiwgbW9kZWxfaW5wdXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXdhaXQgZW5jb2RlckZvcndhcmQoc2VsZiwgbW9kZWxfaW5wdXRzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBJbmZlcmVuY2VTZXNzaW9uIHVzaW5nIGEgbW9kZWwgZmlsZSBsb2NhdGVkIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCBUaGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIG1vZGVsIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZU5hbWUgVGhlIG5hbWUgb2YgdGhlIG1vZGVsIGZpbGUuXG4gKiBAcGFyYW0ge1ByZXRyYWluZWRPcHRpb25zfSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgbW9kZWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiBjb25zdHJ1Y3RTZXNzaW9uKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBmaWxlTmFtZSwgb3B0aW9ucykge1xuICAgIC8vIFRPRE8gYWRkIG9wdGlvbiBmb3IgdXNlciB0byBmb3JjZSBzcGVjaWZ5IHRoZWlyIGRlc2lyZWQgZXhlY3V0aW9uIHByb3ZpZGVyXG4gICAgbGV0IG1vZGVsRmlsZU5hbWUgPSBgb25ueC8ke2ZpbGVOYW1lfSR7b3B0aW9ucy5xdWFudGl6ZWQgPyAnX3F1YW50aXplZCcgOiAnJ30ub25ueGA7XG4gICAgbGV0IGJ1ZmZlciA9IGF3YWl0IGdldE1vZGVsRmlsZShwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgbW9kZWxGaWxlTmFtZSwgdHJ1ZSwgb3B0aW9ucyk7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUoYnVmZmVyLCB7XG4gICAgICAgICAgICBleGVjdXRpb25Qcm92aWRlcnMsXG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZiB0aGUgZXhlY3V0aW9uIHByb3ZpZGVkIHdhcyBvbmx5IHdhc20sIHRocm93IHRoZSBlcnJvclxuICAgICAgICBpZiAoZXhlY3V0aW9uUHJvdmlkZXJzLmxlbmd0aCA9PT0gMSAmJiBleGVjdXRpb25Qcm92aWRlcnNbMF0gPT09ICd3YXNtJykge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS53YXJuKGVycik7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgbW9kZWwgY29uc3RydWN0aW9uIChtb3N0IGxpa2VseSBhIG1pc3Npbmcgb3BlcmF0aW9uKS4gJyArXG4gICAgICAgICAgICAnVXNpbmcgYHdhc21gIGFzIGEgZmFsbGJhY2suICdcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gYXdhaXQgSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUoYnVmZmVyLCB7XG4gICAgICAgICAgICBleGVjdXRpb25Qcm92aWRlcnM6IFsnd2FzbSddXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBtb2RlbCBpbnB1dHNcbiAqIEBwYXJhbSB7SW5mZXJlbmNlU2Vzc2lvbn0gc2Vzc2lvbiBUaGUgSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QgdGhhdCB3aWxsIGJlIHJ1bi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dHMgVGhlIGlucHV0cyB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjaGVja2VkIGlucHV0cy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbnkgaW5wdXRzIGFyZSBtaXNzaW5nLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVJbnB1dHMoc2Vzc2lvbiwgaW5wdXRzKSB7XG4gICAgLy8gTk9URTogT25seSBjcmVhdGUgYSBzaGFsbG93IGNvcHlcbiAgICBjb25zdCBjaGVja2VkSW5wdXRzID0ge307XG4gICAgY29uc3QgbWlzc2luZ0lucHV0cyA9IFtdO1xuICAgIGZvciAobGV0IGlucHV0TmFtZSBvZiBzZXNzaW9uLmlucHV0TmFtZXMpIHtcbiAgICAgICAgaWYgKGlucHV0c1tpbnB1dE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1pc3NpbmdJbnB1dHMucHVzaChpbnB1dE5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tlZElucHV0c1tpbnB1dE5hbWVdID0gaW5wdXRzW2lucHV0TmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pc3NpbmdJbnB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIG1vZGVsIGV4ZWN1dGlvbjogXCJNaXNzaW5nIHRoZSBmb2xsb3dpbmcgaW5wdXRzOiAke21pc3NpbmdJbnB1dHMuam9pbignLCAnKX0uYCk7XG4gICAgfVxuXG4gICAgY29uc3QgbnVtSW5wdXRzUHJvdmlkZWQgPSBPYmplY3Qua2V5cyhpbnB1dHMpLmxlbmd0aDtcbiAgICBjb25zdCBudW1JbnB1dHNOZWVkZWQgPSBzZXNzaW9uLmlucHV0TmFtZXMubGVuZ3RoO1xuICAgIGlmIChudW1JbnB1dHNQcm92aWRlZCA+IG51bUlucHV0c05lZWRlZCkge1xuICAgICAgICAvLyBObyBtaXNzaW5nIGlucHV0cywgYnV0IHRvbyBtYW55IGlucHV0cyB3ZXJlIHByb3ZpZGVkLlxuICAgICAgICAvLyBXYXJuIHRoZSB1c2VyIGFuZCBpZ25vcmUgdGhlIGV4dHJhIGlucHV0cy5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBPYmplY3Qua2V5cyhpbnB1dHMpLmZpbHRlcihpbnB1dE5hbWUgPT4gIXNlc3Npb24uaW5wdXROYW1lcy5pbmNsdWRlcyhpbnB1dE5hbWUpKTtcbiAgICAgICAgY29uc29sZS53YXJuKGBXQVJOSU5HOiBUb28gbWFueSBpbnB1dHMgd2VyZSBwcm92aWRlZCAoJHtudW1JbnB1dHNQcm92aWRlZH0gPiAke251bUlucHV0c05lZWRlZH0pLiBUaGUgZm9sbG93aW5nIGlucHV0cyB3aWxsIGJlIGlnbm9yZWQ6IFwiJHtpZ25vcmVkLmpvaW4oJywgJyl9XCIuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoZWNrZWRJbnB1dHM7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYW4gSW5mZXJlbmNlU2Vzc2lvbiB1c2luZyB0aGUgc3BlY2lmaWVkIGlucHV0cy5cbiAqIE5PVEU6IGBpbnB1dHNgIG11c3QgY29udGFpbiBhdCBsZWFzdCB0aGUgaW5wdXQgbmFtZXMgb2YgdGhlIG1vZGVsLlxuICogIC0gSWYgYWRkaXRpb25hbCBpbnB1dHMgYXJlIHBhc3NlZCwgdGhleSB3aWxsIGJlIGlnbm9yZWQuXG4gKiAgLSBJZiBpbnB1dHMgYXJlIG1pc3NpbmcsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICogXG4gKiBAcGFyYW0ge0luZmVyZW5jZVNlc3Npb259IHNlc3Npb24gVGhlIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0IHRvIHJ1bi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dHMgQW4gb2JqZWN0IHRoYXQgbWFwcyBpbnB1dCBuYW1lcyB0byBpbnB1dCB0ZW5zb3JzLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gb2JqZWN0IHRoYXQgbWFwcyBvdXRwdXQgbmFtZXMgdG8gb3V0cHV0IHRlbnNvcnMuXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiBzZXNzaW9uUnVuKHNlc3Npb24sIGlucHV0cykge1xuICAgIGNvbnN0IGNoZWNrZWRJbnB1dHMgPSBhd2FpdCB2YWxpZGF0ZUlucHV0cyhzZXNzaW9uLCBpbnB1dHMpO1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBhd2FpdCBzZXNzaW9uLnJ1bihjaGVja2VkSW5wdXRzKTtcbiAgICAgICAgb3V0cHV0ID0gcmVwbGFjZVRlbnNvcnMob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFRoaXMgdXN1YWxseSBvY2N1cnMgd2hlbiB0aGUgaW5wdXRzIGFyZSBvZiB0aGUgd3JvbmcgdHlwZS5cbiAgICAgICAgY29uc29sZS5lcnJvcihgQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIG1vZGVsIGV4ZWN1dGlvbjogXCIke2V9XCIuYCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0lucHV0cyBnaXZlbiB0byBtb2RlbDonLCBjaGVja2VkSW5wdXRzKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwbGFjZXMgT05OWCBUZW5zb3Igb2JqZWN0cyB3aXRoIGN1c3RvbSBUZW5zb3Igb2JqZWN0cyB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZnVuY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHJlcGxhY2UgdGVuc29yIG9iamVjdHMgaW4uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgb2JqZWN0IHdpdGggdGVuc29yIG9iamVjdHMgcmVwbGFjZWQgYnkgY3VzdG9tIFRlbnNvciBvYmplY3RzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVwbGFjZVRlbnNvcnMob2JqKSB7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9ialtwcm9wXSBpbnN0YW5jZW9mIE9OTlhUZW5zb3IpIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IG5ldyBUZW5zb3Iob2JqW3Byb3BdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqW3Byb3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmVwbGFjZVRlbnNvcnMob2JqW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb3IgVGVuc29yIG9mIGludGVnZXJzIHRvIGFuIGludDY0IFRlbnNvci5cbiAqIEBwYXJhbSB7QXJyYXl8VGVuc29yfSBpdGVtcyBUaGUgaW5wdXQgaW50ZWdlcnMgdG8gYmUgY29udmVydGVkLlxuICogQHJldHVybnMge1RlbnNvcn0gVGhlIGludDY0IFRlbnNvciB3aXRoIHRoZSBjb252ZXJ0ZWQgdmFsdWVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBpbnB1dCBhcnJheSBpcyBlbXB0eSBvciB0aGUgaW5wdXQgaXMgYSBiYXRjaGVkIFRlbnNvciBhbmQgbm90IGFsbCBzZXF1ZW5jZXMgaGF2ZSB0aGUgc2FtZSBsZW5ndGguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0b0k2NFRlbnNvcihpdGVtcykge1xuICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICAgIC8vIGl0ZW1zIGlzIGFuIGFycmF5XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIml0ZW1zIG11c3QgYmUgbm9uLWVtcHR5XCIpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zWzBdKSkge1xuICAgICAgICAvLyBiYXRjaGVkXG4gICAgICAgIGlmIChpdGVtcy5zb21lKHggPT4geC5sZW5ndGggIT09IGl0ZW1zWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGNyZWF0ZSB0ZW5zb3IsIHlvdSBzaG91bGQgcHJvYmFibHkgYWN0aXZhdGUgdHJ1bmNhdGlvbiBhbmQvb3IgcGFkZGluZyB3aXRoICdwYWRkaW5nPVRydWUnIGFuZC9vciAndHJ1bmNhdGlvbj1UcnVlJyB0byBoYXZlIGJhdGNoZWQgdGVuc29ycyB3aXRoIHRoZSBzYW1lIGxlbmd0aC5cIilcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKCdpbnQ2NCcsXG4gICAgICAgICAgICBCaWdJbnQ2NEFycmF5LmZyb20oaXRlbXMuZmxhdCgpLm1hcCh4ID0+IEJpZ0ludCh4KSkpLFxuICAgICAgICAgICAgW2l0ZW1zLmxlbmd0aCwgaXRlbXNbMF0ubGVuZ3RoXVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vZmxhdFxuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcignaW50NjQnLFxuICAgICAgICAgICAgQmlnSW50NjRBcnJheS5mcm9tKGl0ZW1zLm1hcCh4ID0+IEJpZ0ludCh4KSkpLFxuICAgICAgICAgICAgWzEsIGl0ZW1zLmxlbmd0aF1cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogUHJlcGFyZXMgYW4gYXR0ZW50aW9uIG1hc2sgZm9yIGEgc2VxdWVuY2Ugb2YgdG9rZW5zIGJhc2VkIG9uIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIFRoZSBjYWxsaW5nIG9iamVjdCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7VGVuc29yfSB0b2tlbnMgVGhlIGlucHV0IHRva2Vucy5cbiAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBhdHRlbnRpb24gbWFzayB0ZW5zb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwcmVwYXJlQXR0ZW50aW9uTWFzayhzZWxmLCB0b2tlbnMpIHtcblxuICAgIC8vIFByZXBhcmUgYXR0ZW50aW9uIG1hc2tcbiAgICBsZXQgcGFkX3Rva2VuX2lkID0gc2VsZi5jb25maWcucGFkX3Rva2VuX2lkID8/IG51bGw7XG4gICAgbGV0IGVvc190b2tlbl9pZCA9IHNlbGYuY29uZmlnLmVvc190b2tlbl9pZCA/PyBudWxsO1xuICAgIGlmIChpc0ludGVncmFsTnVtYmVyKGVvc190b2tlbl9pZCkpIHtcbiAgICAgICAgZW9zX3Rva2VuX2lkID0gW2Vvc190b2tlbl9pZF07XG4gICAgfVxuXG4gICAgbGV0IGlzX3BhZF90b2tlbl9pbl9pbnB1dHMgPSB0b2tlbnMuaW5kZXhPZihwYWRfdG9rZW5faWQpICE9PSAtMTtcbiAgICBsZXQgaXNfcGFkX3Rva2VuX25vdF9lcXVhbF90b19lb3NfdG9rZW5faWQgPSAoZW9zX3Rva2VuX2lkID09PSBudWxsKSB8fCAhZW9zX3Rva2VuX2lkLmluY2x1ZGVzKHBhZF90b2tlbl9pZClcblxuICAgIGlmIChpc19wYWRfdG9rZW5faW5faW5wdXRzICYmIGlzX3BhZF90b2tlbl9ub3RfZXF1YWxfdG9fZW9zX3Rva2VuX2lkKSB7XG4gICAgICAgIGxldCBkYXRhID0gQmlnSW50NjRBcnJheS5mcm9tKFxuICAgICAgICAgICAgLy8gTm90ZTogIT0gc28gdGhhdCBpbnQgbWF0Y2hlcyBiaWdpbnRcbiAgICAgICAgICAgIHRva2Vucy5kYXRhLm1hcCh4ID0+IHggIT0gcGFkX3Rva2VuX2lkKVxuICAgICAgICApXG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKCdpbnQ2NCcsIGRhdGEsIHRva2Vucy5kaW1zKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKFxuICAgICAgICAgICAgJ2ludDY0JyxcbiAgICAgICAgICAgIG5ldyBCaWdJbnQ2NEFycmF5KHRva2Vucy5kYXRhLmxlbmd0aCkuZmlsbCgxbiksXG4gICAgICAgICAgICB0b2tlbnMuZGltc1xuICAgICAgICApXG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBib29sZWFuIHRlbnNvciB3aXRoIGEgc2luZ2xlIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIHRlbnNvci5cbiAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBib29sZWFuIHRlbnNvci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJvb2xUZW5zb3IodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFRlbnNvcignYm9vbCcsIFt2YWx1ZV0sIFsxXSk7XG59XG5cbi8vIEpTIGRvZXNuJ3Qgc3VwcG9ydCBtaXhpbnMsIHNvIHdlIGRlZmluZSBzb21lIHJldXNlZCBmdW5jdGlvbnMgaGVyZSwgYW5kIGFsbG93IFwidGhpc1wiIHRvIGJlIHBhc3NlZCBpblxuLyoqXG4gKiBQZXJmb3JtIGZvcndhcmQgcGFzcyBvbiB0aGUgc2VxMnNlcSBtb2RlbCAoYm90aCBlbmNvZGVyIGFuZCBkZWNvZGVyKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIFRoZSBzZXEyc2VxIG1vZGVsIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0IG9iamVjdCBmb3IgdGhlIG1vZGVsIGNvbnRhaW5pbmcgZW5jb2RlciBhbmQgZGVjb2RlciBpbnB1dHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hZGRfZGVjb2Rlcl9wa3Y9dHJ1ZV0gRmxhZyB0byBhZGQgdGhlIGRlY29kZXIgcGFzdCBrZXkgdmFsdWVzLlxuICogQHJldHVybnMge1Byb21pc2U8U2VxMlNlcUxNT3V0cHV0Pn0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG91dHB1dCBvZiB0aGUgc2VxMnNlcSBtb2RlbC5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlcTJzZXFGb3J3YXJkKHNlbGYsIG1vZGVsX2lucHV0cywge1xuICAgIGFkZF9kZWNvZGVyX3BrdiA9IHRydWVcbn0gPSB7fSkge1xuICAgIGxldCB7IGVuY29kZXJfb3V0cHV0cywgcGFzdF9rZXlfdmFsdWVzIH0gPSBtb2RlbF9pbnB1dHM7XG5cbiAgICBpZiAoIWVuY29kZXJfb3V0cHV0cykge1xuICAgICAgICAvLyBFbmNvZGVyIG91dHB1dHMgYXJlIG5vdCBnaXZlbiwgc28gd2UgbXVzdCBjb21wdXRlIHRoZW0uXG4gICAgICAgIGVuY29kZXJfb3V0cHV0cyA9IChhd2FpdCBlbmNvZGVyRm9yd2FyZChzZWxmLCBtb2RlbF9pbnB1dHMpKS5sYXN0X2hpZGRlbl9zdGF0ZTtcbiAgICB9XG4gICAgbGV0IGRlY29kZXJGZWVkcyA9IHtcbiAgICAgICAgaW5wdXRfaWRzOiBtb2RlbF9pbnB1dHMuZGVjb2Rlcl9pbnB1dF9pZHMsXG4gICAgICAgIGVuY29kZXJfaGlkZGVuX3N0YXRlczogZW5jb2Rlcl9vdXRwdXRzLFxuICAgICAgICB1c2VfY2FjaGVfYnJhbmNoOiBib29sVGVuc29yKCEhcGFzdF9rZXlfdmFsdWVzKVxuICAgIH07XG5cbiAgICBpZiAoc2VsZi5kZWNvZGVyX21lcmdlZF9zZXNzaW9uLmlucHV0TmFtZXMuaW5jbHVkZXMoJ2VuY29kZXJfYXR0ZW50aW9uX21hc2snKSkge1xuICAgICAgICBkZWNvZGVyRmVlZHMuZW5jb2Rlcl9hdHRlbnRpb25fbWFzayA9IG1vZGVsX2lucHV0cy5hdHRlbnRpb25fbWFza1xuICAgIH1cbiAgICBzZWxmLmFkZFBhc3RLZXlWYWx1ZXMoZGVjb2RlckZlZWRzLCBwYXN0X2tleV92YWx1ZXMsIGFkZF9kZWNvZGVyX3Brdik7XG5cbiAgICBjb25zdCBkZWNvZGVyUmVzdWx0cyA9IGF3YWl0IHNlc3Npb25SdW4oc2VsZi5kZWNvZGVyX21lcmdlZF9zZXNzaW9uLCBkZWNvZGVyRmVlZHMpO1xuICAgIGxldCBsb2dpdHMgPSBkZWNvZGVyUmVzdWx0cy5sb2dpdHM7XG4gICAgcGFzdF9rZXlfdmFsdWVzID0gc2VsZi5nZXRQYXN0S2V5VmFsdWVzKGRlY29kZXJSZXN1bHRzLCBwYXN0X2tleV92YWx1ZXMpO1xuXG4gICAgLy8gR2V0IGNyb3NzIGF0dGVudGlvbiBhbmQvb3IgZGVjb2RlciBhdHRlbnRpb25zIGlmIHRoZXkgYXJlIHByZXNlbnRcbiAgICBjb25zdCBhdHRucyA9IHNlbGYuZ2V0QXR0ZW50aW9ucyhkZWNvZGVyUmVzdWx0cyk7XG5cbiAgICByZXR1cm4gbmV3IFNlcTJTZXFMTU91dHB1dCh7IGxvZ2l0cywgcGFzdF9rZXlfdmFsdWVzLCBlbmNvZGVyX291dHB1dHMsIC4uLmF0dG5zIH0pO1xufVxuXG4vKipcbiAqIFN0YXJ0IHRoZSBiZWFtIHNlYXJjaCBwcm9jZXNzIGZvciB0aGUgc2VxMnNlcSBtb2RlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIFRoZSBzZXEyc2VxIG1vZGVsIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0W119IGlucHV0VG9rZW5JZHMgQXJyYXkgb2YgaW5wdXQgdG9rZW4gaWRzIGZvciBlYWNoIGlucHV0IHNlcXVlbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygb3V0cHV0IHRva2VucyBmb3IgdGhlIG1vZGVsLlxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWlyZXNfYXR0ZW50aW9uX21hc2s9dHJ1ZV0gRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgbW9kZWwgcmVxdWlyZXMgYW4gYXR0ZW50aW9uIG1hc2suXG4gKiBAcmV0dXJucyB7T2JqZWN0W119IEFycmF5IG9mIGJlYW0gc2VhcmNoIG9iamVjdHMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXEyc2VxU3RhcnRCZWFtcyhzZWxmLCBpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIHJlcXVpcmVzX2F0dGVudGlvbl9tYXNrID0gdHJ1ZSkge1xuICAgIGxldCBiZWFtcyA9IFtdO1xuICAgIGxldCBiZWFtSWQgPSAwO1xuXG4gICAgLy8gZGVjb2Rlcl9pbnB1dF9pZHMgPT0gb3V0cHV0X3Rva2VuX2lkc1xuICAgIGxldCBkZWNvZGVyX2lucHV0X2lkcyA9IHNlbGYuY29uZmlnLmRlY29kZXJfc3RhcnRfdG9rZW5faWQ7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRlY29kZXJfaW5wdXRfaWRzKSkge1xuICAgICAgICBkZWNvZGVyX2lucHV0X2lkcyA9IFtkZWNvZGVyX2lucHV0X2lkc107XG4gICAgfVxuXG4gICAgZm9yIChsZXQgdG9rZW5zIG9mIGlucHV0VG9rZW5JZHMpIHtcbiAgICAgICAgLy8gVE9ETzogSW1wcm92ZVxuICAgICAgICAvLyBDdXJyZW50bHksIGp1c3QgYWRkIGJhY2sgYmF0Y2ggZGltZW5zaW9uLlxuICAgICAgICAvLyBJbiBmdXR1cmUsIGFsbG93IGZvciB0cnVlIHBhcmFsbGVsIGV4ZWN1dGlvblxuICAgICAgICB0b2tlbnMuZGltcyA9IFsxLCAuLi50b2tlbnMuZGltc11cblxuICAgICAgICAvLyBDcmVhdGUgYmVhbVxuICAgICAgICBsZXQgc3RhcnQgPSB7XG4gICAgICAgICAgICBpbnB1dHM6IHRva2VucyxcbiAgICAgICAgICAgIGVuY29kZXJfb3V0cHV0czogbnVsbCxcbiAgICAgICAgICAgIHByZXZfbW9kZWxfb3V0cHV0czogbnVsbCxcblxuICAgICAgICAgICAgb3V0cHV0X3Rva2VuX2lkczogZGVjb2Rlcl9pbnB1dF9pZHMsXG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHNjb3JlOiAwLFxuICAgICAgICAgICAgaWQ6IGJlYW1JZCsrIC8vIGFzc2lnbiB1bmlxdWUgaWQgdG8gYmVhbXNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXF1aXJlc19hdHRlbnRpb25fbWFzaykge1xuICAgICAgICAgICAgc3RhcnQuYXR0ZW50aW9uX21hc2sgPSBwcmVwYXJlQXR0ZW50aW9uTWFzayhzZWxmLCB0b2tlbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVhbXMucHVzaChzdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlYW1zO1xufVxuXG4vKipcbiAqIFJ1biBiZWFtIHNlYXJjaCBvbiB0aGUgc2VxMnNlcSBtb2RlbCBmb3IgYSBzaW5nbGUgYmVhbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIFRoZSBzZXEyc2VxIG1vZGVsIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBiZWFtIFRoZSBiZWFtIHNlYXJjaCBvYmplY3QgZm9yIHdoaWNoIHRvIHJ1biB0aGUgbW9kZWwuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW5wdXRfbmFtZT0naW5wdXRfaWRzJ10gVGhlIG5hbWUgb2YgdGhlIGlucHV0IHRlbnNvciBmb3IgdGhlIGVuY29kZXIuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgb3V0cHV0IG9mIHRoZSBzZXEyc2VxIG1vZGVsIGZvciB0aGUgZ2l2ZW4gYmVhbS5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlcTJzZXFSdW5CZWFtKHNlbGYsIGJlYW0sIHtcbiAgICBpbnB1dF9uYW1lID0gJ2lucHV0X2lkcycsXG59ID0ge31cbikge1xuICAgIC8vIDEuIFByZXBhcmVcbiAgICBsZXQgbW9kZWxfaW5wdXRzID0ge1xuICAgICAgICBbaW5wdXRfbmFtZV06IGJlYW0uaW5wdXRzLFxuICAgICAgICBkZWNvZGVyX2lucHV0X2lkczogdG9JNjRUZW5zb3IoYmVhbS5vdXRwdXRfdG9rZW5faWRzLnNsaWNlKC0xKSksXG4gICAgICAgIGVuY29kZXJfb3V0cHV0czogYmVhbS5lbmNvZGVyX291dHB1dHMsXG4gICAgICAgIHBhc3Rfa2V5X3ZhbHVlczogYmVhbS5wcmV2X21vZGVsX291dHB1dHM/LnBhc3Rfa2V5X3ZhbHVlcyxcbiAgICB9XG4gICAgaWYgKGJlYW0uYXR0ZW50aW9uX21hc2spIHtcbiAgICAgICAgbW9kZWxfaW5wdXRzLmF0dGVudGlvbl9tYXNrID0gYmVhbS5hdHRlbnRpb25fbWFza1xuICAgIH1cblxuICAgIC8vIDIuIFJ1blxuICAgIGxldCBvdXRwdXQgPSBhd2FpdCBzZWxmLmZvcndhcmQobW9kZWxfaW5wdXRzKTtcblxuICAgIC8vIDMuIFVwZGF0ZVxuICAgIGJlYW0ucHJldl9tb2RlbF9vdXRwdXRzID0gb3V0cHV0O1xuICAgIGJlYW0uZW5jb2Rlcl9vdXRwdXRzID0gb3V0cHV0LmVuY29kZXJfb3V0cHV0cztcblxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogRm9yd2FyZCBwYXNzIG9mIGFuIGVuY29kZXIgbW9kZWwuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiBUaGUgZW5jb2RlciBtb2RlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0IGRhdGEgdG8gYmUgdXNlZCBmb3IgdGhlIGZvcndhcmQgcGFzcy5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dHMuXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiBlbmNvZGVyRm9yd2FyZChzZWxmLCBtb2RlbF9pbnB1dHMpIHtcbiAgICBsZXQgZW5jb2RlckZlZWRzID0ge307XG4gICAgZm9yIChsZXQga2V5IG9mIHNlbGYuc2Vzc2lvbi5pbnB1dE5hbWVzKSB7XG4gICAgICAgIGVuY29kZXJGZWVkc1trZXldID0gbW9kZWxfaW5wdXRzW2tleV07XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzZXNzaW9uUnVuKHNlbGYuc2Vzc2lvbiwgZW5jb2RlckZlZWRzKTtcbn1cblxuXG4vKipcbiAqIEZvcndhcmQgcGFzcyBvZiBhIGRlY29kZXIgbW9kZWwuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiBUaGUgZGVjb2RlciBtb2RlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0IGRhdGEgdG8gYmUgdXNlZCBmb3IgdGhlIGZvcndhcmQgcGFzcy5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBsb2dpdHMgYW5kIHBhc3Qga2V5IHZhbHVlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlY29kZXJGb3J3YXJkKHNlbGYsIG1vZGVsX2lucHV0cykge1xuICAgIGxldCB7IGlucHV0X2lkcywgcGFzdF9rZXlfdmFsdWVzLCBhdHRlbnRpb25fbWFzayB9ID0gbW9kZWxfaW5wdXRzO1xuICAgIGxldCBkZWNvZGVyRmVlZHMgPSB7XG4gICAgICAgIGlucHV0X2lkczogaW5wdXRfaWRzLFxuICAgICAgICBhdHRlbnRpb25fbWFzazogYXR0ZW50aW9uX21hc2sgPz8gcHJlcGFyZUF0dGVudGlvbk1hc2soc2VsZiwgaW5wdXRfaWRzKSxcbiAgICAgICAgdXNlX2NhY2hlX2JyYW5jaDogYm9vbFRlbnNvcihwYXN0X2tleV92YWx1ZXMgIT09IG51bGwpXG4gICAgfVxuXG4gICAgc2VsZi5hZGRQYXN0S2V5VmFsdWVzKGRlY29kZXJGZWVkcywgcGFzdF9rZXlfdmFsdWVzKTtcblxuICAgIGxldCBkZWNvZGVyUmVzdWx0cyA9IGF3YWl0IHNlc3Npb25SdW4oc2VsZi5zZXNzaW9uLCBkZWNvZGVyRmVlZHMpO1xuXG4gICAgbGV0IGxvZ2l0cyA9IGRlY29kZXJSZXN1bHRzLmxvZ2l0cztcblxuICAgIHBhc3Rfa2V5X3ZhbHVlcyA9IHNlbGYuZ2V0UGFzdEtleVZhbHVlcyhkZWNvZGVyUmVzdWx0cywgcGFzdF9rZXlfdmFsdWVzKTtcbiAgICByZXR1cm4geyBsb2dpdHMsIHBhc3Rfa2V5X3ZhbHVlcyB9O1xufVxuXG4vKipcbiAqIFN0YXJ0cyB0aGUgZ2VuZXJhdGlvbiBvZiB0ZXh0IGJ5IGluaXRpYWxpemluZyB0aGUgYmVhbXMgZm9yIHRoZSBnaXZlbiBpbnB1dCB0b2tlbiBJRHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiBUaGUgdGV4dCBnZW5lcmF0aW9uIG1vZGVsIG9iamVjdC5cbiAqIEBwYXJhbSB7YW55fSBpbnB1dFRva2VuSWRzIEFuIGFycmF5IG9mIGlucHV0IHRva2VuIElEcyB0byBnZW5lcmF0ZSB0ZXh0IGZyb20uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtT3V0cHV0VG9rZW5zIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0b2tlbnMgdG8gZ2VuZXJhdGUgZm9yIGVhY2ggYmVhbS5cbiAqIEBwYXJhbSB7VGVuc29yfSBbaW5wdXRzX2F0dGVudGlvbl9tYXNrXSBUaGUgYXR0ZW50aW9uIG1hc2sgdGVuc29yIGZvciB0aGUgaW5wdXQgdG9rZW4gSURzLlxuICogQHJldHVybnMge09iamVjdFtdfSBBbiBhcnJheSBvZiBiZWFtcyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIHBhcmFtZXRlcnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGVyU3RhcnRCZWFtcyhzZWxmLCBpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIGlucHV0c19hdHRlbnRpb25fbWFzaykge1xuICAgIGxldCBiZWFtcyA9IFtdO1xuXG4gICAgbGV0IGJlYW1JZCA9IDA7XG4gICAgZm9yIChsZXQgdG9rZW5zIG9mIGlucHV0VG9rZW5JZHMpIHtcbiAgICAgICAgbGV0IG91dHB1dF90b2tlbl9pZHMgPSB0b2tlbnMudG9saXN0KCkubWFwKE51bWJlcik7XG5cbiAgICAgICAgLy8gVE9ETzogSW1wcm92ZVxuICAgICAgICAvLyBDdXJyZW50bHksIGp1c3QgYWRkIGJhY2sgYmF0Y2ggZGltZW5zaW9uLlxuICAgICAgICAvLyBJbiBmdXR1cmUsIGFsbG93IGZvciB0cnVlIHBhcmFsbGVsIGV4ZWN1dGlvblxuICAgICAgICB0b2tlbnMuZGltcyA9IFsxLCAuLi50b2tlbnMuZGltc11cblxuICAgICAgICBsZXQgYXR0bl9tYXNrO1xuICAgICAgICBpZiAoaW5wdXRzX2F0dGVudGlvbl9tYXNrKSB7XG4gICAgICAgICAgICBhdHRuX21hc2sgPSBpbnB1dHNfYXR0ZW50aW9uX21hc2tbYmVhbUlkXTtcbiAgICAgICAgICAgIGF0dG5fbWFzay5kaW1zID0gWzEsIC4uLmF0dG5fbWFzay5kaW1zXVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRuX21hc2sgPSBwcmVwYXJlQXR0ZW50aW9uTWFzayhzZWxmLCB0b2tlbnMpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RhcnQgPSB7XG4gICAgICAgICAgICBpbnB1dDogdG9rZW5zLFxuICAgICAgICAgICAgbW9kZWxfaW5wdXRfaWRzOiB0b2tlbnMsXG4gICAgICAgICAgICBhdHRlbnRpb25fbWFzazogYXR0bl9tYXNrLFxuICAgICAgICAgICAgcHJldl9tb2RlbF9vdXRwdXRzOiBudWxsLFxuXG4gICAgICAgICAgICBvdXRwdXRfdG9rZW5faWRzOiBvdXRwdXRfdG9rZW5faWRzLFxuICAgICAgICAgICAgbnVtX291dHB1dF90b2tlbnM6IG51bU91dHB1dFRva2VucyxcblxuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgIGlkOiBiZWFtSWQrKyAvLyBhc3NpZ24gdW5pcXVlIGlkIHRvIGJlYW1zXG4gICAgICAgIH1cblxuICAgICAgICBiZWFtcy5wdXNoKHN0YXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJlYW1zO1xufVxuXG4vKipcbiAqIFJ1bnMgYSBzaW5nbGUgc3RlcCBvZiB0aGUgdGV4dCBnZW5lcmF0aW9uIHByb2Nlc3MgZm9yIGEgZ2l2ZW4gYmVhbS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiBUaGUgZGVjb2RlciBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gYmVhbSBUaGUgYmVhbSB0byBydW4uXG4gKiBAcGFyYW0ge1RlbnNvcn0gYmVhbS5pbnB1dCBUaGUgaW5wdXQgdGVuc29yLlxuICogQHBhcmFtIHtUZW5zb3J9IGJlYW0ubW9kZWxfaW5wdXRfaWRzIFRoZSBpbnB1dCBpZHMgdG8gdGhlIG1vZGVsLlxuICogQHBhcmFtIHtUZW5zb3J9IGJlYW0uYXR0ZW50aW9uX21hc2sgVGhlIGF0dGVudGlvbiBtYXNrLlxuICogQHBhcmFtIHtPYmplY3R9IGJlYW0ucHJldl9tb2RlbF9vdXRwdXRzIFRoZSBwYXN0IGtleSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcltdfSBiZWFtLm91dHB1dF90b2tlbl9pZHMgVGhlIG91dHB1dCB0b2tlbiBpZHMuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgb3V0cHV0IG9mIHRoZSBnZW5lcmF0aW9uIHN0ZXAuXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiBkZWNvZGVyUnVuQmVhbShzZWxmLCBiZWFtKSB7XG4gICAgbGV0IGF0dG5NYXNrRGF0YSA9IG5ldyBCaWdJbnQ2NEFycmF5KGJlYW0ub3V0cHV0X3Rva2VuX2lkcy5sZW5ndGgpLmZpbGwoMW4pXG5cbiAgICAvLyAxLiBQcmVwYXJlXG4gICAgbGV0IG1vZGVsX2lucHV0cyA9IHtcbiAgICAgICAgaW5wdXRfaWRzOiBiZWFtLm1vZGVsX2lucHV0X2lkcyxcbiAgICAgICAgYXR0ZW50aW9uX21hc2s6IG5ldyBUZW5zb3IoXG4gICAgICAgICAgICAnaW50NjQnLFxuICAgICAgICAgICAgYXR0bk1hc2tEYXRhLFxuICAgICAgICAgICAgWzEsIGF0dG5NYXNrRGF0YS5sZW5ndGhdXG4gICAgICAgICksXG4gICAgICAgIHBhc3Rfa2V5X3ZhbHVlczogYmVhbS5wcmV2X21vZGVsX291dHB1dHM/LnBhc3Rfa2V5X3ZhbHVlcyxcbiAgICB9XG5cbiAgICAvLyAyLiBSdW5cbiAgICBsZXQgb3V0cHV0ID0gYXdhaXQgc2VsZi5mb3J3YXJkKG1vZGVsX2lucHV0cyk7XG5cbiAgICAvLyAzLiBVcGRhdGVcbiAgICBiZWFtLnByZXZfbW9kZWxfb3V0cHV0cyA9IG91dHB1dDtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogVXBkYXRlIGEgYmVhbSB3aXRoIGEgbmV3IHRva2VuIElELlxuICogQHBhcmFtIHtPYmplY3R9IGJlYW0gVGhlIGJlYW0gdG8gdXBkYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG5ld1Rva2VuSWQgVGhlIG5ldyB0b2tlbiBJRCB0byBhZGQgdG8gdGhlIGJlYW0ncyBvdXRwdXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGVyVXBkYXRlYmVhbShiZWFtLCBuZXdUb2tlbklkKSB7XG4gICAgYmVhbS5vdXRwdXRfdG9rZW5faWRzID0gWy4uLmJlYW0ub3V0cHV0X3Rva2VuX2lkcywgbmV3VG9rZW5JZF07XG4gICAgYmVhbS5tb2RlbF9pbnB1dF9pZHMgPSBuZXcgVGVuc29yKCdpbnQ2NCcsIFtCaWdJbnQobmV3VG9rZW5JZCldLCBbMSwgMV0pO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBwcmUtdHJhaW5lZCBtb2RlbHMgdGhhdCBwcm92aWRlcyB0aGUgbW9kZWwgY29uZmlndXJhdGlvbiBhbmQgYW4gT05OWCBzZXNzaW9uLlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuZXhwb3J0IGNsYXNzIFByZVRyYWluZWRNb2RlbCBleHRlbmRzIENhbGxhYmxlIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcmVUcmFpbmVkTW9kZWxgIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIG1vZGVsIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHthbnl9IHNlc3Npb24gc2Vzc2lvbiBmb3IgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbikge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogRGlzcG9zZXMgb2YgYWxsIHRoZSBPTk5YIHNlc3Npb25zIHRoYXQgd2VyZSBjcmVhdGVkIGR1cmluZyBpbmZlcmVuY2UuXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTx1bmtub3duW10+fSBBbiBhcnJheSBvZiBwcm9taXNlcywgb25lIGZvciBlYWNoIE9OTlggc2Vzc2lvbiB0aGF0IGlzIGJlaW5nIGRpc3Bvc2VkLlxuICAgICogQHRvZG8gVXNlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ZpbmFsaXphdGlvblJlZ2lzdHJ5XG4gICAgKi9cbiAgICBhc3luYyBkaXNwb3NlKCkge1xuICAgICAgICBsZXQgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSW5mZXJlbmNlU2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goaXRlbS5oYW5kbGVyLmRpc3Bvc2UoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIG9uZSBvZiB0aGUgbW9kZWwgY2xhc3NlcyBvZiB0aGUgbGlicmFyeSBmcm9tIGEgcHJldHJhaW5lZCBtb2RlbC5cbiAgICAgKiBcbiAgICAgKiBUaGUgbW9kZWwgY2xhc3MgdG8gaW5zdGFudGlhdGUgaXMgc2VsZWN0ZWQgYmFzZWQgb24gdGhlIGBtb2RlbF90eXBlYCBwcm9wZXJ0eSBvZiB0aGUgY29uZmlnIG9iamVjdFxuICAgICAqIChlaXRoZXIgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IG9yIGxvYWRlZCBmcm9tIGBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aGAgaWYgcG9zc2libGUpXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoIFRoZSBuYW1lIG9yIHBhdGggb2YgdGhlIHByZXRyYWluZWQgbW9kZWwuIENhbiBiZSBlaXRoZXI6XG4gICAgICogLSBBIHN0cmluZywgdGhlICptb2RlbCBpZCogb2YgYSBwcmV0cmFpbmVkIG1vZGVsIGhvc3RlZCBpbnNpZGUgYSBtb2RlbCByZXBvIG9uIGh1Z2dpbmdmYWNlLmNvLlxuICAgICAqICAgVmFsaWQgbW9kZWwgaWRzIGNhbiBiZSBsb2NhdGVkIGF0IHRoZSByb290LWxldmVsLCBsaWtlIGBiZXJ0LWJhc2UtdW5jYXNlZGAsIG9yIG5hbWVzcGFjZWQgdW5kZXIgYVxuICAgICAqICAgdXNlciBvciBvcmdhbml6YXRpb24gbmFtZSwgbGlrZSBgZGJtZHovYmVydC1iYXNlLWdlcm1hbi1jYXNlZGAuXG4gICAgICogLSBBIHBhdGggdG8gYSAqZGlyZWN0b3J5KiBjb250YWluaW5nIG1vZGVsIHdlaWdodHMsIGUuZy4sIGAuL215X21vZGVsX2RpcmVjdG9yeS9gLlxuICAgICAqIEBwYXJhbSB7UHJldHJhaW5lZE9wdGlvbnN9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciBsb2FkaW5nIHRoZSBtb2RlbC5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcmVUcmFpbmVkTW9kZWw+fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByZVRyYWluZWRNb2RlbGAgY2xhc3MuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwge1xuICAgICAgICBxdWFudGl6ZWQgPSB0cnVlLFxuICAgICAgICBwcm9ncmVzc19jYWxsYmFjayA9IG51bGwsXG4gICAgICAgIGNvbmZpZyA9IG51bGwsXG4gICAgICAgIGNhY2hlX2RpciA9IG51bGwsXG4gICAgICAgIGxvY2FsX2ZpbGVzX29ubHkgPSBmYWxzZSxcbiAgICAgICAgcmV2aXNpb24gPSAnbWFpbicsXG4gICAgICAgIG1vZGVsX2ZpbGVfbmFtZSA9IG51bGwsXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBxdWFudGl6ZWQsXG4gICAgICAgICAgICBwcm9ncmVzc19jYWxsYmFjayxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGNhY2hlX2RpcixcbiAgICAgICAgICAgIGxvY2FsX2ZpbGVzX29ubHksXG4gICAgICAgICAgICByZXZpc2lvbixcbiAgICAgICAgICAgIG1vZGVsX2ZpbGVfbmFtZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtb2RlbFR5cGUgPSBNT0RFTF9UWVBFX01BUFBJTkcuZ2V0KHRoaXMubmFtZSk7XG5cbiAgICAgICAgbGV0IGluZm87XG4gICAgICAgIGlmIChtb2RlbFR5cGUgPT09IERlY29kZXJPbmx5TW9kZWxUeXBlKSB7XG4gICAgICAgICAgICBpbmZvID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIEF1dG9Db25maWcuZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RTZXNzaW9uKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBvcHRpb25zLm1vZGVsX2ZpbGVfbmFtZSA/PyAnZGVjb2Rlcl9tb2RlbF9tZXJnZWQnLCBvcHRpb25zKSxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobW9kZWxUeXBlID09PSBTZXEyU2VxTW9kZWxUeXBlKSB7XG4gICAgICAgICAgICBpbmZvID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIEF1dG9Db25maWcuZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RTZXNzaW9uKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCAnZW5jb2Rlcl9tb2RlbCcsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdFNlc3Npb24ocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsICdkZWNvZGVyX21vZGVsX21lcmdlZCcsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGdldE1vZGVsSlNPTihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ2dlbmVyYXRpb25fY29uZmlnLmpzb24nLCBmYWxzZSwgb3B0aW9ucyksXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICB9IGVsc2UgaWYgKG1vZGVsVHlwZSA9PT0gRW5jb2RlckRlY29kZXJNb2RlbFR5cGUpIHtcbiAgICAgICAgICAgIGluZm8gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgQXV0b0NvbmZpZy5mcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdFNlc3Npb24ocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsICdlbmNvZGVyX21vZGVsJywgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgY29uc3RydWN0U2Vzc2lvbihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ2RlY29kZXJfbW9kZWxfbWVyZ2VkJywgb3B0aW9ucyksXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICB9IGVsc2UgaWYgKG1vZGVsVHlwZSA9PT0gRW5jb2Rlck9ubHlNb2RlbFR5cGUpIHtcbiAgICAgICAgICAgIGluZm8gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgQXV0b0NvbmZpZy5mcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdFNlc3Npb24ocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIG9wdGlvbnMubW9kZWxfZmlsZV9uYW1lID8/ICdtb2RlbCcsIG9wdGlvbnMpXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNYWxmb3JtZWQgY2xhc3MgZGVmaW5pdGlvbi4nLCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gbG9hZCBtb2RlbDogJHtwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aH0uIFBsZWFzZSByZXBvcnQgdGhpcyBidWcgYXQgaHR0cHM6Ly9naXRodWIuY29tL3hlbm92YS90cmFuc2Zvcm1lcnMuanMvaXNzdWVzL25ldy9jaG9vc2UuYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBuZXcgdGhpcyguLi5pbmZvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBtb2RlbCB3aXRoIHRoZSBwcm92aWRlZCBpbnB1dHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIE9iamVjdCBjb250YWluaW5nIGlucHV0IHRlbnNvcnNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBPYmplY3QgY29udGFpbmluZyBvdXRwdXQgdGVuc29yc1xuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mb3J3YXJkKG1vZGVsX2lucHV0cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yd2FyZCBtZXRob2QgZm9yIGEgcHJldHJhaW5lZCBtb2RlbC4gSWYgbm90IG92ZXJyaWRkZW4gYnkgYSBzdWJjbGFzcywgdGhlIGNvcnJlY3QgZm9yd2FyZCBtZXRob2RcbiAgICAgKiB3aWxsIGJlIGNob3NlbiBiYXNlZCBvbiB0aGUgbW9kZWwgdHlwZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dCBkYXRhIHRvIHRoZSBtb2RlbCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBpbiB0aGUgT05OWCBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgb3V0cHV0IGRhdGEgZnJvbSB0aGUgbW9kZWwgaW4gdGhlIGZvcm1hdCBzcGVjaWZpZWQgaW4gdGhlIE9OTlggbW9kZWwuXG4gICAgICogQHRocm93cyB7RXJyb3J9IFRoaXMgbWV0aG9kIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlcy5cbiAgICAgKi9cbiAgICBhc3luYyBmb3J3YXJkKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZm9yd2FyZCh0aGlzLCBtb2RlbF9pbnB1dHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7R2VuZXJhdGlvbkNvbmZpZ30gZ2VuZXJhdGlvbl9jb25maWcgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlucHV0X2lkc19zZXFfbGVuZ3RoIFRoZSBzdGFydGluZyBzZXF1ZW5jZSBsZW5ndGggZm9yIHRoZSBpbnB1dCBpZHMuXG4gICAgICogQHJldHVybnMge0xvZ2l0c1Byb2Nlc3Nvckxpc3R9XG4gICAgICovXG4gICAgX2dldF9sb2dpdHNfcHJvY2Vzc29yKFxuICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZyxcbiAgICAgICAgaW5wdXRfaWRzX3NlcV9sZW5ndGgsXG4gICAgICAgIC8vIGVuY29kZXJfaW5wdXRfaWRzLCBUT0RPXG4gICAgICAgIC8vIHByZWZpeF9hbGxvd2VkX3Rva2Vuc19mbiwgVE9ET1xuICAgICAgICBsb2dpdHNfcHJvY2Vzc29yID0gbnVsbFxuICAgICkge1xuICAgICAgICBjb25zdCBwcm9jZXNzb3JzID0gbmV3IExvZ2l0c1Byb2Nlc3Nvckxpc3QoKTtcblxuICAgICAgICAvLyBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZGl2ZXJzaXR5X3BlbmFsdHkgIT09IG51bGwgJiYgZ2VuZXJhdGlvbl9jb25maWcuZGl2ZXJzaXR5X3BlbmFsdHkgPiAwLjApIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgSGFtbWluZ0RpdmVyc2l0eUxvZ2l0c1Byb2Nlc3NvcihcbiAgICAgICAgLy8gICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5kaXZlcnNpdHlfcGVuYWx0eSxcbiAgICAgICAgLy8gICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5udW1fYmVhbXMsXG4gICAgICAgIC8vICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcubnVtX2JlYW1fZ3JvdXBzXG4gICAgICAgIC8vICAgICApKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5lbmNvZGVyX3JlcGV0aXRpb25fcGVuYWx0eSAhPT0gbnVsbCAmJiBnZW5lcmF0aW9uX2NvbmZpZy5lbmNvZGVyX3JlcGV0aXRpb25fcGVuYWx0eSAhPT0gMS4wKSB7XG4gICAgICAgIC8vICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IEVuY29kZXJSZXBldGl0aW9uUGVuYWx0eUxvZ2l0c1Byb2Nlc3NvcihcbiAgICAgICAgLy8gICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5lbmNvZGVyX3JlcGV0aXRpb25fcGVuYWx0eSxcbiAgICAgICAgLy8gICAgICAgICBlbmNvZGVyX2lucHV0X2lkc1xuICAgICAgICAvLyAgICAgKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcucmVwZXRpdGlvbl9wZW5hbHR5ICE9PSBudWxsICYmIGdlbmVyYXRpb25fY29uZmlnLnJlcGV0aXRpb25fcGVuYWx0eSAhPT0gMS4wKSB7XG4gICAgICAgICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IFJlcGV0aXRpb25QZW5hbHR5TG9naXRzUHJvY2Vzc29yKGdlbmVyYXRpb25fY29uZmlnLnJlcGV0aXRpb25fcGVuYWx0eSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLm5vX3JlcGVhdF9uZ3JhbV9zaXplICE9PSBudWxsICYmIGdlbmVyYXRpb25fY29uZmlnLm5vX3JlcGVhdF9uZ3JhbV9zaXplID4gMCkge1xuICAgICAgICAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBOb1JlcGVhdE5HcmFtTG9naXRzUHJvY2Vzc29yKGdlbmVyYXRpb25fY29uZmlnLm5vX3JlcGVhdF9uZ3JhbV9zaXplKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZW5jb2Rlcl9ub19yZXBlYXRfbmdyYW1fc2l6ZSAhPT0gbnVsbCAmJiBnZW5lcmF0aW9uX2NvbmZpZy5lbmNvZGVyX25vX3JlcGVhdF9uZ3JhbV9zaXplID4gMCkge1xuICAgICAgICAvLyAgICAgaWYgKHRoaXMuY29uZmlnLmlzX2VuY29kZXJfZGVjb2Rlcikge1xuICAgICAgICAvLyAgICAgICAgIHByb2Nlc3NvcnMucHVzaChuZXcgRW5jb2Rlck5vUmVwZWF0TkdyYW1Mb2dpdHNQcm9jZXNzb3IoXG4gICAgICAgIC8vICAgICAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLmVuY29kZXJfbm9fcmVwZWF0X25ncmFtX3NpemUsXG4gICAgICAgIC8vICAgICAgICAgICAgIGVuY29kZXJfaW5wdXRfaWRzXG4gICAgICAgIC8vICAgICAgICAgKSk7XG4gICAgICAgIC8vICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkl0J3MgaW1wb3NzaWJsZSB0byB1c2UgYGVuY29kZXJfbm9fcmVwZWF0X25ncmFtX3NpemVgIHdpdGggZGVjb2Rlci1vbmx5IGFyY2hpdGVjdHVyZVwiKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5iYWRfd29yZHNfaWRzICE9PSBudWxsKSB7XG4gICAgICAgIC8vICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IE5vQmFkV29yZHNMb2dpdHNQcm9jZXNzb3IoZ2VuZXJhdGlvbl9jb25maWcuYmFkX3dvcmRzX2lkcywgZ2VuZXJhdGlvbl9jb25maWcuZW9zX3Rva2VuX2lkKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZiAoZ2VuZXJhdGlvbl9jb25maWcubWluX2xlbmd0aCAhPT0gbnVsbCAmJiBnZW5lcmF0aW9uX2NvbmZpZy5lb3NfdG9rZW5faWQgIT09IG51bGwgJiYgZ2VuZXJhdGlvbl9jb25maWcubWluX2xlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgTWluTGVuZ3RoTG9naXRzUHJvY2Vzc29yKGdlbmVyYXRpb25fY29uZmlnLm1pbl9sZW5ndGgsIGdlbmVyYXRpb25fY29uZmlnLmVvc190b2tlbl9pZCkpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gaWYgKGdlbmVyYXRpb25fY29uZmlnLm1pbl9uZXdfdG9rZW5zICE9PSBudWxsICYmIGdlbmVyYXRpb25fY29uZmlnLmVvc190b2tlbl9pZCAhPT0gbnVsbCAmJiBnZW5lcmF0aW9uX2NvbmZpZy5taW5fbmV3X3Rva2VucyA+IDApIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgTWluTmV3VG9rZW5zTGVuZ3RoTG9naXRzUHJvY2Vzc29yKFxuICAgICAgICAvLyAgICAgICAgIGlucHV0X2lkc19zZXFfbGVuZ3RoLFxuICAgICAgICAvLyAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLm1pbl9uZXdfdG9rZW5zLFxuICAgICAgICAvLyAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLmVvc190b2tlbl9pZFxuICAgICAgICAvLyAgICAgKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZiAocHJlZml4X2FsbG93ZWRfdG9rZW5zX2ZuICE9PSBudWxsKSB7XG4gICAgICAgIC8vICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IFByZWZpeENvbnN0cmFpbmVkTG9naXRzUHJvY2Vzc29yKFxuICAgICAgICAvLyAgICAgICAgIHByZWZpeF9hbGxvd2VkX3Rva2Vuc19mbixcbiAgICAgICAgLy8gICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5udW1fYmVhbXMgLyBnZW5lcmF0aW9uX2NvbmZpZy5udW1fYmVhbV9ncm91cHNcbiAgICAgICAgLy8gICAgICkpO1xuICAgICAgICAvLyB9XG5cblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZm9yY2VkX2Jvc190b2tlbl9pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBGb3JjZWRCT1NUb2tlbkxvZ2l0c1Byb2Nlc3NvcihnZW5lcmF0aW9uX2NvbmZpZy5mb3JjZWRfYm9zX3Rva2VuX2lkKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZm9yY2VkX2Vvc190b2tlbl9pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBGb3JjZWRFT1NUb2tlbkxvZ2l0c1Byb2Nlc3NvcihcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5tYXhfbGVuZ3RoLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25fY29uZmlnLmZvcmNlZF9lb3NfdG9rZW5faWRcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgKGdlbmVyYXRpb25fY29uZmlnLnJlbW92ZV9pbnZhbGlkX3ZhbHVlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBJbmZOYW5SZW1vdmVMb2dpdHNQcm9jZXNzb3IoKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZXhwb25lbnRpYWxfZGVjYXlfbGVuZ3RoX3BlbmFsdHkgIT09IG51bGwpIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgRXhwb25lbnRpYWxEZWNheUxlbmd0aFBlbmFsdHkoXG4gICAgICAgIC8vICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcuZXhwb25lbnRpYWxfZGVjYXlfbGVuZ3RoX3BlbmFsdHksXG4gICAgICAgIC8vICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcuZW9zX3Rva2VuX2lkLFxuICAgICAgICAvLyAgICAgICAgIGlucHV0X2lkc19zZXFfbGVuZ3RoXG4gICAgICAgIC8vICAgICApKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5zdXBwcmVzc190b2tlbnMgIT09IG51bGwpIHtcbiAgICAgICAgLy8gICAgIHByb2Nlc3NvcnMucHVzaChuZXcgU3VwcHJlc3NUb2tlbnNMb2dpdHNQcm9jZXNzb3IoZ2VuZXJhdGlvbl9jb25maWcuc3VwcHJlc3NfdG9rZW5zKSk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcuYmVnaW5fc3VwcHJlc3NfdG9rZW5zICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgYmVnaW5faW5kZXggPSAoaW5wdXRfaWRzX3NlcV9sZW5ndGggPiAxIHx8IGdlbmVyYXRpb25fY29uZmlnLmZvcmNlZF9ib3NfdG9rZW5faWQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgPyBpbnB1dF9pZHNfc2VxX2xlbmd0aFxuICAgICAgICAgICAgICAgIDogaW5wdXRfaWRzX3NlcV9sZW5ndGggKyAxO1xuXG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcuZm9yY2VkX2RlY29kZXJfaWRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGlvbiBzdGFydHMgYWZ0ZXIgdGhlIGxhc3QgdG9rZW4gdGhhdCBpcyBmb3JjZWRcbiAgICAgICAgICAgICAgICBiZWdpbl9pbmRleCArPSBnZW5lcmF0aW9uX2NvbmZpZy5mb3JjZWRfZGVjb2Rlcl9pZHNbZ2VuZXJhdGlvbl9jb25maWcuZm9yY2VkX2RlY29kZXJfaWRzLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBTdXBwcmVzc1Rva2Vuc0F0QmVnaW5Mb2dpdHNQcm9jZXNzb3IoZ2VuZXJhdGlvbl9jb25maWcuYmVnaW5fc3VwcHJlc3NfdG9rZW5zLCBiZWdpbl9pbmRleCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLmZvcmNlZF9kZWNvZGVyX2lkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvY2Vzc29ycy5wdXNoKG5ldyBGb3JjZVRva2Vuc0xvZ2l0c1Byb2Nlc3NvcihnZW5lcmF0aW9uX2NvbmZpZy5mb3JjZWRfZGVjb2Rlcl9pZHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2dpdHNfcHJvY2Vzc29yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9jZXNzb3JzLmV4dGVuZChsb2dpdHNfcHJvY2Vzc29yKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYExvZ2l0Tm9ybWFsaXphdGlvbmAgc2hvdWxkIGFsd2F5cyBiZSB0aGUgbGFzdCBsb2dpdCBwcm9jZXNzb3IsIHdoZW4gcHJlc2VudFxuICAgICAgICAvLyBpZiAoZ2VuZXJhdGlvbl9jb25maWcucmVub3JtYWxpemVfbG9naXRzID09PSB0cnVlKSB7XG4gICAgICAgIC8vICAgICBwcm9jZXNzb3JzLnB1c2gobmV3IExvZ2l0Tm9ybWFsaXphdGlvbigpKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHJldHVybiBwcm9jZXNzb3JzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbWVyZ2VzIG11bHRpcGxlIGdlbmVyYXRpb24gY29uZmlncyB0b2dldGhlciB0byBmb3JtIGEgZmluYWwgZ2VuZXJhdGlvbiBjb25maWcgdG8gYmUgdXNlZCBieSB0aGUgbW9kZWwgZm9yIHRleHQgZ2VuZXJhdGlvbi5cbiAgICAgKiBJdCBmaXJzdCBjcmVhdGVzIGFuIGVtcHR5IGBHZW5lcmF0aW9uQ29uZmlnYCBvYmplY3QsIHRoZW4gaXQgYXBwbGllcyB0aGUgbW9kZWwncyBvd24gYGdlbmVyYXRpb25fY29uZmlnYCBwcm9wZXJ0eSB0byBpdC4gRmluYWxseSwgaWYgYSBgZ2VuZXJhdGlvbl9jb25maWdgIG9iamVjdCB3YXMgcGFzc2VkIGluIHRoZSBhcmd1bWVudHMsIGl0IG92ZXJ3cml0ZXMgdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydGllcyBpbiB0aGUgZmluYWwgY29uZmlnIHdpdGggdGhvc2Ugb2YgdGhlIHBhc3NlZCBjb25maWcgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtHZW5lcmF0aW9uQ29uZmlnfSBnZW5lcmF0aW9uX2NvbmZpZyBBIGBHZW5lcmF0aW9uQ29uZmlnYCBvYmplY3QgY29udGFpbmluZyBnZW5lcmF0aW9uIHBhcmFtZXRlcnMuXG4gICAgICogQHJldHVybnMge0dlbmVyYXRpb25Db25maWd9IFRoZSBmaW5hbCBnZW5lcmF0aW9uIGNvbmZpZyBvYmplY3QgdG8gYmUgdXNlZCBieSB0aGUgbW9kZWwgZm9yIHRleHQgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBfZ2V0X2dlbmVyYXRpb25fY29uZmlnKGdlbmVyYXRpb25fY29uZmlnKSB7XG4gICAgICAgIC8vIENyZWF0ZSBlbXB0eSBnZW5lcmF0aW9uIGNvbmZpZyAoY29udGFpbnMgZGVmYXVsdHMpXG4gICAgICAgIGxldCBnZW5fY29uZmlnID0gbmV3IEdlbmVyYXRpb25Db25maWcoKTtcblxuICAgICAgICAvLyBBcHBseSBtb2RlbCdzIGdlbmVyYXRpb24gY29uZmlnLCBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKCdnZW5lcmF0aW9uX2NvbmZpZycgaW4gdGhpcykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihnZW5fY29uZmlnLCB0aGlzLmdlbmVyYXRpb25fY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsbHksIHVzZSBhbnkgZ2VuZXJhdGlvbiBjb25maWcgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyXG4gICAgICAgIC8vIHdoZW4gY2FsbGluZyBgZ2VuZXJhdGVgXG4gICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihnZW5fY29uZmlnLCBnZW5lcmF0aW9uX2NvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlbl9jb25maWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge2ltcG9ydCgnLi91dGlscy9tYXRocy5qcycpLlR5cGVkQXJyYXl9IFR5cGVkQXJyYXlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHt7IHNlcXVlbmNlczogVGVuc29yLCBkZWNvZGVyX2F0dGVudGlvbnM6IFRlbnNvciwgY3Jvc3NfYXR0ZW50aW9uczogVGVuc29yIH19IEVuY29kZXJEZWNvZGVyT3V0cHV0XG4gICAgICogQHR5cGVkZWYge09iamVjdH0gRGVjb2Rlck91dHB1dFxuICAgICAqIFxuICAgICAqIEdlbmVyYXRlcyB0ZXh0IGJhc2VkIG9uIHRoZSBnaXZlbiBpbnB1dHMgYW5kIGdlbmVyYXRpb24gY29uZmlndXJhdGlvbiB1c2luZyB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J8QXJyYXl8VHlwZWRBcnJheX0gaW5wdXRzIEFuIGFycmF5IG9mIGlucHV0IHRva2VuIElEcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdHxHZW5lcmF0aW9uQ29uZmlnfG51bGx9IGdlbmVyYXRpb25fY29uZmlnIFRoZSBnZW5lcmF0aW9uIGNvbmZpZ3VyYXRpb24gdG8gdXNlLiBJZiBudWxsLCBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGxvZ2l0c19wcm9jZXNzb3IgQW4gb3B0aW9uYWwgbG9naXRzIHByb2Nlc3NvciB0byB1c2UuIElmIG51bGwsIGEgbmV3IExvZ2l0c1Byb2Nlc3Nvckxpc3QgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW5wdXRzX2F0dGVudGlvbl9tYXNrPW51bGxdIEFuIG9wdGlvbmFsIGF0dGVudGlvbiBtYXNrIGZvciB0aGUgaW5wdXRzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcltdW118RW5jb2RlckRlY29kZXJPdXRwdXR8RGVjb2Rlck91dHB1dD59IEFuIGFycmF5IG9mIGdlbmVyYXRlZCBvdXRwdXQgc2VxdWVuY2VzLCB3aGVyZSBlYWNoIHNlcXVlbmNlIGlzIGFuIGFycmF5IG9mIHRva2VuIElEcy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBpbnB1dHMgYXJyYXkgaXMgZW1wdHkuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoXG4gICAgICAgIGlucHV0cyxcbiAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcgPSBudWxsLFxuICAgICAgICBsb2dpdHNfcHJvY2Vzc29yID0gbnVsbCxcbiAgICAgICAge1xuICAgICAgICAgICAgaW5wdXRzX2F0dGVudGlvbl9tYXNrID0gbnVsbFxuICAgICAgICB9ID0ge30sXG4gICAgKSB7XG5cbiAgICAgICAgaWYgKCEoaW5wdXRzIGluc3RhbmNlb2YgVGVuc29yKSAmJiAhaXNUeXBlZEFycmF5KGlucHV0cykgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXRzKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFxcYGlucHV0c1xcYCBtdXN0IGJlIGEgVGVuc29yLCBUeXBlZEFycmF5LCBvciBBcnJheSwgYnV0IGlzIFwiJHtpbnB1dHMuY29uc3RydWN0b3IubmFtZX1cIi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnB1dF9pZHNfc2VxX2xlbmd0aDtcblxuICAgICAgICAvLyBQcmVwYXJlIGBpbnB1dF9pZHNgIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgYXV0by1yZWdyZXNzaXZlIGdlbmVyYXRpb25cbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHRvIGFsaWduIHdpdGggSEYgdHJhbnNmb3JtZXJzJyBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNfZW5jb2Rlcl9kZWNvZGVyKSB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0aW5nIGZyb20gdGhlIGVuY29kZXIgb3V0cHV0c1xuICAgICAgICAgICAgaW5wdXRfaWRzX3NlcV9sZW5ndGggPSAwO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dF9pZHNfc2VxX2xlbmd0aCA9IGlucHV0cyBpbnN0YW5jZW9mIFRlbnNvciA/IGlucHV0cy5kaW1zWzBdIDogaW5wdXRzLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gZGVjb2Rlci1vbmx5XG4gICAgICAgICAgICBpZiAoaW5wdXRfaWRzX3NlcV9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIk11c3Qgc3VwcGx5IGEgbm9uLWVtcHR5IGFycmF5IG9mIGlucHV0IHRva2VuIGlkcy5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBnZW5lcmF0aW9uIGNvbmZpZyB3aXRoIGRlZmF1bHRzXG4gICAgICAgIGdlbmVyYXRpb25fY29uZmlnID0gdGhpcy5fZ2V0X2dlbmVyYXRpb25fY29uZmlnKGdlbmVyYXRpb25fY29uZmlnKTtcblxuICAgICAgICBsb2dpdHNfcHJvY2Vzc29yID0gbG9naXRzX3Byb2Nlc3NvciA/PyBuZXcgTG9naXRzUHJvY2Vzc29yTGlzdCgpXG5cbiAgICAgICAgLy8gVXBkYXRlIGxvZ2l0cyBwcm9jZXNzb3JcbiAgICAgICAgbG9naXRzX3Byb2Nlc3NvciA9IHRoaXMuX2dldF9sb2dpdHNfcHJvY2Vzc29yKFxuICAgICAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcsXG4gICAgICAgICAgICBpbnB1dF9pZHNfc2VxX2xlbmd0aCxcbiAgICAgICAgICAgIGxvZ2l0c19wcm9jZXNzb3JcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IGVhcmx5X3N0b3BwaW5nXG4gICAgICAgIC8vIGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vYmxvZy9ob3ctdG8tZ2VuZXJhdGVcblxuICAgICAgICBsZXQgbnVtT3V0cHV0VG9rZW5zID0gMTtcbiAgICAgICAgY29uc3QgbWF4T3V0cHV0VG9rZW5zID0gbnVtT3V0cHV0VG9rZW5zICsgKGdlbmVyYXRpb25fY29uZmlnLm1heF9uZXdfdG9rZW5zID8/IEluZmluaXR5KTtcblxuICAgICAgICAvLyBPbmx5IHVzZSBtYXggbGVuZ3RoIGlmIG1heF9uZXdfdG9rZW5zIGlzIG5vdCBwcm92aWRlZFxuICAgICAgICBjb25zdCB1c2VNYXhMZW5ndGggPSBOdW1iZXIuaXNJbnRlZ2VyKGdlbmVyYXRpb25fY29uZmlnLm1heF9sZW5ndGgpICYmIChnZW5lcmF0aW9uX2NvbmZpZy5tYXhfbmV3X3Rva2VucyA/PyBudWxsKSA9PT0gbnVsbDtcbiAgICAgICAgbGV0IHNhbXBsZXIgPSBTYW1wbGVyLmdldFNhbXBsZXIoZ2VuZXJhdGlvbl9jb25maWcpO1xuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IGJlYW1zID0gdGhpcy5nZXRTdGFydEJlYW1zKGlucHV0cywgbnVtT3V0cHV0VG9rZW5zLCBpbnB1dHNfYXR0ZW50aW9uX21hc2spO1xuXG4gICAgICAgIHdoaWxlIChiZWFtcy5zb21lKHggPT4gIXguZG9uZSkgJiYgbnVtT3V0cHV0VG9rZW5zIDwgbWF4T3V0cHV0VG9rZW5zKSB7XG4gICAgICAgICAgICBsZXQgbmV3ZXN0X2JlYW1zID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBiZWFtIG9mIGJlYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJlYW0uZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBiZWFtIGJhY2sgaW50byB0aGUgcG9vbFxuICAgICAgICAgICAgICAgICAgICBuZXdlc3RfYmVhbXMucHVzaChiZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVzZU1heExlbmd0aCAmJiBiZWFtLm91dHB1dF90b2tlbl9pZHMubGVuZ3RoID49IGdlbmVyYXRpb25fY29uZmlnLm1heF9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoaXMgYmVhbSB0byBkb25lIGFuZCBhZGQgaXQgYmFjayBpbnRvIHRoZSBwb29sXG4gICAgICAgICAgICAgICAgICAgIGJlYW0uZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5ld2VzdF9iZWFtcy5wdXNoKGJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gYXdhaXQgdGhpcy5ydW5CZWFtKGJlYW0pO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIGF0dGVudGlvbnMvc2NvcmVzIHRvIGJlYW0gb25seSBpZiB1c2VyIHJlcXVlc3RlZFxuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5vdXRwdXRfYXR0ZW50aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEF0dGVudGlvbnNUb0JlYW0oYmVhbSwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLm91dHB1dF9zY29yZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBhZGRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMb2dpdHMgYXJlIG9mIHRoZSBmb3JtIFtiYXRjaF9zaXplLCBvdXRfc2VxX2xlbmd0aCwgdm9jYWJfc2l6ZV1cbiAgICAgICAgICAgICAgICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIHdpbGwgYmUgW2JhdGNoX3NpemUsIDEsIHZvY2FiX3NpemVdXG4gICAgICAgICAgICAgICAgLy8gU28sIHdlIHNlbGVjdCB0aGUgbGFzdCB0b2tlbidzIGxvZ2l0czpcbiAgICAgICAgICAgICAgICAvLyAoZXF1aXZhbGVudCB0byBgbG9naXRzID0gb3V0cHV0cy5sb2dpdHNbOiwgLTEsIDpdYClcbiAgICAgICAgICAgICAgICBsZXQgbG9naXRzID0gb3V0cHV0LmxvZ2l0cy5zbGljZShudWxsLCAtMSwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBsb2dpdHMgcHJvY2Vzc29yXG4gICAgICAgICAgICAgICAgbG9naXRzX3Byb2Nlc3NvcihiZWFtLm91dHB1dF90b2tlbl9pZHMsIGxvZ2l0cyk7XG5cbiAgICAgICAgICAgICAgICBsZXQgc2FtcGxlZFRva2VucyA9IHNhbXBsZXIobG9naXRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBbbmV3VG9rZW5JZCwgbG9nUHJvYl0gb2Ygc2FtcGxlZFRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgcHJldmlvdXMgYmVhbSBhcyBhIHN0YXJ0aW5nIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdCZWFtID0geyAuLi5iZWFtIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIG5ldyBiZWFtXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCZWFtKG5ld0JlYW0sIG5ld1Rva2VuSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ld0JlYW0uc2NvcmUgKz0gbG9nUHJvYjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VG9rZW5JZCA9PT0gdGhpcy5jb25maWcuZW9zX3Rva2VuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCZWFtLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3ZXN0X2JlYW1zLnB1c2gobmV3QmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytudW1PdXRwdXRUb2tlbnM7XG5cbiAgICAgICAgICAgIC8vIE5leHQsIHdlIGdldCB0aGUgYmVzdCBiZWFtcywgcGVyIElEXG4gICAgICAgICAgICBuZXdlc3RfYmVhbXMgPSB0aGlzLmdyb3VwQmVhbXMobmV3ZXN0X2JlYW1zKS5tYXAoXG4gICAgICAgICAgICAgICAgZ3JvdXAgPT4gZ3JvdXBcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKSAgICAgIC8vIHNvcnQgYnkgc2NvcmVcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIGdlbmVyYXRpb25fY29uZmlnLm51bV9iZWFtcykgIC8vIHJlbW92ZSBvdXRzaWRlIGJlYW0gd2lkdGhcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gYmVhbXNcbiAgICAgICAgICAgIGJlYW1zID0gbmV3ZXN0X2JlYW1zLmZsYXQoKTtcblxuICAgICAgICAgICAgLy8gUnVuIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcuY2FsbGJhY2tfZnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5jYWxsYmFja19mdW5jdGlvbihiZWFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBFbnN1cmUgdGhhdCB3ZSBjYW4gcmV0dXJuIG5vbi1iYXRjaGVkIG91dHB1dHNcblxuICAgICAgICBjb25zdCBncm91cGVkQmVhbXMgPSB0aGlzLmdyb3VwQmVhbXMoYmVhbXMpO1xuXG4gICAgICAgIGNvbnN0IGdldEZsYXR0ZW5lZCA9IChrZXkpID0+IGdyb3VwZWRCZWFtcy5tYXAoXG4gICAgICAgICAgICBiYXRjaCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLm51bV9yZXR1cm5fc2VxdWVuY2VzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2guc2xpY2UoMCwgZ2VuZXJhdGlvbl9jb25maWcubnVtX3JldHVybl9zZXF1ZW5jZXMpLm1hcCh4ID0+IHhba2V5XSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtiYXRjaFswXVtrZXldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICkuZmxhdCgpOyAvLyBGbGF0dGVuIGFjcm9zcyBiYXRjaGVzIChkZXB0aD0xKVxuXG4gICAgICAgIGNvbnN0IHNlcXVlbmNlcyA9IGdldEZsYXR0ZW5lZCgnb3V0cHV0X3Rva2VuX2lkcycpOyAvLyBbMSwgc2VxTGVuZ3RoXVxuXG4gICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5yZXR1cm5fZGljdF9pbl9nZW5lcmF0ZSkge1xuICAgICAgICAgICAgLy8gTk9URTogYGRlY29kZXJfYXR0ZW50aW9uc2AgYW5kIGBjcm9zc19hdHRlbnRpb25zYCBzaG91bGQgYmU6XG4gICAgICAgICAgICAvLyAgICBsaXN0IChvbmUgZWxlbWVudCBmb3IgZWFjaCBnZW5lcmF0ZWQgdG9rZW4pXG4gICAgICAgICAgICAvLyAgICBvZiBsaXN0IChvbmUgZWxlbWVudCBmb3IgZWFjaCBsYXllciBvZiB0aGUgZGVjb2RlcilcbiAgICAgICAgICAgIC8vICAgIG9mIHRvcmNoLkZsb2F0VGVuc29yIG9mIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGdlbmVyYXRlZF9sZW5ndGgsIHNlcXVlbmNlX2xlbmd0aClcbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHdlIGFyZSBvbmx5IGdlbmVyYXRpbmcgb25lIGJhdGNoIGF0IGEgdGltZSwgdGhleSBhcmUgb2YgdGhlIGZvcm06XG4gICAgICAgICAgICAvLyAgIGxpc3QgKGJhdGNoZXMpXG4gICAgICAgICAgICAvLyAgIG9mIGxpc3QgKG9uZSBlbGVtZW50IGZvciBlYWNoIGdlbmVyYXRlZCB0b2tlbilcbiAgICAgICAgICAgIC8vICAgb2YgbGlzdCAob25lIGVsZW1lbnQgZm9yIGVhY2ggbGF5ZXIgb2YgdGhlIGRlY29kZXIpXG4gICAgICAgICAgICAvLyAgIG9mIHRvcmNoLkZsb2F0VGVuc29yIG9mIHNoYXBlICgxLCBudW1faGVhZHMsIGdlbmVyYXRlZF9sZW5ndGgsIHNlcXVlbmNlX2xlbmd0aClcbiAgICAgICAgICAgIC8vIFxuICAgICAgICAgICAgLy8gVE9ETzogSW4gZnV0dXJlICh3aGVuIHRydWUgcGFyYWxsZWxpc20sIHdlIHNob3VsZCBiZSBhYmxlIHRvIHJldHVybiB0aGUgY29ycmVjdCBzaGFwZSlcblxuICAgICAgICAgICAgY29uc3QgZGVjb2Rlcl9hdHRlbnRpb25zID0gZ2V0RmxhdHRlbmVkKCdkZWNvZGVyX2F0dGVudGlvbnMnKTtcbiAgICAgICAgICAgIGNvbnN0IGNyb3NzX2F0dGVudGlvbnMgPSBnZXRGbGF0dGVuZWQoJ2Nyb3NzX2F0dGVudGlvbnMnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZXMsXG5cbiAgICAgICAgICAgICAgICBkZWNvZGVyX2F0dGVudGlvbnMsXG4gICAgICAgICAgICAgICAgY3Jvc3NfYXR0ZW50aW9ucyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZXF1ZW5jZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gYWRkIGF0dGVudGlvbnMgdG8gYmVhbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiZWFtIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXRcbiAgICAgKiBAcHJpdmF0ZSBcbiAgICAgKi9cbiAgICBhZGRBdHRlbnRpb25zVG9CZWFtKGJlYW0sIG91dHB1dCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuaXNfZW5jb2Rlcl9kZWNvZGVyKSB7XG4gICAgICAgICAgICBpZiAoIW91dHB1dC5jcm9zc19hdHRlbnRpb25zIHx8IG91dHB1dC5jcm9zc19hdHRlbnRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcImBvdXRwdXRfYXR0ZW50aW9uc2AgaXMgdHJ1ZSwgYnV0IHRoZSBtb2RlbCBkaWQgbm90IHByb2R1Y2UgY3Jvc3MtYXR0ZW50aW9ucy4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgaXMgbW9zdCBsaWtlbHkgYmVjYXVzZSB0aGUgbW9kZWwgd2FzIG5vdCBleHBvcnRlZCB3aXRoIGBvdXRwdXRfYXR0ZW50aW9ucz1UcnVlYC5cIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYmVhbS5jcm9zc19hdHRlbnRpb25zKSB7XG4gICAgICAgICAgICAgICAgYmVhbS5jcm9zc19hdHRlbnRpb25zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiZWFtLmNyb3NzX2F0dGVudGlvbnMucHVzaChvdXRwdXQuY3Jvc3NfYXR0ZW50aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW91dHB1dC5kZWNvZGVyX2F0dGVudGlvbnMgfHwgb3V0cHV0LmRlY29kZXJfYXR0ZW50aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiYG91dHB1dF9hdHRlbnRpb25zYCBpcyB0cnVlLCBidXQgdGhlIG1vZGVsIGRpZCBub3QgcHJvZHVjZSBkZWNvZGVyLWF0dGVudGlvbnMuIFwiICtcbiAgICAgICAgICAgICAgICBcIlRoaXMgaXMgbW9zdCBsaWtlbHkgYmVjYXVzZSB0aGUgbW9kZWwgd2FzIG5vdCBleHBvcnRlZCB3aXRoIGBvdXRwdXRfYXR0ZW50aW9ucz1UcnVlYC5cIlxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmICghYmVhbS5kZWNvZGVyX2F0dGVudGlvbnMpIHtcbiAgICAgICAgICAgIGJlYW0uZGVjb2Rlcl9hdHRlbnRpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYmVhbS5kZWNvZGVyX2F0dGVudGlvbnMucHVzaChvdXRwdXQuZGVjb2Rlcl9hdHRlbnRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcm91cHMgYW4gYXJyYXkgb2YgYmVhbSBvYmplY3RzIGJ5IHRoZWlyIGlkcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJlYW1zIFRoZSBhcnJheSBvZiBiZWFtIG9iamVjdHMgdG8gZ3JvdXAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBhcnJheXMsIHdoZXJlIGVhY2ggaW5uZXIgYXJyYXkgY29udGFpbnMgYmVhbSBvYmplY3RzIHdpdGggdGhlIHNhbWUgaWQuXG4gICAgICovXG4gICAgZ3JvdXBCZWFtcyhiZWFtcykge1xuICAgICAgICAvLyBHcm91cCBiZWFtcyBieSB0aGVpciBpZHNcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChjb25zdCBvYmogb2YgYmVhbXMpIHtcbiAgICAgICAgICAgIGlmIChncm91cHNbb2JqLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW29iai5pZF0gPSBbb2JqXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW29iai5pZF0ucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZ3JvdXBzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHBhc3Qga2V5IHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBkZWNvZGVyIHJlc3VsdHMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY29kZXJSZXN1bHRzIFRoZSBkZWNvZGVyIHJlc3VsdHMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXN0S2V5VmFsdWVzIFRoZSBwcmV2aW91cyBwYXN0IGtleSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFzdCBrZXkgdmFsdWVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0UGFzdEtleVZhbHVlcyhkZWNvZGVyUmVzdWx0cywgcGFzdEtleVZhbHVlcykge1xuXG4gICAgICAgIGNvbnN0IHBrdnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWNvZGVyUmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgncHJlc2VudCcpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld05hbWUgPSBuYW1lLnJlcGxhY2UoJ3ByZXNlbnQnLCAncGFzdF9rZXlfdmFsdWVzJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFzdEtleVZhbHVlcyAmJiBuYW1lLmluY2x1ZGVzKCdlbmNvZGVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uIGludHJvZHVjZWQgYnkgb3B0aW11bSB0byByZXVzZSBwYXN0IGtleSB2YWx1ZXMuIFNvLCB3ZSBqdXN0IHJlcGxhY2UgdGhlIGNvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgIC8vIG91dHB1dHMgd2l0aCB0aGUgcHJldmlvdXMgcGFzdCBrZXkgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaHVnZ2luZ2ZhY2Uvb3B0aW11bS9ibG9iLzBiZjJjMDVmYjdlMTE4MmI1MmQyMWI3MDNjZmM5NWZkOWU0ZWEzZGMvb3B0aW11bS9vbm54cnVudGltZS9iYXNlLnB5I0w2NzctTDcwNFxuICAgICAgICAgICAgICAgICAgICBwa3ZzW25ld05hbWVdID0gcGFzdEtleVZhbHVlc1tuZXdOYW1lXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwa3ZzW25ld05hbWVdID0gZGVjb2RlclJlc3VsdHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwa3ZzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYXR0ZW50aW9ucyBmcm9tIHRoZSBnaXZlbiBkZWNvZGVyIHJlc3VsdHMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY29kZXJSZXN1bHRzIFRoZSBkZWNvZGVyIHJlc3VsdHMgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIGF0dGVudGlvbnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRBdHRlbnRpb25zKGRlY29kZXJSZXN1bHRzKSB7XG4gICAgICAgIGNvbnN0IGF0dG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGF0dG5OYW1lIG9mIFsnY3Jvc3NfYXR0ZW50aW9ucycsICdkZWNvZGVyX2F0dGVudGlvbnMnXSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVjb2RlclJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKGF0dG5OYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG5hbWUuc3BsaXQoJy4nKS5wb3AoKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gZGVjb2RlclJlc3VsdHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0bnNbYXR0bk5hbWVdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHBhc3Qga2V5IHZhbHVlcyB0byB0aGUgZGVjb2RlciBmZWVkcyBvYmplY3QuIElmIHBhc3RLZXlWYWx1ZXMgaXMgbnVsbCwgY3JlYXRlcyBuZXcgdGVuc29ycyBmb3IgcGFzdCBrZXkgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY29kZXJGZWVkcyBUaGUgZGVjb2RlciBmZWVkcyBvYmplY3QgdG8gYWRkIHBhc3Qga2V5IHZhbHVlcyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFzdEtleVZhbHVlcyBBbiBvYmplY3QgY29udGFpbmluZyBwYXN0IGtleSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaGFzRGVjb2Rlcj1mYWxzZV0gV2hldGhlciB0aGUgbW9kZWwgaGFzIGEgZGVjb2Rlci5cbiAgICAgKi9cbiAgICBhZGRQYXN0S2V5VmFsdWVzKGRlY29kZXJGZWVkcywgcGFzdEtleVZhbHVlcywgaGFzRGVjb2RlciA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChwYXN0S2V5VmFsdWVzKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRlY29kZXJGZWVkcywgcGFzdEtleVZhbHVlcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE8gc3VwcG9ydCBiYXRjaGVzIChpLmUuLCBiYXRjaF9zaXplID4gMSlcbiAgICAgICAgICAgIGlmIChoYXNEZWNvZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGxldCBlbmNvZGVyX2RpbXMgPSBbMSwgdGhpcy5udW1fZW5jb2Rlcl9oZWFkcywgMCwgdGhpcy5lbmNvZGVyX2RpbV9rdl07XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1fZW5jb2Rlcl9sYXllcnM7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVyRmVlZHNbYHBhc3Rfa2V5X3ZhbHVlcy4ke2l9LmVuY29kZXIua2V5YF0gPSBuZXcgVGVuc29yKCdmbG9hdDMyJywgW10sIGVuY29kZXJfZGltcylcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlckZlZWRzW2BwYXN0X2tleV92YWx1ZXMuJHtpfS5lbmNvZGVyLnZhbHVlYF0gPSBuZXcgVGVuc29yKCdmbG9hdDMyJywgW10sIGVuY29kZXJfZGltcylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgbGV0IGRlY29kZXJfZGltcyA9IFsxLCB0aGlzLm51bV9kZWNvZGVyX2hlYWRzLCAwLCB0aGlzLmRlY29kZXJfZGltX2t2XTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bV9kZWNvZGVyX2xheWVyczsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXJGZWVkc1tgcGFzdF9rZXlfdmFsdWVzLiR7aX0uZGVjb2Rlci5rZXlgXSA9IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBbXSwgZGVjb2Rlcl9kaW1zKVxuICAgICAgICAgICAgICAgICAgICBkZWNvZGVyRmVlZHNbYHBhc3Rfa2V5X3ZhbHVlcy4ke2l9LmRlY29kZXIudmFsdWVgXSA9IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBbXSwgZGVjb2Rlcl9kaW1zKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubXVsdGlfcXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBsZXQgZGltcyA9IFsxLCAwLCAyICogdGhpcy5kaW1fa3ZdXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bV9sYXllcnM7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlckZlZWRzW2BwYXN0X2tleV92YWx1ZXMuJHtpfS5rZXlfdmFsdWVgXSA9IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBbXSwgZGltcylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpbXMgPSBbMSwgdGhpcy5udW1faGVhZHMsIDAsIHRoaXMuZGltX2t2XVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1fbGF5ZXJzOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZXJGZWVkc1tgcGFzdF9rZXlfdmFsdWVzLiR7aX0ua2V5YF0gPSBuZXcgVGVuc29yKCdmbG9hdDMyJywgW10sIGRpbXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVyRmVlZHNbYHBhc3Rfa2V5X3ZhbHVlcy4ke2l9LnZhbHVlYF0gPSBuZXcgVGVuc29yKCdmbG9hdDMyJywgW10sIGRpbXMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQmFzZSBtb2RlbCBvdXRwdXQgY2xhc3NcbmV4cG9ydCBjbGFzcyBNb2RlbE91dHB1dCB7IH1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBtb2RlbCdzIG91dHB1dHMsIHdpdGggcG90ZW50aWFsIGhpZGRlbiBzdGF0ZXMgYW5kIGF0dGVudGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlTW9kZWxPdXRwdXQgZXh0ZW5kcyBNb2RlbE91dHB1dCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dCBUaGUgb3V0cHV0IG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0Lmxhc3RfaGlkZGVuX3N0YXRlIFNlcXVlbmNlIG9mIGhpZGRlbi1zdGF0ZXMgYXQgdGhlIG91dHB1dCBvZiB0aGUgbGFzdCBsYXllciBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IFtvdXRwdXQuaGlkZGVuX3N0YXRlc10gSGlkZGVuLXN0YXRlcyBvZiB0aGUgbW9kZWwgYXQgdGhlIG91dHB1dCBvZiBlYWNoIGxheWVyIHBsdXMgdGhlIG9wdGlvbmFsIGluaXRpYWwgZW1iZWRkaW5nIG91dHB1dHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IFtvdXRwdXQuYXR0ZW50aW9uc10gQXR0ZW50aW9ucyB3ZWlnaHRzIGFmdGVyIHRoZSBhdHRlbnRpb24gc29mdG1heCwgdXNlZCB0byBjb21wdXRlIHRoZSB3ZWlnaHRlZCBhdmVyYWdlIGluIHRoZSBzZWxmLWF0dGVudGlvbiBoZWFkcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGxhc3RfaGlkZGVuX3N0YXRlLCBoaWRkZW5fc3RhdGVzID0gbnVsbCwgYXR0ZW50aW9ucyA9IG51bGwgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxhc3RfaGlkZGVuX3N0YXRlID0gbGFzdF9oaWRkZW5fc3RhdGU7XG4gICAgICAgIHRoaXMuaGlkZGVuX3N0YXRlcyA9IGhpZGRlbl9zdGF0ZXM7XG4gICAgICAgIHRoaXMuYXR0ZW50aW9ucyA9IGF0dGVudGlvbnM7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEJlcnQgbW9kZWxzXG5leHBvcnQgY2xhc3MgQmVydFByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBCZXJ0TW9kZWwgZXh0ZW5kcyBCZXJ0UHJlVHJhaW5lZE1vZGVsIHsgfVxuXG4vKipcbiAqIEJlcnRGb3JNYXNrZWRMTSBpcyBhIGNsYXNzIHJlcHJlc2VudGluZyBhIEJFUlQgbW9kZWwgZm9yIG1hc2tlZCBsYW5ndWFnZSBtb2RlbGluZy5cbiAqIEBleHRlbmRzIEJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJlcnRGb3JNYXNrZWRMTSBleHRlbmRzIEJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNYXNrZWRMTU91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIG1hc2tlZCBsYW5ndWFnZSBtb2RlbGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXNrZWRMTU91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBCRVJUIG1vZGVsIGZvciBzZXF1ZW5jZSBjbGFzc2lmaWNhdGlvbi5cbiAqIEBleHRlbmRzIEJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJlcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHNlcXVlbmNlIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQmVydEZvclRva2VuQ2xhc3NpZmljYXRpb24gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBCRVJUIG1vZGVsIGZvciB0b2tlbiBjbGFzc2lmaWNhdGlvbi5cbiAqIEBleHRlbmRzIEJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJlcnRGb3JUb2tlbkNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuQ2xhc3NpZmllck91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHRva2VuIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQmVydEZvclF1ZXN0aW9uQW5zd2VyaW5nIGlzIGEgY2xhc3MgcmVwcmVzZW50aW5nIGEgQkVSVCBtb2RlbCBmb3IgcXVlc3Rpb24gYW5zd2VyaW5nLlxuICogQGV4dGVuZHMgQmVydFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgQmVydEZvclF1ZXN0aW9uQW5zd2VyaW5nIGV4dGVuZHMgQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQ+fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbW9kZWwncyBvdXRwdXQgbG9naXRzIGZvciBxdWVzdGlvbiBhbnN3ZXJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRGlzdGlsQmVydCBtb2RlbHNcbmV4cG9ydCBjbGFzcyBEaXN0aWxCZXJ0UHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIERpc3RpbEJlcnRNb2RlbCBleHRlbmRzIERpc3RpbEJlcnRQcmVUcmFpbmVkTW9kZWwgeyB9XG5cbi8qKlxuICogRGlzdGlsQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBEaXN0aWxCRVJUIG1vZGVsIGZvciBzZXF1ZW5jZSBjbGFzc2lmaWNhdGlvbi5cbiAqIEBleHRlbmRzIERpc3RpbEJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIERpc3RpbEJlcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgRGlzdGlsQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHNlcXVlbmNlIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogRGlzdGlsQmVydEZvclRva2VuQ2xhc3NpZmljYXRpb24gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBEaXN0aWxCRVJUIG1vZGVsIGZvciB0b2tlbiBjbGFzc2lmaWNhdGlvbi5cbiAqIEBleHRlbmRzIERpc3RpbEJlcnRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIERpc3RpbEJlcnRGb3JUb2tlbkNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgRGlzdGlsQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuQ2xhc3NpZmllck91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHRva2VuIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBEaXN0aWxCZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmcgaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBEaXN0aWxCRVJUIG1vZGVsIGZvciBxdWVzdGlvbiBhbnN3ZXJpbmcuXG4gKiBAZXh0ZW5kcyBEaXN0aWxCZXJ0UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBEaXN0aWxCZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmcgZXh0ZW5kcyBEaXN0aWxCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHF1ZXN0aW9uIGFuc3dlcmluZy5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEaXN0aWxCZXJ0Rm9yTWFza2VkTE0gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBEaXN0aWxCRVJUIG1vZGVsIGZvciBtYXNraW5nIHRhc2suXG4gKiBAZXh0ZW5kcyBEaXN0aWxCZXJ0UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBEaXN0aWxCZXJ0Rm9yTWFza2VkTE0gZXh0ZW5kcyBEaXN0aWxCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TWFza2VkTE1PdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXNrZWRMTU91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBNb2JpbGVCZXJ0IG1vZGVsc1xuZXhwb3J0IGNsYXNzIE1vYmlsZUJlcnRQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgTW9iaWxlQmVydE1vZGVsIGV4dGVuZHMgTW9iaWxlQmVydFByZVRyYWluZWRNb2RlbCB7IH1cblxuLyoqXG4gKiBNb2JpbGVCZXJ0Rm9yTWFza2VkTE0gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBNb2JpbGVCRVJUIG1vZGVsIGZvciBtYXNraW5nIHRhc2suXG4gKiBAZXh0ZW5kcyBNb2JpbGVCZXJ0UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2JpbGVCZXJ0Rm9yTWFza2VkTE0gZXh0ZW5kcyBNb2JpbGVCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TWFza2VkTE1PdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXNrZWRMTU91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGV4dGVuZHMgTW9iaWxlQmVydFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgTW9iaWxlQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBNb2JpbGVCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZXh0ZW5kcyBNb2JpbGVCZXJ0UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2JpbGVCZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmcgZXh0ZW5kcyBNb2JpbGVCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1QTmV0IG1vZGVsc1xuZXhwb3J0IGNsYXNzIE1QTmV0UHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuXG4vKipcbiAqIFRoZSBiYXJlIE1QTmV0IE1vZGVsIHRyYW5zZm9ybWVyIG91dHB1dHRpbmcgcmF3IGhpZGRlbi1zdGF0ZXMgd2l0aG91dCBhbnkgc3BlY2lmaWMgaGVhZCBvbiB0b3AuXG4gKiBAZXh0ZW5kcyBNUE5ldFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgTVBOZXRNb2RlbCBleHRlbmRzIE1QTmV0UHJlVHJhaW5lZE1vZGVsIHsgfVxuXG4vKipcbiAqIE1QTmV0Rm9yTWFza2VkTE0gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBNUE5ldCBtb2RlbCBmb3IgbWFza2VkIGxhbmd1YWdlIG1vZGVsaW5nLlxuICogQGV4dGVuZHMgTVBOZXRQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIE1QTmV0Rm9yTWFza2VkTE0gZXh0ZW5kcyBNUE5ldFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1hc2tlZExNT3V0cHV0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsJ3Mgb3V0cHV0IGxvZ2l0cyBmb3IgbWFza2VkIGxhbmd1YWdlIG1vZGVsaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IE1hc2tlZExNT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBNUE5ldEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gaXMgYSBjbGFzcyByZXByZXNlbnRpbmcgYSBNUE5ldCBtb2RlbCBmb3Igc2VxdWVuY2UgY2xhc3NpZmljYXRpb24uXG4gKiBAZXh0ZW5kcyBNUE5ldFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgTVBOZXRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgTVBOZXRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQ+fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbW9kZWwncyBvdXRwdXQgbG9naXRzIGZvciBzZXF1ZW5jZSBjbGFzc2lmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIE1QTmV0Rm9yVG9rZW5DbGFzc2lmaWNhdGlvbiBpcyBhIGNsYXNzIHJlcHJlc2VudGluZyBhIE1QTmV0IG1vZGVsIGZvciB0b2tlbiBjbGFzc2lmaWNhdGlvbi5cbiAqIEBleHRlbmRzIE1QTmV0UHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBNUE5ldEZvclRva2VuQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBNUE5ldFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuQ2xhc3NpZmllck91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHRva2VuIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogTVBOZXRGb3JRdWVzdGlvbkFuc3dlcmluZyBpcyBhIGNsYXNzIHJlcHJlc2VudGluZyBhIE1QTmV0IG1vZGVsIGZvciBxdWVzdGlvbiBhbnN3ZXJpbmcuXG4gKiBAZXh0ZW5kcyBNUE5ldFByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgTVBOZXRGb3JRdWVzdGlvbkFuc3dlcmluZyBleHRlbmRzIE1QTmV0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHF1ZXN0aW9uIGFuc3dlcmluZy5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFNxdWVlemVCZXJ0IG1vZGVsc1xuZXhwb3J0IGNsYXNzIFNxdWVlemVCZXJ0UHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIFNxdWVlemVCZXJ0TW9kZWwgZXh0ZW5kcyBTcXVlZXplQmVydFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBTcXVlZXplQmVydEZvck1hc2tlZExNIGV4dGVuZHMgU3F1ZWV6ZUJlcnRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNYXNrZWRMTU91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IE1hc2tlZExNT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTcXVlZXplQmVydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBTcXVlZXplQmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3F1ZWV6ZUJlcnRGb3JRdWVzdGlvbkFuc3dlcmluZyBleHRlbmRzIFNxdWVlemVCZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dD59IHJldHVybmVkIG9iamVjdFxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQWxiZXJ0IG1vZGVsc1xuZXhwb3J0IGNsYXNzIEFsYmVydFByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBBbGJlcnRNb2RlbCBleHRlbmRzIEFsYmVydFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBBbGJlcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgQWxiZXJ0UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBbGJlcnRGb3JRdWVzdGlvbkFuc3dlcmluZyBleHRlbmRzIEFsYmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBbGJlcnRGb3JNYXNrZWRMTSBleHRlbmRzIEFsYmVydFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1hc2tlZExNT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFza2VkTE1PdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVDUgbW9kZWxzXG5leHBvcnQgY2xhc3MgVDVQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9O1xuXG5leHBvcnQgY2xhc3MgVDVNb2RlbCBleHRlbmRzIFQ1UHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGV4dCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgYXMgdGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKFQ1TW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJUaGUgY3VycmVudCBtb2RlbCBjbGFzcyAoVDVNb2RlbCkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLCBhcyBpdCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGNsYXNzZXMgaW5zdGVhZDogeydUNUZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbid9XCJcbiAgICAgICAgKVxuICAgIH1cbn1cblxuLyoqXG4gKiBUNU1vZGVsIGlzIGEgY2xhc3MgcmVwcmVzZW50aW5nIGEgVDUgbW9kZWwgZm9yIGNvbmRpdGlvbmFsIGdlbmVyYXRpb24uXG4gKiBAZXh0ZW5kcyBUNVByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgVDVGb3JDb25kaXRpb25hbEdlbmVyYXRpb24gZXh0ZW5kcyBUNVByZVRyYWluZWRNb2RlbCB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgVDVGb3JDb25kaXRpb25hbEdlbmVyYXRpb25gIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIG1vZGVsIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHthbnl9IHNlc3Npb24gc2Vzc2lvbiBmb3IgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7YW55fSBkZWNvZGVyX21lcmdlZF9zZXNzaW9uIHNlc3Npb24gZm9yIHRoZSBkZWNvZGVyLlxuICAgICAqIEBwYXJhbSB7R2VuZXJhdGlvbkNvbmZpZ30gZ2VuZXJhdGlvbl9jb25maWcgVGhlIGdlbmVyYXRpb24gY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNlc3Npb24sIGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24sIGdlbmVyYXRpb25fY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiA9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb247XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbl9jb25maWcgPSBnZW5lcmF0aW9uX2NvbmZpZztcblxuICAgICAgICB0aGlzLm51bV9kZWNvZGVyX2xheWVycyA9IHRoaXMuY29uZmlnLm51bV9kZWNvZGVyX2xheWVycztcbiAgICAgICAgdGhpcy5udW1fZGVjb2Rlcl9oZWFkcyA9IHRoaXMuY29uZmlnLm51bV9oZWFkcztcbiAgICAgICAgdGhpcy5kZWNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfa3Y7XG5cbiAgICAgICAgdGhpcy5udW1fZW5jb2Rlcl9sYXllcnMgPSB0aGlzLmNvbmZpZy5udW1fbGF5ZXJzO1xuICAgICAgICB0aGlzLm51bV9lbmNvZGVyX2hlYWRzID0gdGhpcy5jb25maWcubnVtX2hlYWRzO1xuICAgICAgICB0aGlzLmVuY29kZXJfZGltX2t2ID0gdGhpcy5jb25maWcuZF9rdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHN0YXJ0IGJlYW1zIGZvciBhIGdpdmVuIHNldCBvZiBpbnB1dHMgYW5kIG91dHB1dCBsZW5ndGguXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBpbnB1dHMgVGhlIGlucHV0IHRva2VuIElEcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtT3V0cHV0VG9rZW5zIFRoZSBkZXNpcmVkIG91dHB1dCBsZW5ndGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgc3RhcnQgYmVhbXMuXG4gICAgICovXG4gICAgZ2V0U3RhcnRCZWFtcyhpbnB1dHMsIG51bU91dHB1dFRva2VucywgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc2VxMnNlcVN0YXJ0QmVhbXModGhpcywgaW5wdXRzLCBudW1PdXRwdXRUb2tlbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBzaW5nbGUgc3RlcCBvZiB0aGUgYmVhbSBzZWFyY2ggZ2VuZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGN1cnJlbnQgYmVhbSBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIHVwZGF0ZWQgYmVhbSBhZnRlciBhIHNpbmdsZSBnZW5lcmF0aW9uIHN0ZXAuXG4gICAgICovXG4gICAgYXN5bmMgcnVuQmVhbShiZWFtKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZXEyc2VxUnVuQmVhbSh0aGlzLCBiZWFtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnaXZlbiBiZWFtIHdpdGggYSBuZXcgdG9rZW4gSUQuXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGN1cnJlbnQgYmVhbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VG9rZW5JZCBUaGUgbmV3IHRva2VuIElEIHRvIGFkZCB0byB0aGUgb3V0cHV0IHNlcXVlbmNlLlxuICAgICAqL1xuICAgIHVwZGF0ZUJlYW0oYmVhbSwgbmV3VG9rZW5JZCkge1xuICAgICAgICBiZWFtLm91dHB1dF90b2tlbl9pZHMgPSBbLi4uYmVhbS5vdXRwdXRfdG9rZW5faWRzLCBuZXdUb2tlbklkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBmb3J3YXJkIHBhc3Mgb2YgdGhlIG1vZGVsIGZvciBhIGdpdmVuIHNldCBvZiBpbnB1dHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgbW9kZWwgaW5wdXRzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSBtb2RlbCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1UNSBtb2RlbHNcbmV4cG9ydCBjbGFzcyBNVDVQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9O1xuXG5leHBvcnQgY2xhc3MgTVQ1TW9kZWwgZXh0ZW5kcyBNVDVQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKE1UNU1vZGVsKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAsIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgY2xhc3NlcyBpbnN0ZWFkOiB7J01UNUZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbid9XCJcbiAgICAgICAgKVxuICAgIH1cbn1cblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIGNvbmRpdGlvbmFsIHNlcXVlbmNlLXRvLXNlcXVlbmNlIG1vZGVsIGJhc2VkIG9uIHRoZSBNVDUgYXJjaGl0ZWN0dXJlLlxuICpcbiAqIEBleHRlbmRzIE1UNVByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgTVQ1Rm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uIGV4dGVuZHMgTVQ1UHJlVHJhaW5lZE1vZGVsIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBNVDVGb3JDb25kaXRpb25hbEdlbmVyYXRpb25gIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7YW55fSBjb25maWcgVGhlIG1vZGVsIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHthbnl9IHNlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiBjb250YWluaW5nIHRoZSBlbmNvZGVyIHdlaWdodHMuXG4gICAgICogQHBhcmFtIHthbnl9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiBjb250YWluaW5nIHRoZSBtZXJnZWQgZGVjb2RlciB3ZWlnaHRzLlxuICAgICAqIEBwYXJhbSB7R2VuZXJhdGlvbkNvbmZpZ30gZ2VuZXJhdGlvbl9jb25maWcgVGhlIGdlbmVyYXRpb24gY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNlc3Npb24sIGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24sIGdlbmVyYXRpb25fY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiA9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb247XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbl9jb25maWcgPSBnZW5lcmF0aW9uX2NvbmZpZztcblxuICAgICAgICB0aGlzLm51bV9kZWNvZGVyX2xheWVycyA9IHRoaXMuY29uZmlnLm51bV9kZWNvZGVyX2xheWVycztcbiAgICAgICAgdGhpcy5udW1fZGVjb2Rlcl9oZWFkcyA9IHRoaXMuY29uZmlnLm51bV9oZWFkcztcbiAgICAgICAgdGhpcy5kZWNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfa3Y7XG5cbiAgICAgICAgdGhpcy5udW1fZW5jb2Rlcl9sYXllcnMgPSB0aGlzLmNvbmZpZy5udW1fbGF5ZXJzO1xuICAgICAgICB0aGlzLm51bV9lbmNvZGVyX2hlYWRzID0gdGhpcy5jb25maWcubnVtX2hlYWRzO1xuICAgICAgICB0aGlzLmVuY29kZXJfZGltX2t2ID0gdGhpcy5jb25maWcuZF9rdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBzdGFydCBiZWFtcyBmb3IgdGhlIGdpdmVuIGlucHV0IHRva2VucyBhbmQgb3V0cHV0IHNlcXVlbmNlIGxlbmd0aC5cbiAgICpcbiAgICogQHBhcmFtIHthbnlbXX0gaW5wdXRzIFRoZSBpbnB1dCBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBUaGUgZGVzaXJlZCBsZW5ndGggb2YgdGhlIG91dHB1dCBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGBzZXEyc2VxU3RhcnRCZWFtc2AgZnVuY3Rpb24uXG4gICAqIEByZXR1cm5zIHthbnlbXX0gQW4gYXJyYXkgb2YgYEJlYW1gIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBzdGFydCBiZWFtcy5cbiAgICovXG4gICAgZ2V0U3RhcnRCZWFtcyhpbnB1dHMsIG51bU91dHB1dFRva2VucywgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc2VxMnNlcVN0YXJ0QmVhbXModGhpcywgaW5wdXRzLCBudW1PdXRwdXRUb2tlbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBzaW5nbGUgc3RlcCBvZiB0aGUgYmVhbSBzZWFyY2ggZ2VuZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGN1cnJlbnQgYmVhbSBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIHVwZGF0ZWQgYmVhbSBhZnRlciBhIHNpbmdsZSBnZW5lcmF0aW9uIHN0ZXAuXG4gICAgICovXG4gICAgYXN5bmMgcnVuQmVhbShiZWFtKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZXEyc2VxUnVuQmVhbSh0aGlzLCBiZWFtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnaXZlbiBiZWFtIHdpdGggdGhlIG5ldyBwcmVkaWN0ZWQgdG9rZW4uXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGJlYW0gdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdUb2tlbklkIFRoZSBpbmRleCBvZiB0aGUgcHJlZGljdGVkIHRva2VuLlxuICAgICovXG4gICAgdXBkYXRlQmVhbShiZWFtLCBuZXdUb2tlbklkKSB7XG4gICAgICAgIGJlYW0ub3V0cHV0X3Rva2VuX2lkcyA9IFsuLi5iZWFtLm91dHB1dF90b2tlbl9pZHMsIG5ld1Rva2VuSWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogUnVucyB0aGUgZm9yd2FyZCBwYXNzIG9mIHRoZSBtb2RlbCBvbiB0aGUgZ2l2ZW4gaW5wdXRzLlxuICAgICogQHBhcmFtIHthbnl9IG1vZGVsX2lucHV0cyBUaGUgbW9kZWwgaW5wdXRzLlxuICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG1vZGVsIG91dHB1dHMuXG4gICAgKi9cbiAgICBhc3luYyBmb3J3YXJkKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcUZvcndhcmQodGhpcywgbW9kZWxfaW5wdXRzKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQmFydCBtb2RlbHNcbmV4cG9ydCBjbGFzcyBCYXJ0UHJldHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfTtcblxuLyoqXG4gKiBCQVJUIGVuY29kZXIgYW5kIGRlY29kZXIgbW9kZWwuXG4gKiBcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEJhcnRQcmV0cmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJhcnRNb2RlbCBleHRlbmRzIEJhcnRQcmV0cmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBiZWNhdXNlIHRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChCYXJ0TW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYC5cbiAgICAgKiBcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKEJhcnRNb2RlbCkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKEJhcnRNb2RlbCkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLCBhcyBpdCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGNsYXNzZXMgaW5zdGVhZDogeydCYXJ0Rm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uJ31cIlxuICAgICAgICApXG4gICAgfVxufVxuXG4vKipcbiAqIEJBUlQgbW9kZWwgd2l0aCBhIGxhbmd1YWdlIG1vZGVsIGhlYWQgZm9yIGNvbmRpdGlvbmFsIGdlbmVyYXRpb24uXG4gKiBAZXh0ZW5kcyBCYXJ0UHJldHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXJ0Rm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uIGV4dGVuZHMgQmFydFByZXRyYWluZWRNb2RlbCB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgQmFydEZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbmAgY2xhc3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBCYXJ0IG1vZGVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uIFRoZSBPTk5YIHNlc3Npb24gdXNlZCB0byBleGVjdXRlIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiBUaGUgT05OWCBzZXNzaW9uIHVzZWQgdG8gZXhlY3V0ZSB0aGUgZGVjb2Rlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2VuZXJhdGlvbl9jb25maWcgVGhlIGdlbmVyYXRpb24gY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzZXNzaW9uLCBkZWNvZGVyX21lcmdlZF9zZXNzaW9uLCBnZW5lcmF0aW9uX2NvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcsIHNlc3Npb24pO1xuICAgICAgICB0aGlzLmRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gPSBkZWNvZGVyX21lcmdlZF9zZXNzaW9uO1xuICAgICAgICB0aGlzLmdlbmVyYXRpb25fY29uZmlnID0gZ2VuZXJhdGlvbl9jb25maWc7XG5cbiAgICAgICAgdGhpcy5udW1fZGVjb2Rlcl9sYXllcnMgPSB0aGlzLmNvbmZpZy5kZWNvZGVyX2xheWVycztcbiAgICAgICAgdGhpcy5udW1fZGVjb2Rlcl9oZWFkcyA9IHRoaXMuY29uZmlnLmRlY29kZXJfYXR0ZW50aW9uX2hlYWRzO1xuICAgICAgICB0aGlzLmRlY29kZXJfZGltX2t2ID0gdGhpcy5jb25maWcuZF9tb2RlbCAvIHRoaXMubnVtX2RlY29kZXJfaGVhZHM7XG5cbiAgICAgICAgdGhpcy5udW1fZW5jb2Rlcl9sYXllcnMgPSB0aGlzLmNvbmZpZy5lbmNvZGVyX2xheWVycztcbiAgICAgICAgdGhpcy5udW1fZW5jb2Rlcl9oZWFkcyA9IHRoaXMuY29uZmlnLmVuY29kZXJfYXR0ZW50aW9uX2hlYWRzO1xuICAgICAgICB0aGlzLmVuY29kZXJfZGltX2t2ID0gdGhpcy5jb25maWcuZF9tb2RlbCAvIHRoaXMubnVtX2VuY29kZXJfaGVhZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5pdGlhbCBiZWFtIGZvciBnZW5lcmF0aW5nIG91dHB1dCB0ZXh0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dHMgVGhlIGlucHV0IG9iamVjdCBjb250YWluaW5nIHRoZSBlbmNvZGVkIGlucHV0IHRleHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygb3V0cHV0IHRva2VucyB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgc2VxdWVuY2UtdG8tc2VxdWVuY2UgZ2VuZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7YW55fSBUaGUgaW5pdGlhbCBiZWFtIGZvciBnZW5lcmF0aW5nIG91dHB1dCB0ZXh0LlxuICAgICAqL1xuICAgIGdldFN0YXJ0QmVhbXMoaW5wdXRzLCBudW1PdXRwdXRUb2tlbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHNlcTJzZXFTdGFydEJlYW1zKHRoaXMsIGlucHV0cywgbnVtT3V0cHV0VG9rZW5zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2luZ2xlIHN0ZXAgb2YgdGhlIGJlYW0gc2VhcmNoIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB1cGRhdGVkIGJlYW0gYWZ0ZXIgYSBzaW5nbGUgZ2VuZXJhdGlvbiBzdGVwLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkJlYW0oYmVhbSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgc2VxMnNlcVJ1bkJlYW0odGhpcywgYmVhbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYmVhbSBieSBhcHBlbmRpbmcgdGhlIG5ld2x5IGdlbmVyYXRlZCB0b2tlbiBJRCB0byB0aGUgbGlzdCBvZiBvdXRwdXQgdG9rZW4gSURzLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdUb2tlbklkIFRoZSBJRCBvZiB0aGUgbmV3bHkgZ2VuZXJhdGVkIHRva2VuIHRvIGFwcGVuZCB0byB0aGUgbGlzdCBvZiBvdXRwdXQgdG9rZW4gSURzLlxuICAgICAqL1xuICAgIHVwZGF0ZUJlYW0oYmVhbSwgbmV3VG9rZW5JZCkge1xuICAgICAgICBiZWFtLm91dHB1dF90b2tlbl9pZHMgPSBbLi4uYmVhbS5vdXRwdXRfdG9rZW5faWRzLCBuZXdUb2tlbklkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBmb3J3YXJkIHBhc3Mgb2YgdGhlIG1vZGVsIGZvciBhIGdpdmVuIHNldCBvZiBpbnB1dHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgbW9kZWwgaW5wdXRzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSBtb2RlbCBvdXRwdXQuXG4gICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmFydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBCYXJ0UHJldHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsJ3Mgb3V0cHV0IGxvZ2l0cyBmb3Igc2VxdWVuY2UgY2xhc3NpZmljYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFJvYmVydGEgbW9kZWxzXG5leHBvcnQgY2xhc3MgUm9iZXJ0YVByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBSb2JlcnRhTW9kZWwgZXh0ZW5kcyBSb2JlcnRhUHJlVHJhaW5lZE1vZGVsIHsgfVxuXG4vKipcbiAqIFJvYmVydGFGb3JNYXNrZWRMTSBjbGFzcyBmb3IgcGVyZm9ybWluZyBtYXNrZWQgbGFuZ3VhZ2UgbW9kZWxpbmcgb24gUm9iZXJ0YSBtb2RlbHMuXG4gKiBAZXh0ZW5kcyBSb2JlcnRhUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBSb2JlcnRhRm9yTWFza2VkTE0gZXh0ZW5kcyBSb2JlcnRhUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8TWFza2VkTE1PdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXNrZWRMTU91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogUm9iZXJ0YUZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gY2xhc3MgZm9yIHBlcmZvcm1pbmcgc2VxdWVuY2UgY2xhc3NpZmljYXRpb24gb24gUm9iZXJ0YSBtb2RlbHMuXG4gKiBAZXh0ZW5kcyBSb2JlcnRhUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBSb2JlcnRhRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiBleHRlbmRzIFJvYmVydGFQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJvYmVydGFGb3JUb2tlbkNsYXNzaWZpY2F0aW9uIGNsYXNzIGZvciBwZXJmb3JtaW5nIHRva2VuIGNsYXNzaWZpY2F0aW9uIG9uIFJvYmVydGEgbW9kZWxzLlxuICogQGV4dGVuZHMgUm9iZXJ0YVByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgUm9iZXJ0YUZvclRva2VuQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBSb2JlcnRhUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VG9rZW5DbGFzc2lmaWVyT3V0cHV0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1vZGVsJ3Mgb3V0cHV0IGxvZ2l0cyBmb3IgdG9rZW4gY2xhc3NpZmljYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5DbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSb2JlcnRhRm9yUXVlc3Rpb25BbnN3ZXJpbmcgY2xhc3MgZm9yIHBlcmZvcm1pbmcgcXVlc3Rpb24gYW5zd2VyaW5nIG9uIFJvYmVydGEgbW9kZWxzLlxuICogQGV4dGVuZHMgUm9iZXJ0YVByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgUm9iZXJ0YUZvclF1ZXN0aW9uQW5zd2VyaW5nIGV4dGVuZHMgUm9iZXJ0YVByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFF1ZXN0aW9uQW5zd2VyaW5nTW9kZWxPdXRwdXQ+fSByZXR1cm5lZCBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBYTE1Sb2JlcnRhIG1vZGVsc1xuZXhwb3J0IGNsYXNzIFhMTVJvYmVydGFQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgWExNUm9iZXJ0YU1vZGVsIGV4dGVuZHMgWExNUm9iZXJ0YVByZVRyYWluZWRNb2RlbCB7IH1cblxuLyoqXG4gKiBYTE1Sb2JlcnRhRm9yTWFza2VkTE0gY2xhc3MgZm9yIHBlcmZvcm1pbmcgbWFza2VkIGxhbmd1YWdlIG1vZGVsaW5nIG9uIFhMTVJvYmVydGEgbW9kZWxzLlxuICogQGV4dGVuZHMgWExNUm9iZXJ0YVByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgWExNUm9iZXJ0YUZvck1hc2tlZExNIGV4dGVuZHMgWExNUm9iZXJ0YVByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1hc2tlZExNT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFza2VkTE1PdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFhMTVJvYmVydGFGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uIGNsYXNzIGZvciBwZXJmb3JtaW5nIHNlcXVlbmNlIGNsYXNzaWZpY2F0aW9uIG9uIFhMTVJvYmVydGEgbW9kZWxzLlxuICogQGV4dGVuZHMgWExNUm9iZXJ0YVByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgWExNUm9iZXJ0YUZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBYTE1Sb2JlcnRhUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyB0byB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBYTE1Sb2JlcnRhRm9yVG9rZW5DbGFzc2lmaWNhdGlvbiBjbGFzcyBmb3IgcGVyZm9ybWluZyB0b2tlbiBjbGFzc2lmaWNhdGlvbiBvbiBYTE1Sb2JlcnRhIG1vZGVscy5cbiAqIEBleHRlbmRzIFhMTVJvYmVydGFQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIFhMTVJvYmVydGFGb3JUb2tlbkNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgWExNUm9iZXJ0YVByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIG1vZGVsIG9uIG5ldyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgdG8gdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuQ2xhc3NpZmllck91dHB1dD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtb2RlbCdzIG91dHB1dCBsb2dpdHMgZm9yIHRva2VuIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuQ2xhc3NpZmllck91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogWExNUm9iZXJ0YUZvclF1ZXN0aW9uQW5zd2VyaW5nIGNsYXNzIGZvciBwZXJmb3JtaW5nIHF1ZXN0aW9uIGFuc3dlcmluZyBvbiBYTE1Sb2JlcnRhIG1vZGVscy5cbiAqIEBleHRlbmRzIFhMTVJvYmVydGFQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIFhMTVJvYmVydGFGb3JRdWVzdGlvbkFuc3dlcmluZyBleHRlbmRzIFhMTVJvYmVydGFQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIHRvIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0Pn0gcmV0dXJuZWQgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVlc3Rpb25BbnN3ZXJpbmdNb2RlbE91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVDUgbW9kZWxzXG5leHBvcnQgY2xhc3MgV2hpc3BlclByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH07XG5cbi8qKlxuICogV2hpc3Blck1vZGVsIGNsYXNzIGZvciB0cmFpbmluZyBXaGlzcGVyIG1vZGVscyB3aXRob3V0IGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC5cbiAqIEBleHRlbmRzIFdoaXNwZXJQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIFdoaXNwZXJNb2RlbCBleHRlbmRzIFdoaXNwZXJQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIFRocm93cyBhbiBlcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZ2VuZXJhdGUgb3V0cHV0IHNpbmNlIHRoaXMgbW9kZWwgZG9lc24ndCBoYXZlIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC5cbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKFdoaXNwZXJNb2RlbCkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLCBhcyBpdCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGNsYXNzZXMgaW5zdGVhZDogeydXaGlzcGVyRm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uJ31cIlxuICAgICAgICApXG4gICAgfVxufVxuXG4vKipcbiAqIFdoaXNwZXJGb3JDb25kaXRpb25hbEdlbmVyYXRpb24gY2xhc3MgZm9yIGdlbmVyYXRpbmcgY29uZGl0aW9uYWwgb3V0cHV0cyBmcm9tIFdoaXNwZXIgbW9kZWxzLlxuICogQGV4dGVuZHMgV2hpc3BlclByZVRyYWluZWRNb2RlbFxuICovXG5leHBvcnQgY2xhc3MgV2hpc3BlckZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbiBleHRlbmRzIFdoaXNwZXJQcmVUcmFpbmVkTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFdoaXNwZXJGb3JDb25kaXRpb25hbEdlbmVyYXRpb25gIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvbiBPTk5YIFNlc3Npb24gb2JqZWN0IGZvciB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gT05OWCBTZXNzaW9uIG9iamVjdCBmb3IgdGhlIGRlY29kZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdlbmVyYXRpb25fY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgZ2VuZXJhdGlvbiBwcm9jZXNzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbiwgZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiwgZ2VuZXJhdGlvbl9jb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyX21lcmdlZF9zZXNzaW9uID0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uX2NvbmZpZyA9IGdlbmVyYXRpb25fY29uZmlnO1xuXG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcuZGVjb2Rlcl9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5kZWNvZGVyX2F0dGVudGlvbl9oZWFkcztcbiAgICAgICAgdGhpcy5kZWNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfbW9kZWwgLyB0aGlzLm51bV9kZWNvZGVyX2hlYWRzO1xuXG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcuZW5jb2Rlcl9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5lbmNvZGVyX2F0dGVudGlvbl9oZWFkcztcbiAgICAgICAgdGhpcy5lbmNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfbW9kZWwgLyB0aGlzLm51bV9lbmNvZGVyX2hlYWRzO1xuXG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgb3V0cHV0cyBiYXNlZCBvbiBpbnB1dCBhbmQgZ2VuZXJhdGlvbiBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dHMgSW5wdXQgZGF0YSBmb3IgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBnZW5lcmF0aW9uX2NvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIGdlbmVyYXRpb24gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbG9naXRzX3Byb2Nlc3NvciBPcHRpb25hbCBsb2dpdHMgcHJvY2Vzc29yIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnJldHVybl90aW1lc3RhbXBzPW51bGxdIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSB0aW1lc3RhbXBzIHdpdGggdGhlIHRleHQuIFRoaXMgZW5hYmxlcyB0aGUgYFdoaXNwZXJUaW1lc3RhbXBzTG9naXRzUHJvY2Vzc29yYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucmV0dXJuX3Rva2VuX3RpbWVzdGFtcHM9bnVsbF0gV2hldGhlciB0byByZXR1cm4gdG9rZW4tbGV2ZWwgdGltZXN0YW1wc1xuICAgICAqIHdpdGggdGhlIHRleHQuIFRoaXMgY2FuIGJlIHVzZWQgd2l0aCBvciB3aXRob3V0IHRoZSBgcmV0dXJuX3RpbWVzdGFtcHNgIG9wdGlvbi4gVG8gZ2V0IHdvcmQtbGV2ZWxcbiAgICAgKiB0aW1lc3RhbXBzLCB1c2UgdGhlIHRva2VuaXplciB0byBncm91cCB0aGUgdG9rZW5zIGludG8gd29yZHMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUHJvbWlzZSBvYmplY3QgcmVwcmVzZW50cyB0aGUgZ2VuZXJhdGVkIG91dHB1dHMuXG4gICAgICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGFzeW5jIGdlbmVyYXRlKFxuICAgICAgICBpbnB1dHMsXG4gICAgICAgIGdlbmVyYXRpb25fY29uZmlnID0gbnVsbCxcbiAgICAgICAgbG9naXRzX3Byb2Nlc3NvciA9IG51bGwsXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIHJldHVybl90aW1lc3RhbXBzID0gbnVsbCxcbiAgICAgICAgLy8gICAgIHJldHVybl90b2tlbl90aW1lc3RhbXBzID0gbnVsbCxcbiAgICAgICAgLy8gICAgIGxhbmd1YWdlID0gbnVsbCxcbiAgICAgICAgLy8gICAgIHRhc2sgPSBudWxsLFxuICAgICAgICAvLyB9ID0ge30sXG4gICAgKSB7XG4gICAgICAgIC8vIENyZWF0ZSBnZW5lcmF0aW9uIGNvbmZpZyBvYmplY3RcbiAgICAgICAgZ2VuZXJhdGlvbl9jb25maWcgPSB0aGlzLl9nZXRfZ2VuZXJhdGlvbl9jb25maWcoZ2VuZXJhdGlvbl9jb25maWcpO1xuXG5cbiAgICAgICAgLy8gV2hpc3BlciBoYXMgYWRkaXRpb25hbCBvcHRpb25zIGZvciByZXR1cm5pbmcgdGltZXN0YW1wc1xuICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5yZXR1cm5fdGltZXN0YW1wcyA/Pz0gZmFsc2U7XG5cbiAgICAgICAgLy8gVE9ETyBhZGQgbGFuZ3VhZ2UgYW5kIHRhc2tcblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcucmV0dXJuX3RpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgIGxvZ2l0c19wcm9jZXNzb3IgPSBbbmV3IFdoaXNwZXJUaW1lU3RhbXBMb2dpdHNQcm9jZXNzb3IoZ2VuZXJhdGlvbl9jb25maWcpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLnJldHVybl90b2tlbl90aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5vdXRwdXRfYXR0ZW50aW9ucyA9IHRydWU7XG4gICAgICAgICAgICBnZW5lcmF0aW9uX2NvbmZpZy5yZXR1cm5fZGljdF9pbl9nZW5lcmF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy50YXNrID09PSAndHJhbnNsYXRlJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRva2VuLWxldmVsIHRpbWVzdGFtcHMgbWF5IG5vdCBiZSByZWxpYWJsZSBmb3IgdGFzayAndHJhbnNsYXRlJy5cIilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFnZW5lcmF0aW9uX2NvbmZpZy5hbGlnbm1lbnRfaGVhZHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiTW9kZWwgZ2VuZXJhdGlvbiBjb25maWcgaGFzIG5vIGBhbGlnbm1lbnRfaGVhZHNgLCB0b2tlbi1sZXZlbCB0aW1lc3RhbXBzIG5vdCBhdmFpbGFibGUuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vaG9sbGFuY2UvNDJlMzI4NTJmMjQyNDNiNzQ4YWU2YmMxZjk4NWIxM2Egb24gaG93IHRvIGFkZCB0aGlzIHByb3BlcnR5IHRvIHRoZSBnZW5lcmF0aW9uIGNvbmZpZy5cIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG91dHB1dHMgPSBhd2FpdCBzdXBlci5nZW5lcmF0ZShpbnB1dHMsIGdlbmVyYXRpb25fY29uZmlnLCBsb2dpdHNfcHJvY2Vzc29yKTtcblxuICAgICAgICBpZiAoZ2VuZXJhdGlvbl9jb25maWcucmV0dXJuX3Rva2VuX3RpbWVzdGFtcHMgJiYgZ2VuZXJhdGlvbl9jb25maWcuYWxpZ25tZW50X2hlYWRzKSB7XG4gICAgICAgICAgICBvdXRwdXRzW1widG9rZW5fdGltZXN0YW1wc1wiXSA9IHRoaXMuX2V4dHJhY3RfdG9rZW5fdGltZXN0YW1wcyhvdXRwdXRzLCBnZW5lcmF0aW9uX2NvbmZpZy5hbGlnbm1lbnRfaGVhZHMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXJ0IGJlYW1zIGZvciBnZW5lcmF0aW5nIG91dHB1dHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5wdXRUb2tlbklkcyBBcnJheSBvZiBpbnB1dCB0b2tlbiBJRHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBOdW1iZXIgb2Ygb3V0cHV0IHRva2VucyB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN0YXJ0IGJlYW1zLlxuICAgICAqL1xuICAgIGdldFN0YXJ0QmVhbXMoaW5wdXRUb2tlbklkcywgbnVtT3V0cHV0VG9rZW5zLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIGFyZ3VtZW50cyBpZ25vcmVkIGluIHRoaXMgY2FzZVxuICAgICAgICByZXR1cm4gc2VxMnNlcVN0YXJ0QmVhbXModGhpcywgaW5wdXRUb2tlbklkcywgbnVtT3V0cHV0VG9rZW5zLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSBiZWFtIHNlYXJjaCBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgdXBkYXRlZCBiZWFtIGFmdGVyIGEgc2luZ2xlIGdlbmVyYXRpb24gc3RlcC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5CZWFtKGJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFSdW5CZWFtKHRoaXMsIGJlYW0sIHtcbiAgICAgICAgICAgIGlucHV0X25hbWU6ICdpbnB1dF9mZWF0dXJlcycsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGJlYW0gYnkgYXBwZW5kaW5nIHRoZSBuZXdseSBnZW5lcmF0ZWQgdG9rZW4gSUQgdG8gdGhlIGxpc3Qgb2Ygb3V0cHV0IHRva2VuIElEcy5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VG9rZW5JZCBUaGUgSUQgb2YgdGhlIG5ld2x5IGdlbmVyYXRlZCB0b2tlbiB0byBhcHBlbmQgdG8gdGhlIGxpc3Qgb2Ygb3V0cHV0IHRva2VuIElEcy5cbiAgICAgKi9cbiAgICB1cGRhdGVCZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICAgICAgYmVhbS5vdXRwdXRfdG9rZW5faWRzID0gWy4uLmJlYW0ub3V0cHV0X3Rva2VuX2lkcywgbmV3VG9rZW5JZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgZm9yd2FyZCBwYXNzIG9mIHRoZSBtb2RlbCBmb3IgYSBnaXZlbiBzZXQgb2YgaW5wdXRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIG1vZGVsIGlucHV0cy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgbW9kZWwgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIGZvcndhcmQobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZXEyc2VxRm9yd2FyZCh0aGlzLCBtb2RlbF9pbnB1dHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdG9rZW4tbGV2ZWwgdGltZXN0YW1wcyB1c2luZyB0aGUgZW5jb2Rlci1kZWNvZGVyIGNyb3NzLWF0dGVudGlvbnMgYW5kXG4gICAgICogZHluYW1pYyB0aW1lLXdhcnBpbmcgKERUVykgdG8gbWFwIGVhY2ggb3V0cHV0IHRva2VuIHRvIGEgcG9zaXRpb24gaW4gdGhlIGlucHV0IGF1ZGlvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBnZW5lcmF0ZV9vdXRwdXRzIE91dHB1dHMgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbFxuICAgICAqIEBwYXJhbSB7VGVuc29yW11bXVtdfSBnZW5lcmF0ZV9vdXRwdXRzLmNyb3NzX2F0dGVudGlvbnMgVGhlIGNyb3NzIGF0dGVudGlvbnMgb3V0cHV0IGJ5IHRoZSBtb2RlbFxuICAgICAqIEBwYXJhbSB7VGVuc29yW11bXVtdfSBnZW5lcmF0ZV9vdXRwdXRzLmRlY29kZXJfYXR0ZW50aW9ucyBUaGUgZGVjb2RlciBhdHRlbnRpb25zIG91dHB1dCBieSB0aGUgbW9kZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IGdlbmVyYXRlX291dHB1dHMuc2VxdWVuY2VzIFRoZSBzZXF1ZW5jZXMgb3V0cHV0IGJ5IHRoZSBtb2RlbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gYWxpZ25tZW50X2hlYWRzIEFsaWdubWVudCBoZWFkcyBvZiB0aGUgbW9kZWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZV9wcmVjaXNpb24gUHJlY2lzaW9uIG9mIHRoZSB0aW1lc3RhbXBzIGluIHNlY29uZHNcbiAgICAgKiBAcmV0dXJucyB7VGVuc29yfSB0ZW5zb3IgY29udGFpbmluZyB0aGUgdGltZXN0YW1wcyBpbiBzZWNvbmRzIGZvciBlYWNoIHByZWRpY3RlZCB0b2tlblxuICAgICAqL1xuICAgIF9leHRyYWN0X3Rva2VuX3RpbWVzdGFtcHMoZ2VuZXJhdGVfb3V0cHV0cywgYWxpZ25tZW50X2hlYWRzLCB0aW1lX3ByZWNpc2lvbiA9IDAuMDIpIHtcbiAgICAgICAgaWYgKCFnZW5lcmF0ZV9vdXRwdXRzLmNyb3NzX2F0dGVudGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIk1vZGVsIG91dHB1dHMgbXVzdCBjb250YWluIGNyb3NzIGF0dGVudGlvbnMgdG8gZXh0cmFjdCB0aW1lc3RhbXBzLiBcIiArXG4gICAgICAgICAgICAgICAgXCJUaGlzIGlzIG1vc3QgbGlrZWx5IGJlY2F1c2UgdGhlIG1vZGVsIHdhcyBub3QgZXhwb3J0ZWQgd2l0aCBgb3V0cHV0X2F0dGVudGlvbnM9VHJ1ZWAuXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtZWRpYW5fZmlsdGVyX3dpZHRoID0gdGhpcy5jb25maWcubWVkaWFuX2ZpbHRlcl93aWR0aDtcbiAgICAgICAgaWYgKG1lZGlhbl9maWx0ZXJfd2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTW9kZWwgY29uZmlnIGhhcyBubyBgbWVkaWFuX2ZpbHRlcl93aWR0aGAsIHVzaW5nIGRlZmF1bHQgdmFsdWUgb2YgNy5cIilcbiAgICAgICAgICAgIG1lZGlhbl9maWx0ZXJfd2lkdGggPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmF0Y2hlZE1hdHJpY2VzID0gZ2VuZXJhdGVfb3V0cHV0cy5jcm9zc19hdHRlbnRpb25zLm1hcChiYXRjaCA9PiB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IHdpdGggYGRlY29kZXJfbGF5ZXJzYCBlbGVtZW50cywgZWFjaCBhIHRlbnNvciBvZiBzaGFwZVxuICAgICAgICAgICAgLy8gKGJhdGNoIHNpemUsIGF0dGVudGlvbl9oZWFkcywgb3V0cHV0IGxlbmd0aCwgaW5wdXQgbGVuZ3RoKS5cbiAgICAgICAgICAgIGxldCBjcm9zc19hdHRlbnRpb25zID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5jb25maWcuZGVjb2Rlcl9sYXllcnMgfSxcbiAgICAgICAgICAgICAgICAoXywgaSkgPT4gY2F0KGJhdGNoLm1hcCh4ID0+IHhbaV0pLCAyKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGV0IHdlaWdodHMgPSBzdGFjayhhbGlnbm1lbnRfaGVhZHMubWFwKChbbCwgaF0pID0+IGNyb3NzX2F0dGVudGlvbnNbbF0uc2xpY2UobnVsbCwgaCkpKTtcbiAgICAgICAgICAgIHdlaWdodHMgPSB3ZWlnaHRzLnRyYW5zcG9zZSgxLCAwLCAyLCAzKVxuXG4gICAgICAgICAgICBsZXQgW3N0ZCwgY2FsY3VsYXRlZE1lYW5dID0gc3RkX21lYW4od2VpZ2h0cywgLTIsIDAsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYW5kIHNtb290aGVuIHRoZSB3ZWlnaHRzLlxuICAgICAgICAgICAgbGV0IHNtb290aGVkV2VpZ2h0cyA9IHdlaWdodHMuY2xvbmUoKTsgLy8gWzEsIDgsIHNlcUxlbmd0aCwgMTUwMF1cblxuICAgICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBzbW9vdGhlZFdlaWdodHMuZGltc1swXTsgKythKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFUZW5zb3IgPSBzbW9vdGhlZFdlaWdodHNbYV07IC8vIFs4LCBzZXFMZW5ndGgsIDE1MDBdXG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGFUZW5zb3IuZGltc1swXTsgKytiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiVGVuc29yID0gYVRlbnNvcltiXTsgLy8gW3NlcUxlbmd0aCwgMTUwMF1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGRUZW5zb3IgPSBzdGRbYV1bYl1bMF07IC8vIFsxNTAwXVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZWFuVGVuc29yID0gY2FsY3VsYXRlZE1lYW5bYV1bYl1bMF07IC8vIFsxNTAwXVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgYlRlbnNvci5kaW1zWzBdOyArK2MpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNUZW5zb3IgPSBiVGVuc29yW2NdOyAvLyBbMTUwMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgY1RlbnNvci5kYXRhLmxlbmd0aDsgKytkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY1RlbnNvci5kYXRhW2RdID0gKGNUZW5zb3IuZGF0YVtkXSAtIG1lYW5UZW5zb3IuZGF0YVtkXSkgLyBzdGRUZW5zb3IuZGF0YVtkXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBtZWRpYW4gZmlsdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgY1RlbnNvci5kYXRhLnNldChtZWRpYW5GaWx0ZXIoY1RlbnNvci5kYXRhLCBtZWRpYW5fZmlsdGVyX3dpZHRoKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXZlcmFnZSB0aGUgZGlmZmVyZW50IGNyb3NzLWF0dGVudGlvbiBoZWFkcy5cbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IG1lYW4oc21vb3RoZWRXZWlnaHRzLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcHNTaGFwZSA9IFtnZW5lcmF0ZV9vdXRwdXRzLnNlcXVlbmNlcy5sZW5ndGgsIGdlbmVyYXRlX291dHB1dHMuc2VxdWVuY2VzWzBdLmxlbmd0aF07XG5cbiAgICAgICAgY29uc3QgdGltZXN0YW1wcyA9IG5ldyBUZW5zb3IoXG4gICAgICAgICAgICAnZmxvYXQzMicsXG4gICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KHRpbWVzdGFtcHNTaGFwZVswXSAqIHRpbWVzdGFtcHNTaGFwZVsxXSksXG4gICAgICAgICAgICB0aW1lc3RhbXBzU2hhcGVcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBQZXJmb3JtIGR5bmFtaWMgdGltZSB3YXJwaW5nIG9uIGVhY2ggZWxlbWVudCBvZiB0aGUgYmF0Y2guXG4gICAgICAgIGZvciAobGV0IGJhdGNoX2lkeCA9IDA7IGJhdGNoX2lkeCA8IHRpbWVzdGFtcHNTaGFwZVswXTsgKytiYXRjaF9pZHgpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IFNpbmNlIHdlIHJ1biBvbmx5IG9uZSBiYXRjaCBhdCBhIHRpbWUsIHdlIGNhbiBzcXVlZXplIHRvIGdldCB0aGUgc2FtZSBkaW1lbnNpb25zXG4gICAgICAgICAgICAvLyBhcyB0aGUgcHl0aG9uIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSBiYXRjaGVkTWF0cmljZXNbYmF0Y2hfaWR4XS5uZWcoKS5zcXVlZXplXygwKTtcbiAgICAgICAgICAgIGxldCBbdGV4dF9pbmRpY2VzLCB0aW1lX2luZGljZXNdID0gZHluYW1pY1RpbWVXYXJwaW5nKG1hdHJpeCk7XG5cbiAgICAgICAgICAgIGxldCBkaWZmcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRleHRfaW5kaWNlcy5sZW5ndGggLSAxIH0sICh2LCBpKSA9PiB0ZXh0X2luZGljZXNbaSArIDFdIC0gdGV4dF9pbmRpY2VzW2ldKTtcbiAgICAgICAgICAgIGxldCBqdW1wcyA9IG1lcmdlQXJyYXlzKFsxXSwgZGlmZnMpLm1hcCh4ID0+ICEheCk7IC8vIGNvbnZlcnQgdG8gYm9vbGVhblxuXG4gICAgICAgICAgICBsZXQganVtcF90aW1lcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqdW1wcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChqdW1wc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBqdW1wX3RpbWVzLnB1c2godGltZV9pbmRpY2VzW2ldICogdGltZV9wcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBObyBwb2ludCBpbiByb3VuZGluZyBoZXJlLCBzaW5jZSB3ZSBzZXQgdG8gRmxvYXQzMkFycmF5IGxhdGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZXN0YW1wc1tiYXRjaF9pZHhdLmRhdGEuc2V0KGp1bXBfdGltZXMsIDEpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBWaXNpb24gRW5jb2Rlci1EZWNvZGVyIG1vZGVsIGJhc2VkIG9uIE9wZW5BSSdzIEdQVCBhcmNoaXRlY3R1cmUgZm9yIGltYWdlIGNhcHRpb25pbmcgYW5kIG90aGVyIHZpc2lvbiB0YXNrc1xuICogQGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBWaXNpb25FbmNvZGVyRGVjb2Rlck1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgVmlzaW9uRW5jb2RlckRlY29kZXJNb2RlbGAgY2xhc3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgaHlwZXJwYXJhbWV0ZXJzIGFuZCBvdGhlciBtb2RlbCBzZXR0aW5ncy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvbiBUaGUgT05OWCBzZXNzaW9uIGNvbnRhaW5pbmcgdGhlIGVuY29kZXIgbW9kZWwuXG4gICAgICogQHBhcmFtIHthbnl9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiBjb250YWluaW5nIHRoZSBtZXJnZWQgZGVjb2RlciBtb2RlbC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNlc3Npb24sIGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyX21lcmdlZF9zZXNzaW9uID0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbjtcblxuICAgICAgICB0aGlzLm51bV9sYXllcnMgPSB0aGlzLmNvbmZpZy5kZWNvZGVyLm5fbGF5ZXI7XG4gICAgICAgIHRoaXMubnVtX2hlYWRzID0gdGhpcy5jb25maWcuZGVjb2Rlci5uX2hlYWQ7XG4gICAgICAgIHRoaXMuZGltX2t2ID0gdGhpcy5jb25maWcuZGVjb2Rlci5uX2VtYmQgLyB0aGlzLm51bV9oZWFkcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBiZWFtIHNlYXJjaCBvdXRwdXRzIGZvciB0aGUgZ2l2ZW4gaW5wdXQgcGl4ZWxzIGFuZCBudW1iZXIgb2Ygb3V0cHV0IHRva2Vucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGlucHV0cyBUaGUgaW5wdXQgcGl4ZWxzIGFzIGEgVGVuc29yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgVGhlIG51bWJlciBvZiBvdXRwdXQgdG9rZW5zIHRvIGdlbmVyYXRlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBPcHRpb25hbCBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIHRvIHNlcTJzZXFTdGFydEJlYW1zLlxuICAgICAqIEByZXR1cm5zIHthbnl9IEFuIGFycmF5IG9mIEJlYW0gb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIHRvcC1LIG91dHB1dCBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgZ2V0U3RhcnRCZWFtcyhpbnB1dHMsIG51bU91dHB1dFRva2VucywgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc2VxMnNlcVN0YXJ0QmVhbXModGhpcywgaW5wdXRzLCBudW1PdXRwdXRUb2tlbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBzaW5nbGUgc3RlcCBvZiB0aGUgYmVhbSBzZWFyY2ggZ2VuZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGN1cnJlbnQgYmVhbSBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIHVwZGF0ZWQgYmVhbSBhZnRlciBhIHNpbmdsZSBnZW5lcmF0aW9uIHN0ZXAuXG4gICAgICovXG4gICAgYXN5bmMgcnVuQmVhbShiZWFtKSB7XG4gICAgICAgIHJldHVybiBzZXEyc2VxUnVuQmVhbSh0aGlzLCBiZWFtLCB7XG4gICAgICAgICAgICBpbnB1dF9uYW1lOiAncGl4ZWxfdmFsdWVzJyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBnaXZlbiBiZWFtIHdpdGggdGhlIGFkZGl0aW9uYWwgcHJlZGljdGVkIHRva2VuIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGN1cnJlbnQgYmVhbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VG9rZW5JZCBUaGUgbmV3IHByZWRpY3RlZCB0b2tlbiBJRCB0byBhZGQgdG8gdGhlIGJlYW0ncyBvdXRwdXQgc2VxdWVuY2UuXG4gICAgICovXG4gICAgdXBkYXRlQmVhbShiZWFtLCBuZXdUb2tlbklkKSB7XG4gICAgICAgIGJlYW0ub3V0cHV0X3Rva2VuX2lkcyA9IFsuLi5iZWFtLm91dHB1dF90b2tlbl9pZHMsIG5ld1Rva2VuSWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGZvcndhcmQgcGFzcyBvZiB0aGUgbW9kZWwgb24gdGhlIGdpdmVuIGlucHV0IHRlbnNvcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dCB0ZW5zb3JzIGFzIGFuIG9iamVjdCB3aXRoIGtleXMgJ3BpeGVsX3ZhbHVlcycgYW5kICdkZWNvZGVyX2lucHV0X2lkcycuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIG91dHB1dCB0ZW5zb3Igb2YgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGFzeW5jIGZvcndhcmQobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzZXEyc2VxRm9yd2FyZCh0aGlzLCBtb2RlbF9pbnB1dHMsIHtcbiAgICAgICAgICAgIGFkZF9kZWNvZGVyX3BrdjogZmFsc2VcbiAgICAgICAgfSlcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ0xJUCBtb2RlbHNcbmV4cG9ydCBjbGFzcyBDTElQUHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuXG4vKipcbiAqIENMSVAgVGV4dCBhbmQgVmlzaW9uIE1vZGVsIHdpdGggYSBwcm9qZWN0aW9uIGxheWVycyBvbiB0b3BcbiAqIFxuICogKipFeGFtcGxlOioqIFBlcmZvcm0gemVyby1zaG90IGltYWdlIGNsYXNzaWZpY2F0aW9uIHdpdGggYSBgQ0xJUE1vZGVsYC5cbiAqIFxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgQXV0b1Rva2VuaXplciwgQXV0b1Byb2Nlc3NvciwgQ0xJUE1vZGVsLCBSYXdJbWFnZSB9IGZyb20gJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJztcbiAqIFxuICogLy8gTG9hZCB0b2tlbml6ZXIsIHByb2Nlc3NvciwgYW5kIG1vZGVsXG4gKiBsZXQgdG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQoJ1hlbm92YS9jbGlwLXZpdC1iYXNlLXBhdGNoMTYnKTtcbiAqIGxldCBwcm9jZXNzb3IgPSBhd2FpdCBBdXRvUHJvY2Vzc29yLmZyb21fcHJldHJhaW5lZCgnWGVub3ZhL2NsaXAtdml0LWJhc2UtcGF0Y2gxNicpO1xuICogbGV0IG1vZGVsID0gYXdhaXQgQ0xJUE1vZGVsLmZyb21fcHJldHJhaW5lZCgnWGVub3ZhL2NsaXAtdml0LWJhc2UtcGF0Y2gxNicpO1xuICogXG4gKiAvLyBSdW4gdG9rZW5pemF0aW9uXG4gKiBsZXQgdGV4dHMgPSBbJ2EgcGhvdG8gb2YgYSBjYXInLCAnYSBwaG90byBvZiBhIGZvb3RiYWxsIG1hdGNoJ11cbiAqIGxldCB0ZXh0X2lucHV0cyA9IHRva2VuaXplcih0ZXh0cywgeyBwYWRkaW5nOiB0cnVlLCB0cnVuY2F0aW9uOiB0cnVlIH0pO1xuICogXG4gKiAvLyBSZWFkIGltYWdlIGFuZCBydW4gcHJvY2Vzc29yXG4gKiBsZXQgaW1hZ2UgPSBhd2FpdCBSYXdJbWFnZS5yZWFkKCdodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RhdGFzZXRzL1hlbm92YS90cmFuc2Zvcm1lcnMuanMtZG9jcy9yZXNvbHZlL21haW4vZm9vdGJhbGwtbWF0Y2guanBnJyk7XG4gKiBsZXQgaW1hZ2VfaW5wdXRzID0gYXdhaXQgcHJvY2Vzc29yKGltYWdlKTtcbiAqIFxuICogLy8gUnVuIG1vZGVsIHdpdGggYm90aCB0ZXh0IGFuZCBwaXhlbCBpbnB1dHNcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCBtb2RlbCh7IC4uLnRleHRfaW5wdXRzLCAuLi5pbWFnZV9pbnB1dHMgfSk7XG4gKiAvLyB7XG4gKiAvLyAgIGxvZ2l0c19wZXJfaW1hZ2U6IFRlbnNvciB7XG4gKiAvLyAgICAgZGltczogWyAxLCAyIF0sXG4gKiAvLyAgICAgZGF0YTogRmxvYXQzMkFycmF5KDIpIFsgMTguNTc5NzM0ODAyMjQ2MDk0LCAyNC4zMTgzMDU5NjkyMzgyOCBdLFxuICogLy8gICB9LFxuICogLy8gICBsb2dpdHNfcGVyX3RleHQ6IFRlbnNvciB7XG4gKiAvLyAgICAgZGltczogWyAyLCAxIF0sXG4gKiAvLyAgICAgZGF0YTogRmxvYXQzMkFycmF5KDIpIFsgMTguNTc5NzM0ODAyMjQ2MDk0LCAyNC4zMTgzMDU5NjkyMzgyOCBdLFxuICogLy8gICB9LFxuICogLy8gICB0ZXh0X2VtYmVkczogVGVuc29yIHtcbiAqIC8vICAgICBkaW1zOiBbIDIsIDUxMiBdLFxuICogLy8gICAgIGRhdGE6IEZsb2F0MzJBcnJheSgxMDI0KSBbIC4uLiBdLFxuICogLy8gICB9LFxuICogLy8gICBpbWFnZV9lbWJlZHM6IFRlbnNvciB7XG4gKiAvLyAgICAgZGltczogWyAxLCA1MTIgXSxcbiAqIC8vICAgICBkYXRhOiBGbG9hdDMyQXJyYXkoNTEyKSBbIC4uLiBdLFxuICogLy8gICB9XG4gKiAvLyB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIENMSVBNb2RlbCBleHRlbmRzIENMSVBQcmVUcmFpbmVkTW9kZWwgeyB9XG5cbi8qKlxuICogQ0xJUCBUZXh0IE1vZGVsIHdpdGggYSBwcm9qZWN0aW9uIGxheWVyIG9uIHRvcCAoYSBsaW5lYXIgbGF5ZXIgb24gdG9wIG9mIHRoZSBwb29sZWQgb3V0cHV0KVxuICogXG4gKiAqKkV4YW1wbGU6KiogQ29tcHV0ZSB0ZXh0IGVtYmVkZGluZ3Mgd2l0aCBgQ0xJUFRleHRNb2RlbFdpdGhQcm9qZWN0aW9uYC5cbiAqIFxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgQXV0b1Rva2VuaXplciwgQ0xJUFRleHRNb2RlbFdpdGhQcm9qZWN0aW9uIH0gZnJvbSAnQHhlbm92YS90cmFuc2Zvcm1lcnMnO1xuICogXG4gKiAvLyBMb2FkIHRva2VuaXplciBhbmQgdGV4dCBtb2RlbFxuICogY29uc3QgdG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQoJ1hlbm92YS9jbGlwLXZpdC1iYXNlLXBhdGNoMTYnKTtcbiAqIGNvbnN0IHRleHRfbW9kZWwgPSBhd2FpdCBDTElQVGV4dE1vZGVsV2l0aFByb2plY3Rpb24uZnJvbV9wcmV0cmFpbmVkKCdYZW5vdmEvY2xpcC12aXQtYmFzZS1wYXRjaDE2Jyk7XG4gKiBcbiAqIC8vIFJ1biB0b2tlbml6YXRpb25cbiAqIGxldCB0ZXh0cyA9IFsnYSBwaG90byBvZiBhIGNhcicsICdhIHBob3RvIG9mIGEgZm9vdGJhbGwgbWF0Y2gnXTtcbiAqIGxldCB0ZXh0X2lucHV0cyA9IHRva2VuaXplcih0ZXh0cywgeyBwYWRkaW5nOiB0cnVlLCB0cnVuY2F0aW9uOiB0cnVlIH0pO1xuICogXG4gKiAvLyBDb21wdXRlIGVtYmVkZGluZ3NcbiAqIGNvbnN0IHsgdGV4dF9lbWJlZHMgfSA9IGF3YWl0IHRleHRfbW9kZWwodGV4dF9pbnB1dHMpO1xuICogLy8gVGVuc29yIHtcbiAqIC8vICAgZGltczogWyAyLCA1MTIgXSxcbiAqIC8vICAgdHlwZTogJ2Zsb2F0MzInLFxuICogLy8gICBkYXRhOiBGbG9hdDMyQXJyYXkoMTAyNCkgWyAuLi4gXSxcbiAqIC8vICAgc2l6ZTogMTAyNFxuICogLy8gfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDTElQVGV4dE1vZGVsV2l0aFByb2plY3Rpb24gZXh0ZW5kcyBDTElQUHJlVHJhaW5lZE1vZGVsIHtcblxuICAgIC8qKiBAdHlwZSB7UHJlVHJhaW5lZE1vZGVsLmZyb21fcHJldHJhaW5lZH0gKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gVXBkYXRlIGRlZmF1bHQgbW9kZWwgZmlsZSBuYW1lIGlmIG5vdCBwcm92aWRlZFxuICAgICAgICBvcHRpb25zLm1vZGVsX2ZpbGVfbmFtZSA/Pz0gJ3RleHRfbW9kZWwnO1xuICAgICAgICByZXR1cm4gc3VwZXIuZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBvcHRpb25zKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ0xJUCBWaXNpb24gTW9kZWwgd2l0aCBhIHByb2plY3Rpb24gbGF5ZXIgb24gdG9wIChhIGxpbmVhciBsYXllciBvbiB0b3Agb2YgdGhlIHBvb2xlZCBvdXRwdXQpXG4gKiBcbiAqICoqRXhhbXBsZToqKiBDb21wdXRlIHZpc2lvbiBlbWJlZGRpbmdzIHdpdGggYENMSVBWaXNpb25Nb2RlbFdpdGhQcm9qZWN0aW9uYC5cbiAqIFxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgQXV0b1Byb2Nlc3NvciwgQ0xJUFZpc2lvbk1vZGVsV2l0aFByb2plY3Rpb24sIFJhd0ltYWdlfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKiBcbiAqIC8vIExvYWQgcHJvY2Vzc29yIGFuZCB2aXNpb24gbW9kZWxcbiAqIGNvbnN0IHByb2Nlc3NvciA9IGF3YWl0IEF1dG9Qcm9jZXNzb3IuZnJvbV9wcmV0cmFpbmVkKCdYZW5vdmEvY2xpcC12aXQtYmFzZS1wYXRjaDE2Jyk7XG4gKiBjb25zdCB2aXNpb25fbW9kZWwgPSBhd2FpdCBDTElQVmlzaW9uTW9kZWxXaXRoUHJvamVjdGlvbi5mcm9tX3ByZXRyYWluZWQoJ1hlbm92YS9jbGlwLXZpdC1iYXNlLXBhdGNoMTYnKTtcbiAqIFxuICogLy8gUmVhZCBpbWFnZSBhbmQgcnVuIHByb2Nlc3NvclxuICogbGV0IGltYWdlID0gYXdhaXQgUmF3SW1hZ2UucmVhZCgnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL2Zvb3RiYWxsLW1hdGNoLmpwZycpO1xuICogbGV0IGltYWdlX2lucHV0cyA9IGF3YWl0IHByb2Nlc3NvcihpbWFnZSk7XG4gKiBcbiAqIC8vIENvbXB1dGUgZW1iZWRkaW5nc1xuICogY29uc3QgeyBpbWFnZV9lbWJlZHMgfSA9IGF3YWl0IHZpc2lvbl9tb2RlbChpbWFnZV9pbnB1dHMpO1xuICogLy8gVGVuc29yIHtcbiAqIC8vICAgZGltczogWyAxLCA1MTIgXSxcbiAqIC8vICAgdHlwZTogJ2Zsb2F0MzInLFxuICogLy8gICBkYXRhOiBGbG9hdDMyQXJyYXkoNTEyKSBbIC4uLiBdLFxuICogLy8gICBzaXplOiA1MTJcbiAqIC8vIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ0xJUFZpc2lvbk1vZGVsV2l0aFByb2plY3Rpb24gZXh0ZW5kcyBDTElQUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKiogQHR5cGUge1ByZVRyYWluZWRNb2RlbC5mcm9tX3ByZXRyYWluZWR9ICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIFVwZGF0ZSBkZWZhdWx0IG1vZGVsIGZpbGUgbmFtZSBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgb3B0aW9ucy5tb2RlbF9maWxlX25hbWUgPz89ICd2aXNpb25fbW9kZWwnO1xuICAgICAgICByZXR1cm4gc3VwZXIuZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCBvcHRpb25zKTtcbiAgICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBHUFQyIG1vZGVsc1xuZXhwb3J0IGNsYXNzIEdQVDJQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBHUFQyUHJlVHJhaW5lZE1vZGVsYCBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge2FueX0gc2Vzc2lvbiBUaGUgT05OWCBzZXNzaW9uIGNvbnRhaW5pbmcgdGhlIG1vZGVsIHdlaWdodHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzZXNzaW9uKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc2Vzc2lvbik7XG5cbiAgICAgICAgLy8gY29uZmlnIGRvZXNuJ3QgY29udGFpbiBwYWRfdG9rZW5faWQsIHNvIHdlIGFzc3VtZSBpdCBpcyB0aGUgZW9zX3Rva2VuX2lkXG4gICAgICAgIHRoaXMuY29uZmlnLnBhZF90b2tlbl9pZCA9IHRoaXMuY29uZmlnLmVvc190b2tlbl9pZFxuXG4gICAgICAgIHRoaXMubnVtX2hlYWRzID0gdGhpcy5jb25maWcubl9oZWFkXG4gICAgICAgIHRoaXMubnVtX2xheWVycyA9IHRoaXMuY29uZmlnLm5fbGF5ZXJcbiAgICAgICAgdGhpcy5kaW1fa3YgPSB0aGlzLmNvbmZpZy5uX2VtYmQgLyB0aGlzLm51bV9oZWFkcztcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHUFQyTW9kZWwgZXh0ZW5kcyBHUFQyUHJlVHJhaW5lZE1vZGVsIHtcblxuICAgIC8qKlxuICAgICAqIEdQVDJNb2RlbCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAsIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKEdQVDJNb2RlbCkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLCBhcyBpdCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGNsYXNzZXMgaW5zdGVhZDogeydHUFQyTE1IZWFkTW9kZWwnfVwiXG4gICAgICAgIClcbiAgICB9XG59XG5cbi8qKlxuICogR1BULTIgbGFuZ3VhZ2UgbW9kZWwgaGVhZCBvbiB0b3Agb2YgdGhlIEdQVC0yIGJhc2UgbW9kZWwuIFRoaXMgbW9kZWwgaXMgc3VpdGFibGUgZm9yIHRleHQgZ2VuZXJhdGlvbiB0YXNrcy5cbiAqIEBleHRlbmRzIEdQVDJQcmVUcmFpbmVkTW9kZWxcbiAqL1xuZXhwb3J0IGNsYXNzIEdQVDJMTUhlYWRNb2RlbCBleHRlbmRzIEdQVDJQcmVUcmFpbmVkTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW5kIHJldHVybnMgdGhlIGJlYW0gZm9yIHRleHQgZ2VuZXJhdGlvbiB0YXNrXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGlucHV0VG9rZW5JZHMgVGhlIGlucHV0IHRva2VuIGlkcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtT3V0cHV0VG9rZW5zIFRoZSBudW1iZXIgb2YgdG9rZW5zIHRvIGJlIGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gaW5wdXRzX2F0dGVudGlvbl9tYXNrIE9wdGlvbmFsIGlucHV0IGF0dGVudGlvbiBtYXNrLlxuICAgICAqIEByZXR1cm5zIHthbnl9IEEgQmVhbSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbml0aWFsaXplZCBiZWFtLlxuICAgICAqL1xuICAgIGdldFN0YXJ0QmVhbXMoaW5wdXRUb2tlbklkcywgbnVtT3V0cHV0VG9rZW5zLCBpbnB1dHNfYXR0ZW50aW9uX21hc2spIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJTdGFydEJlYW1zKHRoaXMsIGlucHV0VG9rZW5JZHMsIG51bU91dHB1dFRva2VucywgaW5wdXRzX2F0dGVudGlvbl9tYXNrKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBzaW5nbGUgc3RlcCBvZiB0aGUgYmVhbSBzZWFyY2ggZ2VuZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIGN1cnJlbnQgYmVhbSBiZWluZyBnZW5lcmF0ZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIHVwZGF0ZWQgYmVhbSBhZnRlciBhIHNpbmdsZSBnZW5lcmF0aW9uIHN0ZXAuXG4gICAgICovXG4gICAgYXN5bmMgcnVuQmVhbShiZWFtKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBkZWNvZGVyUnVuQmVhbSh0aGlzLCBiZWFtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnaXZlbiBiZWFtIHdpdGggdGhlIG5ldyBnZW5lcmF0ZWQgdG9rZW4gaWQuXG4gICAgICogQHBhcmFtIHthbnl9IGJlYW0gVGhlIEJlYW0gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYmVhbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VG9rZW5JZCBUaGUgbmV3IGdlbmVyYXRlZCB0b2tlbiBpZCB0byBiZSBhZGRlZCB0byB0aGUgYmVhbS5cbiAgICAgKi9cbiAgICB1cGRhdGVCZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZXJVcGRhdGViZWFtKGJlYW0sIG5ld1Rva2VuSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcndhcmQgcGFzcyBmb3IgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgVGhlIGlucHV0cyBmb3IgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSBvdXRwdXQgdGVuc29yIG9mIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBhc3luYyBmb3J3YXJkKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gYXdhaXQgZGVjb2RlckZvcndhcmQodGhpcywgbW9kZWxfaW5wdXRzKTtcbiAgICB9XG5cbn1cbi8vIGV4cG9ydCBjbGFzcyBHUFQyRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiBleHRlbmRzIEdQVDJQcmVUcmFpbmVkTW9kZWwge1xuLy8gVE9ET1xuLy8gfVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBjbGFzcyBHUFROZW9QcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBHUFROZW9QcmVUcmFpbmVkTW9kZWxgIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7YW55fSBzZXNzaW9uIFRoZSBPTk5YIHNlc3Npb24gY29udGFpbmluZyB0aGUgbW9kZWwgd2VpZ2h0cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcblxuICAgICAgICAvLyBjb25maWcgZG9lc24ndCBjb250YWluIHBhZF90b2tlbl9pZCwgc28gd2UgYXNzdW1lIGl0IGlzIHRoZSBlb3NfdG9rZW5faWRcbiAgICAgICAgdGhpcy5jb25maWcucGFkX3Rva2VuX2lkID0gdGhpcy5jb25maWcuZW9zX3Rva2VuX2lkXG5cbiAgICAgICAgdGhpcy5udW1faGVhZHMgPSB0aGlzLmNvbmZpZy5udW1faGVhZHM7XG4gICAgICAgIHRoaXMubnVtX2xheWVycyA9IHRoaXMuY29uZmlnLm51bV9sYXllcnM7XG4gICAgICAgIHRoaXMuZGltX2t2ID0gdGhpcy5jb25maWcuaGlkZGVuX3NpemUgLyB0aGlzLm51bV9oZWFkcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR1BUTmVvTW9kZWwgZXh0ZW5kcyBHUFROZW9QcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChHUFROZW9Nb2RlbCkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLCBhcyBpdCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGNsYXNzZXMgaW5zdGVhZDogeydHUFROZW9Gb3JDYXVzYWxMTSd9XCJcbiAgICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEdQVE5lb0ZvckNhdXNhbExNIGV4dGVuZHMgR1BUTmVvUHJlVHJhaW5lZE1vZGVsIHtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCByZXR1cm5zIHRoZSBiZWFtIGZvciB0ZXh0IGdlbmVyYXRpb24gdGFza1xuICAgICAqIEBwYXJhbSB7VGVuc29yfSBpbnB1dFRva2VuSWRzIFRoZSBpbnB1dCB0b2tlbiBpZHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBUaGUgbnVtYmVyIG9mIHRva2VucyB0byBiZSBnZW5lcmF0ZWQuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGlucHV0c19hdHRlbnRpb25fbWFzayBPcHRpb25hbCBpbnB1dCBhdHRlbnRpb24gbWFzay5cbiAgICAgKiBAcmV0dXJucyB7YW55fSBBIEJlYW0gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5pdGlhbGl6ZWQgYmVhbS5cbiAgICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0VG9rZW5JZHMsIG51bU91dHB1dFRva2VucywgaW5wdXRzX2F0dGVudGlvbl9tYXNrKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVyU3RhcnRCZWFtcyh0aGlzLCBpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIGlucHV0c19hdHRlbnRpb25fbWFzaylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2luZ2xlIHN0ZXAgb2YgdGhlIGJlYW0gc2VhcmNoIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB1cGRhdGVkIGJlYW0gYWZ0ZXIgYSBzaW5nbGUgZ2VuZXJhdGlvbiBzdGVwLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkJlYW0oYmVhbSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZGVjb2RlclJ1bkJlYW0odGhpcywgYmVhbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gYmVhbSB3aXRoIHRoZSBuZXcgZ2VuZXJhdGVkIHRva2VuIGlkLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBCZWFtIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJlYW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1Rva2VuSWQgVGhlIG5ldyBnZW5lcmF0ZWQgdG9rZW4gaWQgdG8gYmUgYWRkZWQgdG8gdGhlIGJlYW0uXG4gICAgICovXG4gICAgdXBkYXRlQmVhbShiZWFtLCBuZXdUb2tlbklkKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVyVXBkYXRlYmVhbShiZWFtLCBuZXdUb2tlbklkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3J3YXJkIHBhc3MgZm9yIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgZm9yIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgb3V0cHV0IHRlbnNvciBvZiB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRlY29kZXJGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEdQVEJpZ0NvZGUgbW9kZWxzXG5leHBvcnQgY2xhc3MgR1BUQmlnQ29kZVByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYEdQVEJpZ0NvZGVQcmVUcmFpbmVkTW9kZWxgIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7YW55fSBzZXNzaW9uIFRoZSBPTk5YIHNlc3Npb24gY29udGFpbmluZyB0aGUgbW9kZWwgd2VpZ2h0cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcblxuICAgICAgICAvLyBjb25maWcgZG9lc24ndCBjb250YWluIHBhZF90b2tlbl9pZCwgc28gd2UgYXNzdW1lIGl0IGlzIHRoZSBlb3NfdG9rZW5faWRcbiAgICAgICAgdGhpcy5jb25maWcucGFkX3Rva2VuX2lkID0gdGhpcy5jb25maWcuZW9zX3Rva2VuX2lkXG5cbiAgICAgICAgdGhpcy5udW1faGVhZHMgPSB0aGlzLmNvbmZpZy5uX2hlYWRcbiAgICAgICAgdGhpcy5udW1fbGF5ZXJzID0gdGhpcy5jb25maWcubl9sYXllclxuICAgICAgICB0aGlzLmRpbV9rdiA9IHRoaXMuY29uZmlnLm5fZW1iZCAvIHRoaXMubnVtX2hlYWRzO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEdQVEJpZ0NvZGVNb2RlbCBleHRlbmRzIEdQVEJpZ0NvZGVQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChHUFRCaWdDb2RlTW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCwgYXMgaXQgZG9lc24ndCBoYXZlIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjbGFzc2VzIGluc3RlYWQ6IHsnR1BUQmlnQ29kZUZvckNhdXNhbExNJ31cIlxuICAgICAgICApXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgR1BUQmlnQ29kZUZvckNhdXNhbExNIGV4dGVuZHMgR1BUQmlnQ29kZVByZVRyYWluZWRNb2RlbCB7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbmQgcmV0dXJucyB0aGUgYmVhbSBmb3IgdGV4dCBnZW5lcmF0aW9uIHRhc2tcbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gaW5wdXRUb2tlbklkcyBUaGUgaW5wdXQgdG9rZW4gaWRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgVGhlIG51bWJlciBvZiB0b2tlbnMgdG8gYmUgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBpbnB1dHNfYXR0ZW50aW9uX21hc2sgT3B0aW9uYWwgaW5wdXQgYXR0ZW50aW9uIG1hc2suXG4gICAgICogQHJldHVybnMge2FueX0gQSBCZWFtIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGluaXRpYWxpemVkIGJlYW0uXG4gICAgICovXG4gICAgZ2V0U3RhcnRCZWFtcyhpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIGlucHV0c19hdHRlbnRpb25fbWFzaykge1xuICAgICAgICByZXR1cm4gZGVjb2RlclN0YXJ0QmVhbXModGhpcywgaW5wdXRUb2tlbklkcywgbnVtT3V0cHV0VG9rZW5zLCBpbnB1dHNfYXR0ZW50aW9uX21hc2spXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSBiZWFtIHNlYXJjaCBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgdXBkYXRlZCBiZWFtIGFmdGVyIGEgc2luZ2xlIGdlbmVyYXRpb24gc3RlcC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5CZWFtKGJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRlY29kZXJSdW5CZWFtKHRoaXMsIGJlYW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGdpdmVuIGJlYW0gd2l0aCB0aGUgbmV3IGdlbmVyYXRlZCB0b2tlbiBpZC5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgQmVhbSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBiZWFtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdUb2tlbklkIFRoZSBuZXcgZ2VuZXJhdGVkIHRva2VuIGlkIHRvIGJlIGFkZGVkIHRvIHRoZSBiZWFtLlxuICAgICAqL1xuICAgIHVwZGF0ZUJlYW0oYmVhbSwgbmV3VG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gZGVjb2RlclVwZGF0ZWJlYW0oYmVhbSwgbmV3VG9rZW5JZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yd2FyZCBwYXNzIGZvciB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vZGVsX2lucHV0cyBUaGUgaW5wdXRzIGZvciB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIG91dHB1dCB0ZW5zb3Igb2YgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIGFzeW5jIGZvcndhcmQobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBkZWNvZGVyRm9yd2FyZCh0aGlzLCBtb2RlbF9pbnB1dHMpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBDb2RlR2VuIG1vZGVsc1xuZXhwb3J0IGNsYXNzIENvZGVHZW5QcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBDb2RlR2VuUHJlVHJhaW5lZE1vZGVsYCBjbGFzcy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIG1vZGVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcblxuICAgICAgICAvLyBjb25maWcgZG9lc24ndCBjb250YWluIHBhZF90b2tlbl9pZCwgc28gd2UgYXNzdW1lIGl0IGlzIHRoZSBlb3NfdG9rZW5faWRcbiAgICAgICAgdGhpcy5jb25maWcucGFkX3Rva2VuX2lkID0gdGhpcy5jb25maWcuZW9zX3Rva2VuX2lkXG5cbiAgICAgICAgdGhpcy5udW1faGVhZHMgPSB0aGlzLmNvbmZpZy5uX2hlYWRcbiAgICAgICAgdGhpcy5udW1fbGF5ZXJzID0gdGhpcy5jb25maWcubl9sYXllclxuICAgICAgICB0aGlzLmRpbV9rdiA9IHRoaXMuY29uZmlnLm5fZW1iZCAvIHRoaXMubnVtX2hlYWRzO1xuICAgIH1cbn1cbi8qKlxuICogQ29kZUdlbk1vZGVsIGlzIGEgY2xhc3MgcmVwcmVzZW50aW5nIGEgY29kZSBnZW5lcmF0aW9uIG1vZGVsIHdpdGhvdXQgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLlxuICogXG4gKiBAZXh0ZW5kcyBDb2RlR2VuUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlR2VuTW9kZWwgZXh0ZW5kcyBDb2RlR2VuUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaW5kaWNhdGluZyB0aGF0IHRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCxcbiAgICAgKiBhcyBpdCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLlxuICAgICAqIFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaGUgY3VycmVudCBtb2RlbCBjbGFzcyBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWBcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZ2VuZXJhdGUgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChDb2RlR2VuTW9kZWwpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYC5nZW5lcmF0ZSgpYCwgYXMgaXQgZG9lc24ndCBoYXZlIGEgbGFuZ3VhZ2UgbW9kZWwgaGVhZC4gUGxlYXNlIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjbGFzc2VzIGluc3RlYWQ6IHsnQ29kZUdlbkZvckNhdXNhbExNJ31cIlxuICAgICAgICApXG4gICAgfVxufVxuXG4vKipcbiAqIENvZGVHZW5Gb3JDYXVzYWxMTSBpcyBhIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGNvZGUgZ2VuZXJhdGlvbiBtb2RlbCBiYXNlZCBvbiB0aGUgR1BULTIgYXJjaGl0ZWN0dXJlLiBJdCBleHRlbmRzIHRoZSBgQ29kZUdlblByZVRyYWluZWRNb2RlbGAgY2xhc3MuXG4gKiBAZXh0ZW5kcyBDb2RlR2VuUHJlVHJhaW5lZE1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlR2VuRm9yQ2F1c2FsTE0gZXh0ZW5kcyBDb2RlR2VuUHJlVHJhaW5lZE1vZGVsIHtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCByZXR1cm5zIHRoZSBiZWFtIGZvciB0ZXh0IGdlbmVyYXRpb24gdGFza1xuICAgICAqIEBwYXJhbSB7VGVuc29yfSBpbnB1dFRva2VuSWRzIFRoZSBpbnB1dCB0b2tlbiBpZHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bU91dHB1dFRva2VucyBUaGUgbnVtYmVyIG9mIHRva2VucyB0byBiZSBnZW5lcmF0ZWQuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGlucHV0c19hdHRlbnRpb25fbWFzayBPcHRpb25hbCBpbnB1dCBhdHRlbnRpb24gbWFzay5cbiAgICAgKiBAcmV0dXJucyB7YW55fSBBIEJlYW0gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5pdGlhbGl6ZWQgYmVhbS5cbiAgICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0VG9rZW5JZHMsIG51bU91dHB1dFRva2VucywgaW5wdXRzX2F0dGVudGlvbl9tYXNrKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVyU3RhcnRCZWFtcyh0aGlzLCBpbnB1dFRva2VuSWRzLCBudW1PdXRwdXRUb2tlbnMsIGlucHV0c19hdHRlbnRpb25fbWFzaylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2luZ2xlIHN0ZXAgb2YgdGhlIGJlYW0gc2VhcmNoIGdlbmVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBjdXJyZW50IGJlYW0gYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB1cGRhdGVkIGJlYW0gYWZ0ZXIgYSBzaW5nbGUgZ2VuZXJhdGlvbiBzdGVwLlxuICAgICAqL1xuICAgIGFzeW5jIHJ1bkJlYW0oYmVhbSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZGVjb2RlclJ1bkJlYW0odGhpcywgYmVhbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZ2l2ZW4gYmVhbSB3aXRoIHRoZSBuZXcgZ2VuZXJhdGVkIHRva2VuIGlkLlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtIFRoZSBCZWFtIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJlYW0uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1Rva2VuSWQgVGhlIG5ldyBnZW5lcmF0ZWQgdG9rZW4gaWQgdG8gYmUgYWRkZWQgdG8gdGhlIGJlYW0uXG4gICAgICovXG4gICAgdXBkYXRlQmVhbShiZWFtLCBuZXdUb2tlbklkKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVyVXBkYXRlYmVhbShiZWFtLCBuZXdUb2tlbklkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3J3YXJkIHBhc3MgZm9yIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kZWxfaW5wdXRzIFRoZSBpbnB1dHMgZm9yIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgb3V0cHV0IHRlbnNvciBvZiB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRlY29kZXJGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxuXG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNsYXNzIFZpVFByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBWaVRGb3JJbWFnZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgVmlUUHJlVHJhaW5lZE1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gbW9kZWxfaW5wdXRzXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VDbGFzc2lmaWVyT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgY2xhc3MgTW9iaWxlVmlUUHJlVHJhaW5lZE1vZGVsIGV4dGVuZHMgUHJlVHJhaW5lZE1vZGVsIHsgfVxuZXhwb3J0IGNsYXNzIE1vYmlsZVZpVEZvckltYWdlQ2xhc3NpZmljYXRpb24gZXh0ZW5kcyBNb2JpbGVWaVRQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBtb2RlbF9pbnB1dHNcbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXF1ZW5jZUNsYXNzaWZpZXJPdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuLy8gVE9ETzogTW9iaWxlVmlURm9yU2VtYW50aWNTZWdtZW50YXRpb25cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgY2xhc3MgRGV0clByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH1cbmV4cG9ydCBjbGFzcyBEZXRyRm9yT2JqZWN0RGV0ZWN0aW9uIGV4dGVuZHMgRGV0clByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IG1vZGVsX2lucHV0c1xuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IERldHJPYmplY3REZXRlY3Rpb25PdXRwdXQoYXdhaXQgc3VwZXIuX2NhbGwobW9kZWxfaW5wdXRzKSk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGV0ckZvclNlZ21lbnRhdGlvbiBleHRlbmRzIERldHJQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIG1vZGVsIHdpdGggdGhlIHByb3ZpZGVkIGlucHV0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHMgTW9kZWwgaW5wdXRzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RGV0clNlZ21lbnRhdGlvbk91dHB1dD59IE9iamVjdCBjb250YWluaW5nIHNlZ21lbnRhdGlvbiBvdXRwdXRzXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwobW9kZWxfaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGV0clNlZ21lbnRhdGlvbk91dHB1dChhd2FpdCBzdXBlci5fY2FsbChtb2RlbF9pbnB1dHMpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZXRyT2JqZWN0RGV0ZWN0aW9uT3V0cHV0IGV4dGVuZHMgTW9kZWxPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgVGhlIG91dHB1dCBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5sb2dpdHMgQ2xhc3NpZmljYXRpb24gbG9naXRzIChpbmNsdWRpbmcgbm8tb2JqZWN0KSBmb3IgYWxsIHF1ZXJpZXMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5wcmVkX2JveGVzIE5vcm1hbGl6ZWQgYm94ZXMgY29vcmRpbmF0ZXMgZm9yIGFsbCBxdWVyaWVzLCByZXByZXNlbnRlZCBhcyAoY2VudGVyX3gsIGNlbnRlcl95LCB3aWR0aCwgaGVpZ2h0KS5cbiAgICAgKiBUaGVzZSB2YWx1ZXMgYXJlIG5vcm1hbGl6ZWQgaW4gWzAsIDFdLCByZWxhdGl2ZSB0byB0aGUgc2l6ZSBvZiBlYWNoIGluZGl2aWR1YWwgaW1hZ2UgaW4gdGhlIGJhdGNoIChkaXNyZWdhcmRpbmcgcG9zc2libGUgcGFkZGluZykuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBsb2dpdHMsIHByZWRfYm94ZXMgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvZ2l0cyA9IGxvZ2l0cztcbiAgICAgICAgdGhpcy5wcmVkX2JveGVzID0gcHJlZF9ib3hlcztcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZXRyU2VnbWVudGF0aW9uT3V0cHV0IGV4dGVuZHMgTW9kZWxPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgVGhlIG91dHB1dCBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5sb2dpdHMgVGhlIG91dHB1dCBsb2dpdHMgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQucHJlZF9ib3hlcyBQcmVkaWN0ZWQgYm94ZXMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5wcmVkX21hc2tzIFByZWRpY3RlZCBtYXNrcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGxvZ2l0cywgcHJlZF9ib3hlcywgcHJlZF9tYXNrcyB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9naXRzID0gbG9naXRzO1xuICAgICAgICB0aGlzLnByZWRfYm94ZXMgPSBwcmVkX2JveGVzO1xuICAgICAgICB0aGlzLnByZWRfbWFza3MgPSBwcmVkX21hc2tzO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBjbGFzcyBTYW1QcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9XG5leHBvcnQgY2xhc3MgU2FtTW9kZWwgZXh0ZW5kcyBTYW1QcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbF9pbnB1dHNcbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbW9kZWxfaW5wdXRzLnBpeGVsX3ZhbHVlcyBQaXhlbCB2YWx1ZXMgYXMgYSBUZW5zb3Igd2l0aCBzaGFwZSBgKGJhdGNoX3NpemUsIG51bV9jaGFubmVscywgaGVpZ2h0LCB3aWR0aClgLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBtb2RlbF9pbnB1dHMuaW5wdXRfcG9pbnRzIElucHV0IDJEIHNwYXRpYWwgcG9pbnRzIHdpdGggc2hhcGUgYChiYXRjaF9zaXplLCBudW1fcG9pbnRzLCAyKWAuIFRoaXMgaXMgdXNlZCBieSB0aGUgcHJvbXB0IGVuY29kZXIgdG8gZW5jb2RlIHRoZSBwcm9tcHQuXG4gICAgICogQHRvZG8gQWRkIHN1cHBvcnQgZm9yIGBpbnB1dF9sYWJlbHNgLCBgaW5wdXRfYm94ZXNgLCBgaW5wdXRfbWFza3NgLCBhbmQgYGltYWdlX2VtYmVkZGluZ3NgLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKG1vZGVsX2lucHV0cykge1xuICAgICAgICByZXR1cm4gbmV3IFNhbUltYWdlU2VnbWVudGF0aW9uT3V0cHV0KGF3YWl0IHN1cGVyLl9jYWxsKG1vZGVsX2lucHV0cykpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFNlZ21lbnQtQW55dGhpbmcgbW9kZWwncyBvdXRwdXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBTYW1JbWFnZVNlZ21lbnRhdGlvbk91dHB1dCBleHRlbmRzIE1vZGVsT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0IFRoZSBvdXRwdXQgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQuaW91X3Njb3JlcyBUaGUgb3V0cHV0IGxvZ2l0cyBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5wcmVkX21hc2tzIFByZWRpY3RlZCBib3hlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGlvdV9zY29yZXMsIHByZWRfbWFza3MgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlvdV9zY29yZXMgPSBpb3Vfc2NvcmVzO1xuICAgICAgICB0aGlzLnByZWRfbWFza3MgPSBwcmVkX21hc2tzO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1hcmlhbk1UIG1vZGVsc1xuZXhwb3J0IGNsYXNzIE1hcmlhblByZVRyYWluZWRNb2RlbCBleHRlbmRzIFByZVRyYWluZWRNb2RlbCB7IH07XG5cbmV4cG9ydCBjbGFzcyBNYXJpYW5Nb2RlbCBleHRlbmRzIE1hcmlhblByZVRyYWluZWRNb2RlbCB7XG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGUoLi4uYXJncykge1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVGhlIGN1cnJlbnQgbW9kZWwgY2xhc3MgKE1hcmlhbk1vZGVsKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAuZ2VuZXJhdGUoKWAsIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhIGxhbmd1YWdlIG1vZGVsIGhlYWQuIFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgY2xhc3NlcyBpbnN0ZWFkOiB7J01hcmlhbk1UTW9kZWwnfVwiXG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNYXJpYW5NVE1vZGVsIGV4dGVuZHMgTWFyaWFuUHJlVHJhaW5lZE1vZGVsIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBNYXJpYW5NVE1vZGVsYCBjbGFzcy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIG1vZGVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb24gVGhlIE9OTlggc2Vzc2lvbiBvYmplY3QuXG4gICAgKiBAcGFyYW0ge2FueX0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiBcbiAgICAqIEBwYXJhbSB7YW55fSBnZW5lcmF0aW9uX2NvbmZpZyBcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc2Vzc2lvbiwgZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiwgZ2VuZXJhdGlvbl9jb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzZXNzaW9uKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyX21lcmdlZF9zZXNzaW9uID0gZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uX2NvbmZpZyA9IGdlbmVyYXRpb25fY29uZmlnO1xuXG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcuZGVjb2Rlcl9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2RlY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5kZWNvZGVyX2F0dGVudGlvbl9oZWFkcztcbiAgICAgICAgdGhpcy5kZWNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfbW9kZWwgLyB0aGlzLm51bV9kZWNvZGVyX2hlYWRzO1xuXG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfbGF5ZXJzID0gdGhpcy5jb25maWcuZW5jb2Rlcl9sYXllcnM7XG4gICAgICAgIHRoaXMubnVtX2VuY29kZXJfaGVhZHMgPSB0aGlzLmNvbmZpZy5lbmNvZGVyX2F0dGVudGlvbl9oZWFkcztcbiAgICAgICAgdGhpcy5lbmNvZGVyX2RpbV9rdiA9IHRoaXMuY29uZmlnLmRfbW9kZWwgLyB0aGlzLm51bV9lbmNvZGVyX2hlYWRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCByZXR1cm5zIHRoZSBiZWFtIGZvciB0ZXh0IGdlbmVyYXRpb24gdGFza1xuICAgICAqIEBwYXJhbSB7YW55W119IGlucHV0cyBUaGUgaW5wdXQgdG9rZW4gaWRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgVGhlIG51bWJlciBvZiB0b2tlbnMgdG8gYmUgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHthbnl9IEEgQmVhbSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbml0aWFsaXplZCBiZWFtLlxuICAgICAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAgICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0cywgbnVtT3V0cHV0VG9rZW5zLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzZXEyc2VxU3RhcnRCZWFtcyh0aGlzLCBpbnB1dHMsIG51bU91dHB1dFRva2Vucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSBiZWFtIHNlYXJjaCBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgdXBkYXRlZCBiZWFtIGFmdGVyIGEgc2luZ2xlIGdlbmVyYXRpb24gc3RlcC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5CZWFtKGJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFSdW5CZWFtKHRoaXMsIGJlYW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtXG4gICAgICogQHBhcmFtIHthbnl9IG5ld1Rva2VuSWRcbiAgICAgKi9cbiAgICB1cGRhdGVCZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICAgICAgYmVhbS5vdXRwdXRfdG9rZW5faWRzID0gWy4uLmJlYW0ub3V0cHV0X3Rva2VuX2lkcywgbmV3VG9rZW5JZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IG1vZGVsX2lucHV0c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcTJTZXFMTU91dHB1dD59XG4gICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE0yTTEwMCBtb2RlbHNcbmV4cG9ydCBjbGFzcyBNMk0xMDBQcmVUcmFpbmVkTW9kZWwgZXh0ZW5kcyBQcmVUcmFpbmVkTW9kZWwgeyB9O1xuXG5leHBvcnQgY2xhc3MgTTJNMTAwTW9kZWwgZXh0ZW5kcyBNMk0xMDBQcmVUcmFpbmVkTW9kZWwge1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBjdXJyZW50IG1vZGVsIGNsYXNzIChNMk0xMDBNb2RlbCkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgLmdlbmVyYXRlKClgLCBhcyBpdCBkb2Vzbid0IGhhdmUgYSBsYW5ndWFnZSBtb2RlbCBoZWFkLiBQbGVhc2UgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGNsYXNzZXMgaW5zdGVhZDogeydNMk0xMDBGb3JDb25kaXRpb25hbEdlbmVyYXRpb24nfVwiXG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNMk0xMDBGb3JDb25kaXRpb25hbEdlbmVyYXRpb24gZXh0ZW5kcyBNMk0xMDBQcmVUcmFpbmVkTW9kZWwge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYE0yTTEwMEZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbmAgY2xhc3MuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBtb2RlbCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uIFRoZSBPTk5YIHNlc3Npb24gb2JqZWN0LlxuICAgICogQHBhcmFtIHthbnl9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24gXG4gICAgKiBAcGFyYW0ge2FueX0gZ2VuZXJhdGlvbl9jb25maWcgXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHNlc3Npb24sIGRlY29kZXJfbWVyZ2VkX3Nlc3Npb24sIGdlbmVyYXRpb25fY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9tZXJnZWRfc2Vzc2lvbiA9IGRlY29kZXJfbWVyZ2VkX3Nlc3Npb247XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbl9jb25maWcgPSBnZW5lcmF0aW9uX2NvbmZpZztcblxuICAgICAgICB0aGlzLm51bV9kZWNvZGVyX2xheWVycyA9IHRoaXMuY29uZmlnLmRlY29kZXJfbGF5ZXJzO1xuICAgICAgICB0aGlzLm51bV9kZWNvZGVyX2hlYWRzID0gdGhpcy5jb25maWcuZGVjb2Rlcl9hdHRlbnRpb25faGVhZHM7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9kaW1fa3YgPSB0aGlzLmNvbmZpZy5kX21vZGVsIC8gdGhpcy5udW1fZGVjb2Rlcl9oZWFkcztcblxuICAgICAgICB0aGlzLm51bV9lbmNvZGVyX2xheWVycyA9IHRoaXMuY29uZmlnLmVuY29kZXJfbGF5ZXJzO1xuICAgICAgICB0aGlzLm51bV9lbmNvZGVyX2hlYWRzID0gdGhpcy5jb25maWcuZW5jb2Rlcl9hdHRlbnRpb25faGVhZHM7XG4gICAgICAgIHRoaXMuZW5jb2Rlcl9kaW1fa3YgPSB0aGlzLmNvbmZpZy5kX21vZGVsIC8gdGhpcy5udW1fZW5jb2Rlcl9oZWFkcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuZCByZXR1cm5zIHRoZSBiZWFtIGZvciB0ZXh0IGdlbmVyYXRpb24gdGFza1xuICAgICAqIEBwYXJhbSB7YW55W119IGlucHV0cyBUaGUgaW5wdXQgdG9rZW4gaWRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1PdXRwdXRUb2tlbnMgVGhlIG51bWJlciBvZiB0b2tlbnMgdG8gYmUgZ2VuZXJhdGVkLlxuICAgICAqIEByZXR1cm5zIHthbnl9IEEgQmVhbSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbml0aWFsaXplZCBiZWFtLlxuICAgICAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAgICAgKi9cbiAgICBnZXRTdGFydEJlYW1zKGlucHV0cywgbnVtT3V0cHV0VG9rZW5zLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzZXEyc2VxU3RhcnRCZWFtcyh0aGlzLCBpbnB1dHMsIG51bU91dHB1dFRva2Vucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIHNpbmdsZSBzdGVwIG9mIHRoZSBiZWFtIHNlYXJjaCBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ge2FueX0gYmVhbSBUaGUgY3VycmVudCBiZWFtIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgdXBkYXRlZCBiZWFtIGFmdGVyIGEgc2luZ2xlIGdlbmVyYXRpb24gc3RlcC5cbiAgICAgKi9cbiAgICBhc3luYyBydW5CZWFtKGJlYW0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFSdW5CZWFtKHRoaXMsIGJlYW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBiZWFtXG4gICAgICogQHBhcmFtIHthbnl9IG5ld1Rva2VuSWRcbiAgICAgKi9cbiAgICB1cGRhdGVCZWFtKGJlYW0sIG5ld1Rva2VuSWQpIHtcbiAgICAgICAgYmVhbS5vdXRwdXRfdG9rZW5faWRzID0gWy4uLmJlYW0ub3V0cHV0X3Rva2VuX2lkcywgbmV3VG9rZW5JZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IG1vZGVsX2lucHV0c1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcTJTZXFMTU91dHB1dD59XG4gICAgICovXG4gICAgYXN5bmMgZm9yd2FyZChtb2RlbF9pbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHNlcTJzZXFGb3J3YXJkKHRoaXMsIG1vZGVsX2lucHV0cyk7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQXV0b01vZGVscywgdXNlZCB0byBzaW1wbGlmeSBjb25zdHJ1Y3Rpb24gb2YgUHJlVHJhaW5lZE1vZGVsc1xuLy8gKHVzZXMgY29uZmlnIHRvIGluc3RhbnRpYXRlIGNvcnJlY3QgY2xhc3MpXG5cbi8qKlxuICogQmFzZSBjbGFzcyBvZiBhbGwgQXV0b01vZGVscy4gQ29udGFpbnMgdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uXG4gKiB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgbW9kZWxzLlxuICovXG5leHBvcnQgY2xhc3MgUHJldHJhaW5lZE1peGluIHtcbiAgICAvKipcbiAgICAgKiBNYXBwaW5nIGZyb20gbW9kZWwgdHlwZSB0byBtb2RlbCBjbGFzcy5cbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgT2JqZWN0PltdfVxuICAgICAqL1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGF0dGVtcHQgdG8gaW5zdGFudGlhdGUgdGhlIGJhc2UgY2xhc3MgKGBQcmV0cmFpbmVkTW9kZWxgKSBpZiBcbiAgICAgKiB0aGUgbW9kZWwgdHlwZSBpcyBub3QgZm91bmQgaW4gdGhlIG1hcHBpbmcuXG4gICAgICovXG4gICAgc3RhdGljIEJBU0VfSUZfRkFJTCA9IGZhbHNlO1xuXG5cbiAgICAvKiogQHR5cGUge1ByZVRyYWluZWRNb2RlbC5mcm9tX3ByZXRyYWluZWR9ICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwge1xuICAgICAgICBxdWFudGl6ZWQgPSB0cnVlLFxuICAgICAgICBwcm9ncmVzc19jYWxsYmFjayA9IG51bGwsXG4gICAgICAgIGNvbmZpZyA9IG51bGwsXG4gICAgICAgIGNhY2hlX2RpciA9IG51bGwsXG4gICAgICAgIGxvY2FsX2ZpbGVzX29ubHkgPSBmYWxzZSxcbiAgICAgICAgcmV2aXNpb24gPSAnbWFpbicsXG4gICAgICAgIG1vZGVsX2ZpbGVfbmFtZSA9IG51bGwsXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBxdWFudGl6ZWQsXG4gICAgICAgICAgICBwcm9ncmVzc19jYWxsYmFjayxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGNhY2hlX2RpcixcbiAgICAgICAgICAgIGxvY2FsX2ZpbGVzX29ubHksXG4gICAgICAgICAgICByZXZpc2lvbixcbiAgICAgICAgICAgIG1vZGVsX2ZpbGVfbmFtZSxcbiAgICAgICAgfVxuICAgICAgICBjb25maWcgPSBhd2FpdCBBdXRvQ29uZmlnLmZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghb3B0aW9ucy5jb25maWcpIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGNvbmZpZyB3YXMgcGFzc2VkLCByZXVzZSB0aGlzIGNvbmZpZyBmb3IgZnV0dXJlIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIG9wdGlvbnMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLk1PREVMX0NMQVNTX01BUFBJTkdTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgTU9ERUxfQ0xBU1NfTUFQUElOR1NgIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyB0eXBlIG9mIGBBdXRvQ2xhc3NgOiBcIiArIHRoaXMubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbW9kZWxDbGFzcztcbiAgICAgICAgZm9yIChsZXQgTU9ERUxfQ0xBU1NfTUFQUElORyBvZiB0aGlzLk1PREVMX0NMQVNTX01BUFBJTkdTKSB7XG4gICAgICAgICAgICBtb2RlbENsYXNzID0gTU9ERUxfQ0xBU1NfTUFQUElORy5nZXQoY29uZmlnLm1vZGVsX3R5cGUpO1xuICAgICAgICAgICAgaWYgKCFtb2RlbENsYXNzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIEl0ZW0gbm90IGZvdW5kIGluIHRoaXMgbWFwcGluZ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgbW9kZWxDbGFzcy5mcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuQkFTRV9JRl9GQUlMKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gbW9kZWwgY2xhc3MgXCIke2NvbmZpZy5tb2RlbF90eXBlfVwiLCBhdHRlbXB0aW5nIHRvIGNvbnN0cnVjdCBmcm9tIGJhc2UgY2xhc3MuYCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgUHJlVHJhaW5lZE1vZGVsLmZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgbW9kZWwgdHlwZTogJHtjb25maWcubW9kZWxfdHlwZX1gKVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBNT0RFTF9NQVBQSU5HX05BTUVTX0VOQ09ERVJfT05MWSA9IG5ldyBNYXAoW1xuICAgIFsnYmVydCcsIEJlcnRNb2RlbF0sXG4gICAgWydtcG5ldCcsIE1QTmV0TW9kZWxdLFxuICAgIFsnYWxiZXJ0JywgQWxiZXJ0TW9kZWxdLFxuICAgIFsnZGlzdGlsYmVydCcsIERpc3RpbEJlcnRNb2RlbF0sXG4gICAgWydyb2JlcnRhJywgUm9iZXJ0YU1vZGVsXSxcbiAgICBbJ3hsbS1yb2JlcnRhJywgWExNUm9iZXJ0YU1vZGVsXSxcbiAgICBbJ2NsaXAnLCBDTElQTW9kZWxdLFxuICAgIFsnbW9iaWxlYmVydCcsIE1vYmlsZUJlcnRNb2RlbF0sXG4gICAgWydzcXVlZXplYmVydCcsIFNxdWVlemVCZXJ0TW9kZWxdLFxuXG4gICAgWydzYW0nLCBTYW1Nb2RlbF0sIC8vIFRPRE8gY2hhbmdlIHRvIGVuY29kZXItZGVjb2RlciB3aGVuIG1vZGVsIGlzIHNwbGl0IGNvcnJlY3RseVxuXSk7XG5cbmNvbnN0IE1PREVMX01BUFBJTkdfTkFNRVNfRU5DT0RFUl9ERUNPREVSID0gbmV3IE1hcChbXG4gICAgWyd0NScsIFQ1TW9kZWxdLFxuICAgIFsnbXQ1JywgTVQ1TW9kZWxdLFxuICAgIFsnYmFydCcsIEJhcnRNb2RlbF0sXG4gICAgWydtYXJpYW4nLCBNYXJpYW5Nb2RlbF0sXG4gICAgWyd3aGlzcGVyJywgV2hpc3Blck1vZGVsXSxcbiAgICBbJ20ybV8xMDAnLCBNMk0xMDBNb2RlbF0sXG5dKTtcblxuXG5jb25zdCBNT0RFTF9NQVBQSU5HX05BTUVTX0RFQ09ERVJfT05MWSA9IG5ldyBNYXAoW1xuICAgIFsnZ3B0MicsIEdQVDJNb2RlbF0sXG4gICAgWydncHRfYmlnY29kZScsIEdQVEJpZ0NvZGVNb2RlbF0sXG4gICAgWydncHRfbmVvJywgR1BUTmVvTW9kZWxdLFxuICAgIFsnY29kZWdlbicsIENvZGVHZW5Nb2RlbF0sXG5dKTtcblxuY29uc3QgTU9ERUxfRk9SX1NFUVVFTkNFX0NMQVNTSUZJQ0FUSU9OX01BUFBJTkdfTkFNRVMgPSBuZXcgTWFwKFtcbiAgICBbJ2JlcnQnLCBCZXJ0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbl0sXG4gICAgWydtcG5ldCcsIE1QTmV0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbl0sXG4gICAgWydhbGJlcnQnLCBBbGJlcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ2Rpc3RpbGJlcnQnLCBEaXN0aWxCZXJ0Rm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbl0sXG4gICAgWydyb2JlcnRhJywgUm9iZXJ0YUZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb25dLFxuICAgIFsneGxtLXJvYmVydGEnLCBYTE1Sb2JlcnRhRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbl0sXG4gICAgWydiYXJ0JywgQmFydEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb25dLFxuICAgIFsnbW9iaWxlYmVydCcsIE1vYmlsZUJlcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ3NxdWVlemViZXJ0JywgU3F1ZWV6ZUJlcnRGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uXSxcbl0pO1xuXG5jb25zdCBNT0RFTF9GT1JfVE9LRU5fQ0xBU1NJRklDQVRJT05fTUFQUElOR19OQU1FUyA9IG5ldyBNYXAoW1xuICAgIFsnYmVydCcsIEJlcnRGb3JUb2tlbkNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ21wbmV0JywgTVBOZXRGb3JUb2tlbkNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ2Rpc3RpbGJlcnQnLCBEaXN0aWxCZXJ0Rm9yVG9rZW5DbGFzc2lmaWNhdGlvbl0sXG4gICAgWydyb2JlcnRhJywgUm9iZXJ0YUZvclRva2VuQ2xhc3NpZmljYXRpb25dLFxuICAgIFsneGxtLXJvYmVydGEnLCBYTE1Sb2JlcnRhRm9yVG9rZW5DbGFzc2lmaWNhdGlvbl0sXG5dKTtcblxuY29uc3QgTU9ERUxfRk9SX1NFUV8yX1NFUV9NQVBQSU5HX05BTUVTID0gbmV3IE1hcChbXG4gICAgWyd0NScsIFQ1Rm9yQ29uZGl0aW9uYWxHZW5lcmF0aW9uXSxcbiAgICBbJ210NScsIE1UNUZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbl0sXG4gICAgWydiYXJ0JywgQmFydEZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbl0sXG4gICAgWyd3aGlzcGVyJywgV2hpc3BlckZvckNvbmRpdGlvbmFsR2VuZXJhdGlvbl0sXG4gICAgWydtYXJpYW4nLCBNYXJpYW5NVE1vZGVsXSxcbiAgICBbJ20ybV8xMDAnLCBNMk0xMDBGb3JDb25kaXRpb25hbEdlbmVyYXRpb25dLFxuXSk7XG5cbmNvbnN0IE1PREVMX1dJVEhfTE1fSEVBRF9NQVBQSU5HX05BTUVTID0gbmV3IE1hcChbXG4gICAgWydncHQyJywgR1BUMkxNSGVhZE1vZGVsXSxcbiAgICBbJ2dwdF9iaWdjb2RlJywgR1BUQmlnQ29kZUZvckNhdXNhbExNXSxcbiAgICBbJ2dwdF9uZW8nLCBHUFROZW9Gb3JDYXVzYWxMTV0sXG4gICAgWydjb2RlZ2VuJywgQ29kZUdlbkZvckNhdXNhbExNXSxcbl0pO1xuXG5jb25zdCBNT0RFTF9GT1JfTUFTS0VEX0xNX01BUFBJTkdfTkFNRVMgPSBuZXcgTWFwKFtcbiAgICBbJ2JlcnQnLCBCZXJ0Rm9yTWFza2VkTE1dLFxuICAgIFsnbXBuZXQnLCBNUE5ldEZvck1hc2tlZExNXSxcbiAgICBbJ2FsYmVydCcsIEFsYmVydEZvck1hc2tlZExNXSxcbiAgICBbJ2Rpc3RpbGJlcnQnLCBEaXN0aWxCZXJ0Rm9yTWFza2VkTE1dLFxuICAgIFsncm9iZXJ0YScsIFJvYmVydGFGb3JNYXNrZWRMTV0sXG4gICAgWyd4bG0tcm9iZXJ0YScsIFhMTVJvYmVydGFGb3JNYXNrZWRMTV0sXG4gICAgWydtb2JpbGViZXJ0JywgTW9iaWxlQmVydEZvck1hc2tlZExNXSxcbiAgICBbJ3NxdWVlemViZXJ0JywgU3F1ZWV6ZUJlcnRGb3JNYXNrZWRMTV0sXG5dKTtcblxuY29uc3QgTU9ERUxfRk9SX1FVRVNUSU9OX0FOU1dFUklOR19NQVBQSU5HX05BTUVTID0gbmV3IE1hcChbXG4gICAgWydiZXJ0JywgQmVydEZvclF1ZXN0aW9uQW5zd2VyaW5nXSxcbiAgICBbJ21wbmV0JywgTVBOZXRGb3JRdWVzdGlvbkFuc3dlcmluZ10sXG4gICAgWydhbGJlcnQnLCBBbGJlcnRGb3JRdWVzdGlvbkFuc3dlcmluZ10sXG4gICAgWydkaXN0aWxiZXJ0JywgRGlzdGlsQmVydEZvclF1ZXN0aW9uQW5zd2VyaW5nXSxcbiAgICBbJ3JvYmVydGEnLCBSb2JlcnRhRm9yUXVlc3Rpb25BbnN3ZXJpbmddLFxuICAgIFsneGxtLXJvYmVydGEnLCBYTE1Sb2JlcnRhRm9yUXVlc3Rpb25BbnN3ZXJpbmddLFxuICAgIFsnbW9iaWxlYmVydCcsIE1vYmlsZUJlcnRGb3JRdWVzdGlvbkFuc3dlcmluZ10sXG4gICAgWydzcXVlZXplYmVydCcsIFNxdWVlemVCZXJ0Rm9yUXVlc3Rpb25BbnN3ZXJpbmddLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9WSVNJT05fMl9TRVFfTUFQUElOR19OQU1FUyA9IG5ldyBNYXAoW1xuICAgIFsndmlzaW9uLWVuY29kZXItZGVjb2RlcicsIFZpc2lvbkVuY29kZXJEZWNvZGVyTW9kZWxdLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9JTUFHRV9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTID0gbmV3IE1hcChbXG4gICAgWyd2aXQnLCBWaVRGb3JJbWFnZUNsYXNzaWZpY2F0aW9uXSxcbiAgICBbJ21vYmlsZXZpdCcsIE1vYmlsZVZpVEZvckltYWdlQ2xhc3NpZmljYXRpb25dLFxuXSk7XG5cbmNvbnN0IE1PREVMX0ZPUl9PQkpFQ1RfREVURUNUSU9OX01BUFBJTkdfTkFNRVMgPSBuZXcgTWFwKFtcbiAgICBbJ2RldHInLCBEZXRyRm9yT2JqZWN0RGV0ZWN0aW9uXSxcbl0pO1xuXG5jb25zdCBNT0RFTF9GT1JfSU1BR0VfU0VHTUVOVEFUSU9OX01BUFBJTkdfTkFNRVMgPSBuZXcgTWFwKFtcbiAgICBbJ2RldHInLCBEZXRyRm9yU2VnbWVudGF0aW9uXSxcbl0pO1xuXG5jb25zdCBNT0RFTF9GT1JfTUFTS19HRU5FUkFUSU9OX01BUFBJTkdfTkFNRVMgPSBuZXcgTWFwKFtcbiAgICBbJ3NhbScsIFNhbU1vZGVsXSxcbl0pO1xuXG5jb25zdCBNT0RFTF9DTEFTU19UWVBFX01BUFBJTkcgPSBbXG4gICAgW01PREVMX01BUFBJTkdfTkFNRVNfRU5DT0RFUl9PTkxZLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX01BUFBJTkdfTkFNRVNfRU5DT0RFUl9ERUNPREVSLCBFbmNvZGVyRGVjb2Rlck1vZGVsVHlwZV0sXG4gICAgW01PREVMX01BUFBJTkdfTkFNRVNfREVDT0RFUl9PTkxZLCBEZWNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9TRVFVRU5DRV9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9UT0tFTl9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9TRVFfMl9TRVFfTUFQUElOR19OQU1FUywgU2VxMlNlcU1vZGVsVHlwZV0sXG4gICAgW01PREVMX1dJVEhfTE1fSEVBRF9NQVBQSU5HX05BTUVTLCBEZWNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9NQVNLRURfTE1fTUFQUElOR19OQU1FUywgRW5jb2Rlck9ubHlNb2RlbFR5cGVdLFxuICAgIFtNT0RFTF9GT1JfUVVFU1RJT05fQU5TV0VSSU5HX01BUFBJTkdfTkFNRVMsIEVuY29kZXJPbmx5TW9kZWxUeXBlXSxcbiAgICBbTU9ERUxfRk9SX1ZJU0lPTl8yX1NFUV9NQVBQSU5HX05BTUVTLCBFbmNvZGVyRGVjb2Rlck1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9JTUFHRV9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9JTUFHRV9TRUdNRU5UQVRJT05fTUFQUElOR19OQU1FUywgRW5jb2Rlck9ubHlNb2RlbFR5cGVdLFxuICAgIFtNT0RFTF9GT1JfT0JKRUNUX0RFVEVDVElPTl9NQVBQSU5HX05BTUVTLCBFbmNvZGVyT25seU1vZGVsVHlwZV0sXG4gICAgW01PREVMX0ZPUl9NQVNLX0dFTkVSQVRJT05fTUFQUElOR19OQU1FUywgRW5jb2Rlck9ubHlNb2RlbFR5cGVdLFxuXTtcblxuZm9yIChjb25zdCBbbWFwcGluZ3MsIHR5cGVdIG9mIE1PREVMX0NMQVNTX1RZUEVfTUFQUElORykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIG1hcHBpbmdzLnZhbHVlcygpKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgTU9ERUxfVFlQRV9NQVBQSU5HLnNldChtb2RlbC5uYW1lLCB0eXBlKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIG1vZGVscyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gbW9kZWwgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsIGNvbmZpZy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbC5mcm9tX3ByZXRyYWluZWQoJ2JlcnQtYmFzZS11bmNhc2VkJyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvTW9kZWwgZXh0ZW5kcyBQcmV0cmFpbmVkTWl4aW4ge1xuICAgIHN0YXRpYyBNT0RFTF9DTEFTU19NQVBQSU5HUyA9IFtNT0RFTF9NQVBQSU5HX05BTUVTX0VOQ09ERVJfT05MWSwgTU9ERUxfTUFQUElOR19OQU1FU19FTkNPREVSX0RFQ09ERVIsIE1PREVMX01BUFBJTkdfTkFNRVNfREVDT0RFUl9PTkxZXTtcbiAgICBzdGF0aWMgQkFTRV9JRl9GQUlMID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIHNlcXVlbmNlIGNsYXNzaWZpY2F0aW9uIG1vZGVscyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gbW9kZWwgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsIGNvbmZpZy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24uZnJvbV9wcmV0cmFpbmVkKCdkaXN0aWxiZXJ0LWJhc2UtdW5jYXNlZC1maW5ldHVuZWQtc3N0LTItZW5nbGlzaCcpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b01vZGVsRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbiBleHRlbmRzIFByZXRyYWluZWRNaXhpbiB7XG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gW01PREVMX0ZPUl9TRVFVRU5DRV9DTEFTU0lGSUNBVElPTl9NQVBQSU5HX05BTUVTXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIHRva2VuIGNsYXNzaWZpY2F0aW9uIG1vZGVscyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gbW9kZWwgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsIGNvbmZpZy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbEZvclRva2VuQ2xhc3NpZmljYXRpb24uZnJvbV9wcmV0cmFpbmVkKCdEYXZsYW4vZGlzdGlsYmVydC1iYXNlLW11bHRpbGluZ3VhbC1jYXNlZC1uZXItaHJsJyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvTW9kZWxGb3JUb2tlbkNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgUHJldHJhaW5lZE1peGluIHtcbiAgICBzdGF0aWMgTU9ERUxfQ0xBU1NfTUFQUElOR1MgPSBbTU9ERUxfRk9SX1RPS0VOX0NMQVNTSUZJQ0FUSU9OX01BUFBJTkdfTkFNRVNdO1xufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgc2VxdWVuY2UtdG8tc2VxdWVuY2UgbW9kZWxzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiBtb2RlbCBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsRm9yU2VxMlNlcUxNLmZyb21fcHJldHJhaW5lZCgndDUtc21hbGwnKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Nb2RlbEZvclNlcTJTZXFMTSBleHRlbmRzIFByZXRyYWluZWRNaXhpbiB7XG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gW01PREVMX0ZPUl9TRVFfMl9TRVFfTUFQUElOR19OQU1FU107XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCBjYXVzYWwgbGFuZ3VhZ2UgbW9kZWxzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiBtb2RlbCBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsRm9yQ2F1c2FsTE0uZnJvbV9wcmV0cmFpbmVkKCdncHQyJyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvTW9kZWxGb3JDYXVzYWxMTSBleHRlbmRzIFByZXRyYWluZWRNaXhpbiB7XG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gW01PREVMX1dJVEhfTE1fSEVBRF9NQVBQSU5HX05BTUVTXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIG1hc2tlZCBsYW5ndWFnZSBtb2RlbHMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIG1vZGVsIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWxGb3JNYXNrZWRMTS5mcm9tX3ByZXRyYWluZWQoJ2JlcnQtYmFzZS11bmNhc2VkJyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvTW9kZWxGb3JNYXNrZWRMTSBleHRlbmRzIFByZXRyYWluZWRNaXhpbiB7XG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gW01PREVMX0ZPUl9NQVNLRURfTE1fTUFQUElOR19OQU1FU107XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCBxdWVzdGlvbiBhbnN3ZXJpbmcgbW9kZWxzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiBtb2RlbCBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsRm9yUXVlc3Rpb25BbnN3ZXJpbmcuZnJvbV9wcmV0cmFpbmVkKCdkaXN0aWxiZXJ0LWJhc2UtY2FzZWQtZGlzdGlsbGVkLXNxdWFkJyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvTW9kZWxGb3JRdWVzdGlvbkFuc3dlcmluZyBleHRlbmRzIFByZXRyYWluZWRNaXhpbiB7XG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gW01PREVMX0ZPUl9RVUVTVElPTl9BTlNXRVJJTkdfTUFQUElOR19OQU1FU107XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCB2aXNpb24tdG8tc2VxdWVuY2UgbW9kZWxzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiBtb2RlbCBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsRm9yVmlzaW9uMlNlcS5mcm9tX3ByZXRyYWluZWQoJ25scGNvbm5lY3Qvdml0LWdwdDItaW1hZ2UtY2FwdGlvbmluZycpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b01vZGVsRm9yVmlzaW9uMlNlcSBleHRlbmRzIFByZXRyYWluZWRNaXhpbiB7XG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gW01PREVMX0ZPUl9WSVNJT05fMl9TRVFfTUFQUElOR19OQU1FU107XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHdoaWNoIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgcHJldHJhaW5lZCBpbWFnZSBjbGFzc2lmaWNhdGlvbiBtb2RlbHMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIG1vZGVsIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWxGb3JJbWFnZUNsYXNzaWZpY2F0aW9uLmZyb21fcHJldHJhaW5lZCgnZ29vZ2xlL3ZpdC1iYXNlLXBhdGNoMTYtMjI0Jyk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvTW9kZWxGb3JJbWFnZUNsYXNzaWZpY2F0aW9uIGV4dGVuZHMgUHJldHJhaW5lZE1peGluIHtcbiAgICBzdGF0aWMgTU9ERUxfQ0xBU1NfTUFQUElOR1MgPSBbTU9ERUxfRk9SX0lNQUdFX0NMQVNTSUZJQ0FUSU9OX01BUFBJTkdfTkFNRVNdO1xufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgaW1hZ2Ugc2VnbWVudGF0aW9uIG1vZGVscyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gbW9kZWwgY2xhc3MgaXMgZGV0ZXJtaW5lZCBieSB0aGUgdHlwZSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsIGNvbmZpZy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGxldCBtb2RlbCA9IGF3YWl0IEF1dG9Nb2RlbEZvckltYWdlU2VnbWVudGF0aW9uLmZyb21fcHJldHJhaW5lZCgnZmFjZWJvb2svZGV0ci1yZXNuZXQtNTAtcGFub3B0aWMnKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Nb2RlbEZvckltYWdlU2VnbWVudGF0aW9uIGV4dGVuZHMgUHJldHJhaW5lZE1peGluIHtcbiAgICBzdGF0aWMgTU9ERUxfQ0xBU1NfTUFQUElOR1MgPSBbTU9ERUxfRk9SX0lNQUdFX1NFR01FTlRBVElPTl9NQVBQSU5HX05BTUVTXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIG9iamVjdCBkZXRlY3Rpb24gbW9kZWxzIHdpdGggdGhlIGBmcm9tX3ByZXRyYWluZWRgIGZ1bmN0aW9uLlxuICogVGhlIGNob3NlbiBtb2RlbCBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IG1vZGVsID0gYXdhaXQgQXV0b01vZGVsRm9yT2JqZWN0RGV0ZWN0aW9uLmZyb21fcHJldHJhaW5lZCgnZmFjZWJvb2svZGV0ci1yZXNuZXQtNTAnKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Nb2RlbEZvck9iamVjdERldGVjdGlvbiBleHRlbmRzIFByZXRyYWluZWRNaXhpbiB7XG4gICAgc3RhdGljIE1PREVMX0NMQVNTX01BUFBJTkdTID0gW01PREVMX0ZPUl9PQkpFQ1RfREVURUNUSU9OX01BUFBJTkdfTkFNRVNdO1xufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgb2JqZWN0IGRldGVjdGlvbiBtb2RlbHMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIG1vZGVsIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCBjb25maWcuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBsZXQgbW9kZWwgPSBhd2FpdCBBdXRvTW9kZWxGb3JNYXNrR2VuZXJhdGlvbi5mcm9tX3ByZXRyYWluZWQoJ1hlbm92YS9zYW0tdml0LWJhc2UnKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Nb2RlbEZvck1hc2tHZW5lcmF0aW9uIGV4dGVuZHMgUHJldHJhaW5lZE1peGluIHtcbiAgICBzdGF0aWMgTU9ERUxfQ0xBU1NfTUFQUElOR1MgPSBbTU9ERUxfRk9SX01BU0tfR0VORVJBVElPTl9NQVBQSU5HX05BTUVTXTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgY2xhc3MgU2VxMlNlcUxNT3V0cHV0IGV4dGVuZHMgTW9kZWxPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgVGhlIG91dHB1dCBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5sb2dpdHMgVGhlIG91dHB1dCBsb2dpdHMgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQucGFzdF9rZXlfdmFsdWVzIEFuIHRlbnNvciBvZiBrZXkvdmFsdWUgcGFpcnMgdGhhdCByZXByZXNlbnQgdGhlIHByZXZpb3VzIHN0YXRlIG9mIHRoZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LmVuY29kZXJfb3V0cHV0cyBUaGUgb3V0cHV0IG9mIHRoZSBlbmNvZGVyIGluIGEgc2VxdWVuY2UtdG8tc2VxdWVuY2UgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IFtvdXRwdXQuZGVjb2Rlcl9hdHRlbnRpb25zXSBBdHRlbnRpb25zIHdlaWdodHMgb2YgdGhlIGRlY29kZXIsIGFmdGVyIHRoZSBhdHRlbnRpb24gc29mdG1heCwgdXNlZCB0byBjb21wdXRlIHRoZSB3ZWlnaHRlZCBhdmVyYWdlIGluIHRoZSBzZWxmLWF0dGVudGlvbiBoZWFkcy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gW291dHB1dC5jcm9zc19hdHRlbnRpb25zXSBBdHRlbnRpb25zIHdlaWdodHMgb2YgdGhlIGRlY29kZXIncyBjcm9zcy1hdHRlbnRpb24gbGF5ZXIsIGFmdGVyIHRoZSBhdHRlbnRpb24gc29mdG1heCwgdXNlZCB0byBjb21wdXRlIHRoZSB3ZWlnaHRlZCBhdmVyYWdlIGluIHRoZSBjcm9zcy1hdHRlbnRpb24gaGVhZHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBsb2dpdHMsIHBhc3Rfa2V5X3ZhbHVlcywgZW5jb2Rlcl9vdXRwdXRzLCBkZWNvZGVyX2F0dGVudGlvbnMgPSBudWxsLCBjcm9zc19hdHRlbnRpb25zID0gbnVsbCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9naXRzID0gbG9naXRzO1xuICAgICAgICB0aGlzLnBhc3Rfa2V5X3ZhbHVlcyA9IHBhc3Rfa2V5X3ZhbHVlcztcbiAgICAgICAgdGhpcy5lbmNvZGVyX291dHB1dHMgPSBlbmNvZGVyX291dHB1dHM7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9hdHRlbnRpb25zID0gZGVjb2Rlcl9hdHRlbnRpb25zO1xuICAgICAgICB0aGlzLmNyb3NzX2F0dGVudGlvbnMgPSBjcm9zc19hdHRlbnRpb25zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBvdXRwdXRzIG9mIHNlbnRlbmNlIGNsYXNzaWZpY2F0aW9uIG1vZGVscy5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlcXVlbmNlQ2xhc3NpZmllck91dHB1dCBleHRlbmRzIE1vZGVsT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0IFRoZSBvdXRwdXQgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQubG9naXRzIGNsYXNzaWZpY2F0aW9uIChvciByZWdyZXNzaW9uIGlmIGNvbmZpZy5udW1fbGFiZWxzPT0xKSBzY29yZXMgKGJlZm9yZSBTb2Z0TWF4KS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGxvZ2l0cyB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9naXRzID0gbG9naXRzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBvdXRwdXRzIG9mIHRva2VuIGNsYXNzaWZpY2F0aW9uIG1vZGVscy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuQ2xhc3NpZmllck91dHB1dCBleHRlbmRzIE1vZGVsT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0IFRoZSBvdXRwdXQgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQubG9naXRzIENsYXNzaWZpY2F0aW9uIHNjb3JlcyAoYmVmb3JlIFNvZnRNYXgpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbG9naXRzIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2dpdHMgPSBsb2dpdHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIG1hc2tlZCBsYW5ndWFnZSBtb2RlbHMgb3V0cHV0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hc2tlZExNT3V0cHV0IGV4dGVuZHMgTW9kZWxPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgVGhlIG91dHB1dCBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5sb2dpdHMgUHJlZGljdGlvbiBzY29yZXMgb2YgdGhlIGxhbmd1YWdlIG1vZGVsaW5nIGhlYWQgKHNjb3JlcyBmb3IgZWFjaCB2b2NhYnVsYXJ5IHRva2VuIGJlZm9yZSBTb2Z0TWF4KS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGxvZ2l0cyB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9naXRzID0gbG9naXRzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBvdXRwdXRzIG9mIHF1ZXN0aW9uIGFuc3dlcmluZyBtb2RlbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWVzdGlvbkFuc3dlcmluZ01vZGVsT3V0cHV0IGV4dGVuZHMgTW9kZWxPdXRwdXQge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdXRwdXQgVGhlIG91dHB1dCBvZiB0aGUgbW9kZWwuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5zdGFydF9sb2dpdHMgU3Bhbi1zdGFydCBzY29yZXMgKGJlZm9yZSBTb2Z0TWF4KS5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gb3V0cHV0LmVuZF9sb2dpdHMgU3Bhbi1lbmQgc2NvcmVzIChiZWZvcmUgU29mdE1heCkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBzdGFydF9sb2dpdHMsIGVuZF9sb2dpdHMgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0YXJ0X2xvZ2l0cyA9IHN0YXJ0X2xvZ2l0cztcbiAgICAgICAgdGhpcy5lbmRfbG9naXRzID0gZW5kX2xvZ2l0cztcbiAgICB9XG59XG5cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBjYXVzYWwgbGFuZ3VhZ2UgbW9kZWwgKG9yIGF1dG9yZWdyZXNzaXZlKSBvdXRwdXRzLlxuICovXG5leHBvcnQgY2xhc3MgQ2F1c2FsTE1PdXRwdXRXaXRoUGFzdCBleHRlbmRzIE1vZGVsT3V0cHV0IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0IFRoZSBvdXRwdXQgb2YgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXQubG9naXRzIFByZWRpY3Rpb24gc2NvcmVzIG9mIHRoZSBsYW5ndWFnZSBtb2RlbGluZyBoZWFkIChzY29yZXMgZm9yIGVhY2ggdm9jYWJ1bGFyeSB0b2tlbiBiZWZvcmUgc29mdG1heCkuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dC5wYXN0X2tleV92YWx1ZXMgQ29udGFpbnMgcHJlLWNvbXB1dGVkIGhpZGRlbi1zdGF0ZXMgKGtleSBhbmQgdmFsdWVzIGluIHRoZSBzZWxmLWF0dGVudGlvbiBibG9ja3MpXG4gICAgICogdGhhdCBjYW4gYmUgdXNlZCAoc2VlIGBwYXN0X2tleV92YWx1ZXNgIGlucHV0KSB0byBzcGVlZCB1cCBzZXF1ZW50aWFsIGRlY29kaW5nLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbG9naXRzLCBwYXN0X2tleV92YWx1ZXMgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvZ2l0cyA9IGxvZ2l0cztcbiAgICAgICAgdGhpcy5wYXN0X2tleV92YWx1ZXMgPSBwYXN0X2tleV92YWx1ZXM7XG4gICAgfVxufSIsIi8qKlxuICogQGZpbGUgUGlwZWxpbmVzIHByb3ZpZGUgYSBoaWdoLWxldmVsLCBlYXN5IHRvIHVzZSwgQVBJIGZvciBydW5uaW5nIG1hY2hpbmUgbGVhcm5pbmcgbW9kZWxzLlxuICogXG4gKiAqKkV4YW1wbGU6KiogSW5zdGFudGlhdGUgcGlwZWxpbmUgdXNpbmcgdGhlIGBwaXBlbGluZWAgZnVuY3Rpb24uXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBwaXBlbGluZSB9IGZyb20gJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJztcbiAqIFxuICogbGV0IGNsYXNzaWZpZXIgPSBhd2FpdCBwaXBlbGluZSgnc2VudGltZW50LWFuYWx5c2lzJyk7XG4gKiBsZXQgcmVzdWx0ID0gYXdhaXQgY2xhc3NpZmllcignSSBsb3ZlIHRyYW5zZm9ybWVycyEnKTtcbiAqIC8vIFt7J2xhYmVsJzogJ1BPU0lUSVZFJywgJ3Njb3JlJzogMC45OTk4MTc2ODZ9XVxuICogYGBgXG4gKiBcbiAqIEBtb2R1bGUgcGlwZWxpbmVzXG4gKi9cblxuaW1wb3J0IHtcbiAgICBBdXRvVG9rZW5pemVyLFxuICAgIFByZVRyYWluZWRUb2tlbml6ZXIsXG59IGZyb20gJy4vdG9rZW5pemVycy5qcyc7XG5pbXBvcnQge1xuICAgIEF1dG9Nb2RlbCxcbiAgICBBdXRvTW9kZWxGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uLFxuICAgIEF1dG9Nb2RlbEZvclRva2VuQ2xhc3NpZmljYXRpb24sXG4gICAgQXV0b01vZGVsRm9yUXVlc3Rpb25BbnN3ZXJpbmcsXG4gICAgQXV0b01vZGVsRm9yTWFza2VkTE0sXG4gICAgQXV0b01vZGVsRm9yU2VxMlNlcUxNLFxuICAgIEF1dG9Nb2RlbEZvckNhdXNhbExNLFxuICAgIEF1dG9Nb2RlbEZvclZpc2lvbjJTZXEsXG4gICAgQXV0b01vZGVsRm9ySW1hZ2VDbGFzc2lmaWNhdGlvbixcbiAgICBBdXRvTW9kZWxGb3JJbWFnZVNlZ21lbnRhdGlvbixcbiAgICBBdXRvTW9kZWxGb3JPYmplY3REZXRlY3Rpb24sXG4gICAgUHJlVHJhaW5lZE1vZGVsLFxufSBmcm9tICcuL21vZGVscy5qcyc7XG5pbXBvcnQge1xuICAgIEF1dG9Qcm9jZXNzb3IsXG4gICAgUHJvY2Vzc29yXG59IGZyb20gJy4vcHJvY2Vzc29ycy5qcyc7XG5cblxuaW1wb3J0IHtcbiAgICBDYWxsYWJsZSxcbiAgICBpc1N0cmluZyxcbiAgICBkaXNwYXRjaENhbGxiYWNrLFxuICAgIHBvcCxcbn0gZnJvbSAnLi91dGlscy9jb3JlLmpzJztcbmltcG9ydCB7XG4gICAgc29mdG1heCxcbiAgICBtYXgsXG4gICAgZ2V0VG9wSXRlbXMsXG4gICAgcm91bmQsXG59IGZyb20gJy4vdXRpbHMvbWF0aHMuanMnO1xuaW1wb3J0IHtcbiAgICByZWFkX2F1ZGlvXG59IGZyb20gJy4vdXRpbHMvYXVkaW8uanMnO1xuaW1wb3J0IHtcbiAgICBtZWFuX3Bvb2xpbmcsXG59IGZyb20gJy4vdXRpbHMvdGVuc29yLmpzJztcbmltcG9ydCB7IFJhd0ltYWdlIH0gZnJvbSAnLi91dGlscy9pbWFnZS5qcyc7XG5cbi8qKlxuICogUHJlcGFyZSBpbWFnZXMgZm9yIGZ1cnRoZXIgdGFza3MuXG4gKiBAcGFyYW0ge2FueVtdfSBpbWFnZXMgaW1hZ2VzIHRvIHByZXBhcmUuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnlbXT59IHJldHVybnMgcHJvY2Vzc2VkIGltYWdlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVJbWFnZXMoaW1hZ2VzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGltYWdlcykpIHtcbiAgICAgICAgaW1hZ2VzID0gW2ltYWdlc107XG4gICAgfVxuXG4gICAgLy8gUG9zc2libHkgY29udmVydCBhbnkgbm9uLWltYWdlcyB0byBpbWFnZXNcbiAgICBpbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChpbWFnZXMubWFwKHggPT4gUmF3SW1hZ2UucmVhZCh4KSkpO1xuICAgIHJldHVybiBpbWFnZXM7XG59XG5cbi8qKlxuICogVGhlIFBpcGVsaW5lIGNsYXNzIGlzIHRoZSBjbGFzcyBmcm9tIHdoaWNoIGFsbCBwaXBlbGluZXMgaW5oZXJpdC5cbiAqIFJlZmVyIHRvIHRoaXMgY2xhc3MgZm9yIG1ldGhvZHMgc2hhcmVkIGFjcm9zcyBkaWZmZXJlbnQgcGlwZWxpbmVzLlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuZXhwb3J0IGNsYXNzIFBpcGVsaW5lIGV4dGVuZHMgQ2FsbGFibGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBQaXBlbGluZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFzayBUaGUgdGFzayBvZiB0aGUgcGlwZWxpbmUuIFVzZWZ1bCBmb3Igc3BlY2lmeWluZyBzdWJ0YXNrcy5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRUb2tlbml6ZXJ9IHRva2VuaXplciBUaGUgdG9rZW5pemVyIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRNb2RlbH0gbW9kZWwgVGhlIG1vZGVsIHRvIHVzZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXNrLCB0b2tlbml6ZXIsIG1vZGVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFzayA9IHRhc2s7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBtb2RlbCBoYXMgYmVlbiBkaXNwb3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBkaXNwb3NlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLm1vZGVsLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgdGFzayBhc3NvY2lhdGVkIHdpdGggdGhlIHBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7YW55fSB0ZXh0cyBUaGUgaW5wdXQgdGV4dHMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGlucHV0cyBhbmQgb3V0cHV0cyBvZiB0aGUgdGFzay5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbCh0ZXh0cykge1xuICAgICAgICAvLyBSdW4gdG9rZW5pemF0aW9uXG4gICAgICAgIGxldCBpbnB1dHMgPSB0aGlzLnRva2VuaXplcih0ZXh0cywge1xuICAgICAgICAgICAgcGFkZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIHRydW5jYXRpb246IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUnVuIG1vZGVsXG4gICAgICAgIGxldCBvdXRwdXRzID0gYXdhaXQgdGhpcy5tb2RlbChpbnB1dHMpXG5cbiAgICAgICAgcmV0dXJuIFtpbnB1dHMsIG91dHB1dHNdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUZXh0IGNsYXNzaWZpY2F0aW9uIHBpcGVsaW5lIHVzaW5nIGFueSBgTW9kZWxGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uYC5cbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0Q2xhc3NpZmljYXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgdGV4dCBjbGFzc2lmaWNhdGlvbiB0YXNrLlxuICAgICAqIEBwYXJhbSB7YW55fSB0ZXh0cyBUaGUgaW5wdXQgdGV4dHMgdG8gYmUgY2xhc3NpZmllZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRvcGs9MV0gVGhlIG51bWJlciBvZiB0b3AgcHJlZGljdGlvbnMgdG8gYmUgcmV0dXJuZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0W118T2JqZWN0Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByZWRpY3RlZCBsYWJlbHMgYW5kIHNjb3Jlcy5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbCh0ZXh0cywge1xuICAgICAgICB0b3BrID0gMVxuICAgIH0gPSB7fSkge1xuXG4gICAgICAgIGxldCBbaW5wdXRzLCBvdXRwdXRzXSA9IGF3YWl0IHN1cGVyLl9jYWxsKHRleHRzKTtcblxuICAgICAgICBsZXQgaWQybGFiZWwgPSB0aGlzLm1vZGVsLmNvbmZpZy5pZDJsYWJlbDtcbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IGJhdGNoIG9mIG91dHB1dHMubG9naXRzKSB7XG4gICAgICAgICAgICBsZXQgc2NvcmVzID0gZ2V0VG9wSXRlbXMoc29mdG1heChiYXRjaC5kYXRhKSwgdG9wayk7XG5cbiAgICAgICAgICAgIGxldCB2YWxzID0gc2NvcmVzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpZDJsYWJlbFt4WzBdXSxcbiAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHhbMV0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodG9wayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goLi4udmFscyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvUmV0dXJuLnB1c2godmFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0ZXh0cykgfHwgdG9wayA9PT0gMSA/IHRvUmV0dXJuIDogdG9SZXR1cm5bMF07XG4gICAgfVxufVxuXG5cbi8qKlxuICogTmFtZWQgRW50aXR5IFJlY29nbml0aW9uIHBpcGVsaW5lIHVzaW5nIGFueSBgTW9kZWxGb3JUb2tlbkNsYXNzaWZpY2F0aW9uYC5cbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBUb2tlbkNsYXNzaWZpY2F0aW9uUGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIHRva2VuIGNsYXNzaWZpY2F0aW9uIHRhc2suXG4gICAgICogQHBhcmFtIHthbnl9IHRleHRzIFRoZSBpbnB1dCB0ZXh0cyB0byBiZSBjbGFzc2lmaWVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3RbXXxPYmplY3Q+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvciBvYmplY3QgY29udGFpbmluZyB0aGUgcHJlZGljdGVkIGxhYmVscyBhbmQgc2NvcmVzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKHRleHRzLCB7XG4gICAgICAgIGlnbm9yZV9sYWJlbHMgPSBbJ08nXSwgLy8gVE9ETyBpbml0IHBhcmFtP1xuICAgIH0gPSB7fSkge1xuXG4gICAgICAgIGxldCBpc0JhdGNoZWQgPSBBcnJheS5pc0FycmF5KHRleHRzKTtcblxuICAgICAgICBpZiAoIWlzQmF0Y2hlZCkge1xuICAgICAgICAgICAgdGV4dHMgPSBbdGV4dHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRva2VuaXplciA9IHRoaXMudG9rZW5pemVyO1xuICAgICAgICBsZXQgW2lucHV0cywgb3V0cHV0c10gPSBhd2FpdCBzdXBlci5fY2FsbCh0ZXh0cyk7XG5cbiAgICAgICAgbGV0IGxvZ2l0cyA9IG91dHB1dHMubG9naXRzO1xuICAgICAgICBsZXQgaWQybGFiZWwgPSB0aGlzLm1vZGVsLmNvbmZpZy5pZDJsYWJlbDtcblxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2dpdHMuZGltc1swXTsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaWRzID0gaW5wdXRzLmlucHV0X2lkc1tpXTtcbiAgICAgICAgICAgIGxldCBiYXRjaCA9IGxvZ2l0c1tpXTtcblxuICAgICAgICAgICAgLy8gTGlzdCBvZiB0b2tlbnMgdGhhdCBhcmVuJ3QgaWdub3JlZFxuICAgICAgICAgICAgbGV0IHRva2VucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiYXRjaC5kaW1zWzBdOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5EYXRhID0gYmF0Y2hbal07XG4gICAgICAgICAgICAgICAgbGV0IHRvcFNjb3JlSW5kZXggPSBtYXgodG9rZW5EYXRhLmRhdGEpWzFdO1xuXG4gICAgICAgICAgICAgICAgbGV0IGVudGl0eSA9IGlkMmxhYmVsW3RvcFNjb3JlSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVfbGFiZWxzLmluY2x1ZGVzKGVudGl0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcHJlZGljdGVkIGEgdG9rZW4gdGhhdCBzaG91bGQgYmUgaWdub3JlZC4gU28sIHdlIHNraXAgaXQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIG9wdGlvbiB0byBrZWVwIHNwZWNpYWwgdG9rZW5zP1xuICAgICAgICAgICAgICAgIGxldCB3b3JkID0gdG9rZW5pemVyLmRlY29kZShbaWRzW2pdLml0ZW0oKV0sIHsgc2tpcF9zcGVjaWFsX3Rva2VuczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAod29yZCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FzIGEgc3BlY2lhbCB0b2tlbi4gU28sIHdlIHNraXAgaXQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBzY29yZXMgPSBzb2Z0bWF4KHRva2VuRGF0YS5kYXRhKTtcblxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5OiBlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlOiBzY29yZXNbdG9wU2NvcmVJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBqLFxuICAgICAgICAgICAgICAgICAgICB3b3JkOiB3b3JkLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG51bGwgZm9yIG5vdywgYnV0IHdpbGwgYWRkXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKHRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQmF0Y2hlZCA/IHRvUmV0dXJuIDogdG9SZXR1cm5bMF07XG4gICAgfVxufVxuLyoqXG4gKiBRdWVzdGlvbiBBbnN3ZXJpbmcgcGlwZWxpbmUgdXNpbmcgYW55IGBNb2RlbEZvclF1ZXN0aW9uQW5zd2VyaW5nYC5cbiAqIFxuICogKipFeGFtcGxlOioqIFJ1biBxdWVzdGlvbiBhbnN3ZXJpbmcgd2l0aCBgZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQtZGlzdGlsbGVkLXNxdWFkYC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCBxdWVzdGlvbiA9ICdXaG8gd2FzIEppbSBIZW5zb24/JztcbiAqIGxldCBjb250ZXh0ID0gJ0ppbSBIZW5zb24gd2FzIGEgbmljZSBwdXBwZXQuJztcbiAqIFxuICogbGV0IGFuc3dlcmVyID0gYXdhaXQgcGlwZWxpbmUoJ3F1ZXN0aW9uLWFuc3dlcmluZycsICdYZW5vdmEvZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQtZGlzdGlsbGVkLXNxdWFkJyk7XG4gKiBsZXQgb3V0cHV0cyA9IGF3YWl0IGFuc3dlcmVyKHF1ZXN0aW9uLCBjb250ZXh0KTtcbiAqIGNvbnNvbGUubG9nKG91dHB1dHMpO1xuICogLy8ge1xuICogLy8gICAgIFwiYW5zd2VyXCI6IFwiYSBuaWNlIHB1cHBldFwiLFxuICogLy8gICAgIFwic2NvcmVcIjogMC41NzY4OTExNTAyNTI2NzQxXG4gKiAvLyB9XG4gKiBgYGBcbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWVzdGlvbkFuc3dlcmluZ1BpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBxdWVzdGlvbiBhbnN3ZXJpbmcgdGFzay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcXVlc3Rpb24gVGhlIHF1ZXN0aW9uKHMpIHRvIGJlIGFuc3dlcmVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBjb250ZXh0IFRoZSBjb250ZXh0KHMpIHdoZXJlIHRoZSBhbnN3ZXIocykgY2FuIGJlIGZvdW5kLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudG9waz0xXSBUaGUgbnVtYmVyIG9mIHRvcCBhbnN3ZXIgcHJlZGljdGlvbnMgdG8gYmUgcmV0dXJuZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByZWRpY3RlZCBhbnN3ZXJzIGFuZCBzY29yZXMuXG4gICAgICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGFzeW5jIF9jYWxsKHF1ZXN0aW9uLCBjb250ZXh0LCB7XG4gICAgICAgIHRvcGsgPSAxXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgLy8gUnVuIHRva2VuaXphdGlvblxuICAgICAgICBsZXQgaW5wdXRzID0gdGhpcy50b2tlbml6ZXIocXVlc3Rpb24sIHtcbiAgICAgICAgICAgIHRleHRfcGFpcjogY29udGV4dCxcbiAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICB0cnVuY2F0aW9uOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBvdXRwdXQgPSBhd2FpdCB0aGlzLm1vZGVsKGlucHV0cyk7XG5cbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3V0cHV0LnN0YXJ0X2xvZ2l0cy5kaW1zWzBdOyArK2opIHtcbiAgICAgICAgICAgIGxldCBpZHMgPSBpbnB1dHMuaW5wdXRfaWRzW2pdO1xuICAgICAgICAgICAgbGV0IHNlcEluZGV4ID0gaWRzLmluZGV4T2YodGhpcy50b2tlbml6ZXIuc2VwX3Rva2VuX2lkKTtcblxuICAgICAgICAgICAgbGV0IHMxID0gQXJyYXkuZnJvbShzb2Z0bWF4KG91dHB1dC5zdGFydF9sb2dpdHNbal0uZGF0YSkpXG4gICAgICAgICAgICAgICAgLm1hcCgoeCwgaSkgPT4gW3gsIGldKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4WzFdID4gc2VwSW5kZXgpO1xuICAgICAgICAgICAgbGV0IGUxID0gQXJyYXkuZnJvbShzb2Z0bWF4KG91dHB1dC5lbmRfbG9naXRzW2pdLmRhdGEpKVxuICAgICAgICAgICAgICAgIC5tYXAoKHgsIGkpID0+IFt4LCBpXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHggPT4geFsxXSA+IHNlcEluZGV4KTtcblxuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSBwcm9kdWN0KHMxLCBlMSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHggPT4geFswXVsxXSA8PSB4WzFdWzFdKVxuICAgICAgICAgICAgICAgIC5tYXAoeCA9PiBbeFswXVsxXSwgeFsxXVsxXSwgeFswXVswXSAqIHhbMV1bMF1dKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiWzJdIC0gYVsyXSk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgTWF0aC5taW4ob3B0aW9ucy5sZW5ndGgsIHRvcGspOyArK2spIHtcbiAgICAgICAgICAgICAgICBsZXQgW3N0YXJ0LCBlbmQsIHNjb3JlXSA9IG9wdGlvbnNba107XG5cbiAgICAgICAgICAgICAgICBsZXQgYW5zd2VyX3Rva2VucyA9IFsuLi5pZHNdLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKVxuXG4gICAgICAgICAgICAgICAgbGV0IGFuc3dlciA9IHRoaXMudG9rZW5pemVyLmRlY29kZShhbnN3ZXJfdG9rZW5zLCB7XG4gICAgICAgICAgICAgICAgICAgIHNraXBfc3BlY2lhbF90b2tlbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIGFkZCBzdGFydCBhbmQgZW5kP1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IEhGIHJldHVybnMgY2hhcmFjdGVyIGluZGV4XG4gICAgICAgICAgICAgICAgdG9SZXR1cm4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFuc3dlciwgc2NvcmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1pbWljIEhGJ3MgcmV0dXJuIHR5cGUgYmFzZWQgb24gdG9wa1xuICAgICAgICByZXR1cm4gKHRvcGsgPT09IDEpID8gdG9SZXR1cm5bMF0gOiB0b1JldHVybjtcblxuICAgIH1cbn1cblxuLyoqXG4gKiBNYXNrZWQgbGFuZ3VhZ2UgbW9kZWxpbmcgcHJlZGljdGlvbiBwaXBlbGluZSB1c2luZyBhbnkgYE1vZGVsV2l0aExNSGVhZGAuXG4gKiBAZXh0ZW5kcyBQaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgRmlsbE1hc2tQaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICAvKipcbiAgICAgKiBGaWxsIHRoZSBtYXNrZWQgdG9rZW4gaW4gdGhlIHRleHQocykgZ2l2ZW4gYXMgaW5wdXRzLlxuICAgICAqIEBwYXJhbSB7YW55fSB0ZXh0cyBUaGUgbWFza2VkIGlucHV0IHRleHRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudG9waz01XSBUaGUgbnVtYmVyIG9mIHRvcCBwcmVkaWN0aW9ucyB0byBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3RbXXxPYmplY3Q+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvciBvYmplY3QgY29udGFpbmluZyB0aGUgcHJlZGljdGVkIHRva2VucyBhbmQgc2NvcmVzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKHRleHRzLCB7XG4gICAgICAgIHRvcGsgPSA1XG4gICAgfSA9IHt9KSB7XG4gICAgICAgIC8vIFJ1biB0b2tlbml6YXRpb25cbiAgICAgICAgbGV0IFtpbnB1dHMsIG91dHB1dHNdID0gYXdhaXQgc3VwZXIuX2NhbGwodGV4dHMpO1xuXG4gICAgICAgIC8vIERldGVybWluZSBpbmRpY2VzIG9mIG1hc2sgdG9rZW5zXG4gICAgICAgIC8vIGxldCBtYXNrX3Rva2VuX2luZGljZXMgPSBpbnB1dHMuaW5wdXRfaWRzLmRhdGEubWFwKHggPT4gKVxuXG4gICAgICAgIC8vIGxldCBsb2dpdHMgPSByZXNoYXBlKG91dHB1dHMubG9naXRzLmRhdGEsIG91dHB1dHMubG9naXRzLmRpbXMpO1xuXG4gICAgICAgIGxldCB0b2tlbml6ZXIgPSB0aGlzLnRva2VuaXplcjtcblxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5pbnB1dF9pZHMuZGltc1swXTsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaWRzID0gaW5wdXRzLmlucHV0X2lkc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXNrX3Rva2VuX2luZGV4ID0gaWRzLmluZGV4T2YodGhpcy50b2tlbml6ZXIubWFza190b2tlbl9pZClcblxuICAgICAgICAgICAgaWYgKG1hc2tfdG9rZW5faW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1hc2sgdG9rZW4gKCR7dG9rZW5pemVyLm1hc2tfdG9rZW59KSBub3QgZm91bmQgaW4gdGV4dC5gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxvZ2l0cyA9IG91dHB1dHMubG9naXRzW2ldO1xuICAgICAgICAgICAgbGV0IGl0ZW1Mb2dpdHMgPSBsb2dpdHNbbWFza190b2tlbl9pbmRleF07XG5cbiAgICAgICAgICAgIGxldCBzY29yZXMgPSBnZXRUb3BJdGVtcyhzb2Z0bWF4KGl0ZW1Mb2dpdHMuZGF0YSksIHRvcGspO1xuXG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKHNjb3Jlcy5tYXAoeCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNlcXVlbmNlID0gWy4uLmlkc107XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VbbWFza190b2tlbl9pbmRleF0gPSB4WzBdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHhbMV0sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiB4WzBdLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHI6IHRva2VuaXplci5tb2RlbC52b2NhYlt4WzBdXSxcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2U6IHRva2VuaXplci5kZWNvZGUoc2VxdWVuY2UsIHsgc2tpcF9zcGVjaWFsX3Rva2VuczogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGV4dHMpID8gdG9SZXR1cm4gOiB0b1JldHVyblswXTtcbiAgICB9XG59XG5cbi8qKlxuICogVGV4dDJUZXh0R2VuZXJhdGlvblBpcGVsaW5lIGNsYXNzIGZvciBnZW5lcmF0aW5nIHRleHQgdXNpbmcgYSBtb2RlbCB0aGF0IHBlcmZvcm1zIHRleHQtdG8tdGV4dCBnZW5lcmF0aW9uIHRhc2tzLlxuICogQGV4dGVuZHMgUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIFRleHQyVGV4dEdlbmVyYXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICBfa2V5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEZpbGwgdGhlIG1hc2tlZCB0b2tlbiBpbiB0aGUgdGV4dChzKSBnaXZlbiBhcyBpbnB1dHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHRleHRzIFRoZSB0ZXh0IG9yIGFycmF5IG9mIHRleHRzIHRvIGJlIHByb2Nlc3NlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbnMgZm9yIHRoZSBmaWxsLW1hc2sgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRvcGs9NV0gVGhlIG51bWJlciBvZiB0b3AtayBwcmVkaWN0aW9ucyB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBzY29yZSwgcHJlZGljdGVkIHRva2VuLCBwcmVkaWN0ZWQgdG9rZW4gc3RyaW5nLFxuICAgICAqIGFuZCB0aGUgc2VxdWVuY2Ugd2l0aCB0aGUgcHJlZGljdGVkIHRva2VuIGZpbGxlZCBpbiwgb3IgYW4gYXJyYXkgb2Ygc3VjaCBhcnJheXMgKG9uZSBmb3IgZWFjaCBpbnB1dCB0ZXh0KS5cbiAgICAgKiBJZiBvbmx5IG9uZSBpbnB1dCB0ZXh0IGlzIGdpdmVuLCB0aGUgb3V0cHV0IHdpbGwgYmUgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gV2hlbiB0aGUgbWFzayB0b2tlbiBpcyBub3QgZm91bmQgaW4gdGhlIGlucHV0IHRleHQuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwodGV4dHMsIGdlbmVyYXRlX2t3YXJncyA9IHt9KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0ZXh0cykpIHtcbiAgICAgICAgICAgIHRleHRzID0gW3RleHRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBnbG9iYWwgcHJlZml4LCBpZiBwcmVzZW50XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmNvbmZpZy5wcmVmaXgpIHtcbiAgICAgICAgICAgIHRleHRzID0gdGV4dHMubWFwKHggPT4gdGhpcy5tb2RlbC5jb25maWcucHJlZml4ICsgeClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0YXNrIHNwZWNpZmljIHBhcmFtczpcbiAgICAgICAgbGV0IHRhc2tfc3BlY2lmaWNfcGFyYW1zID0gdGhpcy5tb2RlbC5jb25maWcudGFza19zcGVjaWZpY19wYXJhbXNcbiAgICAgICAgaWYgKHRhc2tfc3BlY2lmaWNfcGFyYW1zICYmIHRhc2tfc3BlY2lmaWNfcGFyYW1zW3RoaXMudGFza10pIHtcbiAgICAgICAgICAgIC8vIEFkZCBwcmVmaXhlcywgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKHRhc2tfc3BlY2lmaWNfcGFyYW1zW3RoaXMudGFza10ucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgdGV4dHMgPSB0ZXh0cy5tYXAoeCA9PiB0YXNrX3NwZWNpZmljX3BhcmFtc1t0aGlzLnRhc2tdLnByZWZpeCArIHgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE8gdXBkYXRlIGdlbmVyYXRpb24gY29uZmlnXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9rZW5pemVyX29wdGlvbnMgPSB7XG4gICAgICAgICAgICBwYWRkaW5nOiB0cnVlLFxuICAgICAgICAgICAgdHJ1bmNhdGlvbjogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5wdXRfaWRzO1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFRyYW5zbGF0aW9uUGlwZWxpbmUgJiYgJ19idWlsZF90cmFuc2xhdGlvbl9pbnB1dHMnIGluIHRoaXMudG9rZW5pemVyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIHRvIFRyYW5zbGF0aW9uIHBpcGVsaW5lP1xuICAgICAgICAgICAgLy8gQ3VycmVudGx5IHB1dCBoZXJlIHRvIGF2b2lkIGNvZGUgZHVwbGljYXRpb25cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlucHV0X2lkcyA9IHRoaXMudG9rZW5pemVyLl9idWlsZF90cmFuc2xhdGlvbl9pbnB1dHModGV4dHMsIHRva2VuaXplcl9vcHRpb25zLCBnZW5lcmF0ZV9rd2FyZ3MpLmlucHV0X2lkcztcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRfaWRzID0gdGhpcy50b2tlbml6ZXIodGV4dHMsIHRva2VuaXplcl9vcHRpb25zKS5pbnB1dF9pZHM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0cHV0VG9rZW5JZHMgPSBhd2FpdCB0aGlzLm1vZGVsLmdlbmVyYXRlKGlucHV0X2lkcywgZ2VuZXJhdGVfa3dhcmdzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2FueVtdfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHRvUmV0dXJuID0gdGhpcy50b2tlbml6ZXIuYmF0Y2hfZGVjb2RlKG91dHB1dFRva2VuSWRzLCB7XG4gICAgICAgICAgICBza2lwX3NwZWNpYWxfdG9rZW5zOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2tleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9SZXR1cm4gPSB0b1JldHVybi5tYXAodGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9rZXkgPT09IG51bGwpID8gdGV4dCA6IHsgW3RoaXMuX2tleV06IHRleHQgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9SZXR1cm5cbiAgICB9XG59XG5cblxuLyoqXG4gKiBBIHBpcGVsaW5lIGZvciBzdW1tYXJpemF0aW9uIHRhc2tzLCBpbmhlcml0aW5nIGZyb20gVGV4dDJUZXh0R2VuZXJhdGlvblBpcGVsaW5lLlxuICogQGV4dGVuZHMgVGV4dDJUZXh0R2VuZXJhdGlvblBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBTdW1tYXJpemF0aW9uUGlwZWxpbmUgZXh0ZW5kcyBUZXh0MlRleHRHZW5lcmF0aW9uUGlwZWxpbmUge1xuICAgIF9rZXkgPSAnc3VtbWFyeV90ZXh0Jztcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGlvblBpcGVsaW5lIGNsYXNzIHRvIHRyYW5zbGF0ZSB0ZXh0IGZyb20gb25lIGxhbmd1YWdlIHRvIGFub3RoZXIgdXNpbmcgdGhlIHByb3ZpZGVkIG1vZGVsIGFuZCB0b2tlbml6ZXIuXG4gKiBAZXh0ZW5kcyBUZXh0MlRleHRHZW5lcmF0aW9uUGlwZWxpbmVcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zbGF0aW9uUGlwZWxpbmUgZXh0ZW5kcyBUZXh0MlRleHRHZW5lcmF0aW9uUGlwZWxpbmUge1xuICAgIF9rZXkgPSAndHJhbnNsYXRpb25fdGV4dCc7XG59XG5cbi8qKlxuICogTGFuZ3VhZ2UgZ2VuZXJhdGlvbiBwaXBlbGluZSB1c2luZyBhbnkgYE1vZGVsV2l0aExNSGVhZGAgb3IgYE1vZGVsRm9yQ2F1c2FsTE1gLlxuICogVGhpcyBwaXBlbGluZSBwcmVkaWN0cyB0aGUgd29yZHMgdGhhdCB3aWxsIGZvbGxvdyBhIHNwZWNpZmllZCB0ZXh0IHByb21wdC5cbiAqIE5PVEU6IEZvciB0aGUgZnVsbCBsaXN0IG9mIGdlbmVyYXRpb24gcGFyYW1ldGVycywgc2VlIFtgR2VuZXJhdGlvbkNvbmZpZ2BdKC4vdXRpbHMvZ2VuZXJhdGlvbiNtb2R1bGVfdXRpbHMvZ2VuZXJhdGlvbi5HZW5lcmF0aW9uQ29uZmlnKS5cbiAqIFxuICogKipFeGFtcGxlOioqIFRleHQgZ2VuZXJhdGlvbiB3aXRoIGBYZW5vdmEvZGlzdGlsZ3B0MmAgKGRlZmF1bHQgc2V0dGluZ3MpLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IHRleHQgPSAnSSBlbmpveSB3YWxraW5nIHdpdGggbXkgY3V0ZSBkb2csJztcbiAqIGxldCBnZW5lcmF0b3IgPSBhd2FpdCBwaXBlbGluZSgndGV4dC1nZW5lcmF0aW9uJywgJ1hlbm92YS9kaXN0aWxncHQyJyk7XG4gKiBsZXQgb3V0cHV0ID0gYXdhaXQgZ2VuZXJhdG9yKHRleHQpO1xuICogY29uc29sZS5sb2cob3V0cHV0KTtcbiAqIC8vIFt7IGdlbmVyYXRlZF90ZXh0OiBcIkkgZW5qb3kgd2Fsa2luZyB3aXRoIG15IGN1dGUgZG9nLCBhbmQgSSBsb3ZlIHRvIHBsYXkgd2l0aCB0aGUgb3RoZXIgZG9ncy5cIiB9XVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBUZXh0IGdlbmVyYXRpb24gd2l0aCBgWGVub3ZhL2Rpc3RpbGdwdDJgIChjdXN0b20gc2V0dGluZ3MpLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IHRleHQgPSAnT25jZSB1cG9uIGEgdGltZSwgdGhlcmUgd2FzJztcbiAqIGxldCBnZW5lcmF0b3IgPSBhd2FpdCBwaXBlbGluZSgndGV4dC1nZW5lcmF0aW9uJywgJ1hlbm92YS9kaXN0aWxncHQyJyk7XG4gKiBsZXQgb3V0cHV0ID0gYXdhaXQgZ2VuZXJhdG9yKHRleHQsIHtcbiAqICAgICB0ZW1wZXJhdHVyZTogMixcbiAqICAgICBtYXhfbmV3X3Rva2VuczogMTAsXG4gKiAgICAgcmVwZXRpdGlvbl9wZW5hbHR5OiAxLjUsXG4gKiAgICAgbm9fcmVwZWF0X25ncmFtX3NpemU6IDIsXG4gKiAgICAgbnVtX2JlYW1zOiAyLFxuICogICAgIG51bV9yZXR1cm5fc2VxdWVuY2VzOiAyLFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyhvdXRwdXQpO1xuICogLy8gW3tcbiAqIC8vICAgXCJnZW5lcmF0ZWRfdGV4dFwiOiBcIk9uY2UgdXBvbiBhIHRpbWUsIHRoZXJlIHdhcyBhbiBhYnVuZGFuY2Ugb2YgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpc3RvcnkgYW5kIGFjdGl2aXRpZXMgdGhhdFwiXG4gKiAvLyB9LCB7XG4gKiAvLyAgIFwiZ2VuZXJhdGVkX3RleHRcIjogXCJPbmNlIHVwb24gYSB0aW1lLCB0aGVyZSB3YXMgYW4gYWJ1bmRhbmNlIG9mIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtb3N0IGltcG9ydGFudCBhbmQgaW5mbHVlbnRpYWxcIlxuICogLy8gfV1cbiAqIGBgYFxuICogXG4gKiAqKkV4YW1wbGU6KiogUnVuIGNvZGUgZ2VuZXJhdGlvbiB3aXRoIGBYZW5vdmEvY29kZWdlbi0zNTBNLW1vbm9gLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IHRleHQgPSAnZGVmIGZpYihuKTonO1xuICogbGV0IGdlbmVyYXRvciA9IGF3YWl0IHBpcGVsaW5lKCd0ZXh0LWdlbmVyYXRpb24nLCAnWGVub3ZhL2NvZGVnZW4tMzUwTS1tb25vJyk7XG4gKiBsZXQgb3V0cHV0ID0gYXdhaXQgZ2VuZXJhdG9yKHRleHQsIHtcbiAqICAgICBtYXhfbmV3X3Rva2VuczogNDAsXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKG91dHB1dFswXS5nZW5lcmF0ZWRfdGV4dCk7XG4gKiAvLyBkZWYgZmliKG4pOlxuICogLy8gICAgIGlmIG4gPT0gMDpcbiAqIC8vICAgICAgICAgcmV0dXJuIDBcbiAqIC8vICAgICBpZiBuID09IDE6XG4gKiAvLyAgICAgICAgIHJldHVybiAxXG4gKiAvLyAgICAgcmV0dXJuIGZpYihuLTEpICsgZmliKG4tMilcbiAqIGBgYFxuICogXG4gKiBAZXh0ZW5kcyBQaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgVGV4dEdlbmVyYXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGV4dCBiYXNlZCBvbiBhbiBpbnB1dCBwcm9tcHQuXG4gICAgICogQHBhcmFtIHthbnl9IHRleHRzIFRoZSBpbnB1dCBwcm9tcHQgb3IgcHJvbXB0cyB0byBnZW5lcmF0ZSB0ZXh0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtnZW5lcmF0ZV9rd2FyZ3M9e31dIEFkZGl0aW9uYWwgYXJndW1lbnRzIGZvciB0ZXh0IGdlbmVyYXRpb24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIGdlbmVyYXRlZCB0ZXh0IG9yIHRleHRzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKHRleHRzLCBnZW5lcmF0ZV9rd2FyZ3MgPSB7fSkge1xuICAgICAgICBsZXQgc3RyaW5nSW5wdXQgPSB0eXBlb2YgdGV4dHMgPT09ICdzdHJpbmcnIHx8IHRleHRzIGluc3RhbmNlb2YgU3RyaW5nO1xuICAgICAgICBpZiAoc3RyaW5nSW5wdXQpIHtcbiAgICAgICAgICAgIHRleHRzID0gW3RleHRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9rZW5pemVyLnBhZGRpbmdfc2lkZSA9ICdsZWZ0JztcbiAgICAgICAgbGV0IGlucHV0cyA9IHRoaXMudG9rZW5pemVyKHRleHRzLCB7XG4gICAgICAgICAgICBwYWRkaW5nOiB0cnVlLFxuICAgICAgICAgICAgdHJ1bmNhdGlvbjogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGlucHV0X2lkcyA9IGlucHV0cy5pbnB1dF9pZHM7XG4gICAgICAgIGxldCBhdHRlbnRpb25fbWFzayA9IGlucHV0cy5hdHRlbnRpb25fbWFzaztcblxuICAgICAgICBsZXQgb3V0cHV0VG9rZW5JZHMgPSBhd2FpdCB0aGlzLm1vZGVsLmdlbmVyYXRlKGlucHV0X2lkcywgZ2VuZXJhdGVfa3dhcmdzLCBudWxsLCB7XG4gICAgICAgICAgICBpbnB1dHNfYXR0ZW50aW9uX21hc2s6IGF0dGVudGlvbl9tYXNrXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSB0aGlzLnRva2VuaXplci5iYXRjaF9kZWNvZGUob3V0cHV0VG9rZW5JZHMsIHtcbiAgICAgICAgICAgIHNraXBfc3BlY2lhbF90b2tlbnM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b1JldHVybiA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRleHRzLmxlbmd0aCB9LCBfID0+IFtdKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0SW5kZXggPSBNYXRoLmZsb29yKGkgLyBvdXRwdXRUb2tlbklkcy5sZW5ndGggKiB0ZXh0cy5sZW5ndGgpO1xuXG4gICAgICAgICAgICB0b1JldHVyblt0ZXh0SW5kZXhdLnB1c2goe1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZF90ZXh0OiBkZWNvZGVkW2ldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHN0cmluZ0lucHV0ICYmIHRvUmV0dXJuLmxlbmd0aCA9PT0gMSkgPyB0b1JldHVyblswXSA6IHRvUmV0dXJuO1xuICAgIH1cbn1cblxuLyoqXG4gKiBOTEktYmFzZWQgemVyby1zaG90IGNsYXNzaWZpY2F0aW9uIHBpcGVsaW5lIHVzaW5nIGEgYE1vZGVsRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbmBcbiAqIHRyYWluZWQgb24gTkxJIChuYXR1cmFsIGxhbmd1YWdlIGluZmVyZW5jZSkgdGFza3MuIEVxdWl2YWxlbnQgb2YgYHRleHQtY2xhc3NpZmljYXRpb25gXG4gKiBwaXBlbGluZXMsIGJ1dCB0aGVzZSBtb2RlbHMgZG9uJ3QgcmVxdWlyZSBhIGhhcmRjb2RlZCBudW1iZXIgb2YgcG90ZW50aWFsIGNsYXNzZXMsIHRoZXlcbiAqIGNhbiBiZSBjaG9zZW4gYXQgcnVudGltZS4gSXQgdXN1YWxseSBtZWFucyBpdCdzIHNsb3dlciBidXQgaXQgaXMgKiptdWNoKiogbW9yZSBmbGV4aWJsZS5cbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBaZXJvU2hvdENsYXNzaWZpY2F0aW9uUGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgWmVyb1Nob3RDbGFzc2lmaWNhdGlvblBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrIFRoZSB0YXNrIG9mIHRoZSBwaXBlbGluZS4gVXNlZnVsIGZvciBzcGVjaWZ5aW5nIHN1YnRhc2tzLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZFRva2VuaXplcn0gdG9rZW5pemVyIFRoZSB0b2tlbml6ZXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZE1vZGVsfSBtb2RlbCBUaGUgbW9kZWwgdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhc2ssIHRva2VuaXplciwgbW9kZWwpIHtcbiAgICAgICAgc3VwZXIodGFzaywgdG9rZW5pemVyLCBtb2RlbCk7XG5cbiAgICAgICAgLy8gVXNlIG1vZGVsIGNvbmZpZyB0byBnZXQgbGFiZWwyaWQgbWFwcGluZ1xuICAgICAgICB0aGlzLmxhYmVsMmlkID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5tb2RlbC5jb25maWcubGFiZWwyaWQpLm1hcChcbiAgICAgICAgICAgICAgICAoW2ssIHZdKSA9PiBbay50b0xvd2VyQ2FzZSgpLCB2XVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuZW50YWlsbWVudF9pZCA9IHRoaXMubGFiZWwyaWRbJ2VudGFpbG1lbnQnXTtcbiAgICAgICAgaWYgKHRoaXMuZW50YWlsbWVudF9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCAnZW50YWlsbWVudCcgaW4gbGFiZWwyaWQgbWFwcGluZy4gVXNpbmcgMiBhcyBlbnRhaWxtZW50X2lkLlwiKTtcbiAgICAgICAgICAgIHRoaXMuZW50YWlsbWVudF9pZCA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnRyYWRpY3Rpb25faWQgPSB0aGlzLmxhYmVsMmlkWydjb250cmFkaWN0aW9uJ107XG4gICAgICAgIGlmICh0aGlzLmNvbnRyYWRpY3Rpb25faWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgJ2NvbnRyYWRpY3Rpb24nIGluIGxhYmVsMmlkIG1hcHBpbmcuIFVzaW5nIDAgYXMgY29udHJhZGljdGlvbl9pZC5cIik7XG4gICAgICAgICAgICB0aGlzLmNvbnRyYWRpY3Rpb25faWQgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55W119IHRleHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gY2FuZGlkYXRlX2xhYmVsc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9uczpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaHlwb3RoZXNpc190ZW1wbGF0ZT1cIlRoaXMgZXhhbXBsZSBpcyB7fS5cIl0gVGhlIHRlbXBsYXRlIHVzZWQgdG8gdHVybiBlYWNoXG4gICAgICogY2FuZGlkYXRlIGxhYmVsIGludG8gYW4gTkxJLXN0eWxlIGh5cG90aGVzaXMuIFRoZSBjYW5kaWRhdGUgbGFiZWwgd2lsbCByZXBsYWNlIHRoZSB7fSBwbGFjZWhvbGRlci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm11bHRpX2xhYmVsPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCBtdWx0aXBsZSBjYW5kaWRhdGUgbGFiZWxzIGNhbiBiZSB0cnVlLlxuICAgICAqIElmIGBmYWxzZWAsIHRoZSBzY29yZXMgYXJlIG5vcm1hbGl6ZWQgc3VjaCB0aGF0IHRoZSBzdW0gb2YgdGhlIGxhYmVsIGxpa2VsaWhvb2RzIGZvciBlYWNoIHNlcXVlbmNlXG4gICAgICogaXMgMS4gSWYgYHRydWVgLCB0aGUgbGFiZWxzIGFyZSBjb25zaWRlcmVkIGluZGVwZW5kZW50IGFuZCBwcm9iYWJpbGl0aWVzIGFyZSBub3JtYWxpemVkIGZvciBlYWNoXG4gICAgICogY2FuZGlkYXRlIGJ5IGRvaW5nIGEgc29mdG1heCBvZiB0aGUgZW50YWlsbWVudCBzY29yZSB2cy4gdGhlIGNvbnRyYWRpY3Rpb24gc2NvcmUuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3R8T2JqZWN0W10+fSBUaGUgcHJlZGljdGlvbihzKSwgYXMgYSBtYXAgKG9yIGxpc3Qgb2YgbWFwcykgZnJvbSBsYWJlbCB0byBzY29yZS5cbiAgICAgKi9cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYXN5bmMgX2NhbGwodGV4dHMsIGNhbmRpZGF0ZV9sYWJlbHMsIHtcbiAgICAgICAgaHlwb3RoZXNpc190ZW1wbGF0ZSA9IFwiVGhpcyBleGFtcGxlIGlzIHt9LlwiLFxuICAgICAgICBtdWx0aV9sYWJlbCA9IGZhbHNlLFxuICAgIH0gPSB7fSkge1xuXG4gICAgICAgIGxldCBpc0JhdGNoZWQgPSBBcnJheS5pc0FycmF5KHRleHRzKTtcblxuICAgICAgICBpZiAoIWlzQmF0Y2hlZCkge1xuICAgICAgICAgICAgdGV4dHMgPSBbdGV4dHNdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjYW5kaWRhdGVfbGFiZWxzKSkge1xuICAgICAgICAgICAgY2FuZGlkYXRlX2xhYmVscyA9IFtjYW5kaWRhdGVfbGFiZWxzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluc2VydCBsYWJlbHMgaW50byBoeXBvdGhlc2lzIHRlbXBsYXRlXG4gICAgICAgIGxldCBoeXBvdGhlc2VzID0gY2FuZGlkYXRlX2xhYmVscy5tYXAoXG4gICAgICAgICAgICB4ID0+IGh5cG90aGVzaXNfdGVtcGxhdGUucmVwbGFjZSgne30nLCB4KVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEhvdyB0byBwZXJmb3JtIHRoZSBzb2Z0bWF4IG92ZXIgdGhlIGxvZ2l0czpcbiAgICAgICAgLy8gIC0gdHJ1ZTogIHNvZnRtYXggb3ZlciB0aGUgZW50YWlsbWVudCB2cy4gY29udHJhZGljdGlvbiBkaW0gZm9yIGVhY2ggbGFiZWwgaW5kZXBlbmRlbnRseVxuICAgICAgICAvLyAgLSBmYWxzZTogc29mdG1heCB0aGUgXCJlbnRhaWxtZW50XCIgbG9naXRzIG92ZXIgYWxsIGNhbmRpZGF0ZSBsYWJlbHNcbiAgICAgICAgbGV0IHNvZnRtYXhFYWNoID0gbXVsdGlfbGFiZWwgfHwgY2FuZGlkYXRlX2xhYmVscy5sZW5ndGggPT09IDE7XG5cbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IHByZW1pc2Ugb2YgdGV4dHMpIHtcbiAgICAgICAgICAgIGxldCBlbnRhaWxzX2xvZ2l0cyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBoeXBvdGhlc2lzIG9mIGh5cG90aGVzZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXRzID0gdGhpcy50b2tlbml6ZXIocHJlbWlzZSwge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0X3BhaXI6IGh5cG90aGVzaXMsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRydW5jYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBsZXQgb3V0cHV0cyA9IGF3YWl0IHRoaXMubW9kZWwoaW5wdXRzKVxuXG4gICAgICAgICAgICAgICAgaWYgKHNvZnRtYXhFYWNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudGFpbHNfbG9naXRzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5sb2dpdHMuZGF0YVt0aGlzLmNvbnRyYWRpY3Rpb25faWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5sb2dpdHMuZGF0YVt0aGlzLmVudGFpbG1lbnRfaWRdXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW50YWlsc19sb2dpdHMucHVzaChvdXRwdXRzLmxvZ2l0cy5kYXRhW3RoaXMuZW50YWlsbWVudF9pZF0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc2NvcmVzO1xuICAgICAgICAgICAgaWYgKHNvZnRtYXhFYWNoKSB7XG4gICAgICAgICAgICAgICAgc2NvcmVzID0gZW50YWlsc19sb2dpdHMubWFwKHggPT4gc29mdG1heCh4KVsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjb3JlcyA9IHNvZnRtYXgoZW50YWlsc19sb2dpdHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTb3J0IGJ5IHNjb3JlcyAoZGVzYykgYW5kIHJldHVybiBzY29yZXMgd2l0aCBpbmRpY2VzXG4gICAgICAgICAgICBsZXQgc2NvcmVzX3NvcnRlZCA9IHNjb3Jlc1xuICAgICAgICAgICAgICAgIC5tYXAoKHgsIGkpID0+IFt4LCBpXSlcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYlswXSAtIGFbMF07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlcXVlbmNlOiBwcmVtaXNlLFxuICAgICAgICAgICAgICAgIGxhYmVsczogc2NvcmVzX3NvcnRlZC5tYXAoeCA9PiBjYW5kaWRhdGVfbGFiZWxzW3hbMV1dKSxcbiAgICAgICAgICAgICAgICBzY29yZXM6IHNjb3Jlc19zb3J0ZWQubWFwKHggPT4geFswXSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNCYXRjaGVkID8gdG9SZXR1cm4gOiB0b1JldHVyblswXTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBGZWF0dXJlIGV4dHJhY3Rpb24gcGlwZWxpbmUgdXNpbmcgbm8gbW9kZWwgaGVhZC4gVGhpcyBwaXBlbGluZSBleHRyYWN0cyB0aGUgaGlkZGVuXG4gKiBzdGF0ZXMgZnJvbSB0aGUgYmFzZSB0cmFuc2Zvcm1lciwgd2hpY2ggY2FuIGJlIHVzZWQgYXMgZmVhdHVyZXMgaW4gZG93bnN0cmVhbSB0YXNrcy5cbiAqIFxuICogKipFeGFtcGxlOioqIFJ1biBmZWF0dXJlIGV4dHJhY3Rpb24gd2l0aCBgYmVydC1iYXNlLXVuY2FzZWRgICh3aXRob3V0IHBvb2xpbmcvbm9ybWFsaXphdGlvbikuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgZXh0cmFjdG9yID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsICdYZW5vdmEvYmVydC1iYXNlLXVuY2FzZWQnLCB7IHJldmlzaW9uOiAnZGVmYXVsdCcgfSk7XG4gKiBsZXQgcmVzdWx0ID0gYXdhaXQgZXh0cmFjdG9yKCdUaGlzIGlzIGEgc2ltcGxlIHRlc3QuJyk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogLy8gVGVuc29yIHtcbiAqIC8vICAgICB0eXBlOiAnZmxvYXQzMicsXG4gKiAvLyAgICAgZGF0YTogRmxvYXQzMkFycmF5IFswLjA1OTM5OTI0NzE2OTQ5NDYzLCAwLjAyMTY1NTkzNTc5NDExNTA2NywgLi4uXSxcbiAqIC8vICAgICBkaW1zOiBbMSwgOCwgNzY4XVxuICogLy8gfVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBSdW4gZmVhdHVyZSBleHRyYWN0aW9uIHdpdGggYGJlcnQtYmFzZS11bmNhc2VkYCAod2l0aCBwb29saW5nL25vcm1hbGl6YXRpb24pLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IGV4dHJhY3RvciA9IGF3YWl0IHBpcGVsaW5lKCdmZWF0dXJlLWV4dHJhY3Rpb24nLCAnWGVub3ZhL2JlcnQtYmFzZS11bmNhc2VkJywgeyByZXZpc2lvbjogJ2RlZmF1bHQnIH0pO1xuICogbGV0IHJlc3VsdCA9IGF3YWl0IGV4dHJhY3RvcignVGhpcyBpcyBhIHNpbXBsZSB0ZXN0LicsIHsgcG9vbGluZzogJ21lYW4nLCBub3JtYWxpemU6IHRydWUgfSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogLy8gVGVuc29yIHtcbiAqIC8vICAgICB0eXBlOiAnZmxvYXQzMicsXG4gKiAvLyAgICAgZGF0YTogRmxvYXQzMkFycmF5IFswLjAzMzczNzc4OTgzOTUwNjE1LCAtMC4wMTAxMDYwNzc0MTc3MzEyODUsIC4uLl0sXG4gKiAvLyAgICAgZGltczogWzEsIDc2OF1cbiAqIC8vIH1cbiAqIGBgYFxuICogXG4gKiAqKkV4YW1wbGU6KiogQ2FsY3VsYXRpbmcgZW1iZWRkaW5ncyB3aXRoIGBzZW50ZW5jZS10cmFuc2Zvcm1lcnNgIG1vZGVscy5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCBleHRyYWN0b3IgPSBhd2FpdCBwaXBlbGluZSgnZmVhdHVyZS1leHRyYWN0aW9uJywgJ1hlbm92YS9hbGwtTWluaUxNLUw2LXYyJyk7XG4gKiBsZXQgcmVzdWx0ID0gYXdhaXQgZXh0cmFjdG9yKCdUaGlzIGlzIGEgc2ltcGxlIHRlc3QuJywgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAvLyBUZW5zb3Ige1xuICogLy8gICAgIHR5cGU6ICdmbG9hdDMyJyxcbiAqIC8vICAgICBkYXRhOiBGbG9hdDMyQXJyYXkgWzAuMDkwOTQ5ODI1OTQyNTE2MzMsIC0wLjAxNDc3NDI0NjE0MTMxNDUwNywgLi4uXSxcbiAqIC8vICAgICBkaW1zOiBbMSwgMzg0XVxuICogLy8gfVxuICogYGBgXG4gKiBAZXh0ZW5kcyBQaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgRmVhdHVyZUV4dHJhY3Rpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgdGhlIGZlYXR1cmVzIG9mIHRoZSBpbnB1dChzKS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdGV4dHMgVGhlIGlucHV0IHRleHRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zOlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb29saW5nPVwibm9uZVwiXSBUaGUgcG9vbGluZyBtZXRob2QgdG8gdXNlLiBDYW4gYmUgb25lIG9mOiBcIm5vbmVcIiwgXCJtZWFuXCIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5ub3JtYWxpemU9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIG5vcm1hbGl6ZSB0aGUgZW1iZWRkaW5ncyBpbiB0aGUgbGFzdCBkaW1lbnNpb24uXG4gICAgICogQHJldHVybnMgVGhlIGZlYXR1cmVzIGNvbXB1dGVkIGJ5IHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbCh0ZXh0cywge1xuICAgICAgICBwb29saW5nID0gJ25vbmUnLFxuICAgICAgICBub3JtYWxpemUgPSBmYWxzZSxcbiAgICB9ID0ge30pIHtcbiAgICAgICAgbGV0IFtpbnB1dHMsIG91dHB1dHNdID0gYXdhaXQgc3VwZXIuX2NhbGwodGV4dHMpO1xuXG4gICAgICAgIC8vIFRPRE86IFByb3ZpZGUgd2FybmluZyB0byB0aGUgdXNlciB0aGF0IHRoZXkgbWlnaHQgYmUgdXNpbmcgbW9kZWwgd2hpY2ggd2FzIG5vdCBleHBvcnRlZFxuICAgICAgICAvLyBzcGVjaWZpY2FsbHkgZm9yIGZlYXR1cmUgZXh0cmFjdGlvblxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm1vZGVsLmNvbmZpZylcbiAgICAgICAgLy8gY29uc29sZS5sb2cob3V0cHV0cylcblxuICAgICAgICBsZXQgcmVzdWx0ID0gb3V0cHV0cy5sYXN0X2hpZGRlbl9zdGF0ZSA/PyBvdXRwdXRzLmxvZ2l0cztcbiAgICAgICAgaWYgKHBvb2xpbmcgPT09ICdub25lJykge1xuICAgICAgICAgICAgLy8gU2tpcCBwb29saW5nXG4gICAgICAgIH0gZWxzZSBpZiAocG9vbGluZyA9PT0gJ21lYW4nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtZWFuX3Bvb2xpbmcocmVzdWx0LCBpbnB1dHMuYXR0ZW50aW9uX21hc2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFBvb2xpbmcgbWV0aG9kICcke3Bvb2xpbmd9JyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm5vcm1hbGl6ZSgyLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLy8gVE9ET1xuLy8gZXhwb3J0IGNsYXNzIFNlbnRlbmNlU2ltaWxhcml0eVBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuLy8gfVxuXG5cbi8qKlxuICogUGlwZWxpbmUgdGhhdCBhaW1zIGF0IGV4dHJhY3Rpbmcgc3Bva2VuIHRleHQgY29udGFpbmVkIHdpdGhpbiBzb21lIGF1ZGlvLlxuICpcbiAqICoqRXhhbXBsZToqKiBUcmFuc2NyaWJlIEVuZ2xpc2guXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi9qZmsud2F2JztcbiAqIGxldCB0cmFuc2NyaWJlciA9IGF3YWl0IHBpcGVsaW5lKCdhdXRvbWF0aWMtc3BlZWNoLXJlY29nbml0aW9uJywgJ1hlbm92YS93aGlzcGVyLXRpbnkuZW4nKTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCB0cmFuc2NyaWJlcih1cmwpO1xuICogLy8geyB0ZXh0OiBcIiBBbmQgc28gbXkgZmVsbG93IEFtZXJpY2FucyBhc2sgbm90IHdoYXQgeW91ciBjb3VudHJ5IGNhbiBkbyBmb3IgeW91LCBhc2sgd2hhdCB5b3UgY2FuIGRvIGZvciB5b3VyIGNvdW50cnkuXCIgfVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBUcmFuc2NyaWJlIEVuZ2xpc2ggdy8gdGltZXN0YW1wcy5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCB1cmwgPSAnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL2pmay53YXYnO1xuICogbGV0IHRyYW5zY3JpYmVyID0gYXdhaXQgcGlwZWxpbmUoJ2F1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb24nLCAnWGVub3ZhL3doaXNwZXItdGlueS5lbicpO1xuICogbGV0IG91dHB1dCA9IGF3YWl0IHRyYW5zY3JpYmVyKHVybCwgeyByZXR1cm5fdGltZXN0YW1wczogdHJ1ZSB9KTtcbiAqIC8vIHtcbiAqIC8vICAgdGV4dDogXCIgQW5kIHNvIG15IGZlbGxvdyBBbWVyaWNhbnMgYXNrIG5vdCB3aGF0IHlvdXIgY291bnRyeSBjYW4gZG8gZm9yIHlvdSwgYXNrIHdoYXQgeW91IGNhbiBkbyBmb3IgeW91ciBjb3VudHJ5LlwiXG4gKiAvLyAgIGNodW5rczogW1xuICogLy8gICAgIHsgdGltZXN0YW1wOiBbMCwgOF0sICB0ZXh0OiBcIiBBbmQgc28gbXkgZmVsbG93IEFtZXJpY2FucyBhc2sgbm90IHdoYXQgeW91ciBjb3VudHJ5IGNhbiBkbyBmb3IgeW91XCIgfVxuICogLy8gICAgIHsgdGltZXN0YW1wOiBbOCwgMTFdLCB0ZXh0OiBcIiBhc2sgd2hhdCB5b3UgY2FuIGRvIGZvciB5b3VyIGNvdW50cnkuXCIgfVxuICogLy8gICBdXG4gKiAvLyB9XG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIFRyYW5zY3JpYmUgRW5nbGlzaCB3LyB3b3JkLWxldmVsIHRpbWVzdGFtcHMuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi9qZmsud2F2JztcbiAqIGxldCB0cmFuc2NyaWJlciA9IGF3YWl0IHBpcGVsaW5lKCdhdXRvbWF0aWMtc3BlZWNoLXJlY29nbml0aW9uJywgJ1hlbm92YS93aGlzcGVyLXRpbnkuZW4nLCB7XG4gKiAgICAgcmV2aXNpb246ICdvdXRwdXRfYXR0ZW50aW9ucycsXG4gKiB9KTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCB0cmFuc2NyaWJlcih1cmwsIHsgcmV0dXJuX3RpbWVzdGFtcHM6ICd3b3JkJyB9KTtcbiAqIC8vIHtcbiAqIC8vICAgXCJ0ZXh0XCI6IFwiIEFuZCBzbyBteSBmZWxsb3cgQW1lcmljYW5zIGFzayBub3Qgd2hhdCB5b3VyIGNvdW50cnkgY2FuIGRvIGZvciB5b3UgYXNrIHdoYXQgeW91IGNhbiBkbyBmb3IgeW91ciBjb3VudHJ5LlwiLFxuICogLy8gICBcImNodW5rc1wiOiBbXG4gKiAvLyAgICAgeyBcInRleHRcIjogXCIgQW5kXCIsIFwidGltZXN0YW1wXCI6IFswLCAwLjc4XSB9LFxuICogLy8gICAgIHsgXCJ0ZXh0XCI6IFwiIHNvXCIsIFwidGltZXN0YW1wXCI6IFswLjc4LCAxLjA2XSB9LFxuICogLy8gICAgIHsgXCJ0ZXh0XCI6IFwiIG15XCIsIFwidGltZXN0YW1wXCI6IFsxLjA2LCAxLjQ2XSB9LFxuICogLy8gICAgIC4uLlxuICogLy8gICAgIHsgXCJ0ZXh0XCI6IFwiIGZvclwiLCBcInRpbWVzdGFtcFwiOiBbOS43MiwgOS45Ml0gfSxcbiAqIC8vICAgICB7IFwidGV4dFwiOiBcIiB5b3VyXCIsIFwidGltZXN0YW1wXCI6IFs5LjkyLCAxMC4yMl0gfSxcbiAqIC8vICAgICB7IFwidGV4dFwiOiBcIiBjb3VudHJ5LlwiLCBcInRpbWVzdGFtcFwiOiBbMTAuMjIsIDEzLjVdIH1cbiAqIC8vICAgXVxuICogLy8gfVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBUcmFuc2NyaWJlIEZyZW5jaC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCB1cmwgPSAnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL2ZyZW5jaC1hdWRpby5tcDMnO1xuICogbGV0IHRyYW5zY3JpYmVyID0gYXdhaXQgcGlwZWxpbmUoJ2F1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb24nLCAnWGVub3ZhL3doaXNwZXItc21hbGwnKTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCB0cmFuc2NyaWJlcih1cmwsIHsgbGFuZ3VhZ2U6ICdmcmVuY2gnLCB0YXNrOiAndHJhbnNjcmliZScgfSk7XG4gKiAvLyB7IHRleHQ6IFwiIEonYWRvcmUsIGonYWltZSwgamUgbidhaW1lIHBhcywgamUgZMOpdGVzdGUuXCIgfVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBUcmFuc2xhdGUgRnJlbmNoIHRvIEVuZ2xpc2guXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi9mcmVuY2gtYXVkaW8ubXAzJztcbiAqIGxldCB0cmFuc2NyaWJlciA9IGF3YWl0IHBpcGVsaW5lKCdhdXRvbWF0aWMtc3BlZWNoLXJlY29nbml0aW9uJywgJ1hlbm92YS93aGlzcGVyLXNtYWxsJyk7XG4gKiBsZXQgb3V0cHV0ID0gYXdhaXQgdHJhbnNjcmliZXIodXJsLCB7IGxhbmd1YWdlOiAnZnJlbmNoJywgdGFzazogJ3RyYW5zbGF0ZScgfSk7XG4gKiAvLyB7IHRleHQ6IFwiIEkgbG92ZSwgSSBsaWtlLCBJIGRvbid0IGxpa2UsIEkgaGF0ZS5cIiB9XG4gKiBgYGBcbiAqIFxuICogKipFeGFtcGxlOioqIFRyYW5zY3JpYmUvdHJhbnNsYXRlIGF1ZGlvIGxvbmdlciB0aGFuIDMwIHNlY29uZHMuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi90ZWRfNjAud2F2JztcbiAqIGxldCB0cmFuc2NyaWJlciA9IGF3YWl0IHBpcGVsaW5lKCdhdXRvbWF0aWMtc3BlZWNoLXJlY29nbml0aW9uJywgJ1hlbm92YS93aGlzcGVyLXRpbnkuZW4nKTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCB0cmFuc2NyaWJlcih1cmwsIHsgY2h1bmtfbGVuZ3RoX3M6IDMwLCBzdHJpZGVfbGVuZ3RoX3M6IDUgfSk7XG4gKiAvLyB7IHRleHQ6IFwiIFNvIGluIGNvbGxlZ2UsIEkgd2FzIGEgZ292ZXJubWVudCBtYWpvciwgd2hpY2ggbWVhbnMgWy4uLl0gU28gSSdkIHN0YXJ0IG9mZiBsaWdodCBhbmQgSSdkIGJ1bXAgaXQgdXBcIiB9XG4gKiBgYGBcbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvbWF0aWNTcGVlY2hSZWNvZ25pdGlvblBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEF1dG9tYXRpY1NwZWVjaFJlY29nbml0aW9uUGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhc2sgVGhlIHRhc2sgb2YgdGhlIHBpcGVsaW5lLiBVc2VmdWwgZm9yIHNwZWNpZnlpbmcgc3VidGFza3MuXG4gICAgICogQHBhcmFtIHtQcmVUcmFpbmVkVG9rZW5pemVyfSB0b2tlbml6ZXIgVGhlIHRva2VuaXplciB0byB1c2UuXG4gICAgICogQHBhcmFtIHtQcmVUcmFpbmVkTW9kZWx9IG1vZGVsIFRoZSBtb2RlbCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtQcm9jZXNzb3J9IHByb2Nlc3NvciBUaGUgcHJvY2Vzc29yIHRvIHVzZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXNrLCB0b2tlbml6ZXIsIG1vZGVsLCBwcm9jZXNzb3IpIHtcbiAgICAgICAgc3VwZXIodGFzaywgdG9rZW5pemVyLCBtb2RlbCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXByb2Nlc3NlcyB0aGUgaW5wdXQgYXVkaW8gZm9yIHRoZSBBdXRvbWF0aWNTcGVlY2hSZWNvZ25pdGlvblBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7YW55fSBhdWRpbyBUaGUgYXVkaW8gdG8gYmUgcHJlcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGluZ19yYXRlIFRoZSBzYW1wbGluZyByYXRlIG9mIHRoZSBhdWRpby5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGbG9hdDMyQXJyYXk+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcHJlcHJvY2Vzc2VkIGF1ZGlvIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfcHJlcHJvY2VzcyhhdWRpbywgc2FtcGxpbmdfcmF0ZSkge1xuICAgICAgICBpZiAoaXNTdHJpbmcoYXVkaW8pKSB7XG4gICAgICAgICAgICBhdWRpbyA9IGF3YWl0IHJlYWRfYXVkaW8oYXVkaW8sIHNhbXBsaW5nX3JhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF1ZGlvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdXRpbHMvdGVuc29yLmpzJykuVGVuc29yfSBUZW5zb3JcbiAgICAgKiBAdHlwZWRlZiB7e3N0cmlkZTogbnVtYmVyW10sIGlucHV0X2ZlYXR1cmVzOiBUZW5zb3IsIGlzX2xhc3Q6IGJvb2xlYW4sIHRva2Vucz86IG51bWJlcltdLCB0b2tlbl90aW1lc3RhbXBzPzogbnVtYmVyW119fSBDaHVua1xuICAgICAqIFxuICAgICAqIEBjYWxsYmFjayBDaHVua0NhbGxiYWNrXG4gICAgICogQHBhcmFtIHtDaHVua30gY2h1bmsgVGhlIGNodW5rIHRvIHByb2Nlc3MuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSBwcm9jZXNzZXMgYXVkaW8gYW5kIGdlbmVyYXRlcyB0ZXh0IHRyYW5zY3JpcHRpb24gdXNpbmcgdGhlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEZsb2F0MzJBcnJheVtdfSBhdWRpbyBUaGUgYXVkaW8gdG8gYmUgdHJhbnNjcmliZWQuIENhbiBiZSBhIHNpbmdsZSBGbG9hdDMyQXJyYXkgb3IgYW4gYXJyYXkgb2YgRmxvYXQzMkFycmF5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2t3YXJncz17fV0gT3B0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnwnd29yZCd9IFtrd2FyZ3MucmV0dXJuX3RpbWVzdGFtcHNdIFdoZXRoZXIgdG8gcmV0dXJuIHRpbWVzdGFtcHMgb3Igbm90LiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuY2h1bmtfbGVuZ3RoX3NdIFRoZSBsZW5ndGggb2YgYXVkaW8gY2h1bmtzIHRvIHByb2Nlc3MgaW4gc2Vjb25kcy4gRGVmYXVsdCBpcyAwIChubyBjaHVua2luZykuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3Muc3RyaWRlX2xlbmd0aF9zXSBUaGUgbGVuZ3RoIG9mIG92ZXJsYXAgYmV0d2VlbiBjb25zZWN1dGl2ZSBhdWRpbyBjaHVua3MgaW4gc2Vjb25kcy4gSWYgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBgY2h1bmtfbGVuZ3RoX3MgLyA2YC5cbiAgICAgKiBAcGFyYW0ge0NodW5rQ2FsbGJhY2t9IFtrd2FyZ3MuY2h1bmtfY2FsbGJhY2tdIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIGVhY2ggY2h1bmsgcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5mb3JjZV9mdWxsX3NlcXVlbmNlc10gV2hldGhlciB0byBmb3JjZSBvdXRwdXR0aW5nIGZ1bGwgc2VxdWVuY2VzIG9yIG5vdC4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba3dhcmdzLmxhbmd1YWdlXSBUaGUgc291cmNlIGxhbmd1YWdlLiBEZWZhdWx0IGlzIGBudWxsYCwgbWVhbmluZyBpdCBzaG91bGQgYmUgYXV0by1kZXRlY3RlZC4gVXNlIHRoaXMgdG8gcG90ZW50aWFsbHkgaW1wcm92ZSBwZXJmb3JtYW5jZSBpZiB0aGUgc291cmNlIGxhbmd1YWdlIGlzIGtub3duLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba3dhcmdzLnRhc2tdIFRoZSB0YXNrIHRvIHBlcmZvcm0uIERlZmF1bHQgaXMgYG51bGxgLCBtZWFuaW5nIGl0IHNob3VsZCBiZSBhdXRvLWRldGVjdGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gW2t3YXJncy5mb3JjZWRfZGVjb2Rlcl9pZHNdIEEgbGlzdCBvZiBwYWlycyBvZiBpbnRlZ2VycyB3aGljaCBpbmRpY2F0ZXMgYSBtYXBwaW5nIGZyb20gZ2VuZXJhdGlvbiBpbmRpY2VzIHRvIHRva2VuIGluZGljZXNcbiAgICAgKiB0aGF0IHdpbGwgYmUgZm9yY2VkIGJlZm9yZSBzYW1wbGluZy4gRm9yIGV4YW1wbGUsIFtbMSwgMTIzXV0gbWVhbnMgdGhlIHNlY29uZCBnZW5lcmF0ZWQgdG9rZW4gd2lsbCBhbHdheXMgYmUgYSB0b2tlbiBvZiBpbmRleCAxMjMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRyYW5zY3JpcHRpb24gdGV4dCBhbmQgb3B0aW9uYWxseSB0aW1lc3RhbXBzIGlmIGByZXR1cm5fdGltZXN0YW1wc2AgaXMgYHRydWVgLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGF1ZGlvLCBrd2FyZ3MgPSB7fSkge1xuICAgICAgICBsZXQgcmV0dXJuX3RpbWVzdGFtcHMgPSBrd2FyZ3MucmV0dXJuX3RpbWVzdGFtcHMgPz8gZmFsc2U7XG4gICAgICAgIGxldCBjaHVua19sZW5ndGhfcyA9IGt3YXJncy5jaHVua19sZW5ndGhfcyA/PyAwO1xuICAgICAgICBsZXQgc3RyaWRlX2xlbmd0aF9zID0ga3dhcmdzLnN0cmlkZV9sZW5ndGhfcyA/PyBudWxsO1xuICAgICAgICBsZXQgY2h1bmtfY2FsbGJhY2sgPSBrd2FyZ3MuY2h1bmtfY2FsbGJhY2sgPz8gbnVsbDtcbiAgICAgICAgbGV0IGZvcmNlX2Z1bGxfc2VxdWVuY2VzID0ga3dhcmdzLmZvcmNlX2Z1bGxfc2VxdWVuY2VzID8/IGZhbHNlO1xuXG4gICAgICAgIGlmIChyZXR1cm5fdGltZXN0YW1wcyA9PT0gJ3dvcmQnKSB7XG4gICAgICAgICAgICBrd2FyZ3NbJ3JldHVybl90b2tlbl90aW1lc3RhbXBzJ10gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxhbmd1YWdlID0gcG9wKGt3YXJncywgJ2xhbmd1YWdlJywgbnVsbCk7XG4gICAgICAgIGxldCB0YXNrID0gcG9wKGt3YXJncywgJ3Rhc2snLCBudWxsKTtcblxuICAgICAgICBpZiAobGFuZ3VhZ2UgfHwgdGFzayB8fCByZXR1cm5fdGltZXN0YW1wcykge1xuICAgICAgICAgICAgaWYgKGt3YXJncy5mb3JjZWRfZGVjb2Rlcl9pZHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3BlY2lmeSBgbGFuZ3VhZ2VgL2B0YXNrYC9gcmV0dXJuX3RpbWVzdGFtcHNgIGFuZCBgZm9yY2VkX2RlY29kZXJfaWRzYCBhdCB0aGUgc2FtZSB0aW1lLlwiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbGV0IGRlY29kZXJfcHJvbXB0X2lkcyA9IHRoaXMudG9rZW5pemVyLmdldF9kZWNvZGVyX3Byb21wdF9pZHMoeyBsYW5ndWFnZSwgdGFzaywgbm9fdGltZXN0YW1wczogIXJldHVybl90aW1lc3RhbXBzIH0pXG4gICAgICAgICAgICBpZiAoZGVjb2Rlcl9wcm9tcHRfaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBrd2FyZ3MuZm9yY2VkX2RlY29kZXJfaWRzID0gZGVjb2Rlcl9wcm9tcHRfaWRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNpbmdsZSA9ICFBcnJheS5pc0FycmF5KGF1ZGlvKTtcbiAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgYXVkaW8gPSBbYXVkaW9dO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2FtcGxpbmdfcmF0ZSA9IHRoaXMucHJvY2Vzc29yLmZlYXR1cmVfZXh0cmFjdG9yLmNvbmZpZy5zYW1wbGluZ19yYXRlO1xuICAgICAgICBjb25zdCB0aW1lX3ByZWNpc2lvbiA9IHRoaXMucHJvY2Vzc29yLmZlYXR1cmVfZXh0cmFjdG9yLmNvbmZpZy5jaHVua19sZW5ndGggLyB0aGlzLm1vZGVsLmNvbmZpZy5tYXhfc291cmNlX3Bvc2l0aW9ucztcblxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgYXVkIG9mIGF1ZGlvKSB7XG4gICAgICAgICAgICBhdWQgPSBhd2FpdCB0aGlzLl9wcmVwcm9jZXNzKGF1ZCwgc2FtcGxpbmdfcmF0ZSlcblxuICAgICAgICAgICAgLyoqIEB0eXBlIHtDaHVua1tdfSAqL1xuICAgICAgICAgICAgbGV0IGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGNodW5rX2xlbmd0aF9zID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJpZGVfbGVuZ3RoX3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaWRlX2xlbmd0aF9zID0gY2h1bmtfbGVuZ3RoX3MgLyA2O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2h1bmtfbGVuZ3RoX3MgPD0gc3RyaWRlX2xlbmd0aF9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiYGNodW5rX2xlbmd0aF9zYCBtdXN0IGJlIGxhcmdlciB0aGFuIGBzdHJpZGVfbGVuZ3RoX3NgLlwiKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gc3VwcG9ydCBkaWZmZXJlbnQgc3RyaWRlX2xlbmd0aF9zIChmb3IgbGVmdCBhbmQgcmlnaHQpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB3aW5kb3cgPSBzYW1wbGluZ19yYXRlICogY2h1bmtfbGVuZ3RoX3M7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaWRlID0gc2FtcGxpbmdfcmF0ZSAqIHN0cmlkZV9sZW5ndGhfcztcbiAgICAgICAgICAgICAgICBjb25zdCBqdW1wID0gd2luZG93IC0gMiAqIHN0cmlkZTtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBzdWJhcnJheXMgb2YgYXVkaW8gd2l0aCBvdmVybGFwc1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IGF1ZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1YmFyciA9IGF1ZC5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmZWF0dXJlID0gYXdhaXQgdGhpcy5wcm9jZXNzb3Ioc3ViYXJyKTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNGaXJzdCA9IG9mZnNldCA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzTGFzdCA9IG9mZnNldCArIGp1bXAgPj0gYXVkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWRlOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViYXJyLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0ID8gMCA6IHN0cmlkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xhc3QgPyAwIDogc3RyaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfZmVhdHVyZXM6IGZlYXR1cmUuaW5wdXRfZmVhdHVyZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc19sYXN0OiBpc0xhc3RcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGp1bXA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rcyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIHN0cmlkZTogW2F1ZC5sZW5ndGgsIDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dF9mZWF0dXJlczogKGF3YWl0IHRoaXMucHJvY2Vzc29yKGF1ZCkpLmlucHV0X2ZlYXR1cmVzLFxuICAgICAgICAgICAgICAgICAgICBpc19sYXN0OiB0cnVlXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgZm9yIGVhY2ggc2V0IG9mIGlucHV0IGZlYXR1cmVzXG4gICAgICAgICAgICBmb3IgKGxldCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBkb2luZyBzZXF1ZW50aWFsbHkgZm9yIG5vd1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gYXdhaXQgdGhpcy5tb2RlbC5nZW5lcmF0ZShjaHVuay5pbnB1dF9mZWF0dXJlcywga3dhcmdzKTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFJpZ2h0IG5vdyB3ZSBvbmx5IGdldCB0b3AgYmVhbVxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5fdGltZXN0YW1wcyA9PT0gJ3dvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnRva2VucyA9IGRhdGEuc2VxdWVuY2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICBjaHVuay50b2tlbl90aW1lc3RhbXBzID0gZGF0YS50b2tlbl90aW1lc3RhbXBzLnRvbGlzdCgpWzBdLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPT4gcm91bmQoeCwgMilcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnRva2VucyA9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBzdHJpZGUgdG8gc2Vjb25kc1xuICAgICAgICAgICAgICAgIGNodW5rLnN0cmlkZSA9IGNodW5rLnN0cmlkZS5tYXAoeCA9PiB4IC8gc2FtcGxpbmdfcmF0ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtfY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtfY2FsbGJhY2soY2h1bmspXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNZXJnZSB0ZXh0IGNodW5rc1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbGV0IFtmdWxsX3RleHQsIG9wdGlvbmFsXSA9IHRoaXMudG9rZW5pemVyLl9kZWNvZGVfYXNyKGNodW5rcywge1xuICAgICAgICAgICAgICAgIHRpbWVfcHJlY2lzaW9uLCByZXR1cm5fdGltZXN0YW1wcywgZm9yY2VfZnVsbF9zZXF1ZW5jZXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKHsgdGV4dDogZnVsbF90ZXh0LCAuLi5vcHRpb25hbCB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW5nbGUgPyB0b1JldHVyblswXSA6IHRvUmV0dXJuO1xuICAgIH1cbn1cblxuLyoqXG4gKiBJbWFnZSBUbyBUZXh0IHBpcGVsaW5lIHVzaW5nIGEgYEF1dG9Nb2RlbEZvclZpc2lvbjJTZXFgLiBUaGlzIHBpcGVsaW5lIHByZWRpY3RzIGEgY2FwdGlvbiBmb3IgYSBnaXZlbiBpbWFnZS5cbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZVRvVGV4dFBpcGVsaW5lIGV4dGVuZHMgUGlwZWxpbmUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBJbWFnZVRvVGV4dFBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrIFRoZSB0YXNrIG9mIHRoZSBwaXBlbGluZS4gVXNlZnVsIGZvciBzcGVjaWZ5aW5nIHN1YnRhc2tzLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZFRva2VuaXplcn0gdG9rZW5pemVyIFRoZSB0b2tlbml6ZXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZE1vZGVsfSBtb2RlbCBUaGUgbW9kZWwgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJvY2Vzc29yfSBwcm9jZXNzb3IgVGhlIHByb2Nlc3NvciB0byB1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFzaywgdG9rZW5pemVyLCBtb2RlbCwgcHJvY2Vzc29yKSB7XG4gICAgICAgIHN1cGVyKHRhc2ssIHRva2VuaXplciwgbW9kZWwpO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gbGFiZWxzIHRvIHRoZSBpbWFnZShzKSBwYXNzZWQgYXMgaW5wdXRzLlxuICAgICAqIEBwYXJhbSB7YW55W119IGltYWdlcyBUaGUgaW1hZ2VzIHRvIGJlIGNhcHRpb25lZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2dlbmVyYXRlX2t3YXJncz17fV0gT3B0aW9uYWwgZ2VuZXJhdGlvbiBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fE9iamVjdFtdPn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gb2JqZWN0IChvciBhcnJheSBvZiBvYmplY3RzKSBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgdGV4dChzKS5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChpbWFnZXMsIGdlbmVyYXRlX2t3YXJncyA9IHt9KSB7XG4gICAgICAgIGxldCBpc0JhdGNoZWQgPSBBcnJheS5pc0FycmF5KGltYWdlcyk7XG5cbiAgICAgICAgaW1hZ2VzID0gYXdhaXQgcHJlcGFyZUltYWdlcyhpbWFnZXMpO1xuXG4gICAgICAgIGxldCB7IHBpeGVsX3ZhbHVlcyB9ID0gYXdhaXQgdGhpcy5wcm9jZXNzb3IoaW1hZ2VzKTtcblxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgYmF0Y2ggb2YgcGl4ZWxfdmFsdWVzKSB7XG4gICAgICAgICAgICBiYXRjaC5kaW1zID0gWzEsIC4uLmJhdGNoLmRpbXNdXG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gYXdhaXQgdGhpcy5tb2RlbC5nZW5lcmF0ZShiYXRjaCwgZ2VuZXJhdGVfa3dhcmdzKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkID0gdGhpcy50b2tlbml6ZXIuYmF0Y2hfZGVjb2RlKG91dHB1dCwge1xuICAgICAgICAgICAgICAgIHNraXBfc3BlY2lhbF90b2tlbnM6IHRydWUsXG4gICAgICAgICAgICB9KS5tYXAoeCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZ2VuZXJhdGVkX3RleHQ6IHgudHJpbSgpIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKGRlY29kZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzQmF0Y2hlZCA/IHRvUmV0dXJuIDogdG9SZXR1cm5bMF07XG4gICAgfVxufVxuXG4vKipcbiAqIEltYWdlIGNsYXNzaWZpY2F0aW9uIHBpcGVsaW5lIHVzaW5nIGFueSBgQXV0b01vZGVsRm9ySW1hZ2VDbGFzc2lmaWNhdGlvbmAuXG4gKiBUaGlzIHBpcGVsaW5lIHByZWRpY3RzIHRoZSBjbGFzcyBvZiBhbiBpbWFnZS5cbiAqIFxuICogKipFeGFtcGxlOioqIENsYXNzaWZ5IGFuIGltYWdlLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IGNsYXNzaWZpZXIgPSBhd2FpdCBwaXBlbGluZSgnaW1hZ2UtY2xhc3NpZmljYXRpb24nLCAnWGVub3ZhL3ZpdC1iYXNlLXBhdGNoMTYtMjI0Jyk7XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi90aWdlci5qcGcnO1xuICogbGV0IG91dHB1dHMgPSBhd2FpdCBjbGFzc2lmaWVyKHVybCk7XG4gKiAvLyBBcnJheSgxKSBbXG4gKiAvLyAgIHtsYWJlbDogJ3RpZ2VyLCBQYW50aGVyYSB0aWdyaXMnLCBzY29yZTogMC42MzI2OTU3MzQ1MDA4ODV9LFxuICogLy8gXVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBDbGFzc2lmeSBhbiBpbWFnZSBhbmQgcmV0dXJuIHRvcCBgbmAgY2xhc3Nlcy5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGxldCBjbGFzc2lmaWVyID0gYXdhaXQgcGlwZWxpbmUoJ2ltYWdlLWNsYXNzaWZpY2F0aW9uJywgJ1hlbm92YS92aXQtYmFzZS1wYXRjaDE2LTIyNCcpO1xuICogbGV0IHVybCA9ICdodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RhdGFzZXRzL1hlbm92YS90cmFuc2Zvcm1lcnMuanMtZG9jcy9yZXNvbHZlL21haW4vdGlnZXIuanBnJztcbiAqIGxldCBvdXRwdXRzID0gYXdhaXQgY2xhc3NpZmllcih1cmwsIHsgdG9wazogMyB9KTtcbiAqIC8vIEFycmF5KDMpIFtcbiAqIC8vICAge2xhYmVsOiAndGlnZXIsIFBhbnRoZXJhIHRpZ3JpcycsIHNjb3JlOiAwLjYzMjY5NTczNDUwMDg4NX0sXG4gKiAvLyAgIHtsYWJlbDogJ3RpZ2VyIGNhdCcsIHNjb3JlOiAwLjM2MzQ4MjU2NDY4NzcyODl9LFxuICogLy8gICB7bGFiZWw6ICdsaW9uLCBraW5nIG9mIGJlYXN0cywgUGFudGhlcmEgbGVvJywgc2NvcmU6IDAuMDAwNDUwNjAzMDgxODQ0NzQ3MDd9LFxuICogLy8gXVxuICogYGBgXG4gKiBcbiAqICoqRXhhbXBsZToqKiBDbGFzc2lmeSBhbiBpbWFnZSBhbmQgcmV0dXJuIGFsbCBjbGFzc2VzLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IGNsYXNzaWZpZXIgPSBhd2FpdCBwaXBlbGluZSgnaW1hZ2UtY2xhc3NpZmljYXRpb24nLCAnWGVub3ZhL3ZpdC1iYXNlLXBhdGNoMTYtMjI0Jyk7XG4gKiBsZXQgdXJsID0gJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi90aWdlci5qcGcnO1xuICogbGV0IG91dHB1dHMgPSBhd2FpdCBjbGFzc2lmaWVyKHVybCwgeyB0b3BrOiAwIH0pO1xuICogLy8gQXJyYXkoMTAwMCkgW1xuICogLy8gICB7bGFiZWw6ICd0aWdlciwgUGFudGhlcmEgdGlncmlzJywgc2NvcmU6IDAuNjMyNjk1NzM0NTAwODg1fSxcbiAqIC8vICAge2xhYmVsOiAndGlnZXIgY2F0Jywgc2NvcmU6IDAuMzYzNDgyNTY0Njg3NzI4OX0sXG4gKiAvLyAgIHtsYWJlbDogJ2xpb24sIGtpbmcgb2YgYmVhc3RzLCBQYW50aGVyYSBsZW8nLCBzY29yZTogMC4wMDA0NTA2MDMwODE4NDQ3NDcwN30sXG4gKiAvLyAgIHtsYWJlbDogJ2phZ3VhciwgcGFudGhlciwgUGFudGhlcmEgb25jYSwgRmVsaXMgb25jYScsIHNjb3JlOiAwLjAwMDM1NDY1NDk5OTY4MjY3OTc3fSxcbiAqIC8vICAgLi4uXG4gKiAvLyBdXG4gKiBgYGBcbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZUNsYXNzaWZpY2F0aW9uUGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEltYWdlQ2xhc3NpZmljYXRpb25QaXBlbGluZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFzayBUaGUgdGFzayBvZiB0aGUgcGlwZWxpbmUuIFVzZWZ1bCBmb3Igc3BlY2lmeWluZyBzdWJ0YXNrcy5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRNb2RlbH0gbW9kZWwgVGhlIG1vZGVsIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIFRoZSBwcm9jZXNzb3IgdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhc2ssIG1vZGVsLCBwcm9jZXNzb3IpIHtcbiAgICAgICAgc3VwZXIodGFzaywgbnVsbCwgbW9kZWwpOyAvLyBUT0RPIHRva2VuaXplclxuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFzc2lmeSB0aGUgZ2l2ZW4gaW1hZ2VzLlxuICAgICAqIEBwYXJhbSB7YW55fSBpbWFnZXMgVGhlIGltYWdlcyB0byBjbGFzc2lmeS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyB0byB1c2UgZm9yIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50b3BrPTFdIFRoZSBudW1iZXIgb2YgdG9wIHJlc3VsdHMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFRoZSB0b3AgY2xhc3NpZmljYXRpb24gcmVzdWx0cyBmb3IgdGhlIGltYWdlcy5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChpbWFnZXMsIHtcbiAgICAgICAgdG9wayA9IDFcbiAgICB9ID0ge30pIHtcbiAgICAgICAgbGV0IGlzQmF0Y2hlZCA9IEFycmF5LmlzQXJyYXkoaW1hZ2VzKTtcbiAgICAgICAgaW1hZ2VzID0gYXdhaXQgcHJlcGFyZUltYWdlcyhpbWFnZXMpO1xuXG4gICAgICAgIGxldCB7IHBpeGVsX3ZhbHVlcyB9ID0gYXdhaXQgdGhpcy5wcm9jZXNzb3IoaW1hZ2VzKTtcbiAgICAgICAgbGV0IG91dHB1dCA9IGF3YWl0IHRoaXMubW9kZWwoeyBwaXhlbF92YWx1ZXMgfSk7XG5cbiAgICAgICAgbGV0IGlkMmxhYmVsID0gdGhpcy5tb2RlbC5jb25maWcuaWQybGFiZWw7XG4gICAgICAgIGxldCB0b1JldHVybiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBiYXRjaCBvZiBvdXRwdXQubG9naXRzKSB7XG4gICAgICAgICAgICBsZXQgc2NvcmVzID0gZ2V0VG9wSXRlbXMoc29mdG1heChiYXRjaC5kYXRhKSwgdG9wayk7XG5cbiAgICAgICAgICAgIGxldCB2YWxzID0gc2NvcmVzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpZDJsYWJlbFt4WzBdXSxcbiAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHhbMV0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodG9wayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goLi4udmFscyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvUmV0dXJuLnB1c2godmFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNCYXRjaGVkIHx8IHRvcGsgPT09IDEgPyB0b1JldHVybiA6IHRvUmV0dXJuWzBdO1xuICAgIH1cblxufVxuXG4vKipcbiAqIEltYWdlIHNlZ21lbnRhdGlvbiBwaXBlbGluZSB1c2luZyBhbnkgYEF1dG9Nb2RlbEZvclhYWFNlZ21lbnRhdGlvbmAuXG4gKiBUaGlzIHBpcGVsaW5lIHByZWRpY3RzIG1hc2tzIG9mIG9iamVjdHMgYW5kIHRoZWlyIGNsYXNzZXMuXG4gKiBAZXh0ZW5kcyBQaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgSW1hZ2VTZWdtZW50YXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgSW1hZ2VTZWdtZW50YXRpb25QaXBlbGluZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFzayBUaGUgdGFzayBvZiB0aGUgcGlwZWxpbmUuIFVzZWZ1bCBmb3Igc3BlY2lmeWluZyBzdWJ0YXNrcy5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRNb2RlbH0gbW9kZWwgVGhlIG1vZGVsIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIFRoZSBwcm9jZXNzb3IgdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhc2ssIG1vZGVsLCBwcm9jZXNzb3IpIHtcbiAgICAgICAgc3VwZXIodGFzaywgbnVsbCwgbW9kZWwpOyAvLyBUT0RPIHRva2VuaXplclxuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcblxuICAgICAgICB0aGlzLnN1YnRhc2tzX21hcHBpbmcgPSB7XG4gICAgICAgICAgICAvLyBNYXBwaW5nIG9mIHN1YnRhc2tzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAgICAgICAgcGFub3B0aWM6ICdwb3N0X3Byb2Nlc3NfcGFub3B0aWNfc2VnbWVudGF0aW9uJyxcbiAgICAgICAgICAgIGluc3RhbmNlOiAncG9zdF9wcm9jZXNzX2luc3RhbmNlX3NlZ21lbnRhdGlvbicsXG4gICAgICAgICAgICBzZW1hbnRpYzogJ3Bvc3RfcHJvY2Vzc19zZW1hbnRpY19zZWdtZW50YXRpb24nXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWdtZW50IHRoZSBpbnB1dCBpbWFnZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW1hZ2VzIFRoZSBpbnB1dCBpbWFnZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgdG8gdXNlIGZvciBzZWdtZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0wLjVdIFByb2JhYmlsaXR5IHRocmVzaG9sZCB0byBmaWx0ZXIgb3V0IHByZWRpY3RlZCBtYXNrcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWFza190aHJlc2hvbGQ9MC41XSBUaHJlc2hvbGQgdG8gdXNlIHdoZW4gdHVybmluZyB0aGUgcHJlZGljdGVkIG1hc2tzIGludG8gYmluYXJ5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMub3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkPTAuOF0gTWFzayBvdmVybGFwIHRocmVzaG9sZCB0byBlbGltaW5hdGUgc21hbGwsIGRpc2Nvbm5lY3RlZCBzZWdtZW50cy5cbiAgICAgKiBAcGFyYW0ge251bGx8c3RyaW5nfSBbb3B0aW9ucy5zdWJ0YXNrPW51bGxdIFNlZ21lbnRhdGlvbiB0YXNrIHRvIGJlIHBlcmZvcm1lZC4gT25lIG9mIFtgcGFub3B0aWNgLCBgaW5zdGFuY2VgLCBhbmQgYHNlbWFudGljYF0sIGRlcGVuZGluZyBvbiBtb2RlbCBjYXBhYmlsaXRpZXMuIElmIG5vdCBzZXQsIHRoZSBwaXBlbGluZSB3aWxsIGF0dGVtcHQgdG8gcmVzb2x2ZSAoaW4gdGhhdCBvcmRlcikuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubGFiZWxfaWRzX3RvX2Z1c2U9bnVsbF0gTGlzdCBvZiBsYWJlbCBpZHMgdG8gZnVzZS4gSWYgbm90IHNldCwgZG8gbm90IGZ1c2UgYW55IGxhYmVscy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy50YXJnZXRfc2l6ZXM9bnVsbF0gTGlzdCBvZiB0YXJnZXQgc2l6ZXMgZm9yIHRoZSBpbnB1dCBpbWFnZXMuIElmIG5vdCBzZXQsIHVzZSB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZXMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSBUaGUgYW5ub3RhdGVkIHNlZ21lbnRzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGltYWdlcywge1xuICAgICAgICB0aHJlc2hvbGQgPSAwLjUsXG4gICAgICAgIG1hc2tfdGhyZXNob2xkID0gMC41LFxuICAgICAgICBvdmVybGFwX21hc2tfYXJlYV90aHJlc2hvbGQgPSAwLjgsXG4gICAgICAgIGxhYmVsX2lkc190b19mdXNlID0gbnVsbCxcbiAgICAgICAgdGFyZ2V0X3NpemVzID0gbnVsbCxcbiAgICAgICAgc3VidGFzayA9IG51bGwsIC8vIFRPRE8gdXNlXG4gICAgfSA9IHt9KSB7XG4gICAgICAgIGxldCBpc0JhdGNoZWQgPSBBcnJheS5pc0FycmF5KGltYWdlcyk7XG5cbiAgICAgICAgaWYgKGlzQmF0Y2hlZCAmJiBpbWFnZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkltYWdlIHNlZ21lbnRhdGlvbiBwaXBlbGluZSBjdXJyZW50bHkgb25seSBzdXBwb3J0cyBhIGJhdGNoIHNpemUgb2YgMS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpbWFnZXMgPSBhd2FpdCBwcmVwYXJlSW1hZ2VzKGltYWdlcyk7XG4gICAgICAgIGxldCBpbWFnZVNpemVzID0gaW1hZ2VzLm1hcCh4ID0+IFt4LmhlaWdodCwgeC53aWR0aF0pO1xuXG4gICAgICAgIGxldCB7IHBpeGVsX3ZhbHVlcywgcGl4ZWxfbWFzayB9ID0gYXdhaXQgdGhpcy5wcm9jZXNzb3IoaW1hZ2VzKTtcbiAgICAgICAgbGV0IG91dHB1dCA9IGF3YWl0IHRoaXMubW9kZWwoeyBwaXhlbF92YWx1ZXMsIHBpeGVsX21hc2sgfSk7XG5cbiAgICAgICAgbGV0IGZuID0gbnVsbDtcbiAgICAgICAgaWYgKHN1YnRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZuID0gdGhpcy5zdWJ0YXNrc19tYXBwaW5nW3N1YnRhc2tdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgW3Rhc2ssIGZ1bmNdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuc3VidGFza3NfbWFwcGluZykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVuYyBpbiB0aGlzLnByb2Nlc3Nvci5mZWF0dXJlX2V4dHJhY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBmbiA9IHRoaXMucHJvY2Vzc29yLmZlYXR1cmVfZXh0cmFjdG9yW2Z1bmNdLmJpbmQodGhpcy5wcm9jZXNzb3IuZmVhdHVyZV9leHRyYWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBzdWJ0YXNrID0gdGFzaztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGFubm90YXRpb25zXG4gICAgICAgIGxldCBhbm5vdGF0aW9uID0gW107XG5cbiAgICAgICAgaWYgKHN1YnRhc2sgPT09ICdwYW5vcHRpYycgfHwgc3VidGFzayA9PT0gJ2luc3RhbmNlJykge1xuXG4gICAgICAgICAgICBsZXQgcHJvY2Vzc2VkID0gZm4oXG4gICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICBtYXNrX3RocmVzaG9sZCxcbiAgICAgICAgICAgICAgICBvdmVybGFwX21hc2tfYXJlYV90aHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgbGFiZWxfaWRzX3RvX2Z1c2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0X3NpemVzID8/IGltYWdlU2l6ZXMsIC8vIFRPRE8gRklYP1xuICAgICAgICAgICAgKVswXTtcblxuICAgICAgICAgICAgbGV0IHNlZ21lbnRhdGlvbiA9IHByb2Nlc3NlZC5zZWdtZW50YXRpb247XG4gICAgICAgICAgICBsZXQgaWQybGFiZWwgPSB0aGlzLm1vZGVsLmNvbmZpZy5pZDJsYWJlbDtcblxuICAgICAgICAgICAgZm9yIChsZXQgc2VnbWVudCBvZiBwcm9jZXNzZWQuc2VnbWVudHNfaW5mbykge1xuICAgICAgICAgICAgICAgIGxldCBtYXNrRGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShzZWdtZW50YXRpb24uZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudGF0aW9uLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRhdGlvbi5kYXRhW2ldID09PSBzZWdtZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrRGF0YVtpXSA9IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBtYXNrID0gbmV3IFJhd0ltYWdlKG1hc2tEYXRhLCBzZWdtZW50YXRpb24uZGltc1sxXSwgc2VnbWVudGF0aW9uLmRpbXNbMF0sIDEpXG5cbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzY29yZTogc2VnbWVudC5zY29yZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGlkMmxhYmVsW3NlZ21lbnQubGFiZWxfaWRdLFxuICAgICAgICAgICAgICAgICAgICBtYXNrOiBtYXNrXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHN1YnRhc2sgPT09ICdzZW1hbnRpYycpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBzZW1hbnRpYyBzZWdtZW50YXRpb24gbm90IHlldCBzdXBwb3J0ZWQuYCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBTdWJ0YXNrICR7c3VidGFza30gbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIFplcm8gc2hvdCBpbWFnZSBjbGFzc2lmaWNhdGlvbiBwaXBlbGluZS4gVGhpcyBwaXBlbGluZSBwcmVkaWN0cyB0aGUgY2xhc3Mgb2ZcbiAqIGFuIGltYWdlIHdoZW4geW91IHByb3ZpZGUgYW4gaW1hZ2UgYW5kIGEgc2V0IG9mIGBjYW5kaWRhdGVfbGFiZWxzYC5cbiAqIEBleHRlbmRzIFBpcGVsaW5lXG4gKi9cbmV4cG9ydCBjbGFzcyBaZXJvU2hvdEltYWdlQ2xhc3NpZmljYXRpb25QaXBlbGluZSBleHRlbmRzIFBpcGVsaW5lIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBaZXJvU2hvdEltYWdlQ2xhc3NpZmljYXRpb25QaXBlbGluZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFzayBUaGUgdGFzayBvZiB0aGUgcGlwZWxpbmUuIFVzZWZ1bCBmb3Igc3BlY2lmeWluZyBzdWJ0YXNrcy5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRUb2tlbml6ZXJ9IHRva2VuaXplciBUaGUgdG9rZW5pemVyIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1ByZVRyYWluZWRNb2RlbH0gbW9kZWwgVGhlIG1vZGVsIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge1Byb2Nlc3Nvcn0gcHJvY2Vzc29yIFRoZSBwcm9jZXNzb3IgdG8gdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhc2ssIHRva2VuaXplciwgbW9kZWwsIHByb2Nlc3Nvcikge1xuICAgICAgICBzdXBlcih0YXNrLCB0b2tlbml6ZXIsIG1vZGVsKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhc3NpZnkgdGhlIGlucHV0IGltYWdlcyB3aXRoIGNhbmRpZGF0ZSBsYWJlbHMgdXNpbmcgYSB6ZXJvLXNob3QgYXBwcm9hY2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW1hZ2VzIFRoZSBpbnB1dCBpbWFnZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2FuZGlkYXRlX2xhYmVscyBUaGUgY2FuZGlkYXRlIGxhYmVscy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIGNsYXNzaWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5oeXBvdGhlc2lzX3RlbXBsYXRlXSBUaGUgaHlwb3RoZXNpcyB0ZW1wbGF0ZSB0byB1c2UgZm9yIHplcm8tc2hvdCBjbGFzc2lmaWNhdGlvbi4gRGVmYXVsdDogXCJUaGlzIGlzIGEgcGhvdG8gb2Yge31cIi5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBBbiBhcnJheSBvZiBjbGFzc2lmaWNhdGlvbnMgZm9yIGVhY2ggaW5wdXQgaW1hZ2Ugb3IgYSBzaW5nbGUgY2xhc3NpZmljYXRpb24gb2JqZWN0IGlmIG9ubHkgb25lIGlucHV0IGltYWdlIGlzIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhc3luYyBfY2FsbChpbWFnZXMsIGNhbmRpZGF0ZV9sYWJlbHMsIHtcbiAgICAgICAgaHlwb3RoZXNpc190ZW1wbGF0ZSA9IFwiVGhpcyBpcyBhIHBob3RvIG9mIHt9XCJcbiAgICB9ID0ge30pIHtcbiAgICAgICAgbGV0IGlzQmF0Y2hlZCA9IEFycmF5LmlzQXJyYXkoaW1hZ2VzKTtcbiAgICAgICAgaW1hZ2VzID0gYXdhaXQgcHJlcGFyZUltYWdlcyhpbWFnZXMpO1xuXG4gICAgICAgIC8vIEluc2VydCBsYWJlbCBpbnRvIGh5cG90aGVzaXMgdGVtcGxhdGUgXG4gICAgICAgIGxldCB0ZXh0cyA9IGNhbmRpZGF0ZV9sYWJlbHMubWFwKFxuICAgICAgICAgICAgeCA9PiBoeXBvdGhlc2lzX3RlbXBsYXRlLnJlcGxhY2UoJ3t9JywgeClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBSdW4gdG9rZW5pemF0aW9uXG4gICAgICAgIGxldCB0ZXh0X2lucHV0cyA9IHRoaXMudG9rZW5pemVyKHRleHRzLCB7XG4gICAgICAgICAgICBwYWRkaW5nOiB0cnVlLFxuICAgICAgICAgICAgdHJ1bmNhdGlvbjogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSdW4gcHJvY2Vzc29yXG4gICAgICAgIGxldCB7IHBpeGVsX3ZhbHVlcyB9ID0gYXdhaXQgdGhpcy5wcm9jZXNzb3IoaW1hZ2VzKTtcblxuICAgICAgICAvLyBSdW4gbW9kZWwgd2l0aCBib3RoIHRleHQgYW5kIHBpeGVsIGlucHV0c1xuICAgICAgICBsZXQgb3V0cHV0ID0gYXdhaXQgdGhpcy5tb2RlbCh7IC4uLnRleHRfaW5wdXRzLCBwaXhlbF92YWx1ZXMgfSk7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBlYWNoIGltYWdlIHdpdGggZWFjaCBjYW5kaWRhdGUgbGFiZWxcbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IGJhdGNoIG9mIG91dHB1dC5sb2dpdHNfcGVyX2ltYWdlKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHNvZnRtYXggcGVyIGltYWdlXG4gICAgICAgICAgICBsZXQgcHJvYnMgPSBzb2Z0bWF4KGJhdGNoLmRhdGEpO1xuXG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKFsuLi5wcm9ic10ubWFwKCh4LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHgsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBjYW5kaWRhdGVfbGFiZWxzW2ldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzQmF0Y2hlZCA/IHRvUmV0dXJuIDogdG9SZXR1cm5bMF07XG4gICAgfVxufVxuXG4vKipcbiAqIE9iamVjdCBkZXRlY3Rpb24gcGlwZWxpbmUgdXNpbmcgYW55IGBBdXRvTW9kZWxGb3JPYmplY3REZXRlY3Rpb25gLlxuICogVGhpcyBwaXBlbGluZSBwcmVkaWN0cyBib3VuZGluZyBib3hlcyBvZiBvYmplY3RzIGFuZCB0aGVpciBjbGFzc2VzLlxuICogXG4gKiAqKkV4YW1wbGU6KiogUnVuIG9iamVjdC1kZXRlY3Rpb24gd2l0aCBgZmFjZWJvb2svZGV0ci1yZXNuZXQtNTBgLlxuICogYGBgamF2YXNjcmlwdFxuICogbGV0IGltZyA9ICdodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RhdGFzZXRzL1hlbm92YS90cmFuc2Zvcm1lcnMuanMtZG9jcy9yZXNvbHZlL21haW4vY2F0cy5qcGcnO1xuICogXG4gKiBsZXQgZGV0ZWN0b3IgPSBhd2FpdCBwaXBlbGluZSgnb2JqZWN0LWRldGVjdGlvbicsICdYZW5vdmEvZGV0ci1yZXNuZXQtNTAnKTtcbiAqIGxldCBvdXRwdXQgPSBhd2FpdCBkZXRlY3RvcihpbWcsIHsgdGhyZXNob2xkOiAwLjkgfSk7XG4gKiAvLyBbe1xuICogLy8gICBcInNjb3JlXCI6IDAuOTk3NjM3MDkzMDY3MTY5MixcbiAqIC8vICAgXCJsYWJlbFwiOiBcInJlbW90ZVwiLFxuICogLy8gICBcImJveFwiOiB7IFwieG1pblwiOiAzMSwgXCJ5bWluXCI6IDY4LCBcInhtYXhcIjogMTkwLCBcInltYXhcIjogMTE4IH1cbiAqIC8vIH0sXG4gKiAvLyAuLi5cbiAqIC8vIHtcbiAqIC8vICAgXCJzY29yZVwiOiAwLjk5ODQwOTIxMTYzNTU4OTYsXG4gKiAvLyAgIFwibGFiZWxcIjogXCJjYXRcIixcbiAqIC8vICAgXCJib3hcIjogeyBcInhtaW5cIjogMzMxLCBcInltaW5cIjogMTksIFwieG1heFwiOiA2NDksIFwieW1heFwiOiAzNzEgfVxuICogLy8gfV1cbiAqIGBgYFxuICogXG4gKiBAZXh0ZW5kcyBQaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgT2JqZWN0RGV0ZWN0aW9uUGlwZWxpbmUgZXh0ZW5kcyBQaXBlbGluZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE9iamVjdERldGVjdGlvblBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrIFRoZSB0YXNrIG9mIHRoZSBwaXBlbGluZS4gVXNlZnVsIGZvciBzcGVjaWZ5aW5nIHN1YnRhc2tzLlxuICAgICAqIEBwYXJhbSB7UHJlVHJhaW5lZE1vZGVsfSBtb2RlbCBUaGUgbW9kZWwgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UHJvY2Vzc29yfSBwcm9jZXNzb3IgVGhlIHByb2Nlc3NvciB0byB1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFzaywgbW9kZWwsIHByb2Nlc3Nvcikge1xuICAgICAgICBzdXBlcih0YXNrLCBudWxsLCBtb2RlbCk7IC8vIFRPRE8gdG9rZW5pemVyXG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVjdCBvYmplY3RzIChib3VuZGluZyBib3hlcyAmIGNsYXNzZXMpIGluIHRoZSBpbWFnZShzKSBwYXNzZWQgYXMgaW5wdXRzLlxuICAgICAqIEBwYXJhbSB7YW55W119IGltYWdlcyBUaGUgaW5wdXQgaW1hZ2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgb2JqZWN0IGRldGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTAuOV0gVGhlIHRocmVzaG9sZCB1c2VkIHRvIGZpbHRlciBib3hlcyBieSBzY29yZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBlcmNlbnRhZ2U9ZmFsc2VdIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBib3hlcyBjb29yZGluYXRlcyBpbiBwZXJjZW50YWdlICh0cnVlKSBvciBpbiBwaXhlbHMgKGZhbHNlKS5cbiAgICAgKi9cbiAgICBhc3luYyBfY2FsbChpbWFnZXMsIHtcbiAgICAgICAgdGhyZXNob2xkID0gMC45LFxuICAgICAgICBwZXJjZW50YWdlID0gZmFsc2UsXG4gICAgfSA9IHt9KSB7XG4gICAgICAgIGxldCBpc0JhdGNoZWQgPSBBcnJheS5pc0FycmF5KGltYWdlcyk7XG5cbiAgICAgICAgaWYgKGlzQmF0Y2hlZCAmJiBpbWFnZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIk9iamVjdCBkZXRlY3Rpb24gcGlwZWxpbmUgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgYSBiYXRjaCBzaXplIG9mIDEuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlcyA9IGF3YWl0IHByZXBhcmVJbWFnZXMoaW1hZ2VzKTtcblxuICAgICAgICBsZXQgaW1hZ2VTaXplcyA9IHBlcmNlbnRhZ2UgPyBudWxsIDogaW1hZ2VzLm1hcCh4ID0+IFt4LmhlaWdodCwgeC53aWR0aF0pO1xuXG4gICAgICAgIGxldCB7IHBpeGVsX3ZhbHVlcywgcGl4ZWxfbWFzayB9ID0gYXdhaXQgdGhpcy5wcm9jZXNzb3IoaW1hZ2VzKTtcbiAgICAgICAgbGV0IG91dHB1dCA9IGF3YWl0IHRoaXMubW9kZWwoeyBwaXhlbF92YWx1ZXMsIHBpeGVsX21hc2sgfSk7XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgcHJvY2Vzc2VkID0gdGhpcy5wcm9jZXNzb3IuZmVhdHVyZV9leHRyYWN0b3IucG9zdF9wcm9jZXNzX29iamVjdF9kZXRlY3Rpb24ob3V0cHV0LCB0aHJlc2hvbGQsIGltYWdlU2l6ZXMpO1xuXG4gICAgICAgIC8vIEFkZCBsYWJlbHNcbiAgICAgICAgbGV0IGlkMmxhYmVsID0gdGhpcy5tb2RlbC5jb25maWcuaWQybGFiZWw7XG5cbiAgICAgICAgLy8gRm9ybWF0IG91dHB1dFxuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9jZXNzZWQubWFwKGJhdGNoID0+IHtcbiAgICAgICAgICAgIHJldHVybiBiYXRjaC5ib3hlcy5tYXAoKGJveCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlOiBiYXRjaC5zY29yZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpZDJsYWJlbFtiYXRjaC5jbGFzc2VzW2ldXSxcbiAgICAgICAgICAgICAgICAgICAgYm94OiB0aGlzLl9nZXRfYm91bmRpbmdfYm94KGJveCwgIXBlcmNlbnRhZ2UpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIGlzQmF0Y2hlZCA/IHJlc3VsdCA6IHJlc3VsdFswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBsaXN0IFt4bWluLCB4bWF4LCB5bWluLCB5bWF4XSBpbnRvIG9iamVjdCB7IFwieG1pblwiOiB4bWluLCAuLi4gfVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGJveCBUaGUgYm91bmRpbmcgYm94IGFzIGEgbGlzdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFzSW50ZWdlciBXaGV0aGVyIHRvIGNhc3QgdG8gaW50ZWdlcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGJvdW5kaW5nIGJveCBhcyBhbiBvYmplY3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0X2JvdW5kaW5nX2JveChib3gsIGFzSW50ZWdlcikge1xuICAgICAgICBpZiAoYXNJbnRlZ2VyKSB7XG4gICAgICAgICAgICBib3ggPSBib3gubWFwKHggPT4geCB8IDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt4bWluLCB5bWluLCB4bWF4LCB5bWF4XSA9IGJveDtcblxuICAgICAgICByZXR1cm4geyB4bWluLCB5bWluLCB4bWF4LCB5bWF4IH07XG4gICAgfVxufVxuXG5jb25zdCBTVVBQT1JURURfVEFTS1MgPSB7XG4gICAgXCJ0ZXh0LWNsYXNzaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBUZXh0Q2xhc3NpZmljYXRpb25QaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JTZXF1ZW5jZUNsYXNzaWZpY2F0aW9uLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQtZmluZXR1bmVkLXNzdC0yLWVuZ2xpc2hcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZGlzdGlsYmVydC1iYXNlLXVuY2FzZWQtZmluZXR1bmVkLXNzdC0yLWVuZ2xpc2hcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiLFxuICAgIH0sXG4gICAgXCJ0b2tlbi1jbGFzc2lmaWNhdGlvblwiOiB7XG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogVG9rZW5DbGFzc2lmaWNhdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvclRva2VuQ2xhc3NpZmljYXRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJEYXZsYW4vYmVydC1iYXNlLW11bHRpbGluZ3VhbC1jYXNlZC1uZXItaHJsXCIsXG4gICAgICAgICAgICBcIm1vZGVsXCI6IFwiWGVub3ZhL2JlcnQtYmFzZS1tdWx0aWxpbmd1YWwtY2FzZWQtbmVyLWhybFwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcbiAgICBcInF1ZXN0aW9uLWFuc3dlcmluZ1wiOiB7XG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogUXVlc3Rpb25BbnN3ZXJpbmdQaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JRdWVzdGlvbkFuc3dlcmluZyxcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcImRpc3RpbGJlcnQtYmFzZS1jYXNlZC1kaXN0aWxsZWQtc3F1YWRcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZGlzdGlsYmVydC1iYXNlLWNhc2VkLWRpc3RpbGxlZC1zcXVhZFwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcblxuICAgIFwiZmlsbC1tYXNrXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBGaWxsTWFza1BpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvck1hc2tlZExNLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiYmVydC1iYXNlLXVuY2FzZWRcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvYmVydC1iYXNlLXVuY2FzZWRcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiLFxuICAgIH0sXG4gICAgXCJzdW1tYXJpemF0aW9uXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBTdW1tYXJpemF0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yU2VxMlNlcUxNLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwic3NobGVpZmVyL2Rpc3RpbGJhcnQtY25uLTYtNlwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS9kaXN0aWxiYXJ0LWNubi02LTZcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiLFxuICAgIH0sXG4gICAgXCJ0cmFuc2xhdGlvblwiOiB7XG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogVHJhbnNsYXRpb25QaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JTZXEyU2VxTE0sXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJ0NS1zbWFsbFwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS90NS1zbWFsbFwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcbiAgICBcInRleHQydGV4dC1nZW5lcmF0aW9uXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBUZXh0MlRleHRHZW5lcmF0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yU2VxMlNlcUxNLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiZ29vZ2xlL2ZsYW4tdDUtc21hbGxcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZmxhbi10NS1zbWFsbFwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcbiAgICBcInRleHQtZ2VuZXJhdGlvblwiOiB7XG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogVGV4dEdlbmVyYXRpb25QaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JDYXVzYWxMTSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcImdwdDJcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZ3B0MlwiLFxuICAgICAgICB9LFxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgfSxcbiAgICBcInplcm8tc2hvdC1jbGFzc2lmaWNhdGlvblwiOiB7XG4gICAgICAgIFwidG9rZW5pemVyXCI6IEF1dG9Ub2tlbml6ZXIsXG4gICAgICAgIFwicGlwZWxpbmVcIjogWmVyb1Nob3RDbGFzc2lmaWNhdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvclNlcXVlbmNlQ2xhc3NpZmljYXRpb24sXG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIFwibW9kZWxcIjogXCJ0eXBlZm9ybS9kaXN0aWxiZXJ0LWJhc2UtdW5jYXNlZC1tbmxpXCIsXG4gICAgICAgICAgICBcIm1vZGVsXCI6IFwiWGVub3ZhL2Rpc3RpbGJlcnQtYmFzZS11bmNhc2VkLW1ubGlcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiLFxuICAgIH0sXG5cbiAgICBcImF1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb25cIjoge1xuICAgICAgICBcInRva2VuaXplclwiOiBBdXRvVG9rZW5pemVyLFxuICAgICAgICBcInBpcGVsaW5lXCI6IEF1dG9tYXRpY1NwZWVjaFJlY29nbml0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yU2VxMlNlcUxNLFxuICAgICAgICBcInByb2Nlc3NvclwiOiBBdXRvUHJvY2Vzc29yLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwib3BlbmFpL3doaXNwZXItdGlueS5lblwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS93aGlzcGVyLXRpbnkuZW5cIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibXVsdGltb2RhbFwiLFxuICAgIH0sXG5cbiAgICBcImltYWdlLXRvLXRleHRcIjoge1xuICAgICAgICBcInRva2VuaXplclwiOiBBdXRvVG9rZW5pemVyLFxuICAgICAgICBcInBpcGVsaW5lXCI6IEltYWdlVG9UZXh0UGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yVmlzaW9uMlNlcSxcbiAgICAgICAgXCJwcm9jZXNzb3JcIjogQXV0b1Byb2Nlc3NvcixcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcIm5scGNvbm5lY3Qvdml0LWdwdDItaW1hZ2UtY2FwdGlvbmluZ1wiLFxuICAgICAgICAgICAgXCJtb2RlbFwiOiBcIlhlbm92YS92aXQtZ3B0Mi1pbWFnZS1jYXB0aW9uaW5nXCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHlwZVwiOiBcIm11bHRpbW9kYWxcIixcbiAgICB9LFxuXG4gICAgXCJpbWFnZS1jbGFzc2lmaWNhdGlvblwiOiB7XG4gICAgICAgIC8vIG5vIHRva2VuaXplclxuICAgICAgICBcInBpcGVsaW5lXCI6IEltYWdlQ2xhc3NpZmljYXRpb25QaXBlbGluZSxcbiAgICAgICAgXCJtb2RlbFwiOiBBdXRvTW9kZWxGb3JJbWFnZUNsYXNzaWZpY2F0aW9uLFxuICAgICAgICBcInByb2Nlc3NvclwiOiBBdXRvUHJvY2Vzc29yLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiZ29vZ2xlL3ZpdC1iYXNlLXBhdGNoMTYtMjI0XCIsXG4gICAgICAgICAgICBcIm1vZGVsXCI6IFwiWGVub3ZhL3ZpdC1iYXNlLXBhdGNoMTYtMjI0XCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHlwZVwiOiBcIm11bHRpbW9kYWxcIixcbiAgICB9LFxuXG4gICAgXCJpbWFnZS1zZWdtZW50YXRpb25cIjoge1xuICAgICAgICAvLyBubyB0b2tlbml6ZXJcbiAgICAgICAgXCJwaXBlbGluZVwiOiBJbWFnZVNlZ21lbnRhdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbEZvckltYWdlU2VnbWVudGF0aW9uLFxuICAgICAgICBcInByb2Nlc3NvclwiOiBBdXRvUHJvY2Vzc29yLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiZmFjZWJvb2svZGV0ci1yZXNuZXQtNTAtcGFub3B0aWNcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZGV0ci1yZXNuZXQtNTAtcGFub3B0aWNcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibXVsdGltb2RhbFwiLFxuICAgIH0sXG5cbiAgICBcInplcm8tc2hvdC1pbWFnZS1jbGFzc2lmaWNhdGlvblwiOiB7XG4gICAgICAgIC8vIG5vIHRva2VuaXplclxuICAgICAgICBcInRva2VuaXplclwiOiBBdXRvVG9rZW5pemVyLFxuICAgICAgICBcInBpcGVsaW5lXCI6IFplcm9TaG90SW1hZ2VDbGFzc2lmaWNhdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbCxcbiAgICAgICAgXCJwcm9jZXNzb3JcIjogQXV0b1Byb2Nlc3NvcixcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcIm9wZW5haS9jbGlwLXZpdC1iYXNlLXBhdGNoMzJcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvY2xpcC12aXQtYmFzZS1wYXRjaDMyXCIsXG4gICAgICAgIH0sXG4gICAgICAgIFwidHlwZVwiOiBcIm11bHRpbW9kYWxcIixcbiAgICB9LFxuXG4gICAgXCJvYmplY3QtZGV0ZWN0aW9uXCI6IHtcbiAgICAgICAgLy8gbm8gdG9rZW5pemVyXG4gICAgICAgIFwicGlwZWxpbmVcIjogT2JqZWN0RGV0ZWN0aW9uUGlwZWxpbmUsXG4gICAgICAgIFwibW9kZWxcIjogQXV0b01vZGVsRm9yT2JqZWN0RGV0ZWN0aW9uLFxuICAgICAgICBcInByb2Nlc3NvclwiOiBBdXRvUHJvY2Vzc29yLFxuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBcIm1vZGVsXCI6IFwiZmFjZWJvb2svZGV0ci1yZXNuZXQtNTBcIixcbiAgICAgICAgICAgIFwibW9kZWxcIjogXCJYZW5vdmEvZGV0ci1yZXNuZXQtNTBcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwibXVsdGltb2RhbFwiLFxuICAgIH0sXG5cbiAgICAvLyBUaGlzIHRhc2sgc2VydmVzIGFzIGEgdXNlZnVsIGludGVyZmFjZSBmb3IgZGVhbGluZyB3aXRoIHNlbnRlbmNlLXRyYW5zZm9ybWVycyAoaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9zZW50ZW5jZS10cmFuc2Zvcm1lcnMpLlxuICAgIFwiZmVhdHVyZS1leHRyYWN0aW9uXCI6IHtcbiAgICAgICAgXCJ0b2tlbml6ZXJcIjogQXV0b1Rva2VuaXplcixcbiAgICAgICAgXCJwaXBlbGluZVwiOiBGZWF0dXJlRXh0cmFjdGlvblBpcGVsaW5lLFxuICAgICAgICBcIm1vZGVsXCI6IEF1dG9Nb2RlbCxcbiAgICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gXCJtb2RlbFwiOiBcInNlbnRlbmNlLXRyYW5zZm9ybWVycy9hbGwtTWluaUxNLUw2LXYyXCIsXG4gICAgICAgICAgICBcIm1vZGVsXCI6IFwiWGVub3ZhL2FsbC1NaW5pTE0tTDYtdjJcIixcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiLFxuICAgIH0sXG59XG5cblxuY29uc3QgVEFTS19BTElBU0VTID0ge1xuICAgIFwic2VudGltZW50LWFuYWx5c2lzXCI6IFwidGV4dC1jbGFzc2lmaWNhdGlvblwiLFxuICAgIFwibmVyXCI6IFwidG9rZW4tY2xhc3NpZmljYXRpb25cIixcbiAgICBcInZxYVwiOiBcInZpc3VhbC1xdWVzdGlvbi1hbnN3ZXJpbmdcIixcbiAgICBcImFzclwiOiBcImF1dG9tYXRpYy1zcGVlY2gtcmVjb2duaXRpb25cIixcblxuICAgIC8vIEFkZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBcImVtYmVkZGluZ3NcIjogXCJmZWF0dXJlLWV4dHJhY3Rpb25cIixcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3V0aWxzL2h1Yi5qcycpLlByZXRyYWluZWRPcHRpb25zfSBQcmV0cmFpbmVkT3B0aW9uc1xuICovXG5cbi8qKlxuICogVXRpbGl0eSBmYWN0b3J5IG1ldGhvZCB0byBidWlsZCBhIFtgUGlwZWxpbmVgXSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhc2sgVGhlIHRhc2sgb2YgdGhlIHBpcGVsaW5lLlxuICogQHBhcmFtIHtzdHJpbmd9IFttb2RlbD1udWxsXSBUaGUgbmFtZSBvZiB0aGUgcHJlLXRyYWluZWQgbW9kZWwgdG8gdXNlLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBtb2RlbCBmb3IgdGhlIHRhc2sgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIHtQcmV0cmFpbmVkT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBwaXBlbGluZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPFBpcGVsaW5lPn0gQSBQaXBlbGluZSBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgdGFzay5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbiB1bnN1cHBvcnRlZCBwaXBlbGluZSBpcyByZXF1ZXN0ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwaXBlbGluZShcbiAgICB0YXNrLFxuICAgIG1vZGVsID0gbnVsbCxcbiAgICB7XG4gICAgICAgIHF1YW50aXplZCA9IHRydWUsXG4gICAgICAgIHByb2dyZXNzX2NhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgY29uZmlnID0gbnVsbCxcbiAgICAgICAgY2FjaGVfZGlyID0gbnVsbCxcbiAgICAgICAgbG9jYWxfZmlsZXNfb25seSA9IGZhbHNlLFxuICAgICAgICByZXZpc2lvbiA9ICdtYWluJyxcbiAgICB9ID0ge31cbikge1xuICAgIC8vIEhlbHBlciBtZXRob2QgdG8gY29uc3RydWN0IHBpcGVsaW5lXG5cbiAgICAvLyBBcHBseSBhbGlhc2VzXG4gICAgdGFzayA9IFRBU0tfQUxJQVNFU1t0YXNrXSA/PyB0YXNrO1xuXG4gICAgLy8gR2V0IHBpcGVsaW5lIGluZm9cbiAgICBsZXQgcGlwZWxpbmVJbmZvID0gU1VQUE9SVEVEX1RBU0tTW3Rhc2suc3BsaXQoJ18nLCAxKVswXV07XG4gICAgaWYgKCFwaXBlbGluZUluZm8pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHBpcGVsaW5lOiAke3Rhc2t9LiBNdXN0IGJlIG9uZSBvZiBbJHtPYmplY3Qua2V5cyhTVVBQT1JURURfVEFTS1MpfV1gKVxuICAgIH1cblxuICAgIC8vIFVzZSBtb2RlbCBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSwgdXNlIGRlZmF1bHRcbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgIG1vZGVsID0gcGlwZWxpbmVJbmZvLmRlZmF1bHQubW9kZWxcbiAgICAgICAgY29uc29sZS5sb2coYE5vIG1vZGVsIHNwZWNpZmllZC4gVXNpbmcgZGVmYXVsdCBtb2RlbDogXCIke21vZGVsfVwiLmApO1xuICAgIH1cblxuICAgIGxldCB0b2tlbml6ZXJDbGFzcyA9IHBpcGVsaW5lSW5mby50b2tlbml6ZXI7XG4gICAgbGV0IG1vZGVsQ2xhc3MgPSBwaXBlbGluZUluZm8ubW9kZWw7XG4gICAgbGV0IHBpcGVsaW5lQ2xhc3MgPSBwaXBlbGluZUluZm8ucGlwZWxpbmU7XG4gICAgbGV0IHByb2Nlc3NvckNsYXNzID0gcGlwZWxpbmVJbmZvLnByb2Nlc3NvcjtcblxuICAgIGxldCBwcm9taXNlcyA9IFtdO1xuXG4gICAgbGV0IHByZXRyYWluZWRPcHRpb25zID0ge1xuICAgICAgICBxdWFudGl6ZWQsXG4gICAgICAgIHByb2dyZXNzX2NhbGxiYWNrLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGNhY2hlX2RpcixcbiAgICAgICAgbG9jYWxfZmlsZXNfb25seSxcbiAgICAgICAgcmV2aXNpb24sXG4gICAgfVxuICAgIGlmICh0b2tlbml6ZXJDbGFzcykge1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgdG9rZW5pemVyQ2xhc3MuZnJvbV9wcmV0cmFpbmVkKG1vZGVsLCBwcmV0cmFpbmVkT3B0aW9ucyksXG4gICAgICAgIClcbiAgICB9XG4gICAgaWYgKG1vZGVsQ2xhc3MpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIG1vZGVsQ2xhc3MuZnJvbV9wcmV0cmFpbmVkKG1vZGVsLCBwcmV0cmFpbmVkT3B0aW9ucylcbiAgICAgICAgKVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzb3JDbGFzcykge1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgcHJvY2Vzc29yQ2xhc3MuZnJvbV9wcmV0cmFpbmVkKG1vZGVsLCBwcmV0cmFpbmVkT3B0aW9ucylcbiAgICAgICAgKVxuICAgIH1cblxuICAgIC8vIExvYWQgdG9rZW5pemVyIGFuZCBtb2RlbFxuICAgIGxldCBpdGVtcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuXG4gICAgZGlzcGF0Y2hDYWxsYmFjayhwcm9ncmVzc19jYWxsYmFjaywge1xuICAgICAgICAnc3RhdHVzJzogJ3JlYWR5JyxcbiAgICAgICAgJ3Rhc2snOiB0YXNrLFxuICAgICAgICAnbW9kZWwnOiBtb2RlbCxcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgcGlwZWxpbmVDbGFzcyh0YXNrLCAuLi5pdGVtcyk7XG5cbn1cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBDYXJ0ZXNpYW4gcHJvZHVjdCBvZiBnaXZlbiBhcnJheXNcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IGEgQXJyYXlzIHRvIGNvbXB1dGUgdGhlIHByb2R1Y3RcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29tcHV0ZWQgQ2FydGVzaWFuIHByb2R1Y3QgYXMgYW4gYXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByb2R1Y3QoLi4uYSkge1xuICAgIC8vIENhcnRlc2lhbiBwcm9kdWN0IG9mIGl0ZW1zXG4gICAgLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MzA1MzgwM1xuICAgIHJldHVybiBhLnJlZHVjZSgoYSwgYikgPT4gYS5mbGF0TWFwKGQgPT4gYi5tYXAoZSA9PiBbZCwgZV0pKSk7XG59XG4iLCJcbi8qKlxuICogQGZpbGUgUHJvY2Vzc29ycyBhcmUgdXNlZCB0byBwcmVwYXJlIG5vbi10ZXh0dWFsIGlucHV0cyAoZS5nLiwgaW1hZ2Ugb3IgYXVkaW8pIGZvciBhIG1vZGVsLlxuICogXG4gKiAqKkV4YW1wbGU6KiogVXNpbmcgYSBgV2hpc3BlclByb2Nlc3NvcmAgdG8gcHJlcGFyZSBhbiBhdWRpbyBpbnB1dCBmb3IgYSBtb2RlbC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IEF1dG9Qcm9jZXNzb3IsIHJlYWRfYXVkaW8gfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKlxuICogbGV0IHByb2Nlc3NvciA9IGF3YWl0IEF1dG9Qcm9jZXNzb3IuZnJvbV9wcmV0cmFpbmVkKCdvcGVuYWkvd2hpc3Blci10aW55LmVuJyk7XG4gKiBsZXQgYXVkaW8gPSBhd2FpdCByZWFkX2F1ZGlvKCdodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RhdGFzZXRzL05hcnNpbC9hc3JfZHVtbXkvcmVzb2x2ZS9tYWluL21say5mbGFjJywgMTYwMDApO1xuICogbGV0IHsgaW5wdXRfZmVhdHVyZXMgfSA9IGF3YWl0IHByb2Nlc3NvcihhdWRpbyk7XG4gKiAvLyBUZW5zb3Ige1xuICogLy8gICBkYXRhOiBGbG9hdDMyQXJyYXkoMjQwMDAwKSBbMC40NzUyOTg0NjQyOTgyNDgzLCAwLjU1OTcyNTg4MDYyMjg2MzgsIDAuNTY0MzQxNjY0MzE0MjcsIC4uLl0sXG4gKiAvLyAgIGRpbXM6IFsxLCA4MCwgMzAwMF0sXG4gKiAvLyAgIHR5cGU6ICdmbG9hdDMyJyxcbiAqIC8vICAgc2l6ZTogMjQwMDAwLFxuICogLy8gfVxuICogYGBgXG4gKiBcbiAqIEBtb2R1bGUgcHJvY2Vzc29yc1xuICovXG5pbXBvcnQge1xuICAgIENhbGxhYmxlLFxuICAgIGNhbGN1bGF0ZURpbWVuc2lvbnMsXG59IGZyb20gJy4vdXRpbHMvY29yZS5qcyc7XG5cbmltcG9ydCB7XG4gICAgZ2V0TW9kZWxKU09OLFxufSBmcm9tICcuL3V0aWxzL2h1Yi5qcyc7XG5cbmltcG9ydCB7XG4gICAgbWF4LFxuICAgIHNvZnRtYXgsXG4gICAgRkZUXG59IGZyb20gJy4vdXRpbHMvbWF0aHMuanMnO1xuXG5cbmltcG9ydCB7IFRlbnNvciwgdHJhbnNwb3NlLCBjYXQsIGludGVycG9sYXRlIH0gZnJvbSAnLi91dGlscy90ZW5zb3IuanMnO1xuXG5pbXBvcnQgeyBSYXdJbWFnZSB9IGZyb20gJy4vdXRpbHMvaW1hZ2UuanMnO1xuaW1wb3J0IHsgZ2V0TWVsRmlsdGVycyB9IGZyb20gJy4vdXRpbHMvYXVkaW8uanMnO1xuXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgZmVhdHVyZSBleHRyYWN0b3JzLlxuICpcbiAqIEBleHRlbmRzIENhbGxhYmxlXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWF0dXJlRXh0cmFjdG9yIGV4dGVuZHMgQ2FsbGFibGUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRmVhdHVyZUV4dHJhY3RvciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBmZWF0dXJlIGV4dHJhY3Rvci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWdcbiAgICB9XG59XG5cbi8qKlxuICogRmVhdHVyZSBleHRyYWN0b3IgZm9yIGltYWdlIG1vZGVscy5cbiAqXG4gKiBAZXh0ZW5kcyBGZWF0dXJlRXh0cmFjdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZUZlYXR1cmVFeHRyYWN0b3IgZXh0ZW5kcyBGZWF0dXJlRXh0cmFjdG9yIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgSW1hZ2VGZWF0dXJlRXh0cmFjdG9yIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGZlYXR1cmUgZXh0cmFjdG9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGNvbmZpZy5pbWFnZV9tZWFuIFRoZSBtZWFuIHZhbHVlcyBmb3IgaW1hZ2Ugbm9ybWFsaXphdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBjb25maWcuaW1hZ2Vfc3RkIFRoZSBzdGFuZGFyZCBkZXZpYXRpb24gdmFsdWVzIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZmlnLmRvX3Jlc2NhbGUgV2hldGhlciB0byByZXNjYWxlIHRoZSBpbWFnZSBwaXhlbCB2YWx1ZXMgdG8gdGhlIFswLDFdIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcucmVzY2FsZV9mYWN0b3IgVGhlIGZhY3RvciB0byB1c2UgZm9yIHJlc2NhbGluZyB0aGUgaW1hZ2UgcGl4ZWwgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZmlnLmRvX25vcm1hbGl6ZSBXaGV0aGVyIHRvIG5vcm1hbGl6ZSB0aGUgaW1hZ2UgcGl4ZWwgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZmlnLmRvX3Jlc2l6ZSBXaGV0aGVyIHRvIHJlc2l6ZSB0aGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5yZXNhbXBsZSBXaGF0IG1ldGhvZCB0byB1c2UgZm9yIHJlc2FtcGxpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5zaXplIFRoZSBzaXplIHRvIHJlc2l6ZSB0aGUgaW1hZ2UgdG8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5pbWFnZV9tZWFuID0gdGhpcy5jb25maWcuaW1hZ2VfbWVhbjtcbiAgICAgICAgdGhpcy5pbWFnZV9zdGQgPSB0aGlzLmNvbmZpZy5pbWFnZV9zdGQ7XG5cbiAgICAgICAgdGhpcy5yZXNhbXBsZSA9IHRoaXMuY29uZmlnLnJlc2FtcGxlID8/IDI7IC8vIDIgPT4gYmlsaW5lYXJcbiAgICAgICAgdGhpcy5kb19yZXNjYWxlID0gdGhpcy5jb25maWcuZG9fcmVzY2FsZSA/PyB0cnVlO1xuICAgICAgICB0aGlzLnJlc2NhbGVfZmFjdG9yID0gdGhpcy5jb25maWcucmVzY2FsZV9mYWN0b3IgPz8gKDEgLyAyNTUpO1xuICAgICAgICB0aGlzLmRvX25vcm1hbGl6ZSA9IHRoaXMuY29uZmlnLmRvX25vcm1hbGl6ZTtcblxuICAgICAgICB0aGlzLmRvX3Jlc2l6ZSA9IHRoaXMuY29uZmlnLmRvX3Jlc2l6ZTtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5jb25maWcuc2l6ZTtcblxuICAgICAgICB0aGlzLmRvX2NlbnRlcl9jcm9wID0gdGhpcy5jb25maWcuZG9fY2VudGVyX2Nyb3A7XG4gICAgICAgIHRoaXMuY3JvcF9zaXplID0gdGhpcy5jb25maWcuY3JvcF9zaXplO1xuICAgICAgICB0aGlzLmRvX2NvbnZlcnRfcmdiID0gdGhpcy5jb25maWcuZG9fY29udmVydF9yZ2IgPz8gdHJ1ZTtcblxuICAgICAgICB0aGlzLnBhZF9zaXplID0gdGhpcy5jb25maWcucGFkX3NpemU7XG4gICAgICAgIHRoaXMuZG9fcGFkID0gKHRoaXMuY29uZmlnLmRvX3BhZCA/PyBmYWxzZSkgJiYgdGhpcy5wYWRfc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwcm9jZXNzZXMgdGhlIGdpdmVuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSYXdJbWFnZX0gaW1hZ2UgVGhlIGltYWdlIHRvIHByZXByb2Nlc3MuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gVGhlIHByZXByb2Nlc3NlZCBpbWFnZSBhcyBhIFRlbnNvci5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVwcm9jZXNzKGltYWdlKSB7XG5cbiAgICAgICAgLy8gRmlyc3QsIGNvbnZlcnQgaW1hZ2UgdG8gUkdCIGlmIHNwZWNpZmllZCBpbiBjb25maWcuXG4gICAgICAgIGlmICh0aGlzLmRvX2NvbnZlcnRfcmdiKSB7XG4gICAgICAgICAgICBpbWFnZSA9IGltYWdlLnJnYigpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3JjV2lkdGggPSBpbWFnZS53aWR0aDsgICAvLyBvcmlnaW5hbCB3aWR0aFxuICAgICAgICBjb25zdCBzcmNIZWlnaHQgPSBpbWFnZS5oZWlnaHQ7IC8vIG9yaWdpbmFsIGhlaWdodFxuXG4gICAgICAgIC8vIE5leHQsIHJlc2l6ZSBhbGwgaW1hZ2VzXG4gICAgICAgIGlmICh0aGlzLmRvX3Jlc2l6ZSkge1xuICAgICAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgICAgIC8vIEZvciBlZmZpY2llbmN5IHJlYXNvbnMsIGl0IG1pZ2h0IGJlIGJlc3QgdG8gbWVyZ2UgdGhlIHJlc2l6ZSBhbmQgY2VudGVyIGNyb3Agb3BlcmF0aW9ucyBpbnRvIG9uZS5cblxuICAgICAgICAgICAgLy8gYHRoaXMuc2l6ZWAgY29tZXMgaW4gbWFueSBmb3Jtcywgc28gd2UgbmVlZCB0byBoYW5kbGUgdGhlbSBhbGwgaGVyZTpcbiAgICAgICAgICAgIC8vIDEuIGB0aGlzLnNpemVgIGlzIGFuIGludGVnZXIsIGluIHdoaWNoIGNhc2Ugd2UgcmVzaXplIHRoZSBpbWFnZSB0byBiZSBhIHNxdWFyZSBcblxuICAgICAgICAgICAgbGV0IHNob3J0ZXN0X2VkZ2U7XG4gICAgICAgICAgICBsZXQgbG9uZ2VzdF9lZGdlO1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0IGJvdGggZm9ybWF0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHRoaXMuc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBzaG9ydGVzdF9lZGdlID0gdGhpcy5zaXplO1xuICAgICAgICAgICAgICAgIGxvbmdlc3RfZWRnZSA9IHRoaXMuY29uZmlnLm1heF9zaXplID8/IHNob3J0ZXN0X2VkZ2U7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBrbm93biBwcm9wZXJ0aWVzIGZyb20gYHRoaXMuc2l6ZWBcbiAgICAgICAgICAgICAgICBzaG9ydGVzdF9lZGdlID0gdGhpcy5zaXplLnNob3J0ZXN0X2VkZ2U7XG4gICAgICAgICAgICAgICAgbG9uZ2VzdF9lZGdlID0gdGhpcy5zaXplLmxvbmdlc3RfZWRnZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYGxvbmdlc3RfZWRnZWAgYW5kIGBzaG9ydGVzdF9lZGdlYCBhcmUgc2V0LCBtYWludGFpbiBhc3BlY3QgcmF0aW8gYW5kIHJlc2l6ZSB0byBgc2hvcnRlc3RfZWRnZWBcbiAgICAgICAgICAgIC8vIHdoaWxlIGtlZXBpbmcgdGhlIGxhcmdlc3QgZGltZW5zaW9uIDw9IGBsb25nZXN0X2VkZ2VgXG4gICAgICAgICAgICBpZiAoc2hvcnRlc3RfZWRnZSAhPT0gdW5kZWZpbmVkIHx8IGxvbmdlc3RfZWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL29wZW5zb3VyY2VoYWNrZXIuY29tLzIwMTEvMTIvMDEvY2FsY3VsYXRlLWFzcGVjdC1yYXRpby1jb25zZXJ2aW5nLXJlc2l6ZS1mb3ItaW1hZ2VzLWluLWphdmFzY3JpcHQvXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHJlc2l6ZSBzbyB0aGF0IHNob3J0ZXN0IGVkZ2UgaXMgYHRoaXMuc2hvcnRlc3RfZWRnZWAgKHRhcmdldClcbiAgICAgICAgICAgICAgICBjb25zdCBzaG9ydFJlc2l6ZUZhY3RvciA9IHNob3J0ZXN0X2VkZ2UgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IDEgLy8gSWYgYHNob3J0ZXN0X2VkZ2VgIGlzIG5vdCBzZXQsIGRvbid0IHVwc2NhbGVcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1heChzaG9ydGVzdF9lZGdlIC8gc3JjV2lkdGgsIHNob3J0ZXN0X2VkZ2UgLyBzcmNIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3V2lkdGggPSBzcmNXaWR0aCAqIHNob3J0UmVzaXplRmFjdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IHNyY0hlaWdodCAqIHNob3J0UmVzaXplRmFjdG9yO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIG5ldyB3aWR0aCBhbmQgaGVpZ2h0IG1pZ2h0IGJlIGdyZWF0ZXIgdGhhbiBgdGhpcy5sb25nZXN0X2VkZ2VgLCBzb1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvd25zY2FsZSBhZ2FpbiB0byBlbnN1cmUgdGhlIGxhcmdlc3QgZGltZW5zaW9uIGlzIGB0aGlzLmxvbmdlc3RfZWRnZWAgXG4gICAgICAgICAgICAgICAgY29uc3QgbG9uZ1Jlc2l6ZUZhY3RvciA9IGxvbmdlc3RfZWRnZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gMSAvLyBJZiBgbG9uZ2VzdF9lZGdlYCBpcyBub3Qgc2V0LCBkb24ndCBkb3duc2NhbGVcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbihsb25nZXN0X2VkZ2UgLyBuZXdXaWR0aCwgbG9uZ2VzdF9lZGdlIC8gbmV3SGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIC8vIFRvIGF2b2lkIGNlcnRhaW4gZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIGlzc3Vlcywgd2Ugcm91bmQgdG8gMyBkZWNpbWFsIHBsYWNlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsV2lkdGggPSBNYXRoLmZsb29yKE51bWJlcigobmV3V2lkdGggKiBsb25nUmVzaXplRmFjdG9yKS50b1ByZWNpc2lvbigzKSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsSGVpZ2h0ID0gTWF0aC5mbG9vcihOdW1iZXIoKG5ld0hlaWdodCAqIGxvbmdSZXNpemVGYWN0b3IpLnRvUHJlY2lzaW9uKDMpKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIHJlc2l6ZVxuICAgICAgICAgICAgICAgIGltYWdlID0gYXdhaXQgaW1hZ2UucmVzaXplKGZpbmFsV2lkdGgsIGZpbmFsSGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2FtcGxlOiB0aGlzLnJlc2FtcGxlLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2l6ZS53aWR0aCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2l6ZS5oZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGB3aWR0aGAgYW5kIGBoZWlnaHRgIGFyZSBzZXQsIHJlc2l6ZSB0byB0aG9zZSBkaW1lbnNpb25zXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBhd2FpdCBpbWFnZS5yZXNpemUodGhpcy5zaXplLndpZHRoLCB0aGlzLnNpemUuaGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2FtcGxlOiB0aGlzLnJlc2FtcGxlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZXNpemUgaW1hZ2UgZHVlIHRvIHVuc3VwcG9ydGVkIFxcYHRoaXMuc2l6ZVxcYCBvcHRpb24gaW4gY29uZmlnOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuc2l6ZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kb19jZW50ZXJfY3JvcCkge1xuXG4gICAgICAgICAgICBsZXQgY3JvcF93aWR0aDtcbiAgICAgICAgICAgIGxldCBjcm9wX2hlaWdodDtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHRoaXMuY3JvcF9zaXplKSkge1xuICAgICAgICAgICAgICAgIGNyb3Bfd2lkdGggPSB0aGlzLmNyb3Bfc2l6ZTtcbiAgICAgICAgICAgICAgICBjcm9wX2hlaWdodCA9IHRoaXMuY3JvcF9zaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcm9wX3dpZHRoID0gdGhpcy5jcm9wX3NpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgY3JvcF9oZWlnaHQgPSB0aGlzLmNyb3Bfc2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGltYWdlID0gYXdhaXQgaW1hZ2UuY2VudGVyX2Nyb3AoY3JvcF93aWR0aCwgY3JvcF9oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc2hhcGVkX2lucHV0X3NpemUgPSBbaW1hZ2UuaGVpZ2h0LCBpbWFnZS53aWR0aF07XG5cbiAgICAgICAgLy8gVE9ETyBpcyBpdCBva2F5IHRvIHBhZCBiZWZvcmUgcmVzY2FsaW5nL25vcm1hbGl6aW5nP1xuICAgICAgICBpZiAodGhpcy5kb19wYWQpIHtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gMDtcbiAgICAgICAgICAgIGxldCByaWdodCA9IHRoaXMucGFkX3NpemUud2lkdGggLSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgIGxldCB0b3AgPSAwO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IHRoaXMucGFkX3NpemUuaGVpZ2h0IC0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpbWFnZSA9IGF3YWl0IGltYWdlLnBhZChbbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwaXhlbERhdGEgPSBGbG9hdDMyQXJyYXkuZnJvbShpbWFnZS5kYXRhKTtcblxuICAgICAgICBpZiAodGhpcy5kb19yZXNjYWxlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpeGVsRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHBpeGVsRGF0YVtpXSA9IHRoaXMucmVzY2FsZV9mYWN0b3IgKiBwaXhlbERhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kb19ub3JtYWxpemUpIHtcbiAgICAgICAgICAgIGxldCBpbWFnZV9tZWFuID0gdGhpcy5pbWFnZV9tZWFuO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuaW1hZ2VfbWVhbikpIHtcbiAgICAgICAgICAgICAgICBpbWFnZV9tZWFuID0gbmV3IEFycmF5KGltYWdlLmNoYW5uZWxzKS5maWxsKGltYWdlX21lYW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaW1hZ2Vfc3RkID0gdGhpcy5pbWFnZV9zdGQ7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5pbWFnZV9zdGQpKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2Vfc3RkID0gbmV3IEFycmF5KGltYWdlLmNoYW5uZWxzKS5maWxsKGltYWdlX21lYW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW1hZ2VfbWVhbi5sZW5ndGggIT09IGltYWdlLmNoYW5uZWxzIHx8IGltYWdlX3N0ZC5sZW5ndGggIT09IGltYWdlLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaGVuIHNldCB0byBhcnJheXMsIHRoZSBsZW5ndGggb2YgXFxgaW1hZ2VfbWVhblxcYCAoJHtpbWFnZV9tZWFuLmxlbmd0aH0pIGFuZCBcXGBpbWFnZV9zdGRcXGAgKCR7aW1hZ2Vfc3RkLmxlbmd0aH0pIG11c3QgbWF0Y2ggdGhlIG51bWJlciBvZiBjaGFubmVscyBpbiB0aGUgaW1hZ2UgKCR7aW1hZ2UuY2hhbm5lbHN9KS5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXhlbERhdGEubGVuZ3RoOyBpICs9IGltYWdlLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbWFnZS5jaGFubmVsczsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsRGF0YVtpICsgal0gPSAocGl4ZWxEYXRhW2kgKyBqXSAtIHRoaXMuaW1hZ2VfbWVhbltqXSkgLyB0aGlzLmltYWdlX3N0ZFtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb252ZXJ0IHRvIGNoYW5uZWwgZGltZW5zaW9uIGZvcm1hdDpcbiAgICAgICAgbGV0IGltZ0RpbXMgPSBbaW1hZ2UuaGVpZ2h0LCBpbWFnZS53aWR0aCwgaW1hZ2UuY2hhbm5lbHNdO1xuICAgICAgICBsZXQgaW1nID0gbmV3IFRlbnNvcignZmxvYXQzMicsIHBpeGVsRGF0YSwgaW1nRGltcyk7XG4gICAgICAgIGxldCB0cmFuc3Bvc2VkID0gdHJhbnNwb3NlKGltZywgWzIsIDAsIDFdKTsgLy8gaHdjIC0+IGNod1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnaW5hbF9zaXplOiBbc3JjSGVpZ2h0LCBzcmNXaWR0aF0sXG4gICAgICAgICAgICByZXNoYXBlZF9pbnB1dF9zaXplOiByZXNoYXBlZF9pbnB1dF9zaXplLFxuICAgICAgICAgICAgcGl4ZWxfdmFsdWVzOiB0cmFuc3Bvc2VkLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGZlYXR1cmUgZXh0cmFjdGlvbiBwcm9jZXNzIG9uIGFuIGFycmF5IG9mIGltYWdlXG4gICAgICogVVJMcywgcHJlcHJvY2Vzc2VzIGVhY2ggaW1hZ2UsIGFuZCBjb25jYXRlbmF0ZXMgdGhlIHJlc3VsdGluZ1xuICAgICAqIGZlYXR1cmVzIGludG8gYSBzaW5nbGUgVGVuc29yLlxuICAgICAqIEBwYXJhbSB7YW55fSBpbWFnZXMgVGhlIFVSTChzKSBvZiB0aGUgaW1hZ2UocykgdG8gZXh0cmFjdCBmZWF0dXJlcyBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcGl4ZWwgdmFsdWVzIChhbmQgb3RoZXIgbWV0YWRhdGEpIG9mIHRoZSBwcmVwcm9jZXNzZWQgaW1hZ2VzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGltYWdlcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW1hZ2VzKSkge1xuICAgICAgICAgICAgaW1hZ2VzID0gW2ltYWdlc107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW1hZ2VEYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwoaW1hZ2VzLm1hcCh4ID0+IHRoaXMucHJlcHJvY2Vzcyh4KSkpO1xuXG4gICAgICAgIC8vIFRPRE86XG5cbiAgICAgICAgLy8gQ29uY2F0ZW5hdGUgcGl4ZWwgdmFsdWVzXG4gICAgICAgIC8vIFRFTVA6IEFkZCBiYXRjaCBkaW1lbnNpb24gc28gdGhhdCBjb25jYXQgd29ya3NcbiAgICAgICAgaW1hZ2VEYXRhLmZvckVhY2goeCA9PiB4LnBpeGVsX3ZhbHVlcy5kaW1zID0gWzEsIC4uLngucGl4ZWxfdmFsdWVzLmRpbXNdKTtcbiAgICAgICAgbGV0IHBpeGVsX3ZhbHVlcyA9IGNhdChpbWFnZURhdGEubWFwKHggPT4geC5waXhlbF92YWx1ZXMpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGl4ZWxfdmFsdWVzOiBwaXhlbF92YWx1ZXMsXG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIHNpemVzIG9mIGltYWdlc1xuICAgICAgICAgICAgb3JpZ2luYWxfc2l6ZXM6IGltYWdlRGF0YS5tYXAoeCA9PiB4Lm9yaWdpbmFsX3NpemUpLFxuXG4gICAgICAgICAgICAvLyBSZXNoYXBlZCBzaXplcyBvZiBpbWFnZXMsIGJlZm9yZSBwYWRkaW5nIG9yIGNyb3BwaW5nXG4gICAgICAgICAgICByZXNoYXBlZF9pbnB1dF9zaXplczogaW1hZ2VEYXRhLm1hcCh4ID0+IHgucmVzaGFwZWRfaW5wdXRfc2l6ZSksXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IGNsYXNzIFZpVEZlYXR1cmVFeHRyYWN0b3IgZXh0ZW5kcyBJbWFnZUZlYXR1cmVFeHRyYWN0b3IgeyB9XG5leHBvcnQgY2xhc3MgTW9iaWxlVmlURmVhdHVyZUV4dHJhY3RvciBleHRlbmRzIEltYWdlRmVhdHVyZUV4dHJhY3RvciB7IH1cblxuLyoqXG4gKiBEZXRyIEZlYXR1cmUgRXh0cmFjdG9yLlxuICpcbiAqIEBleHRlbmRzIEltYWdlRmVhdHVyZUV4dHJhY3RvclxuICovXG5leHBvcnQgY2xhc3MgRGV0ckZlYXR1cmVFeHRyYWN0b3IgZXh0ZW5kcyBJbWFnZUZlYXR1cmVFeHRyYWN0b3Ige1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBmZWF0dXJlIGV4dHJhY3Rpb24gcHJvY2VzcyBvbiBhbiBhcnJheSBvZiBpbWFnZVxuICAgICAqIFVSTHMsIHByZXByb2Nlc3NlcyBlYWNoIGltYWdlLCBhbmQgY29uY2F0ZW5hdGVzIHRoZSByZXN1bHRpbmdcbiAgICAgKiBmZWF0dXJlcyBpbnRvIGEgc2luZ2xlIFRlbnNvci5cbiAgICAgKiBAcGFyYW0ge2FueX0gdXJscyBUaGUgVVJMKHMpIG9mIHRoZSBpbWFnZShzKSB0byBleHRyYWN0IGZlYXR1cmVzIGZyb20uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCBwaXhlbCB2YWx1ZXMgb2YgdGhlIHByZXByb2Nlc3NlZCBpbWFnZXMuXG4gICAgICovXG4gICAgYXN5bmMgX2NhbGwodXJscykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3VwZXIuX2NhbGwodXJscyk7XG5cbiAgICAgICAgLy8gVE9ETyBzdXBwb3J0IGRpZmZlcmVudGx5LXNpemVkIGltYWdlcywgZm9yIG5vdyBhc3N1bWUgYWxsIGltYWdlcyBhcmUgdGhlIHNhbWUgc2l6ZS5cbiAgICAgICAgLy8gVE9ETyBzdXBwb3J0IGRpZmZlcmVudCBtYXNrIHNpemVzIChub3QganVzdCA2NHg2NClcbiAgICAgICAgLy8gQ3VycmVudGx5LCBqdXN0IGZpbGwgcGl4ZWwgbWFzayB3aXRoIDFzXG4gICAgICAgIGxldCBtYXNrU2l6ZSA9IFtyZXN1bHQucGl4ZWxfdmFsdWVzLmRpbXNbMF0sIDY0LCA2NF07XG4gICAgICAgIHJlc3VsdC5waXhlbF9tYXNrID0gbmV3IFRlbnNvcihcbiAgICAgICAgICAgICdpbnQ2NCcsXG4gICAgICAgICAgICAvLyBUT0RPOiBmaXggZXJyb3IgYmVsb3dcbiAgICAgICAgICAgIG5ldyBCaWdJbnQ2NEFycmF5KG1hc2tTaXplLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpKS5maWxsKDFuKSxcbiAgICAgICAgICAgIG1hc2tTaXplXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhcnIgVGhlIFVSTChzKSBvZiB0aGUgaW1hZ2UocykgdG8gZXh0cmFjdCBmZWF0dXJlcyBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCBwaXhlbCB2YWx1ZXMgb2YgdGhlIHByZXByb2Nlc3NlZCBpbWFnZXMuXG4gICAgICovXG4gICAgY2VudGVyX3RvX2Nvcm5lcnNfZm9ybWF0KFtjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0XSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY2VudGVyWCAtIHdpZHRoIC8gMixcbiAgICAgICAgICAgIGNlbnRlclkgLSBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgY2VudGVyWCArIHdpZHRoIC8gMixcbiAgICAgICAgICAgIGNlbnRlclkgKyBoZWlnaHQgLyAyXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zdC1wcm9jZXNzZXMgdGhlIG91dHB1dHMgb2YgdGhlIG1vZGVsIChmb3Igb2JqZWN0IGRldGVjdGlvbikuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG91dHB1dHMgVGhlIG91dHB1dHMgb2YgdGhlIG1vZGVsIHRoYXQgbXVzdCBiZSBwb3N0LXByb2Nlc3NlZFxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBvdXRwdXRzLmxvZ2l0cyBUaGUgbG9naXRzXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG91dHB1dHMucHJlZF9ib3hlcyBUaGUgcHJlZGljdGVkIGJveGVzLlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHBvc3QtcHJvY2Vzc2VkIG91dHB1dHMuXG4gICAgICovXG4gICAgcG9zdF9wcm9jZXNzX29iamVjdF9kZXRlY3Rpb24ob3V0cHV0cywgdGhyZXNob2xkID0gMC41LCB0YXJnZXRfc2l6ZXMgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG91dF9sb2dpdHMgPSBvdXRwdXRzLmxvZ2l0cztcbiAgICAgICAgY29uc3Qgb3V0X2Jib3ggPSBvdXRwdXRzLnByZWRfYm94ZXM7XG4gICAgICAgIGNvbnN0IFtiYXRjaF9zaXplLCBudW1fYm94ZXMsIG51bV9jbGFzc2VzXSA9IG91dF9sb2dpdHMuZGltcztcblxuICAgICAgICBpZiAodGFyZ2V0X3NpemVzICE9PSBudWxsICYmIHRhcmdldF9zaXplcy5sZW5ndGggIT09IGJhdGNoX3NpemUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiTWFrZSBzdXJlIHRoYXQgeW91IHBhc3MgaW4gYXMgbWFueSB0YXJnZXQgc2l6ZXMgYXMgdGhlIGJhdGNoIGRpbWVuc2lvbiBvZiB0aGUgbG9naXRzXCIpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hfc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0X3NpemUgPSB0YXJnZXRfc2l6ZXMgIT09IG51bGwgPyB0YXJnZXRfc2l6ZXNbaV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IGluZm8gPSB7XG4gICAgICAgICAgICAgICAgYm94ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNsYXNzZXM6IFtdLFxuICAgICAgICAgICAgICAgIHNjb3JlczogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBsb2dpdHMgPSBvdXRfbG9naXRzW2ldO1xuICAgICAgICAgICAgbGV0IGJib3ggPSBvdXRfYmJveFtpXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1fYm94ZXM7ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBsb2dpdCA9IGxvZ2l0c1tqXTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBtb3N0IHByb2JhYmxlIGNsYXNzXG4gICAgICAgICAgICAgICAgbGV0IG1heEluZGV4ID0gbWF4KGxvZ2l0LmRhdGEpWzFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1heEluZGV4ID09PSBudW1fY2xhc3NlcyAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgYmFja2dyb3VuZCBjbGFzcywgc2tpcCBpdFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHNvZnRtYXggb3ZlciBjbGFzc2VzXG4gICAgICAgICAgICAgICAgbGV0IHByb2JzID0gc29mdG1heChsb2dpdC5kYXRhKTtcblxuICAgICAgICAgICAgICAgIGxldCBzY29yZSA9IHByb2JzW21heEluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU29tZSBjbGFzcyBoYXMgYSBoaWdoIGVub3VnaCBwcm9iYWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcltdfSAqL1xuICAgICAgICAgICAgICAgICAgICBsZXQgYm94ID0gYmJveFtqXS5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gW3gwLCB5MCwgeDEsIHkxXSBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgYm94ID0gdGhpcy5jZW50ZXJfdG9fY29ybmVyc19mb3JtYXQoYm94KVxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0X3NpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveCA9IGJveC5tYXAoKHgsIGkpID0+IHggKiB0YXJnZXRfc2l6ZVsoaSArIDEpICUgMl0pXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpbmZvLmJveGVzLnB1c2goYm94KTtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5jbGFzc2VzLnB1c2gobWF4SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnNjb3Jlcy5wdXNoKHNjb3JlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKGluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5hcml6ZSB0aGUgZ2l2ZW4gbWFza3MgdXNpbmcgYG9iamVjdF9tYXNrX3RocmVzaG9sZGAsIGl0IHJldHVybnMgdGhlIGFzc29jaWF0ZWQgdmFsdWVzIG9mIGBtYXNrc2AsIGBzY29yZXNgIGFuZCBgbGFiZWxzYC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gY2xhc3NfbG9naXRzIFRoZSBjbGFzcyBsb2dpdHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IG1hc2tfbG9naXRzIFRoZSBtYXNrIGxvZ2l0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2JqZWN0X21hc2tfdGhyZXNob2xkIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSB1c2VkIHRvIGJpbmFyaXplIHRoZSBtYXNrcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtX2xhYmVscyBUaGUgbnVtYmVyIG9mIGxhYmVscy5cbiAgICAgKiBAcmV0dXJucyB7W1RlbnNvcltdLCBudW1iZXJbXSwgbnVtYmVyW11dfSBUaGUgYmluYXJpemVkIG1hc2tzLCB0aGUgc2NvcmVzLCBhbmQgdGhlIGxhYmVscy5cbiAgICAgKi9cbiAgICByZW1vdmVfbG93X2FuZF9ub19vYmplY3RzKGNsYXNzX2xvZ2l0cywgbWFza19sb2dpdHMsIG9iamVjdF9tYXNrX3RocmVzaG9sZCwgbnVtX2xhYmVscykge1xuXG4gICAgICAgIGxldCBtYXNrX3Byb2JzX2l0ZW0gPSBbXTtcbiAgICAgICAgbGV0IHByZWRfc2NvcmVzX2l0ZW0gPSBbXTtcbiAgICAgICAgbGV0IHByZWRfbGFiZWxzX2l0ZW0gPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNsYXNzX2xvZ2l0cy5kaW1zWzBdOyArK2opIHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBjbGFzc19sb2dpdHNbal07XG4gICAgICAgICAgICBsZXQgbWFzayA9IG1hc2tfbG9naXRzW2pdO1xuXG4gICAgICAgICAgICBsZXQgcHJlZF9sYWJlbCA9IG1heChjbHMuZGF0YSlbMV07XG4gICAgICAgICAgICBpZiAocHJlZF9sYWJlbCA9PT0gbnVtX2xhYmVscykge1xuICAgICAgICAgICAgICAgIC8vIElzIHRoZSBiYWNrZ3JvdW5kLCBzbyB3ZSBpZ25vcmUgaXRcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHNjb3JlcyA9IHNvZnRtYXgoY2xzLmRhdGEpO1xuICAgICAgICAgICAgbGV0IHByZWRfc2NvcmUgPSBzY29yZXNbcHJlZF9sYWJlbF07XG4gICAgICAgICAgICBpZiAocHJlZF9zY29yZSA+IG9iamVjdF9tYXNrX3RocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIG1hc2tfcHJvYnNfaXRlbS5wdXNoKG1hc2spO1xuICAgICAgICAgICAgICAgIHByZWRfc2NvcmVzX2l0ZW0ucHVzaChwcmVkX3Njb3JlKTtcbiAgICAgICAgICAgICAgICBwcmVkX2xhYmVsc19pdGVtLnB1c2gocHJlZF9sYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21hc2tfcHJvYnNfaXRlbSwgcHJlZF9zY29yZXNfaXRlbSwgcHJlZF9sYWJlbHNfaXRlbV07XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgc2VnbWVudCBpcyB2YWxpZCBvciBub3QuXG4gICAgICogQHBhcmFtIHtJbnQzMkFycmF5fSBtYXNrX2xhYmVscyBMYWJlbHMgZm9yIGVhY2ggcGl4ZWwgaW4gdGhlIG1hc2suXG4gICAgICogQHBhcmFtIHtUZW5zb3JbXX0gbWFza19wcm9icyBQcm9iYWJpbGl0aWVzIGZvciBlYWNoIHBpeGVsIGluIHRoZSBtYXNrcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gayBUaGUgY2xhc3MgaWQgb2YgdGhlIHNlZ21lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1hc2tfdGhyZXNob2xkIFRoZSBtYXNrIHRocmVzaG9sZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkIFRoZSBvdmVybGFwIG1hc2sgYXJlYSB0aHJlc2hvbGQuXG4gICAgICogQHJldHVybnMge1tib29sZWFuLCBudW1iZXJbXV19IFdoZXRoZXIgdGhlIHNlZ21lbnQgaXMgdmFsaWQgb3Igbm90LCBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHZhbGlkIGxhYmVscy5cbiAgICAgKi9cbiAgICBjaGVja19zZWdtZW50X3ZhbGlkaXR5KFxuICAgICAgICBtYXNrX2xhYmVscyxcbiAgICAgICAgbWFza19wcm9icyxcbiAgICAgICAgayxcbiAgICAgICAgbWFza190aHJlc2hvbGQgPSAwLjUsXG4gICAgICAgIG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZCA9IDAuOFxuICAgICkge1xuICAgICAgICAvLyBtYXNrX2sgaXMgYSAxRCBhcnJheSBvZiBpbmRpY2VzLCBpbmRpY2F0aW5nIHdoZXJlIHRoZSBtYXNrIGlzIGVxdWFsIHRvIGtcbiAgICAgICAgbGV0IG1hc2tfayA9IFtdO1xuICAgICAgICBsZXQgbWFza19rX2FyZWEgPSAwO1xuICAgICAgICBsZXQgb3JpZ2luYWxfYXJlYSA9IDA7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgYXJlYSBvZiBhbGwgdGhlIHN0dWZmIGluIHF1ZXJ5IGtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXNrX2xhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1hc2tfbGFiZWxzW2ldID09PSBrKSB7XG4gICAgICAgICAgICAgICAgbWFza19rLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgKyttYXNrX2tfYXJlYTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hc2tfcHJvYnNba10uZGF0YVtpXSA+PSBtYXNrX3RocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICsrb3JpZ2luYWxfYXJlYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFza19leGlzdHMgPSBtYXNrX2tfYXJlYSA+IDAgJiYgb3JpZ2luYWxfYXJlYSA+IDA7XG5cbiAgICAgICAgLy8gRWxpbWluYXRlIGRpc2Nvbm5lY3RlZCB0aW55IHNlZ21lbnRzXG4gICAgICAgIGlmIChtYXNrX2V4aXN0cykge1xuICAgICAgICAgICAgLy8gUGVyZm9ybSBhZGRpdGlvbmFsIGNoZWNrXG4gICAgICAgICAgICBsZXQgYXJlYV9yYXRpbyA9IG1hc2tfa19hcmVhIC8gb3JpZ2luYWxfYXJlYTtcbiAgICAgICAgICAgIG1hc2tfZXhpc3RzID0gYXJlYV9yYXRpbyA+IG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbWFza19leGlzdHMsIG1hc2tfa11cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc2VnbWVudHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3JbXX0gbWFza19wcm9icyBUaGUgbWFzayBwcm9iYWJpbGl0aWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHByZWRfc2NvcmVzIFRoZSBwcmVkaWN0ZWQgc2NvcmVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHByZWRfbGFiZWxzIFRoZSBwcmVkaWN0ZWQgbGFiZWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNrX3RocmVzaG9sZCBUaGUgbWFzayB0aHJlc2hvbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZCBUaGUgb3ZlcmxhcCBtYXNrIGFyZWEgdGhyZXNob2xkLlxuICAgICAqIEBwYXJhbSB7U2V0PG51bWJlcj59IGxhYmVsX2lkc190b19mdXNlIFRoZSBsYWJlbCBpZHMgdG8gZnVzZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0YXJnZXRfc2l6ZSBUaGUgdGFyZ2V0IHNpemUgb2YgdGhlIGltYWdlLlxuICAgICAqIEByZXR1cm5zIHtbVGVuc29yLCBBcnJheTx7aWQ6IG51bWJlciwgbGFiZWxfaWQ6IG51bWJlciwgc2NvcmU6IG51bWJlcn0+XX0gVGhlIGNvbXB1dGVkIHNlZ21lbnRzLlxuICAgICAqL1xuICAgIGNvbXB1dGVfc2VnbWVudHMoXG4gICAgICAgIG1hc2tfcHJvYnMsXG4gICAgICAgIHByZWRfc2NvcmVzLFxuICAgICAgICBwcmVkX2xhYmVscyxcbiAgICAgICAgbWFza190aHJlc2hvbGQsXG4gICAgICAgIG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZCxcbiAgICAgICAgbGFiZWxfaWRzX3RvX2Z1c2UgPSBudWxsLFxuICAgICAgICB0YXJnZXRfc2l6ZSA9IG51bGwsXG4gICAgKSB7XG4gICAgICAgIGxldCBbaGVpZ2h0LCB3aWR0aF0gPSB0YXJnZXRfc2l6ZSA/PyBtYXNrX3Byb2JzWzBdLmRpbXM7XG5cbiAgICAgICAgbGV0IHNlZ21lbnRhdGlvbiA9IG5ldyBUZW5zb3IoXG4gICAgICAgICAgICAnaW50MzInLFxuICAgICAgICAgICAgbmV3IEludDMyQXJyYXkoaGVpZ2h0ICogd2lkdGgpLFxuICAgICAgICAgICAgW2hlaWdodCwgd2lkdGhdXG4gICAgICAgICk7XG4gICAgICAgIGxldCBzZWdtZW50cyA9IFtdO1xuXG4gICAgICAgIC8vIDEuIElmIHRhcmdldF9zaXplIGlzIG5vdCBudWxsLCB3ZSBuZWVkIHRvIHJlc2l6ZSB0aGUgbWFza3MgdG8gdGhlIHRhcmdldCBzaXplXG4gICAgICAgIGlmICh0YXJnZXRfc2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gcmVzaXplIHRoZSBtYXNrcyB0byB0aGUgdGFyZ2V0IHNpemVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFza19wcm9icy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIG1hc2tfcHJvYnNbaV0gPSBpbnRlcnBvbGF0ZShtYXNrX3Byb2JzW2ldLCB0YXJnZXRfc2l6ZSwgJ2JpbGluZWFyJywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gV2VpZ2ggZWFjaCBtYXNrIGJ5IGl0cyBwcmVkaWN0aW9uIHNjb3JlXG4gICAgICAgIC8vIE5PVEU6IGBtYXNrX3Byb2JzYCBpcyB1cGRhdGVkIGluLXBsYWNlXG4gICAgICAgIC8vIFxuICAgICAgICAvLyBUZW1wb3Jhcnkgc3RvcmFnZSBmb3IgdGhlIGJlc3QgbGFiZWwvc2NvcmVzIGZvciBlYWNoIHBpeGVsIChbaGVpZ2h0LCB3aWR0aF0pOlxuICAgICAgICBsZXQgbWFza19sYWJlbHMgPSBuZXcgSW50MzJBcnJheShtYXNrX3Byb2JzWzBdLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgbGV0IGJlc3RTY29yZXMgPSBuZXcgRmxvYXQzMkFycmF5KG1hc2tfcHJvYnNbMF0uZGF0YS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFza19wcm9icy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IHNjb3JlID0gcHJlZF9zY29yZXNbaV07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWFza19wcm9ic1tpXS5kYXRhLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgbWFza19wcm9ic1tpXS5kYXRhW2pdICo9IHNjb3JlXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tfcHJvYnNbaV0uZGF0YVtqXSA+IGJlc3RTY29yZXNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWFza19sYWJlbHNbal0gPSBpO1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2NvcmVzW2pdID0gbWFza19wcm9ic1tpXS5kYXRhW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjdXJyZW50X3NlZ21lbnRfaWQgPSAwO1xuXG4gICAgICAgIC8vIGxldCBzdHVmZl9tZW1vcnlfbGlzdCA9IHt9XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcHJlZF9sYWJlbHMubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgIGxldCBwcmVkX2NsYXNzID0gcHJlZF9sYWJlbHNba107XG5cbiAgICAgICAgICAgIC8vIFRPRE8gYWRkIGBzaG91bGRfZnVzZWBcbiAgICAgICAgICAgIC8vIGxldCBzaG91bGRfZnVzZSA9IHByZWRfY2xhc3MgaW4gbGFiZWxfaWRzX3RvX2Z1c2VcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbWFzayBleGlzdHMgYW5kIGxhcmdlIGVub3VnaCB0byBiZSBhIHNlZ21lbnRcbiAgICAgICAgICAgIGxldCBbbWFza19leGlzdHMsIG1hc2tfa10gPSB0aGlzLmNoZWNrX3NlZ21lbnRfdmFsaWRpdHkoXG4gICAgICAgICAgICAgICAgbWFza19sYWJlbHMsXG4gICAgICAgICAgICAgICAgbWFza19wcm9icyxcbiAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgIG1hc2tfdGhyZXNob2xkLFxuICAgICAgICAgICAgICAgIG92ZXJsYXBfbWFza19hcmVhX3RocmVzaG9sZFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBpZiAoIW1hc2tfZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBzZWUgaGVyZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyBpZiAocHJlZF9jbGFzcyBpbiBzdHVmZl9tZW1vcnlfbGlzdCkge1xuICAgICAgICAgICAgLy8gICAgIGN1cnJlbnRfc2VnbWVudF9pZCA9IHN0dWZmX21lbW9yeV9saXN0W3ByZWRfY2xhc3NdXG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIGN1cnJlbnRfc2VnbWVudF9pZCArPSAxO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgKytjdXJyZW50X3NlZ21lbnRfaWQ7XG5cblxuICAgICAgICAgICAgLy8gQWRkIGN1cnJlbnQgb2JqZWN0IHNlZ21lbnQgdG8gZmluYWwgc2VnbWVudGF0aW9uIG1hcFxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggb2YgbWFza19rKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudGF0aW9uLmRhdGFbaW5kZXhdID0gY3VycmVudF9zZWdtZW50X2lkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogY3VycmVudF9zZWdtZW50X2lkLFxuICAgICAgICAgICAgICAgIGxhYmVsX2lkOiBwcmVkX2NsYXNzLFxuICAgICAgICAgICAgICAgIC8vIHdhc19mdXNlZDogc2hvdWxkX2Z1c2UsIFRPRE9cbiAgICAgICAgICAgICAgICBzY29yZTogcHJlZF9zY29yZXNba10sXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAvLyBpZihzaG91bGRfZnVzZSl7XG4gICAgICAgICAgICAvLyAgICAgc3R1ZmZfbWVtb3J5X2xpc3RbcHJlZF9jbGFzc10gPSBjdXJyZW50X3NlZ21lbnRfaWRcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbc2VnbWVudGF0aW9uLCBzZWdtZW50c107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zdC1wcm9jZXNzIHRoZSBtb2RlbCBvdXRwdXQgdG8gZ2VuZXJhdGUgdGhlIGZpbmFsIHBhbm9wdGljIHNlZ21lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IG91dHB1dHMgVGhlIG1vZGVsIG91dHB1dCB0byBwb3N0IHByb2Nlc3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RocmVzaG9sZD0wLjVdIFRoZSBwcm9iYWJpbGl0eSBzY29yZSB0aHJlc2hvbGQgdG8ga2VlcCBwcmVkaWN0ZWQgaW5zdGFuY2UgbWFza3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXNrX3RocmVzaG9sZD0wLjVdIFRocmVzaG9sZCB0byB1c2Ugd2hlbiB0dXJuaW5nIHRoZSBwcmVkaWN0ZWQgbWFza3MgaW50byBiaW5hcnkgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkPTAuOF0gVGhlIG92ZXJsYXAgbWFzayBhcmVhIHRocmVzaG9sZCB0byBtZXJnZSBvciBkaXNjYXJkIHNtYWxsIGRpc2Nvbm5lY3RlZCBwYXJ0cyB3aXRoaW4gZWFjaCBiaW5hcnkgaW5zdGFuY2UgbWFzay5cbiAgICAgKiBAcGFyYW0ge1NldDxudW1iZXI+fSBbbGFiZWxfaWRzX3RvX2Z1c2U9bnVsbF0gVGhlIGxhYmVscyBpbiB0aGlzIHN0YXRlIHdpbGwgaGF2ZSBhbGwgdGhlaXIgaW5zdGFuY2VzIGJlIGZ1c2VkIHRvZ2V0aGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gW3RhcmdldF9zaXplcz1udWxsXSBUaGUgdGFyZ2V0IHNpemVzIHRvIHJlc2l6ZSB0aGUgbWFza3MgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5PHsgc2VnbWVudGF0aW9uOiBUZW5zb3IsIHNlZ21lbnRzX2luZm86IEFycmF5PHtpZDogbnVtYmVyLCBsYWJlbF9pZDogbnVtYmVyLCBzY29yZTogbnVtYmVyfT59Pn1cbiAgICAgKi9cbiAgICBwb3N0X3Byb2Nlc3NfcGFub3B0aWNfc2VnbWVudGF0aW9uKFxuICAgICAgICBvdXRwdXRzLFxuICAgICAgICB0aHJlc2hvbGQgPSAwLjUsXG4gICAgICAgIG1hc2tfdGhyZXNob2xkID0gMC41LFxuICAgICAgICBvdmVybGFwX21hc2tfYXJlYV90aHJlc2hvbGQgPSAwLjgsXG4gICAgICAgIGxhYmVsX2lkc190b19mdXNlID0gbnVsbCxcbiAgICAgICAgdGFyZ2V0X3NpemVzID0gbnVsbCxcbiAgICApIHtcbiAgICAgICAgaWYgKGxhYmVsX2lkc190b19mdXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJgbGFiZWxfaWRzX3RvX2Z1c2VgIHVuc2V0LiBObyBpbnN0YW5jZSB3aWxsIGJlIGZ1c2VkLlwiKVxuICAgICAgICAgICAgbGFiZWxfaWRzX3RvX2Z1c2UgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbGFzc19xdWVyaWVzX2xvZ2l0cyA9IG91dHB1dHMubG9naXRzOyAvLyBbYmF0Y2hfc2l6ZSwgbnVtX3F1ZXJpZXMsIG51bV9jbGFzc2VzKzFdXG4gICAgICAgIGNvbnN0IG1hc2tzX3F1ZXJpZXNfbG9naXRzID0gb3V0cHV0cy5wcmVkX21hc2tzOyAvLyBbYmF0Y2hfc2l6ZSwgbnVtX3F1ZXJpZXMsIGhlaWdodCwgd2lkdGhdXG5cbiAgICAgICAgY29uc3QgbWFza19wcm9icyA9IG1hc2tzX3F1ZXJpZXNfbG9naXRzLnNpZ21vaWQoKSAgLy8gW2JhdGNoX3NpemUsIG51bV9xdWVyaWVzLCBoZWlnaHQsIHdpZHRoXVxuXG4gICAgICAgIGxldCBbYmF0Y2hfc2l6ZSwgbnVtX3F1ZXJpZXMsIG51bV9sYWJlbHNdID0gY2xhc3NfcXVlcmllc19sb2dpdHMuZGltcztcbiAgICAgICAgbnVtX2xhYmVscyAtPSAxOyAvLyBSZW1vdmUgbGFzdCBjbGFzcyAoYmFja2dyb3VuZClcblxuICAgICAgICBpZiAodGFyZ2V0X3NpemVzICE9PSBudWxsICYmIHRhcmdldF9zaXplcy5sZW5ndGggIT09IGJhdGNoX3NpemUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiTWFrZSBzdXJlIHRoYXQgeW91IHBhc3MgaW4gYXMgbWFueSB0YXJnZXQgc2l6ZXMgYXMgdGhlIGJhdGNoIGRpbWVuc2lvbiBvZiB0aGUgbG9naXRzXCIpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9SZXR1cm4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaF9zaXplOyArK2kpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRfc2l6ZSA9IHRhcmdldF9zaXplcyAhPT0gbnVsbCA/IHRhcmdldF9zaXplc1tpXSA6IG51bGw7XG5cbiAgICAgICAgICAgIGxldCBjbGFzc19sb2dpdHMgPSBjbGFzc19xdWVyaWVzX2xvZ2l0c1tpXTtcbiAgICAgICAgICAgIGxldCBtYXNrX2xvZ2l0cyA9IG1hc2tfcHJvYnNbaV07XG5cbiAgICAgICAgICAgIGxldCBbbWFza19wcm9ic19pdGVtLCBwcmVkX3Njb3Jlc19pdGVtLCBwcmVkX2xhYmVsc19pdGVtXSA9IHRoaXMucmVtb3ZlX2xvd19hbmRfbm9fb2JqZWN0cyhjbGFzc19sb2dpdHMsIG1hc2tfbG9naXRzLCB0aHJlc2hvbGQsIG51bV9sYWJlbHMpO1xuXG4gICAgICAgICAgICBpZiAocHJlZF9sYWJlbHNfaXRlbS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBObyBtYXNrIGZvdW5kXG4gICAgICAgICAgICAgICAgbGV0IFtoZWlnaHQsIHdpZHRoXSA9IHRhcmdldF9zaXplID8/IG1hc2tfbG9naXRzLmRpbXMuc2xpY2UoLTIpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHNlZ21lbnRhdGlvbiA9IG5ldyBUZW5zb3IoXG4gICAgICAgICAgICAgICAgICAgICdpbnQzMicsXG4gICAgICAgICAgICAgICAgICAgIG5ldyBJbnQzMkFycmF5KGhlaWdodCAqIHdpZHRoKS5maWxsKC0xKSxcbiAgICAgICAgICAgICAgICAgICAgW2hlaWdodCwgd2lkdGhdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHRvUmV0dXJuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50YXRpb246IHNlZ21lbnRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHNfaW5mbzogW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyBHZXQgc2VnbWVudGF0aW9uIG1hcCBhbmQgc2VnbWVudCBpbmZvcm1hdGlvbiBvZiBiYXRjaCBpdGVtXG4gICAgICAgICAgICBsZXQgW3NlZ21lbnRhdGlvbiwgc2VnbWVudHNdID0gdGhpcy5jb21wdXRlX3NlZ21lbnRzKFxuICAgICAgICAgICAgICAgIG1hc2tfcHJvYnNfaXRlbSxcbiAgICAgICAgICAgICAgICBwcmVkX3Njb3Jlc19pdGVtLFxuICAgICAgICAgICAgICAgIHByZWRfbGFiZWxzX2l0ZW0sXG4gICAgICAgICAgICAgICAgbWFza190aHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgb3ZlcmxhcF9tYXNrX2FyZWFfdGhyZXNob2xkLFxuICAgICAgICAgICAgICAgIGxhYmVsX2lkc190b19mdXNlLFxuICAgICAgICAgICAgICAgIHRhcmdldF9zaXplLFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWdtZW50YXRpb246IHNlZ21lbnRhdGlvbixcbiAgICAgICAgICAgICAgICBzZWdtZW50c19pbmZvOiBzZWdtZW50c1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICB9XG5cbiAgICBwb3N0X3Byb2Nlc3NfaW5zdGFuY2Vfc2VnbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHRocm93IEVycm9yKFwiTm90IGltcGxlbWVudGVkIHlldFwiKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTYW1JbWFnZVByb2Nlc3NvciBleHRlbmRzIEltYWdlRmVhdHVyZUV4dHJhY3RvciB7XG4gICAgYXN5bmMgX2NhbGwoaW1hZ2VzLCBpbnB1dF9wb2ludHMpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIHBpeGVsX3ZhbHVlcyxcbiAgICAgICAgICAgIG9yaWdpbmFsX3NpemVzLFxuICAgICAgICAgICAgcmVzaGFwZWRfaW5wdXRfc2l6ZXMsXG4gICAgICAgIH0gPSBhd2FpdCBzdXBlci5fY2FsbChpbWFnZXMpO1xuXG4gICAgICAgIGxldCBzaGFwZSA9IGNhbGN1bGF0ZURpbWVuc2lvbnMoaW5wdXRfcG9pbnRzKTtcblxuICAgICAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAvLyBDb3JyZWN0IHVzZXIncyBpbnB1dFxuICAgICAgICAgICAgc2hhcGUgPSBbMSwgLi4uc2hhcGVdO1xuICAgICAgICAgICAgaW5wdXRfcG9pbnRzID0gW2lucHV0X3BvaW50c107XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGUubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBpbnB1dF9wb2ludHMgbXVzdCBiZSBhIDREIHRlbnNvciBvZiBzaGFwZSBgYmF0Y2hfc2l6ZWAsIGBwb2ludF9iYXRjaF9zaXplYCwgYG5iX3BvaW50c19wZXJfaW1hZ2VgLCBgMmAuXCIpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNoYXBlIGlucHV0IHBvaW50c1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0X3BvaW50cy5sZW5ndGg7ICsraSkgeyAvLyBiYXRjaF9zaXplXG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxJbWFnZVNpemUgPSBvcmlnaW5hbF9zaXplc1tpXTtcbiAgICAgICAgICAgIGxldCByZXNoYXBlZEltYWdlU2l6ZSA9IHJlc2hhcGVkX2lucHV0X3NpemVzW2ldO1xuXG4gICAgICAgICAgICBsZXQgcmVzaXplRmFjdG9ycyA9IFtcbiAgICAgICAgICAgICAgICByZXNoYXBlZEltYWdlU2l6ZVswXSAvIG9yaWdpbmFsSW1hZ2VTaXplWzBdLFxuICAgICAgICAgICAgICAgIHJlc2hhcGVkSW1hZ2VTaXplWzFdIC8gb3JpZ2luYWxJbWFnZVNpemVbMV1cbiAgICAgICAgICAgIF1cblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbnB1dF9wb2ludHNbaV0ubGVuZ3RoOyArK2opIHsgLy8gcG9pbnRfYmF0Y2hfc2l6ZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRfcG9pbnRzW2ldW2pdLmxlbmd0aDsgKytrKSB7IC8vIG5iX3BvaW50c19wZXJfaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdyA9IDA7IHcgPCBpbnB1dF9wb2ludHNbaV1bal1ba10ubGVuZ3RoOyArK3cpIHsgLy8gMlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfcG9pbnRzW2ldW2pdW2tdW3ddICo9IHJlc2l6ZUZhY3RvcnNbd107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW5wdXRfcG9pbnRzX3RlbnNvciA9IG5ldyBUZW5zb3IoXG4gICAgICAgICAgICAnaW50NjQnLFxuICAgICAgICAgICAgQmlnSW50NjRBcnJheS5mcm9tKGlucHV0X3BvaW50cy5mbGF0KEluZmluaXR5KVxuICAgICAgICAgICAgICAgIC5tYXAoeCA9PiBCaWdJbnQoTWF0aC5yb3VuZCh4KSkpKSxcbiAgICAgICAgICAgIHNoYXBlXG4gICAgICAgIClcblxuICAgICAgICAvLyBUT0RPOiBhbGxvd2VkIHRvIGJlIGZsb2F0cz9cbiAgICAgICAgLy8gbGV0IGlucHV0X3BvaW50c190ZW5zb3IgPSBuZXcgVGVuc29yKFxuICAgICAgICAvLyAgICAgJ2Zsb2F0MzInLFxuICAgICAgICAvLyAgICAgRmxvYXQzMkFycmF5LmZyb20oaW5wdXRfcG9pbnRzLmZsYXQoSW5maW5pdHkpKSxcbiAgICAgICAgLy8gICAgIHNoYXBlXG4gICAgICAgIC8vIClcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGl4ZWxfdmFsdWVzLFxuICAgICAgICAgICAgb3JpZ2luYWxfc2l6ZXM6IG9yaWdpbmFsX3NpemVzLFxuICAgICAgICAgICAgcmVzaGFwZWRfaW5wdXRfc2l6ZXM6IHJlc2hhcGVkX2lucHV0X3NpemVzLFxuICAgICAgICAgICAgaW5wdXRfcG9pbnRzOiBpbnB1dF9wb2ludHNfdGVuc29yXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgcGFkZGluZyBhbmQgdXBzY2FsZSBtYXNrcyB0byB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZS5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbWFza3MgQmF0Y2hlZCBtYXNrcyBmcm9tIHRoZSBtYXNrX2RlY29kZXIgaW4gKGJhdGNoX3NpemUsIG51bV9jaGFubmVscywgaGVpZ2h0LCB3aWR0aCkgZm9ybWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gb3JpZ2luYWxfc2l6ZXMgVGhlIG9yaWdpbmFsIHNpemVzIG9mIGVhY2ggaW1hZ2UgYmVmb3JlIGl0IHdhcyByZXNpemVkIHRvIHRoZSBtb2RlbCdzIGV4cGVjdGVkIGlucHV0IHNoYXBlLCBpbiAoaGVpZ2h0LCB3aWR0aCkgZm9ybWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gcmVzaGFwZWRfaW5wdXRfc2l6ZXMgVGhlIHNpemUgb2YgZWFjaCBpbWFnZSBhcyBpdCBpcyBmZWQgdG8gdGhlIG1vZGVsLCBpbiAoaGVpZ2h0LCB3aWR0aCkgZm9ybWF0LiBVc2VkIHRvIHJlbW92ZSBwYWRkaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHBvc3QtcHJvY2Vzc2luZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWFza190aHJlc2hvbGRdIFRoZSB0aHJlc2hvbGQgdG8gdXNlIGZvciBiaW5hcml6aW5nIHRoZSBtYXNrcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJpbmFyaXplXSBXaGV0aGVyIHRvIGJpbmFyaXplIHRoZSBtYXNrcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFkX3NpemVdIFRoZSB0YXJnZXQgc2l6ZSB0aGUgaW1hZ2VzIHdlcmUgcGFkZGVkIHRvIGJlZm9yZSBiZWluZyBwYXNzZWQgdG8gdGhlIG1vZGVsLiBJZiBgbnVsbGAsIHRoZSB0YXJnZXQgc2l6ZSBpcyBhc3N1bWVkIHRvIGJlIHRoZSBwcm9jZXNzb3IncyBgcGFkX3NpemVgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wYWRfc2l6ZS5oZWlnaHRdIFRoZSBoZWlnaHQgdGhlIGltYWdlcyB3ZXJlIHBhZGRlZCB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucGFkX3NpemUud2lkdGhdIFRoZSB3aWR0aCB0aGUgaW1hZ2VzIHdlcmUgcGFkZGVkIHRvLlxuICAgICAqIEByZXR1cm5zIHtUZW5zb3JbXX0gQmF0Y2hlZCBtYXNrcyBpbiBiYXRjaF9zaXplLCBudW1fY2hhbm5lbHMsIGhlaWdodCwgd2lkdGgpIGZvcm1hdCwgd2hlcmUgKGhlaWdodCwgd2lkdGgpIGlzIGdpdmVuIGJ5IG9yaWdpbmFsX3NpemUuXG4gICAgICovXG4gICAgcG9zdF9wcm9jZXNzX21hc2tzKG1hc2tzLCBvcmlnaW5hbF9zaXplcywgcmVzaGFwZWRfaW5wdXRfc2l6ZXMsIHtcbiAgICAgICAgbWFza190aHJlc2hvbGQgPSAwLjAsXG4gICAgICAgIGJpbmFyaXplID0gdHJ1ZSxcbiAgICAgICAgcGFkX3NpemUgPSBudWxsLFxuICAgIH0gPSB7fSkge1xuICAgICAgICAvLyBtYXNrczogWzEsIDEsIDMsIDI1NiwgMjU2XVxuXG4gICAgICAgIGxldCBvdXRwdXRfbWFza3MgPSBbXTtcblxuICAgICAgICBwYWRfc2l6ZSA9IHBhZF9zaXplID8/IHRoaXMucGFkX3NpemU7XG5cbiAgICAgICAgbGV0IHRhcmdldF9pbWFnZV9zaXplID0gW3BhZF9zaXplLmhlaWdodCwgcGFkX3NpemUud2lkdGhdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2luYWxfc2l6ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbF9zaXplID0gb3JpZ2luYWxfc2l6ZXNbaV07XG4gICAgICAgICAgICBsZXQgcmVzaGFwZWRfaW5wdXRfc2l6ZSA9IHJlc2hhcGVkX2lucHV0X3NpemVzW2ldO1xuXG4gICAgICAgICAgICBsZXQgbWFzayA9IG1hc2tzW2ldOyAvLyBbYiwgYywgaCwgd11cblxuICAgICAgICAgICAgLy8gVE9ETzogaW1wcm92ZVxuICAgICAgICAgICAgbGV0IGludGVycG9sYXRlZF9tYXNrcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXNrLmRpbXNbMF07ICsraikge1xuICAgICAgICAgICAgICAgIGxldCBtID0gbWFza1tqXTsgLy8gM2QgdGVuc29yXG5cbiAgICAgICAgICAgICAgICAvLyBVcHNjYWxlIG1hc2sgdG8gcGFkZGVkIHNpemVcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJwb2xhdGVkX21hc2sgPSBpbnRlcnBvbGF0ZShtLCB0YXJnZXRfaW1hZ2Vfc2l6ZSwgJ2JpbGluZWFyJywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JvcCBtYXNrXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkX21hc2sgPSBpbnRlcnBvbGF0ZWRfbWFzay5zbGljZShudWxsLCBbMCwgcmVzaGFwZWRfaW5wdXRfc2l6ZVswXV0sIFswLCByZXNoYXBlZF9pbnB1dF9zaXplWzFdXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBEb3duc2NhbGUgbWFza1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlZF9tYXNrID0gaW50ZXJwb2xhdGUobWFzaywgb3JpZ2luYWxfc2l6ZSwgJ2JpbGluZWFyJywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJpbmFyaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlZF9tYXNrID0gbmV3IFRlbnNvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdib29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmZyb20oaW50ZXJwb2xhdGVkX21hc2suZGF0YSkubWFwKHggPT4geCA+IG1hc2tfdGhyZXNob2xkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlZF9tYXNrLmRpbXNcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFkZCBiYWNrIGJhdGNoIGRpbSBmb3IgY29uY2F0XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkX21hc2suZGltcyA9IFsxLCAuLi5pbnRlcnBvbGF0ZWRfbWFzay5kaW1zXTtcblxuICAgICAgICAgICAgICAgIGludGVycG9sYXRlZF9tYXNrcy5wdXNoKGludGVycG9sYXRlZF9tYXNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNvbmNhdGVuYXRlZCA9IGNhdChpbnRlcnBvbGF0ZWRfbWFza3MpO1xuICAgICAgICAgICAgb3V0cHV0X21hc2tzLnB1c2goY29uY2F0ZW5hdGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRfbWFza3M7XG5cbiAgICB9XG59XG5cblxuZXhwb3J0IGNsYXNzIFdoaXNwZXJGZWF0dXJlRXh0cmFjdG9yIGV4dGVuZHMgRmVhdHVyZUV4dHJhY3RvciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICAvLyBQcmVmZXIgZ2l2ZW4gYG1lbF9maWx0ZXJzYCBmcm9tIHByZXByb2Nlc3Nvcl9jb25maWcuanNvbiwgb3IgY2FsY3VsYXRlIHRoZW0gaWYgdGhleSBkb24ndCBleGlzdC5cbiAgICAgICAgdGhpcy5jb25maWcubWVsX2ZpbHRlcnMgPz89IGdldE1lbEZpbHRlcnModGhpcy5jb25maWcuc2FtcGxpbmdfcmF0ZSwgdGhpcy5jb25maWcubl9mZnQsIHRoaXMuY29uZmlnLmZlYXR1cmVfc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGluZGV4IG9mZnNldCBmb3IgYSBnaXZlbiBpbmRleCBhbmQgd2luZG93IHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3IFRoZSB3aW5kb3cgc2l6ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaW5kZXggb2Zmc2V0LlxuICAgICAqL1xuICAgIGNhbGNPZmZzZXQoaSwgdykge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoKGkgKyB3KSAlICgyICogdykgLSB3KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGFuIGFycmF5IHdpdGggYSByZWZsZWN0ZWQgdmVyc2lvbiBvZiBpdHNlbGYgb24gYm90aCBlbmRzLlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IFRoZSBhbW91bnQgb2YgcGFkZGluZyB0byBhZGQgdG8gdGhlIGxlZnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFRoZSBhbW91bnQgb2YgcGFkZGluZyB0byBhZGQgdG8gdGhlIHJpZ2h0LlxuICAgICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9IFRoZSBwYWRkZWQgYXJyYXkuXG4gICAgICovXG4gICAgcGFkUmVmbGVjdChhcnJheSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgY29uc3QgcGFkZGVkID0gbmV3IEZsb2F0MzJBcnJheShhcnJheS5sZW5ndGggKyBsZWZ0ICsgcmlnaHQpO1xuICAgICAgICBjb25zdCB3ID0gYXJyYXkubGVuZ3RoIC0gMTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBwYWRkZWRbbGVmdCArIGldID0gYXJyYXlbaV07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBsZWZ0OyArK2kpIHtcbiAgICAgICAgICAgIHBhZGRlZFtsZWZ0IC0gaV0gPSBhcnJheVt0aGlzLmNhbGNPZmZzZXQoaSwgdyldO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcmlnaHQ7ICsraSkge1xuICAgICAgICAgICAgcGFkZGVkW3cgKyBsZWZ0ICsgaV0gPSBhcnJheVt0aGlzLmNhbGNPZmZzZXQodyAtIGksIHcpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYWRkZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY29tcGxleCBTaG9ydC1UaW1lIEZvdXJpZXIgVHJhbnNmb3JtIChTVEZUKSBvZiB0aGUgZ2l2ZW4gZnJhbWVkIHNpZ25hbC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IGZyYW1lcyBBIDJEIGFycmF5IHJlcHJlc2VudGluZyB0aGUgc2lnbmFsIGZyYW1lcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB3aW5kb3cgQSAxRCBhcnJheSByZXByZXNlbnRpbmcgdGhlIHdpbmRvdyB0byBiZSBhcHBsaWVkIHRvIHRoZSBmcmFtZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqIC0gZGF0YTogQSAxRCBhcnJheSByZXByZXNlbnRpbmcgdGhlIGNvbXBsZXggU1RGVCBvZiB0aGUgc2lnbmFsLlxuICAgICAqIC0gZGltczogQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBTVEZUIGRhdGEsIGkuZS4gW251bV9mcmFtZXMsIG51bV9mZnRfYmluc10uXG4gICAgICovXG4gICAgc3RmdChmcmFtZXMsIHdpbmRvdykge1xuICAgICAgICAvLyBDYWxjdWxhdGVzIHRoZSBjb21wbGV4IFNob3J0LVRpbWUgRm91cmllciBUcmFuc2Zvcm0gKFNURlQpIG9mIHRoZSBnaXZlbiBmcmFtZWQgc2lnbmFsLlxuICAgICAgICAvLyBcbiAgICAgICAgLy8gTk9URTogU2luY2UgdGhlIHdpbmRvdyB3aWR0aCBpcyBub3QgYSBwb3dlciBvZiAyLCB3ZSBtdXN0IFxuICAgICAgICAvLyBwZXJmb3JtIEZhc3QgRm91cmllciBUcmFuc2Zvcm0gd2l0aCBjaGlycC16IHRyYW5zZm9ybTpcbiAgICAgICAgLy8gaHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NzExOC9ub24tcG93ZXItb2YtMi1mZnRzLzc3MTU2Izc3MTU2XG5cbiAgICAgICAgLy8gSGVscGVyIHZhcmlhYmxlc1xuICAgICAgICBjb25zdCBmZnRfc2l6ZSA9IHRoaXMuY29uZmlnLm5fZmZ0O1xuICAgICAgICBjb25zdCBhID0gMiAqIChmZnRfc2l6ZSAtIDEpO1xuICAgICAgICBjb25zdCBiID0gMiAqICgyICogZmZ0X3NpemUgLSAxKTtcbiAgICAgICAgY29uc3QgbmV4dFAyID0gMiAqKiAoTWF0aC5jZWlsKE1hdGgubG9nMihiKSkpXG4gICAgICAgIGNvbnN0IG51bV9mZnRfYmlucyA9IGZmdF9zaXplICsgMjtcblxuICAgICAgICAvLyBQcmVhbGxvY2F0ZSBhcnJheSB0byBzdG9yZSBvdXRwdXRcbiAgICAgICAgLy8gZG91YmxlIHNpbmNlIHdlIHN0b3JlIGNvbXBsZXggbnVtYmVyc1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShudW1fZmZ0X2JpbnMgKiBmcmFtZXMubGVuZ3RoKTtcblxuICAgICAgICAvLyBEZWZpbmUgYnVmZmVyc1xuICAgICAgICAvLyBDb21wdXRlIGNoaXJwIGZvciB0cmFuc2Zvcm1cbiAgICAgICAgY29uc3QgY2hpcnAgPSBuZXcgRmxvYXQzMkFycmF5KGIpO1xuICAgICAgICBjb25zdCBpY2hpcnAgPSBuZXcgRmxvYXQzMkFycmF5KG5leHRQMik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcjEgPSBuZXcgRmxvYXQzMkFycmF5KG5leHRQMik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcjIgPSBuZXcgRmxvYXQzMkFycmF5KG5leHRQMik7XG4gICAgICAgIGNvbnN0IG91dEJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkobmV4dFAyKTtcbiAgICAgICAgY29uc3Qgb3V0QnVmZmVyMiA9IG5ldyBGbG9hdDMyQXJyYXkobmV4dFAyKTtcbiAgICAgICAgY29uc3Qgb3V0QnVmZmVyMyA9IG5ldyBGbG9hdDMyQXJyYXkobmV4dFAyKTtcblxuICAgICAgICAvLyBDb21wdXRlIGNvbXBsZXggZXhwb25lbnRpYXRpb25cbiAgICAgICAgY29uc3QgdGhldGEgPSAtMiAqIE1hdGguUEkgLyBmZnRfc2l6ZTtcbiAgICAgICAgY29uc3QgYmFzZVIgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgIGNvbnN0IGJhc2VJID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICAgIC8vIFByZWNvbXB1dGUgaGVscGVyIGZvciBjaGlycC16IHRyYW5zZm9ybVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIgPj4gMTsgKytpKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIGNvbXBsZXggcG93ZXI6XG4gICAgICAgICAgICBjb25zdCBlID0gKGkgKyAxIC0gZmZ0X3NpemUpICoqIDIgLyAyLjA7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsdXMgYW5kIGFyZ3VtZW50IG9mIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdF9tb2QgPSBNYXRoLnNxcnQoYmFzZVIgKiogMiArIGJhc2VJICoqIDIpICoqIGU7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRfYXJnID0gZSAqIE1hdGguYXRhbjIoYmFzZUksIGJhc2VSKTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gcmVjdGFuZ3VsYXIgZm9ybVxuICAgICAgICAgICAgLy8gYW5kIGFzc2lnbiB0byBjaGlycCBhbmQgaWNoaXJwXG4gICAgICAgICAgICBsZXQgaTIgPSAyICogaTtcbiAgICAgICAgICAgIGNoaXJwW2kyXSA9IHJlc3VsdF9tb2QgKiBNYXRoLmNvcyhyZXN1bHRfYXJnKTtcbiAgICAgICAgICAgIGNoaXJwW2kyICsgMV0gPSByZXN1bHRfbW9kICogTWF0aC5zaW4ocmVzdWx0X2FyZyk7XG5cbiAgICAgICAgICAgIC8vIGNvbmp1Z2F0ZVxuICAgICAgICAgICAgaWNoaXJwW2kyXSA9IGNoaXJwW2kyXTtcbiAgICAgICAgICAgIGljaGlycFtpMiArIDFdID0gLSBjaGlycFtpMiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNsaWNlZENoaXJwID0gY2hpcnAuc3ViYXJyYXkoYSwgYik7XG5cbiAgICAgICAgLy8gY3JlYXRlIG9iamVjdCB0byBwZXJmb3JtIEZhc3QgRm91cmllciBUcmFuc2Zvcm1zXG4gICAgICAgIC8vIHdpdGggYG5leHRQMmAgY29tcGxleCBudW1iZXJzXG4gICAgICAgIGNvbnN0IGYgPSBuZXcgRkZUKG5leHRQMiA+PiAxKTtcbiAgICAgICAgLy8gVE9ETzogZGVjaWRlIGJldHdlZW4gRmxvYXQzMkFycmF5IGFuZCBGbG9hdDY0QXJyYXlcbiAgICAgICAgZi50cmFuc2Zvcm0ob3V0QnVmZmVyLCBpY2hpcnApO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tpXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzbGljZWRDaGlycC5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGoyID0gaiArIDFcbiAgICAgICAgICAgICAgICBjb25zdCBqMyA9IGogPj4gMTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFfcmVhbCA9IGZyYW1lW2ozXSAqIHdpbmRvd1tqM107XG4gICAgICAgICAgICAgICAgYnVmZmVyMVtqXSA9IGFfcmVhbCAqIHNsaWNlZENoaXJwW2pdO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcjFbajJdID0gYV9yZWFsICogc2xpY2VkQ2hpcnBbajJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogZGVjaWRlIGJldHdlZW4gRmxvYXQzMkFycmF5IGFuZCBGbG9hdDY0QXJyYXlcbiAgICAgICAgICAgIGYudHJhbnNmb3JtKG91dEJ1ZmZlcjIsIGJ1ZmZlcjEpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG91dEJ1ZmZlci5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGoyID0gaiArIDE7XG5cbiAgICAgICAgICAgICAgICBidWZmZXIyW2pdID0gb3V0QnVmZmVyMltqXSAqIG91dEJ1ZmZlcltqXSAtIG91dEJ1ZmZlcjJbajJdICogb3V0QnVmZmVyW2oyXVxuICAgICAgICAgICAgICAgIGJ1ZmZlcjJbajJdID0gb3V0QnVmZmVyMltqXSAqIG91dEJ1ZmZlcltqMl0gKyBvdXRCdWZmZXIyW2oyXSAqIG91dEJ1ZmZlcltqXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogZGVjaWRlIGJldHdlZW4gRmxvYXQzMkFycmF5IGFuZCBGbG9hdDY0QXJyYXlcbiAgICAgICAgICAgIGYuaW52ZXJzZVRyYW5zZm9ybShvdXRCdWZmZXIzLCBidWZmZXIyKVxuXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogbnVtX2ZmdF9iaW5zO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1fZmZ0X2JpbnM7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFfcmVhbCA9IG91dEJ1ZmZlcjNbaiArIGFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFfaW1hZyA9IG91dEJ1ZmZlcjNbaiArIGEgKyAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBiX3JlYWwgPSBzbGljZWRDaGlycFtqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBiX2ltYWcgPSBzbGljZWRDaGlycFtqICsgMV07XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIHdyaXRlIGFzIHRyYW5zcG9zZVxuICAgICAgICAgICAgICAgIGNvbnN0IG8xID0gb2Zmc2V0ICsgajtcbiAgICAgICAgICAgICAgICBkYXRhW28xXSA9IGFfcmVhbCAqIGJfcmVhbCAtIGFfaW1hZyAqIGJfaW1hZ1xuICAgICAgICAgICAgICAgIGRhdGFbbzEgKyAxXSA9IGFfcmVhbCAqIGJfaW1hZyArIGFfaW1hZyAqIGJfcmVhbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBkaW1zOiBbZnJhbWVzLmxlbmd0aCwgbnVtX2ZmdF9iaW5zXSAvLyBbMzAwMSwgNDAyXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnJhbWVzIGZyb20gYSBnaXZlbiB3YXZlZm9ybS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB3YXZlZm9ybSBUaGUgd2F2ZWZvcm0gdG8gY3JlYXRlIGZyYW1lcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NlbnRlcj10cnVlXSBXaGV0aGVyIHRvIGNlbnRlciB0aGUgZnJhbWVzIG9uIHRoZWlyIGNvcnJlc3BvbmRpbmcgcG9zaXRpb25zIGluIHRoZSB3YXZlZm9ybS4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGZyYW1lcy5cbiAgICAgKi9cbiAgICBmcmFtX3dhdmUod2F2ZWZvcm0sIGNlbnRlciA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgZnJhbWVzID0gW107XG4gICAgICAgIGNvbnN0IGhhbGZfd2luZG93ID0gTWF0aC5mbG9vcigodGhpcy5jb25maWcubl9mZnQgLSAxKSAvIDIpICsgMTtcbiAgICAgICAgY29uc3Qgd2F2ZWZvcm1MZW5ndGggPSB3YXZlZm9ybS5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3YXZlZm9ybUxlbmd0aCArIDE7IGkgKz0gdGhpcy5jb25maWcuaG9wX2xlbmd0aCkge1xuXG4gICAgICAgICAgICBsZXQgZnJhbWU7XG4gICAgICAgICAgICBpZiAoY2VudGVyKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgZnJhbWVTdGFydCA9IGkgPiBoYWxmX3dpbmRvdyA/IGkgLSBoYWxmX3dpbmRvdyA6IDA7XG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lRW5kID1cbiAgICAgICAgICAgICAgICAgICAgaSA8IHdhdmVmb3JtTGVuZ3RoIC0gaGFsZl93aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaSArIGhhbGZfd2luZG93XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHdhdmVmb3JtTGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZnJhbWUgPSB3YXZlZm9ybS5zdWJhcnJheShmcmFtZVN0YXJ0LCBmcmFtZUVuZClcblxuICAgICAgICAgICAgICAgIGlmIChmcmFtZVN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lID0gdGhpcy5wYWRSZWZsZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAtaSArIGhhbGZfd2luZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lRW5kID09PSB3YXZlZm9ybUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IHRoaXMucGFkUmVmbGVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgLSB3YXZlZm9ybUxlbmd0aCArIGhhbGZfd2luZG93XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY29uZmlnLm5fZmZ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmFtZUFycmF5ID0gd2F2ZWZvcm0uc3ViYXJyYXkoaSwgaSArIHRoaXMuY29uZmlnLm5fZmZ0KTtcblxuICAgICAgICAgICAgICAgIGlmIChmcmFtZUFycmF5Lmxlbmd0aCA8IHRoaXMuY29uZmlnLm5fZmZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnNldChmcmFtZUFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuZmlsbCgwLCBmcmFtZUFycmF5Lmxlbmd0aCwgdGhpcy5jb25maWcubl9mZnQpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBmcmFtZUFycmF5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhbWVzLnB1c2goZnJhbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZyYW1lcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBIYW5uaW5nIHdpbmRvdyBvZiBsZW5ndGggTS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBNIFRoZSBsZW5ndGggb2YgdGhlIEhhbm5pbmcgd2luZG93IHRvIGdlbmVyYXRlLlxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgZ2VuZXJhdGVkIEhhbm5pbmcgd2luZG93LlxuICAgICAqL1xuICAgIGhhbm5pbmcoTSkge1xuICAgICAgICBpZiAoTSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFsxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZW5vbSA9IE0gLSAxO1xuICAgICAgICBjb25zdCBjb3NfdmFscyA9IG5ldyBGbG9hdDMyQXJyYXkoZGVub20pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbm9tOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSAyICogaSAtIE0gKyAxO1xuICAgICAgICAgICAgY29zX3ZhbHNbaV0gPSAwLjUgKyAwLjUgKiBNYXRoLmNvcyhNYXRoLlBJICogbiAvIGRlbm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29zX3ZhbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGxvZy1NZWwgc3BlY3Ryb2dyYW0gb2YgdGhlIHByb3ZpZGVkIGF1ZGlvIHdhdmVmb3JtLlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEZsb2F0NjRBcnJheX0gd2F2ZWZvcm0gVGhlIGF1ZGlvIHdhdmVmb3JtIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge3tkYXRhOiBGbG9hdDMyQXJyYXksIGRpbXM6IG51bWJlcltdfX0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGxvZy1NZWwgc3BlY3Ryb2dyYW0gZGF0YSBhcyBhIEZsb2F0MzJBcnJheSBhbmQgaXRzIGRpbWVuc2lvbnMgYXMgYW4gYXJyYXkgb2YgbnVtYmVycy5cbiAgICAgKi9cbiAgICBfZXh0cmFjdF9mYmFua19mZWF0dXJlcyh3YXZlZm9ybSkge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBsb2ctTWVsIHNwZWN0cm9ncmFtIG9mIHRoZSBwcm92aWRlZCBhdWRpb1xuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5jb25maWcubl9zYW1wbGVzKTtcbiAgICAgICAgYnVmZmVyLnNldCh3YXZlZm9ybSlcblxuICAgICAgICBjb25zdCB3aW5kb3cgPSB0aGlzLmhhbm5pbmcodGhpcy5jb25maWcubl9mZnQgKyAxKVxuICAgICAgICBjb25zdCBmcmFtZXMgPSB0aGlzLmZyYW1fd2F2ZShidWZmZXIpXG5cbiAgICAgICAgY29uc3Qgc3RmdCA9IHRoaXMuc3RmdChmcmFtZXMsIHdpbmRvdylcblxuICAgICAgICBjb25zdCBzdGZ0RGF0YSA9IHN0ZnQuZGF0YTtcbiAgICAgICAgY29uc3QgZDEgPSBzdGZ0LmRpbXNbMF0gLSAxOyAvLyBJZ25vcmUgbGFzdCByb3dcbiAgICAgICAgY29uc3QgZDIgPSBzdGZ0LmRpbXNbMV0gPj4gMTsgLy8gT25seSBuZWVkIHRvIHN0b3JlIHJlYWwgbnVtYmVycyBub3dcblxuICAgICAgICAvLyBjb21wdXRlIG1hZ25pdHVkZXNcbiAgICAgICAgLy8gTk9URTogVW5saWtlIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiwgd2UgZG8gbm90XG4gICAgICAgIC8vIHRyYW5zcG9zZSBzaW5jZSB3ZSBwZXJmb3JtIG1hdHJpeCBtdWx0aXBsaWNhdGlvbiBsYXRlclxuICAgICAgICBjb25zdCBtYWduaXR1ZGVzID0gbmV3IEZsb2F0MzJBcnJheShkMSAqIGQyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkMTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGQyOyArK2opIHtcbiAgICAgICAgICAgICAgICAvLyBsZXQgb3V0T2Zmc2V0ID0gKGogKiBkMSArIGkpOyAvLyB0cmFuc3Bvc2VcbiAgICAgICAgICAgICAgICBsZXQgb3V0T2Zmc2V0ID0gaSAqIGQyICsgajtcbiAgICAgICAgICAgICAgICBsZXQgaW5PZmZzZXQgPSBvdXRPZmZzZXQgPDwgMTsgLy8gKiAyIHNpbmNlIGNvbXBsZXhcbiAgICAgICAgICAgICAgICBsZXQgbWFnbml0dWRlID0gc3RmdERhdGFbaW5PZmZzZXRdICoqIDIgKyBzdGZ0RGF0YVtpbk9mZnNldCArIDFdICoqIDJcbiAgICAgICAgICAgICAgICBtYWduaXR1ZGVzW291dE9mZnNldF0gPSBtYWduaXR1ZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZWxfZmlsdGVycyA9IHRoaXMuY29uZmlnLm1lbF9maWx0ZXJzO1xuICAgICAgICBjb25zdCBudW1fbWVsX2ZpbHRlcnMgPSBtZWxfZmlsdGVycy5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgbWVsX3NwZWMgPSBuZXcgRmxvYXQzMkFycmF5KG51bV9tZWxfZmlsdGVycyAqIGQxKTtcbiAgICAgICAgbGV0IG1JbmRleCA9IDA7XG5cbiAgICAgICAgLy8gUGVyZm9ybSBtYXRyaXggbXVsaXBsaWNhdGlvbjpcbiAgICAgICAgLy8gbWVsX3NwZWMgPSBmaWx0ZXJzIEAgbWFnbml0dWRlc1xuICAgICAgICAvLyAgLSBmaWx0ZXJzLnNoYXBlPSg4MCwgMjAxKVxuICAgICAgICAvLyAgLSBtYWduaXR1ZGVzLnNoYXBlPSgyMDEsIDMwMDApXG4gICAgICAgIC8vICAtIG1lbF9zcGVjLnNoYXBlPSg4MCwgMzAwMClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1fbWVsX2ZpbHRlcnM7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbWVsX2ZpbHRlciA9IG1lbF9maWx0ZXJzW2ldO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGQxOyArK2opIHtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gZG90IHByb2R1Y3RcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGQyOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IG1lbF9maWx0ZXJba10gKiBtYWduaXR1ZGVzW2ogKiBkMiArIGtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lbF9zcGVjW21JbmRleCsrXSA9IHN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFfbWluID0gMWUtMTA7XG4gICAgICAgIGNvbnN0IGxvZ19zcGVjID0gbmV3IEZsb2F0MzJBcnJheShtZWxfc3BlYy5sZW5ndGgpO1xuXG4gICAgICAgIGxldCBtYXhMb2dTcGVjID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWxfc3BlYy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY2xpcHBlZCA9IE1hdGgubWF4KGFfbWluLCBtZWxfc3BlY1tpXSk7XG4gICAgICAgICAgICBjb25zdCBsb2cxMCA9IE1hdGgubG9nMTAoY2xpcHBlZCk7XG4gICAgICAgICAgICBsb2dfc3BlY1tpXSA9IGxvZzEwO1xuICAgICAgICAgICAgbWF4TG9nU3BlYyA9IE1hdGgubWF4KGxvZzEwLCBtYXhMb2dTcGVjKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2dfc3BlYy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbG9nX3NwZWNbaV0gPSBNYXRoLm1heChsb2dfc3BlY1tpXSwgbWF4TG9nU3BlYyAtIDgpO1xuICAgICAgICAgICAgbG9nX3NwZWNbaV0gPSAobG9nX3NwZWNbaV0gKyA0KSAvIDQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbG9nX3NwZWMsXG4gICAgICAgICAgICBkaW1zOiBbbnVtX21lbF9maWx0ZXJzLCBkMV1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXNseSBleHRyYWN0cyBmZWF0dXJlcyBmcm9tIGEgZ2l2ZW4gYXVkaW8gdXNpbmcgdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8RmxvYXQ2NEFycmF5fSBhdWRpbyBUaGUgYXVkaW8gZGF0YSBhcyBhIEZsb2F0MzJBcnJheS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGlucHV0X2ZlYXR1cmVzOiBUZW5zb3IgfT59IEEgUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGV4dHJhY3RlZCBpbnB1dCBmZWF0dXJlcyBhcyBhIFRlbnNvci5cbiAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGF1ZGlvKSB7XG4gICAgICAgIGlmICghKGF1ZGlvIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IGF1ZGlvIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBgV2hpc3BlckZlYXR1cmVFeHRyYWN0b3IgZXhwZWN0cyBpbnB1dCB0byBiZSBhIEZsb2F0MzJBcnJheSBvciBhIEZsb2F0NjRBcnJheSwgYnV0IGdvdCAke2F1ZGlvPy5jb25zdHJ1Y3Rvcj8ubmFtZSA/PyB0eXBlb2YgYXVkaW99IGluc3RlYWQuYCArXG4gICAgICAgICAgICAgICAgYElmIHVzaW5nIHRoZSBmZWF0dXJlIGV4dHJhY3RvciBkaXJlY3RseSwgcmVtZW1iZXIgdG8gdXNlIFxcYHJlYWRfYXVkaW8odXJsLCBzYW1wbGluZ19yYXRlKVxcYCB0byBvYnRhaW4gdGhlIHJhdyBhdWRpbyBkYXRhIG9mIHRoZSBmaWxlL3VybC5gXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXVkaW8ubGVuZ3RoID4gdGhpcy5jb25maWcubl9zYW1wbGVzKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJBdHRlbXB0aW5nIHRvIGV4dHJhY3QgZmVhdHVyZXMgZm9yIGF1ZGlvIGxvbmdlciB0aGFuIDMwIHNlY29uZHMuIFwiICtcbiAgICAgICAgICAgICAgICBcIklmIHVzaW5nIGEgcGlwZWxpbmUgdG8gZXh0cmFjdCB0cmFuc2NyaXB0IGZyb20gYSBsb25nIGF1ZGlvIGNsaXAsIFwiICtcbiAgICAgICAgICAgICAgICBcInJlbWVtYmVyIHRvIHNwZWNpZnkgYGNodW5rX2xlbmd0aF9zYCBhbmQvb3IgYHN0cmlkZV9sZW5ndGhfc2AuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhdmVmb3JtID0gYXVkaW8uc2xpY2UoMCwgdGhpcy5jb25maWcubl9zYW1wbGVzKTtcblxuICAgICAgICBsZXQgZmVhdHVyZXMgPSB0aGlzLl9leHRyYWN0X2ZiYW5rX2ZlYXR1cmVzKHdhdmVmb3JtKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXRfZmVhdHVyZXM6IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLFxuICAgICAgICAgICAgICAgIGZlYXR1cmVzLmRhdGEsXG4gICAgICAgICAgICAgICAgWzEsIC4uLmZlYXR1cmVzLmRpbXNdXG4gICAgICAgICAgICApXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBQcm9jZXNzb3IgdGhhdCBleHRyYWN0cyBmZWF0dXJlcyBmcm9tIGFuIGlucHV0LlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuZXhwb3J0IGNsYXNzIFByb2Nlc3NvciBleHRlbmRzIENhbGxhYmxlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFByb2Nlc3NvciB3aXRoIHRoZSBnaXZlbiBmZWF0dXJlIGV4dHJhY3Rvci5cbiAgICAgKiBAcGFyYW0ge0ZlYXR1cmVFeHRyYWN0b3J9IGZlYXR1cmVfZXh0cmFjdG9yIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGV4dHJhY3QgZmVhdHVyZXMgZnJvbSB0aGUgaW5wdXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZmVhdHVyZV9leHRyYWN0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlX2V4dHJhY3RvciA9IGZlYXR1cmVfZXh0cmFjdG9yO1xuICAgICAgICAvLyBUT0RPIHVzZSB0b2tlbml6ZXIgaGVyZT9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgZmVhdHVyZV9leHRyYWN0b3IgZnVuY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gaW5wdXQuXG4gICAgICogQHBhcmFtIHthbnl9IGlucHV0IFRoZSBpbnB1dCB0byBleHRyYWN0IGZlYXR1cmVzIGZyb20uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0cmFjdGVkIGZlYXR1cmVzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZlYXR1cmVfZXh0cmFjdG9yKGlucHV0KTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTYW1Qcm9jZXNzb3IgZXh0ZW5kcyBQcm9jZXNzb3Ige1xuXG4gICAgYXN5bmMgX2NhbGwoaW1hZ2VzLCBpbnB1dF9wb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmVhdHVyZV9leHRyYWN0b3IoaW1hZ2VzLCBpbnB1dF9wb2ludHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBib3Jyb3dzIFNhbUltYWdlUHJvY2Vzc29yI3Bvc3RfcHJvY2Vzc19tYXNrcyBhcyBwb3N0X3Byb2Nlc3NfbWFza3NcbiAgICAgKi9cbiAgICBwb3N0X3Byb2Nlc3NfbWFza3MoLi4uYXJncykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVfZXh0cmFjdG9yLnBvc3RfcHJvY2Vzc19tYXNrcyguLi5hcmdzKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIFdoaXNwZXJQcm9jZXNzb3IgdGhhdCBleHRyYWN0cyBmZWF0dXJlcyBmcm9tIGFuIGF1ZGlvIGlucHV0LlxuICogQGV4dGVuZHMgUHJvY2Vzc29yXG4gKi9cbmV4cG9ydCBjbGFzcyBXaGlzcGVyUHJvY2Vzc29yIGV4dGVuZHMgUHJvY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgZmVhdHVyZV9leHRyYWN0b3IgZnVuY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gYXVkaW8gaW5wdXQuXG4gICAgICogQHBhcmFtIHthbnl9IGF1ZGlvIFRoZSBhdWRpbyBpbnB1dCB0byBleHRyYWN0IGZlYXR1cmVzIGZyb20uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0cmFjdGVkIGZlYXR1cmVzLlxuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsKGF1ZGlvKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZlYXR1cmVfZXh0cmFjdG9yKGF1ZGlvKVxuICAgIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi91dGlscy9odWIuanMnKS5QcmV0cmFpbmVkT3B0aW9uc30gUHJldHJhaW5lZE9wdGlvbnNcbiAqL1xuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgd2hpY2ggaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBwcmV0cmFpbmVkIHByb2Nlc3NvcnMgd2l0aCB0aGUgYGZyb21fcHJldHJhaW5lZGAgZnVuY3Rpb24uXG4gKiBUaGUgY2hvc2VuIHByb2Nlc3NvciBjbGFzcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0eXBlIHNwZWNpZmllZCBpbiB0aGUgcHJvY2Vzc29yIGNvbmZpZy5cbiAqIFxuICogKipFeGFtcGxlOioqIExvYWQgYSBwcm9jZXNzb3IgdXNpbmcgYGZyb21fcHJldHJhaW5lZGAuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgcHJvY2Vzc29yID0gYXdhaXQgQXV0b1Byb2Nlc3Nvci5mcm9tX3ByZXRyYWluZWQoJ29wZW5haS93aGlzcGVyLXRpbnkuZW4nKTtcbiAqIGBgYFxuICogXG4gKiAqKkV4YW1wbGU6KiogUnVuIGFuIGltYWdlIHRocm91Z2ggYSBwcm9jZXNzb3IuXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBsZXQgcHJvY2Vzc29yID0gYXdhaXQgQXV0b1Byb2Nlc3Nvci5mcm9tX3ByZXRyYWluZWQoJ1hlbm92YS9jbGlwLXZpdC1iYXNlLXBhdGNoMTYnKTtcbiAqIGxldCBpbWFnZSA9IGF3YWl0IFJhd0ltYWdlLnJlYWQoJ2h0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vZGF0YXNldHMvWGVub3ZhL3RyYW5zZm9ybWVycy5qcy1kb2NzL3Jlc29sdmUvbWFpbi9mb290YmFsbC1tYXRjaC5qcGcnKTtcbiAqIGxldCBpbWFnZV9pbnB1dHMgPSBhd2FpdCBwcm9jZXNzb3IoaW1hZ2UpO1xuICogLy8ge1xuICogLy8gICBcInBpeGVsX3ZhbHVlc1wiOiB7XG4gKiAvLyAgICAgXCJkaW1zXCI6IFsgMSwgMywgMjI0LCAyMjQgXSxcbiAqIC8vICAgICBcInR5cGVcIjogXCJmbG9hdDMyXCIsXG4gKiAvLyAgICAgXCJkYXRhXCI6IEZsb2F0MzJBcnJheSBbIC0xLjU1ODY4NzY4NjkyMDE2NiwgLTEuNTU4Njg3Njg2OTIwMTY2LCAtMS41NDQwODkzMTczMjE3NzczLCAuLi4gXSxcbiAqIC8vICAgICBcInNpemVcIjogMTUwNTI4XG4gKiAvLyAgIH0sXG4gKiAvLyAgIFwib3JpZ2luYWxfc2l6ZXNcIjogW1xuICogLy8gICAgIFsgNTMzLCA4MDAgXVxuICogLy8gICBdLFxuICogLy8gICBcInJlc2hhcGVkX2lucHV0X3NpemVzXCI6IFtcbiAqIC8vICAgICBbIDIyNCwgMjI0IF1cbiAqIC8vICAgXVxuICogLy8gfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvUHJvY2Vzc29yIHtcbiAgICBzdGF0aWMgRkVBVFVSRV9FWFRSQUNUT1JfQ0xBU1NfTUFQUElORyA9IHtcbiAgICAgICAgJ1doaXNwZXJGZWF0dXJlRXh0cmFjdG9yJzogV2hpc3BlckZlYXR1cmVFeHRyYWN0b3IsXG4gICAgICAgICdWaVRGZWF0dXJlRXh0cmFjdG9yJzogVmlURmVhdHVyZUV4dHJhY3RvcixcbiAgICAgICAgJ01vYmlsZVZpVEZlYXR1cmVFeHRyYWN0b3InOiBNb2JpbGVWaVRGZWF0dXJlRXh0cmFjdG9yLFxuICAgICAgICAnRGV0ckZlYXR1cmVFeHRyYWN0b3InOiBEZXRyRmVhdHVyZUV4dHJhY3RvcixcblxuICAgICAgICAnU2FtSW1hZ2VQcm9jZXNzb3InOiBTYW1JbWFnZVByb2Nlc3NvcixcbiAgICB9XG5cbiAgICBzdGF0aWMgUFJPQ0VTU09SX0NMQVNTX01BUFBJTkcgPSB7XG4gICAgICAgICdXaGlzcGVyUHJvY2Vzc29yJzogV2hpc3BlclByb2Nlc3NvcixcbiAgICAgICAgJ1NhbVByb2Nlc3Nvcic6IFNhbVByb2Nlc3NvcixcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBvbmUgb2YgdGhlIHByb2Nlc3NvciBjbGFzc2VzIG9mIHRoZSBsaWJyYXJ5IGZyb20gYSBwcmV0cmFpbmVkIG1vZGVsLlxuICAgICAqIFxuICAgICAqIFRoZSBwcm9jZXNzb3IgY2xhc3MgdG8gaW5zdGFudGlhdGUgaXMgc2VsZWN0ZWQgYmFzZWQgb24gdGhlIGBmZWF0dXJlX2V4dHJhY3Rvcl90eXBlYCBwcm9wZXJ0eSBvZiB0aGUgY29uZmlnIG9iamVjdFxuICAgICAqIChlaXRoZXIgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IG9yIGxvYWRlZCBmcm9tIGBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aGAgaWYgcG9zc2libGUpXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoIFRoZSBuYW1lIG9yIHBhdGggb2YgdGhlIHByZXRyYWluZWQgbW9kZWwuIENhbiBiZSBlaXRoZXI6XG4gICAgICogLSBBIHN0cmluZywgdGhlICptb2RlbCBpZCogb2YgYSBwcmV0cmFpbmVkIHByb2Nlc3NvciBob3N0ZWQgaW5zaWRlIGEgbW9kZWwgcmVwbyBvbiBodWdnaW5nZmFjZS5jby5cbiAgICAgKiAgIFZhbGlkIG1vZGVsIGlkcyBjYW4gYmUgbG9jYXRlZCBhdCB0aGUgcm9vdC1sZXZlbCwgbGlrZSBgYmVydC1iYXNlLXVuY2FzZWRgLCBvciBuYW1lc3BhY2VkIHVuZGVyIGFcbiAgICAgKiAgIHVzZXIgb3Igb3JnYW5pemF0aW9uIG5hbWUsIGxpa2UgYGRibWR6L2JlcnQtYmFzZS1nZXJtYW4tY2FzZWRgLlxuICAgICAqIC0gQSBwYXRoIHRvIGEgKmRpcmVjdG9yeSogY29udGFpbmluZyBwcm9jZXNzb3IgZmlsZXMsIGUuZy4sIGAuL215X21vZGVsX2RpcmVjdG9yeS9gLlxuICAgICAqIEBwYXJhbSB7UHJldHJhaW5lZE9wdGlvbnN9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciBsb2FkaW5nIHRoZSBwcm9jZXNzb3IuXG4gICAgICogXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UHJvY2Vzc29yPn0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFByb2Nlc3NvciBjbGFzcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoLCB7XG4gICAgICAgIHByb2dyZXNzX2NhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgY29uZmlnID0gbnVsbCxcbiAgICAgICAgY2FjaGVfZGlyID0gbnVsbCxcbiAgICAgICAgbG9jYWxfZmlsZXNfb25seSA9IGZhbHNlLFxuICAgICAgICByZXZpc2lvbiA9ICdtYWluJyxcbiAgICB9ID0ge30pIHtcblxuICAgICAgICBsZXQgcHJlcHJvY2Vzc29yQ29uZmlnID0gY29uZmlnID8/IGF3YWl0IGdldE1vZGVsSlNPTihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ3ByZXByb2Nlc3Nvcl9jb25maWcuanNvbicsIHRydWUsIHtcbiAgICAgICAgICAgIHByb2dyZXNzX2NhbGxiYWNrLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgY2FjaGVfZGlyLFxuICAgICAgICAgICAgbG9jYWxfZmlsZXNfb25seSxcbiAgICAgICAgICAgIHJldmlzaW9uLFxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIERldGVybWluZSBmZWF0dXJlIGV4dHJhY3RvciBjbGFzc1xuICAgICAgICAvLyBUT0RPOiBFbnN1cmUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgY29uZmlnc1xuICAgICAgICBsZXQga2V5ID0gcHJlcHJvY2Vzc29yQ29uZmlnLmZlYXR1cmVfZXh0cmFjdG9yX3R5cGUgPz8gcHJlcHJvY2Vzc29yQ29uZmlnLmltYWdlX3Byb2Nlc3Nvcl90eXBlO1xuICAgICAgICBsZXQgZmVhdHVyZV9leHRyYWN0b3JfY2xhc3MgPSB0aGlzLkZFQVRVUkVfRVhUUkFDVE9SX0NMQVNTX01BUFBJTkdba2V5XTtcblxuICAgICAgICBpZiAoIWZlYXR1cmVfZXh0cmFjdG9yX2NsYXNzKSB7XG4gICAgICAgICAgICBpZiAocHJlcHJvY2Vzc29yQ29uZmlnLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBJbWFnZUZlYXR1cmVFeHRyYWN0b3JcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZlYXR1cmUgZXh0cmFjdG9yIHR5cGUgbm90IHNwZWNpZmllZCwgYXNzdW1pbmcgSW1hZ2VGZWF0dXJlRXh0cmFjdG9yIGR1ZSB0byBzaXplIHBhcmFtZXRlciBpbiBjb25maWcuJyk7XG4gICAgICAgICAgICAgICAgZmVhdHVyZV9leHRyYWN0b3JfY2xhc3MgPSBJbWFnZUZlYXR1cmVFeHRyYWN0b3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBGZWF0dXJlIEV4dHJhY3RvciB0eXBlOiAke3ByZXByb2Nlc3NvckNvbmZpZy5mZWF0dXJlX2V4dHJhY3Rvcl90eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gYXNzb2NpYXRlZCBwcm9jZXNzb3IgY2xhc3MsIHVzZSBkZWZhdWx0XG4gICAgICAgIGxldCBwcm9jZXNzb3JfY2xhc3MgPSB0aGlzLlBST0NFU1NPUl9DTEFTU19NQVBQSU5HW3ByZXByb2Nlc3NvckNvbmZpZy5wcm9jZXNzb3JfY2xhc3NdID8/IFByb2Nlc3NvcjtcblxuICAgICAgICAvLyBJbnN0YW50aWF0ZSBwcm9jZXNzb3IgYW5kIGZlYXR1cmUgZXh0cmFjdG9yXG4gICAgICAgIGxldCBmZWF0dXJlX2V4dHJhY3RvciA9IG5ldyBmZWF0dXJlX2V4dHJhY3Rvcl9jbGFzcyhwcmVwcm9jZXNzb3JDb25maWcpO1xuICAgICAgICByZXR1cm4gbmV3IHByb2Nlc3Nvcl9jbGFzcyhmZWF0dXJlX2V4dHJhY3Rvcik7XG4gICAgfVxufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuIiwiXG4vKipcbiAqIEBmaWxlIFRva2VuaXplcnMgYXJlIHVzZWQgdG8gcHJlcGFyZSB0ZXh0dWFsIGlucHV0cyBmb3IgYSBtb2RlbC5cbiAqIFxuICogKipFeGFtcGxlOioqIENyZWF0ZSBhbiBgQXV0b1Rva2VuaXplcmAgYW5kIHVzZSBpdCB0byB0b2tlbml6ZSBhIHNlbnRlbmNlLlxuICogVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSB0b2tlbml6ZXIgdHlwZSBiYXNlZCBvbiB0aGUgdG9rZW5pemVyIGNsYXNzIGRlZmluZWQgaW4gYHRva2VuaXplci5qc29uYC5cbiAqIGBgYGphdmFzY3JpcHRcbiAqIGltcG9ydCB7IEF1dG9Ub2tlbml6ZXIgfSBmcm9tICdAeGVub3ZhL3RyYW5zZm9ybWVycyc7XG4gKiBcbiAqIGxldCB0b2tlbml6ZXIgPSBhd2FpdCBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZCgnYmVydC1iYXNlLXVuY2FzZWQnKTtcbiAqIGxldCB7IGlucHV0X2lkcyB9ID0gYXdhaXQgdG9rZW5pemVyKCdJIGxvdmUgdHJhbnNmb3JtZXJzIScpO1xuICogLy8gVGVuc29yIHtcbiAqIC8vICAgZGF0YTogQmlnSW50NjRBcnJheSg2KSBbMTAxbiwgMTA0NW4sIDIyOTNuLCAxOTA4MW4sIDk5OW4sIDEwMm5dLFxuICogLy8gICBkaW1zOiBbMSwgNl0sXG4gKiAvLyAgIHR5cGU6ICdpbnQ2NCcsXG4gKiAvLyAgIHNpemU6IDYsXG4gKiAvLyB9XG4gKiBgYGBcbiAqIFxuICogQG1vZHVsZSB0b2tlbml6ZXJzXG4gKi9cblxuaW1wb3J0IHtcbiAgICBDYWxsYWJsZSxcbiAgICByZXZlcnNlRGljdGlvbmFyeSxcbiAgICBlc2NhcGVSZWdFeHAsXG4gICAgaXNJbnRlZ3JhbE51bWJlcixcbiAgICBtZXJnZUFycmF5cyxcbn0gZnJvbSAnLi91dGlscy9jb3JlLmpzJztcblxuaW1wb3J0IHtcbiAgICBnZXRNb2RlbEpTT04sXG59IGZyb20gJy4vdXRpbHMvaHViLmpzJztcblxuaW1wb3J0IHsgbWF4LCBtaW4sIHJvdW5kIH0gZnJvbSAnLi91dGlscy9tYXRocy5qcyc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3V0aWxzL3RlbnNvci5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi91dGlscy9odWIuanMnKS5QcmV0cmFpbmVkT3B0aW9uc30gUHJldHJhaW5lZE9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIExvYWRzIGEgdG9rZW5pemVyIGZyb20gdGhlIHNwZWNpZmllZCBwYXRoLlxuICogQHBhcmFtIHtzdHJpbmd9IHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoIFRoZSBwYXRoIHRvIHRoZSB0b2tlbml6ZXIgZGlyZWN0b3J5LlxuICogQHBhcmFtIHtQcmV0cmFpbmVkT3B0aW9uc30gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIHRva2VuaXplci5cbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbG9hZGVkIHRva2VuaXplci5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZFRva2VuaXplcihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgb3B0aW9ucykge1xuXG4gICAgbGV0IGluZm8gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldE1vZGVsSlNPTihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ3Rva2VuaXplci5qc29uJywgdHJ1ZSwgb3B0aW9ucyksXG4gICAgICAgIGdldE1vZGVsSlNPTihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwgJ3Rva2VuaXplcl9jb25maWcuanNvbicsIHRydWUsIG9wdGlvbnMpLFxuICAgIF0pXG4gICAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBjb25zdHJ1Y3QgYSBwYXR0ZXJuIGZyb20gYSBjb25maWcgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHBhdHRlcm4gVGhlIHBhdHRlcm4gb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBpbnZlcnQgV2hldGhlciB0byBpbnZlcnQgdGhlIHBhdHRlcm4gKG9ubHkgYXBwbGljYWJsZSBmb3IgUmVnZXggcGF0dGVybnMpLlxuICogQHJldHVybnMge1JlZ0V4cHxzdHJpbmd8bnVsbH0gVGhlIGNvbXBpbGVkIHBhdHRlcm4uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhdHRlcm4ocGF0dGVybiwgaW52ZXJ0ID0gdHJ1ZSkge1xuXG4gICAgaWYgKHBhdHRlcm4uUmVnZXgpIHtcbiAgICAgICAgLy8gTk9URTogaWYgaW52ZXJ0IGlzIHRydWUsIHdlIHdyYXAgdGhlIHBhdHRlcm4gaW4gYSBncm91cCBzbyB0aGF0IGl0IGlzIGtlcHQgd2hlbiBwZXJmb3JtaW5nIC5zcGxpdCgpXG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGludmVydCA/IHBhdHRlcm4uUmVnZXggOiBgKCR7cGF0dGVybi5SZWdleH0pYCwgJ2d1Jyk7XG5cbiAgICB9IGVsc2UgaWYgKHBhdHRlcm4uU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLlN0cmluZztcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVW5rbm93biBwYXR0ZXJuIHR5cGU6JywgcGF0dGVybilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIENsZWFuIHVwIGEgbGlzdCBvZiBzaW1wbGUgRW5nbGlzaCB0b2tlbml6YXRpb24gYXJ0aWZhY3RzIGxpa2Ugc3BhY2VzIGJlZm9yZSBwdW5jdHVhdGlvbnMgYW5kIGFiYnJldmlhdGVkIGZvcm1zXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBjbGVhbiB1cC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjbGVhbmVkIHVwIHRleHQuXG4gKi9cbmZ1bmN0aW9uIGNsZWFuX3VwX3Rva2VuaXphdGlvbih0ZXh0KSB7XG4gICAgLy8gQ2xlYW4gdXAgYSBsaXN0IG9mIHNpbXBsZSBFbmdsaXNoIHRva2VuaXphdGlvbiBhcnRpZmFjdHNcbiAgICAvLyBsaWtlIHNwYWNlcyBiZWZvcmUgcHVuY3R1YXRpb25zIGFuZCBhYmJyZXZpYXRlZCBmb3Jtc1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyBcXC4vZywgJy4nKVxuICAgICAgICAucmVwbGFjZSgvIFxcPy9nLCAnPycpXG4gICAgICAgIC5yZXBsYWNlKC8gXFwhL2csICchJylcbiAgICAgICAgLnJlcGxhY2UoLyAsL2csICcsJylcbiAgICAgICAgLnJlcGxhY2UoLyBcXCcgL2csIFwiJ1wiKVxuICAgICAgICAucmVwbGFjZSgvIG5cXCd0L2csIFwibid0XCIpXG4gICAgICAgIC5yZXBsYWNlKC8gXFwnbS9nLCBcIidtXCIpXG4gICAgICAgIC5yZXBsYWNlKC8gXFwncy9nLCBcIidzXCIpXG4gICAgICAgIC5yZXBsYWNlKC8gXFwndmUvZywgXCIndmVcIilcbiAgICAgICAgLnJlcGxhY2UoLyBcXCdyZS9nLCBcIidyZVwiKTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZnVzZSBjb25zZWN1dGl2ZSB2YWx1ZXMgaW4gYW4gYXJyYXkgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgaW5wdXQgYXJyYXlcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gZnVzZSBvbi5cbiAqL1xuZnVuY3Rpb24gZnVzZShhcnIsIHZhbHVlKSB7XG4gICAgbGV0IGZ1c2VkID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICBmdXNlZC5wdXNoKGFycltpXSlcbiAgICAgICAgaWYgKGFycltpXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGkgPCBhcnIubGVuZ3RoICYmIGFycltpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdXNlZDtcbn1cblxuLyoqXG4gKiBTcGxpdCBhIHN0cmluZyBvbiB3aGl0ZXNwYWNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc3BsaXQuXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBzcGxpdCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHdoaXRlc3BhY2Vfc3BsaXQodGV4dCkge1xuICAgIHJldHVybiB0ZXh0Lm1hdGNoKC9cXFMrL2cpIHx8IFtdO1xufVxuXG5jb25zdCBQVU5DVFVBVElPTl9SRUdFWCA9ICdcXFxccHtQfVxcXFx1MDAyMS1cXFxcdTAwMkZcXFxcdTAwM0EtXFxcXHUwMDQwXFxcXHUwMDVCLVxcXFx1MDA2MFxcXFx1MDA3Qi1cXFxcdTAwN0UnO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHRva2VuaXplciBtb2RlbHMuXG4gKlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuaXplck1vZGVsIGV4dGVuZHMgQ2FsbGFibGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgVG9rZW5pemVyTW9kZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBUb2tlbml6ZXJNb2RlbC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cbiAgICAgICAgdGhpcy52b2NhYiA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcHBpbmcgb2YgdG9rZW5zIHRvIGlkcy5cbiAgICAgICAgICogQHR5cGUge01hcDxzdHJpbmcsIG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRva2Vuc190b19pZHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy51bmtfdG9rZW5faWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudW5rX3Rva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVuZF9vZl93b3JkX3N1ZmZpeCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdG8gZnVzZSB1bmtub3duIHRva2VucyB3aGVuIGVuY29kaW5nLiBEZWZhdWx0cyB0byBmYWxzZS4gKi9cbiAgICAgICAgdGhpcy5mdXNlX3VuayA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIG5ldyBUb2tlbml6ZXJNb2RlbCBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBUb2tlbml6ZXJNb2RlbC5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgT3B0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIHNwZWNpZmljIFRva2VuaXplck1vZGVsIGNvbnN0cnVjdG9yLlxuICAgICAqIEByZXR1cm5zIHtUb2tlbml6ZXJNb2RlbH0gQSBuZXcgaW5zdGFuY2Ugb2YgYSBUb2tlbml6ZXJNb2RlbC5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIFRva2VuaXplck1vZGVsIHR5cGUgaW4gdGhlIGNvbmZpZyBpcyBub3QgcmVjb2duaXplZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUNvbmZpZyhjb25maWcsIC4uLmFyZ3MpIHtcbiAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnV29yZFBpZWNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRQaWVjZVRva2VuaXplcihjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnVW5pZ3JhbSc6XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5pZ3JhbShjb25maWcsIC4uLmFyZ3MpO1xuXG4gICAgICAgICAgICBjYXNlICdCUEUnOlxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJQRShjb25maWcsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gVG9rZW5pemVyTW9kZWwgdHlwZTogJHtjb25maWcudHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHRvIGNhbGwgdGhlIFRva2VuaXplck1vZGVsIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBUaGUgdG9rZW5zIHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IFRoZSBlbmNvZGVkIHRva2VuIElEcy5cbiAgICAgKi9cbiAgICBfY2FsbCh0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKHRva2Vucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhIGxpc3Qgb2YgdG9rZW5zIGludG8gYSBsaXN0IG9mIHRva2VuIElEcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0b2tlbnMgVGhlIHRva2VucyB0byBlbmNvZGUuXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBUaGUgZW5jb2RlZCB0b2tlbiBJRHMuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIG5vdCBpbXBsZW1lbnRlZCBpbiBhIHN1YmNsYXNzLlxuICAgICAqL1xuICAgIGVuY29kZSh0b2tlbnMpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJlbmNvZGUgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbGlzdCBvZiB0b2tlbnMgaW50byBhIGxpc3Qgb2YgdG9rZW4gSURzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBUaGUgdG9rZW5zIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBUaGUgY29udmVydGVkIHRva2VuIElEcy5cbiAgICAgKi9cbiAgICBjb252ZXJ0X3Rva2Vuc190b19pZHModG9rZW5zKSB7XG4gICAgICAgIGxldCBpZHMgPSB0b2tlbnMubWFwKHQgPT4gdGhpcy50b2tlbnNfdG9faWRzLmdldCh0KSA/PyB0aGlzLnVua190b2tlbl9pZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZnVzZV91bmspIHtcbiAgICAgICAgICAgIC8vIEZ1c2UgdW5rbm93biB0b2tlbnNcbiAgICAgICAgICAgIGlkcyA9IGZ1c2UoaWRzLCB0aGlzLnVua190b2tlbl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGxpc3Qgb2YgdG9rZW4gSURzIGludG8gYSBsaXN0IG9mIHRva2Vucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpZHMgVGhlIHRva2VuIElEcyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGNvbnZlcnRlZCB0b2tlbnMuXG4gICAgICovXG4gICAgY29udmVydF9pZHNfdG9fdG9rZW5zKGlkcykge1xuICAgICAgICByZXR1cm4gaWRzLm1hcChpID0+IHRoaXMudm9jYWJbaV0gPz8gdGhpcy51bmtfdG9rZW4pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHN1YmNsYXNzIG9mIFRva2VuaXplck1vZGVsIHRoYXQgdXNlcyBXb3JkUGllY2UgZW5jb2RpbmcgdG8gZW5jb2RlIHRva2Vucy5cbiAqIEBleHRlbmRzIFRva2VuaXplck1vZGVsXG4gKi9cbmNsYXNzIFdvcmRQaWVjZVRva2VuaXplciBleHRlbmRzIFRva2VuaXplck1vZGVsIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge01hcDxzdHJpbmcsIG51bWJlcj59IGNvbmZpZy52b2NhYiBBIG1hcHBpbmcgb2YgdG9rZW5zIHRvIGlkcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLnVua190b2tlbiBUaGUgdW5rbm93biB0b2tlbiBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5jb250aW51aW5nX3N1YndvcmRfcHJlZml4IFRoZSBwcmVmaXggdG8gdXNlIGZvciBjb250aW51aW5nIHN1YndvcmRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXBwaW5nIG9mIHRva2VucyB0byBpZHMuXG4gICAgICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2tlbnNfdG9faWRzID0gY29uZmlnLnZvY2FiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWQgb2YgdGhlIHVua25vd24gdG9rZW4uXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVua190b2tlbl9pZCA9IHRoaXMudG9rZW5zX3RvX2lkcy5nZXQoY29uZmlnLnVua190b2tlbik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmtub3duIHRva2VuIHN0cmluZy5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5rX3Rva2VuID0gY29uZmlnLnVua190b2tlbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgdG9rZW5zLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZvY2FiID0gbmV3IEFycmF5KHRoaXMudG9rZW5zX3RvX2lkcy5zaXplKTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLnRva2Vuc190b19pZHMpIHtcbiAgICAgICAgICAgIHRoaXMudm9jYWJbdmFsdWVdID0ga2V5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhbiBhcnJheSBvZiB0b2tlbnMgdXNpbmcgV29yZFBpZWNlIGVuY29kaW5nLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBUaGUgdG9rZW5zIHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGVuY29kZWQgdG9rZW5zLlxuICAgICAqL1xuICAgIGVuY29kZSh0b2tlbnMpIHtcbiAgICAgICAgbGV0IG91dHB1dFRva2VucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIGxldCBjaGFycyA9IFsuLi50b2tlbl07XG4gICAgICAgICAgICAvLyBUT0RPIGFkZFxuICAgICAgICAgICAgLy8gaWYgbGVuKGNoYXJzKSA+IHNlbGYubWF4X2lucHV0X2NoYXJzX3Blcl93b3JkOlxuICAgICAgICAgICAgLy8gICAgIG91dHB1dF90b2tlbnMuYXBwZW5kKHNlbGYudW5rX3Rva2VuKVxuICAgICAgICAgICAgLy8gICAgIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIGxldCBpc1Vua25vd24gPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgICAgICBsZXQgc3ViVG9rZW5zID0gW107XG5cbiAgICAgICAgICAgIHdoaWxlIChzdGFydCA8IGNoYXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBjaGFycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdWJzdHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3Vic3RyID0gY2hhcnMuc2xpY2Uoc3RhcnQsIGVuZCkuam9pbignJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RyID0gdGhpcy5jb25maWcuY29udGludWluZ19zdWJ3b3JkX3ByZWZpeCArIHN1YnN0cjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b2tlbnNfdG9faWRzLmhhcyhzdWJzdHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3Vic3RyaW5nID0gc3Vic3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAtLWVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdWJzdHJpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNVbmtub3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YlRva2Vucy5wdXNoKGN1cnJlbnRTdWJzdHJpbmcpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVW5rbm93bikge1xuICAgICAgICAgICAgICAgIG91dHB1dFRva2Vucy5wdXNoKHRoaXMudW5rX3Rva2VuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0VG9rZW5zLnB1c2goLi4uc3ViVG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRUb2tlbnM7XG4gICAgfVxuXG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgVW5pZ3JhbSB0b2tlbml6ZXIgbW9kZWwuXG4gKiBAZXh0ZW5kcyBUb2tlbml6ZXJNb2RlbFxuICovXG5jbGFzcyBVbmlncmFtIGV4dGVuZHMgVG9rZW5pemVyTW9kZWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBVbmlncmFtIHRva2VuaXplciBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIFVuaWdyYW0gbW9kZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy51bmtfaWQgVGhlIElEIG9mIHRoZSB1bmtub3duIHRva2VuXG4gICAgICogQHBhcmFtIHtNYXA8c3RyaW5nLCBudW1iZXI+fSBjb25maWcudm9jYWIgQSBtYXBwaW5nIG9mIHRva2VucyB0byBzY29yZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vcmVDb25maWcgQWRkaXRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIFVuaWdyYW0gbW9kZWwuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBtb3JlQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy52b2NhYiA9IG5ldyBBcnJheShjb25maWcudm9jYWIuc2l6ZSk7XG4gICAgICAgIHRoaXMuc2NvcmVzID0gbmV3IEFycmF5KGNvbmZpZy52b2NhYi5zaXplKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgY29uZmlnLnZvY2FiLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMudm9jYWJbY291bnRdID0ga2V5O1xuICAgICAgICAgICAgdGhpcy5zY29yZXNbY291bnRdID0gdmFsdWU7XG4gICAgICAgICAgICArK2NvdW50O1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnVua190b2tlbl9pZCA9IGNvbmZpZy51bmtfaWQ7XG4gICAgICAgIHRoaXMudW5rX3Rva2VuID0gdGhpcy52b2NhYltjb25maWcudW5rX2lkXTtcblxuICAgICAgICB0aGlzLnRva2Vuc190b19pZHMgPSBuZXcgTWFwKHRoaXMudm9jYWIubWFwKCh4LCBpKSA9PiBbeCwgaV0pKTtcbiAgICAgICAgdGhpcy5ib3NUb2tlbiA9ICcgJzsgLy8gYmVnaW5uaW5nIG9mIGEgc2VudGVuY2UgdG9rZW5cblxuICAgICAgICB0aGlzLmJvc1Rva2VuSWQgPSB0aGlzLnRva2Vuc190b19pZHMuZ2V0KHRoaXMuYm9zVG9rZW4pOyAvLyBOT1RFOiBtYXkgYmUgdW5kZWZpbmVkXG4gICAgICAgIHRoaXMuZW9zVG9rZW4gPSBtb3JlQ29uZmlnLmVvc190b2tlbjtcblxuICAgICAgICB0aGlzLmVvc1Rva2VuSWQgPSB0aGlzLnRva2Vuc190b19pZHMuZ2V0KHRoaXMuZW9zVG9rZW4pO1xuICAgICAgICB0aGlzLnVua1Rva2VuID0gdGhpcy52b2NhYlt0aGlzLnVua190b2tlbl9pZF07XG5cbiAgICAgICAgdGhpcy5taW5TY29yZSA9IG1pbih0aGlzLnNjb3JlcylbMF07XG5cbiAgICAgICAgdGhpcy51bmtTY29yZSA9IHRoaXMubWluU2NvcmUgLSAxMC4wO1xuICAgICAgICB0aGlzLnNjb3Jlc1t0aGlzLnVua190b2tlbl9pZF0gPSB0aGlzLnVua1Njb3JlO1xuXG4gICAgICAgIHRoaXMudHJpZSA9IG5ldyBDaGFyVHJpZSgpO1xuICAgICAgICB0aGlzLnRyaWUuZXh0ZW5kKHRoaXMudm9jYWIpO1xuXG4gICAgICAgIC8vIE5PVEU6IGBmdXNlX3Vua2AgaXMgaGFyZGNvZGVkIHRvIHRydWUgZm9yIFVuaWdyYW0gbW9kZWxzXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2h1Z2dpbmdmYWNlL3Rva2VuaXplcnMvYmxvYi9iNTgyMjdjN2YxY2NmOGI3M2VlMjI2ODM1NDMzNmRhNTZkOTFlNDkyL3Rva2VuaXplcnMvc3JjL21vZGVscy91bmlncmFtL21vZGVsLnJzI0wxMTlcbiAgICAgICAgdGhpcy5mdXNlX3VuayA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9wdWxhdGVzIGxhdHRpY2Ugbm9kZXMuXG4gICAgICogQHBhcmFtIHtUb2tlbkxhdHRpY2V9IGxhdHRpY2UgVGhlIHRva2VuIGxhdHRpY2UgdG8gcG9wdWxhdGUgd2l0aCBub2Rlcy5cbiAgICAgKi9cbiAgICBwb3B1bGF0ZU5vZGVzKGxhdHRpY2UpIHtcbiAgICAgICAgY29uc3Qgc2VudGVuY2UgPSBsYXR0aWNlLnNlbnRlbmNlO1xuICAgICAgICBjb25zdCBsZW4gPSBzZW50ZW5jZS5sZW5ndGg7XG4gICAgICAgIGxldCBiZWdpblBvcyA9IDA7XG4gICAgICAgIHdoaWxlIChiZWdpblBvcyA8IGxlbikge1xuICAgICAgICAgICAgY29uc3QgbWJsZW4gPSAxO1xuICAgICAgICAgICAgbGV0IGhhc1NpbmdsZU5vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0aGlzLnRyaWUuY29tbW9uUHJlZml4U2VhcmNoKHNlbnRlbmNlLnNsaWNlKGJlZ2luUG9zKSkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IHRoaXMudG9rZW5zX3RvX2lkcy5nZXQodG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuU2NvcmUgPSB0aGlzLnNjb3Jlc1t0b2tlbklkXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxhdHRpY2UuaW5zZXJ0KGJlZ2luUG9zLCBuLCB0b2tlblNjb3JlLCB0b2tlbklkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1NpbmdsZU5vZGUgJiYgbiA9PT0gbWJsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzU2luZ2xlTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNTaW5nbGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgbGF0dGljZS5pbnNlcnQoYmVnaW5Qb3MsIG1ibGVuLCB0aGlzLnVua1Njb3JlLCB0aGlzLnVua190b2tlbl9pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiZWdpblBvcyArPSBtYmxlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYW4gYXJyYXkgb2YgdG9rZW5zIGludG8gYW4gYXJyYXkgb2Ygc3VidG9rZW5zIHVzaW5nIHRoZSB1bmlncmFtIG1vZGVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5vcm1hbGl6ZWQgVGhlIG5vcm1hbGl6ZWQgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2Ygc3VidG9rZW5zIG9idGFpbmVkIGJ5IGVuY29kaW5nIHRoZSBpbnB1dCB0b2tlbnMgdXNpbmcgdGhlIHVuaWdyYW0gbW9kZWwuXG4gICAgICovXG4gICAgdG9rZW5pemUobm9ybWFsaXplZCkge1xuICAgICAgICBjb25zdCBsYXR0aWNlID0gbmV3IFRva2VuTGF0dGljZShub3JtYWxpemVkLCB0aGlzLmJvc1Rva2VuSWQsIHRoaXMuZW9zVG9rZW5JZCk7XG4gICAgICAgIHRoaXMucG9wdWxhdGVOb2RlcyhsYXR0aWNlKTtcbiAgICAgICAgcmV0dXJuIGxhdHRpY2UudG9rZW5zKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlcyBhbiBhcnJheSBvZiB0b2tlbnMgdXNpbmcgV29yZFBpZWNlIGVuY29kaW5nLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBUaGUgdG9rZW5zIHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGVuY29kZWQgdG9rZW5zLlxuICAgICAqL1xuICAgIGVuY29kZSh0b2tlbnMpIHtcbiAgICAgICAgbGV0IHRvUmV0dXJuID0gW107XG4gICAgICAgIGZvciAobGV0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5pemVkID0gdGhpcy50b2tlbml6ZSh0b2tlbik7XG4gICAgICAgICAgICB0b1JldHVybi5wdXNoKC4uLnRva2VuaXplZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgIH1cblxufVxuXG4vKipcbiAqIFJldHVybnMgbGlzdCBvZiB1dGYtOCBieXRlIGFuZCBhIG1hcHBpbmcgdG8gdW5pY29kZSBzdHJpbmdzLlxuICogU3BlY2lmaWNhbGx5IGF2b2lkcyBtYXBwaW5nIHRvIHdoaXRlc3BhY2UvY29udHJvbCBjaGFyYWN0ZXJzIHRoZSBCUEUgY29kZSBiYXJmcyBvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB3aXRoIHV0Zi04IGJ5dGUga2V5cyBhbmQgdW5pY29kZSBzdHJpbmcgdmFsdWVzLlxuICovXG5jb25zdCBCWVRFU19UT19VTklDT0RFID0gKCgpID0+IHtcbiAgICAvLyBSZXR1cm5zIGxpc3Qgb2YgdXRmLTggYnl0ZSBhbmQgYSBtYXBwaW5nIHRvIHVuaWNvZGUgc3RyaW5ncy5cbiAgICAvLyBXZSBzcGVjaWZpY2FsbHkgYXZvaWRzIG1hcHBpbmcgdG8gd2hpdGVzcGFjZS9jb250cm9sIGNoYXJhY3RlcnNcbiAgICAvLyB0aGUgYnBlIGNvZGUgYmFyZnMgb24uXG5cbiAgICBjb25zdCBicyA9IFtcbiAgICAgICAgLi4uQXJyYXkuZnJvbSh7IGxlbmd0aDogXCJ+XCIuY2hhckNvZGVBdCgwKSAtIFwiIVwiLmNoYXJDb2RlQXQoMCkgKyAxIH0sIChfLCBpKSA9PiBpICsgXCIhXCIuY2hhckNvZGVBdCgwKSksXG4gICAgICAgIC4uLkFycmF5LmZyb20oeyBsZW5ndGg6IFwiwqxcIi5jaGFyQ29kZUF0KDApIC0gXCLCoVwiLmNoYXJDb2RlQXQoMCkgKyAxIH0sIChfLCBpKSA9PiBpICsgXCLCoVwiLmNoYXJDb2RlQXQoMCkpLFxuICAgICAgICAuLi5BcnJheS5mcm9tKHsgbGVuZ3RoOiBcIsO/XCIuY2hhckNvZGVBdCgwKSAtIFwiwq5cIi5jaGFyQ29kZUF0KDApICsgMSB9LCAoXywgaSkgPT4gaSArIFwiwq5cIi5jaGFyQ29kZUF0KDApKSxcbiAgICBdO1xuICAgIGxldCBjcyA9IGJzLnNsaWNlKCk7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAobGV0IGIgPSAwOyBiIDwgMjU2OyArK2IpIHtcbiAgICAgICAgaWYgKCFicy5pbmNsdWRlcyhiKSkge1xuICAgICAgICAgICAgYnMucHVzaChiKTtcbiAgICAgICAgICAgIGNzLnB1c2goMjU2ICsgbik7XG4gICAgICAgICAgICBuICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNjcyA9IGNzLm1hcChuID0+IFN0cmluZy5mcm9tQ2hhckNvZGUobikpO1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoYnMubWFwKChiLCBpKSA9PiBbYiwgY2NzW2ldXSkpO1xufSkoKTtcblxuY29uc3QgVU5JQ09ERV9UT19CWVRFUyA9IHJldmVyc2VEaWN0aW9uYXJ5KEJZVEVTX1RPX1VOSUNPREUpO1xuXG4vKipcbiAqIEJQRSBjbGFzcyBmb3IgZW5jb2RpbmcgdGV4dCBpbnRvIEJ5dGUtUGFpci1FbmNvZGluZyAoQlBFKSB0b2tlbnMuXG4gKiBAZXh0ZW5kcyBUb2tlbml6ZXJNb2RlbFxuICovXG5jbGFzcyBCUEUgZXh0ZW5kcyBUb2tlbml6ZXJNb2RlbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgQlBFIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBCUEUuXG4gICAgICogQHBhcmFtIHtNYXA8c3RyaW5nLCBudW1iZXI+fSBjb25maWcudm9jYWIgQSBtYXBwaW5nIG9mIHRva2VucyB0byBpZHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy51bmtfdG9rZW4gVGhlIHVua25vd24gdG9rZW4gdXNlZCBmb3Igb3V0IG9mIHZvY2FidWxhcnkgd29yZHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5lbmRfb2Zfd29yZF9zdWZmaXggVGhlIHN1ZmZpeCB0byBwbGFjZSBhdCB0aGUgZW5kIG9mIGVhY2ggd29yZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWcubWVyZ2VzIEFuIGFycmF5IG9mIEJQRSBtZXJnZXMgYXMgc3RyaW5ncy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICB0aGlzLkJQRV9TUExJVF9UT0tFTiA9ICcgJztcblxuICAgICAgICB0aGlzLnRva2Vuc190b19pZHMgPSBjb25maWcudm9jYWI7XG5cbiAgICAgICAgdGhpcy51bmtfdG9rZW5faWQgPSB0aGlzLnRva2Vuc190b19pZHMuZ2V0KGNvbmZpZy51bmtfdG9rZW4pO1xuICAgICAgICB0aGlzLnVua190b2tlbiA9IGNvbmZpZy51bmtfdG9rZW47XG5cbiAgICAgICAgdGhpcy52b2NhYiA9IG5ldyBBcnJheSh0aGlzLnRva2Vuc190b19pZHMuc2l6ZSk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMudG9rZW5zX3RvX2lkcykge1xuICAgICAgICAgICAgdGhpcy52b2NhYlt2YWx1ZV0gPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJwZV9yYW5rcyA9IE9iamVjdC5mcm9tRW50cmllcyhjb25maWcubWVyZ2VzLm1hcCgoeCwgaSkgPT4gW3gsIGldKSk7XG4gICAgICAgIHRoaXMubWVyZ2VzID0gY29uZmlnLm1lcmdlcy5tYXAoeCA9PiB4LnNwbGl0KHRoaXMuQlBFX1NQTElUX1RPS0VOKSk7XG5cbiAgICAgICAgdGhpcy5lbmRfb2Zfd29yZF9zdWZmaXggPSBjb25maWcuZW5kX29mX3dvcmRfc3VmZml4O1xuXG4gICAgICAgIHRoaXMuYnl0ZV9mYWxsYmFjayA9IHRoaXMuY29uZmlnLmJ5dGVfZmFsbGJhY2sgPz8gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuYnl0ZV9mYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy50ZXh0X2VuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIHRoaXMuZnVzZV91bmsgPz89IHRoaXMuY29uZmlnLmZ1c2VfdW5rO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIHBvc3NpYmxlIHBhaXJzIG9mIGNoYXJhY3RlcnMgaW4gYSB3b3JkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHdvcmQgVGhlIHdvcmQgdG8gZ2V0IHBhaXJzIGZyb20uXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBwYWlycy5cbiAgICAgKi9cbiAgICBnZXRfcGFpcnMod29yZCkge1xuICAgICAgICBsZXQgcGFpcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBwcmV2X2NoYXIgPSB3b3JkWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdvcmQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjaGFyID0gd29yZFtpXTtcbiAgICAgICAgICAgIHBhaXJzLmFkZChwcmV2X2NoYXIgKyB0aGlzLkJQRV9TUExJVF9UT0tFTiArIGNoYXIpO1xuICAgICAgICAgICAgcHJldl9jaGFyID0gY2hhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShwYWlycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgQnl0ZS1QYWlyLUVuY29kaW5nIChCUEUpIHRvIGEgZ2l2ZW4gdG9rZW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRoZSB0b2tlbiB0byBlbmNvZGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIEJQRSBlbmNvZGVkIHRva2VuLlxuICAgICAqL1xuICAgIGJwZSh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4gaW4gdGhpcy5jYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3b3JkID0gQXJyYXkuZnJvbSh0b2tlbik7XG4gICAgICAgIGlmICh0aGlzLmVuZF9vZl93b3JkX3N1ZmZpeCkge1xuICAgICAgICAgICAgd29yZFt3b3JkLmxlbmd0aCAtIDFdICs9IHRoaXMuZW5kX29mX3dvcmRfc3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYWlycyA9IHRoaXMuZ2V0X3BhaXJzKHdvcmQpO1xuXG4gICAgICAgIGlmICghcGFpcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmRfb2Zfd29yZF9zdWZmaXgpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiArPSB0aGlzLmVuZF9vZl93b3JkX3N1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBsZXQgYmlncmFtID0gcGFpcnMucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB0aGlzLmJwZV9yYW5rc1thXSA/PyBJbmZpbml0eVxuICAgICAgICAgICAgICAgIGxldCBkID0gdGhpcy5icGVfcmFua3NbYl0gPz8gSW5maW5pdHlcbiAgICAgICAgICAgICAgICByZXR1cm4gYyA8PSBkID8gYSA6IGI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghKGJpZ3JhbSBpbiB0aGlzLmJwZV9yYW5rcykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBbZmlyc3QsIHNlY29uZF0gPSBiaWdyYW0uc3BsaXQodGhpcy5CUEVfU1BMSVRfVE9LRU4pO1xuICAgICAgICAgICAgbGV0IG5ld193b3JkID0gW107XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBsZXQgaiA9IC0xO1xuXG4gICAgICAgICAgICB3aGlsZSAoaSA8IHdvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaiA9IHdvcmQuaW5kZXhPZihmaXJzdCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09PSAtMSkgdGhyb3cgXCJFcnJvclwiO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3X3dvcmQucHVzaCguLi53b3JkLnNsaWNlKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld193b3JkLnB1c2goLi4ud29yZC5zbGljZShpLCBqKSk7XG4gICAgICAgICAgICAgICAgaSA9IGo7XG5cbiAgICAgICAgICAgICAgICBpZiAod29yZFtpXSA9PT0gZmlyc3QgJiYgaSA8IHdvcmQubGVuZ3RoIC0gMSAmJiB3b3JkW2kgKyAxXSA9PT0gc2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld193b3JkLnB1c2goZmlyc3QgKyBzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3X3dvcmQucHVzaCh3b3JkW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmQgPSBuZXdfd29yZFxuICAgICAgICAgICAgaWYgKHdvcmQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhaXJzID0gdGhpcy5nZXRfcGFpcnMod29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbmFsX3dvcmQgPSB3b3JkLmpvaW4odGhpcy5CUEVfU1BMSVRfVE9LRU4pO1xuICAgICAgICB0aGlzLmNhY2hlW3Rva2VuXSA9IGZpbmFsX3dvcmQ7XG4gICAgICAgIHJldHVybiBmaW5hbF93b3JkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIGlucHV0IHNlcXVlbmNlIG9mIHRva2VucyB1c2luZyB0aGUgQlBFIGFsZ29yaXRobSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIHN1YndvcmQgdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBUaGUgaW5wdXQgc2VxdWVuY2Ugb2YgdG9rZW5zIHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZXN1bHRpbmcgc3Vid29yZCB0b2tlbnMgYWZ0ZXIgYXBwbHlpbmcgdGhlIEJQRSBhbGdvcml0aG0gdG8gdGhlIGlucHV0IHNlcXVlbmNlIG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICBlbmNvZGUodG9rZW5zKSB7XG4gICAgICAgIGxldCBvdXRwdXRUb2tlbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIGxldCBicGVfdG9rZW5fbGlzdCA9IHRoaXMuYnBlKHRva2VuKS5zcGxpdCh0aGlzLkJQRV9TUExJVF9UT0tFTik7XG5cbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgYnBlX3Rva2VuX2xpc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b2tlbnNfdG9faWRzLmhhcyh0KSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb2tlbnMucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ieXRlX2ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb2tlbnMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5BcnJheS5mcm9tKHRoaXMudGV4dF9lbmNvZGVyLmVuY29kZSh0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCh4ID0+IGA8MHgke3gudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoMiwgJzAnKX0+YClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb2tlbnMucHVzaCh0aGlzLnVua190b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0VG9rZW5zO1xuICAgIH1cblxufVxuXG4vKipcbiAqIEEgYmFzZSBjbGFzcyBmb3IgdGV4dCBub3JtYWxpemF0aW9uLlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIE5vcm1hbGl6ZXIgZXh0ZW5kcyBDYWxsYWJsZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBub3JtYWxpemVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgbm9ybWFsaXplcnMgZnJvbSBjb25maWcgb2JqZWN0cy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBub3JtYWxpemVyLlxuICAgICAqIEByZXR1cm5zIHtOb3JtYWxpemVyfSBBIE5vcm1hbGl6ZXIgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbiB1bmtub3duIE5vcm1hbGl6ZXIgdHlwZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGNvbmZpZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHN3aXRjaCAoY29uZmlnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0JlcnROb3JtYWxpemVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJlcnROb3JtYWxpemVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdQcmVjb21waWxlZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVjb21waWxlZChjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnU2VxdWVuY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTm9ybWFsaXplclNlcXVlbmNlKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdSZXBsYWNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2UoY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ05GQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBORkMoY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ05GS0QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTkZLRChjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnU3RyaXBBY2NlbnRzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmlwQWNjZW50cyhjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnTG93ZXJjYXNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExvd2VyY2FzZShjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnUHJlcGVuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVwZW5kKGNvbmZpZyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBOb3JtYWxpemVyIHR5cGU6ICR7Y29uZmlnLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgdGhlIGlucHV0IHRleHQuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gbm9ybWFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBub3JtYWxpemVkIHRleHQuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBhIHN1YmNsYXNzLlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9ybWFsaXplIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzcy5cIilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIE5vcm1hbGl6ZXIjbm9ybWFsaXplfS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBub3JtYWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgdGV4dC5cbiAgICAgKi9cbiAgICBfY2FsbCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSh0ZXh0KTtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBSZXBsYWNlIG5vcm1hbGl6ZXIgdGhhdCByZXBsYWNlcyBvY2N1cnJlbmNlcyBvZiBhIHBhdHRlcm4gd2l0aCBhIGdpdmVuIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24uXG4gKiBAZXh0ZW5kcyBOb3JtYWxpemVyXG4gKi9cbmNsYXNzIFJlcGxhY2UgZXh0ZW5kcyBOb3JtYWxpemVyIHtcbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgdGhlIGlucHV0IHRleHQgYnkgcmVwbGFjaW5nIHRoZSBwYXR0ZXJuIHdpdGggdGhlIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIGlucHV0IHRleHQgdG8gYmUgbm9ybWFsaXplZC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCB0ZXh0IGFmdGVyIHJlcGxhY2luZyB0aGUgcGF0dGVybiB3aXRoIHRoZSBjb250ZW50LlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gY3JlYXRlUGF0dGVybih0aGlzLmNvbmZpZy5wYXR0ZXJuKTtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbChwYXR0ZXJuLCB0aGlzLmNvbmZpZy5jb250ZW50KVxuXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIG5vcm1hbGl6ZXIgdGhhdCBhcHBsaWVzIFVuaWNvZGUgbm9ybWFsaXphdGlvbiBmb3JtIEMgKE5GQykgdG8gdGhlIGlucHV0IHRleHQuXG4gKiBAZXh0ZW5kcyBOb3JtYWxpemVyXG4gKi9cbmNsYXNzIE5GQyBleHRlbmRzIE5vcm1hbGl6ZXIge1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSB0aGUgaW5wdXQgdGV4dCBieSBhcHBseWluZyBVbmljb2RlIG5vcm1hbGl6YXRpb24gZm9ybSBDIChORkMpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSBpbnB1dCB0ZXh0IHRvIGJlIG5vcm1hbGl6ZWQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgdGV4dC5cbiAgICAgKi9cbiAgICBub3JtYWxpemUodGV4dCkge1xuICAgICAgICB0ZXh0ID0gdGV4dC5ub3JtYWxpemUoJ05GQycpXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBORktEIE5vcm1hbGl6ZXIuXG4gKiBAZXh0ZW5kcyBOb3JtYWxpemVyXG4gKi9cbmNsYXNzIE5GS0QgZXh0ZW5kcyBOb3JtYWxpemVyIHtcbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgdGV4dCB1c2luZyBORktEIG5vcm1hbGl6YXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gYmUgbm9ybWFsaXplZC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCB0ZXh0LlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIHRleHQgPSB0ZXh0Lm5vcm1hbGl6ZSgnTkZLRCcpXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBTdHJpcEFjY2VudHMgbm9ybWFsaXplciByZW1vdmVzIGFsbCBhY2NlbnRzIGZyb20gdGhlIHRleHQuXG4gKiBAZXh0ZW5kcyBOb3JtYWxpemVyXG4gKi9cbmNsYXNzIFN0cmlwQWNjZW50cyBleHRlbmRzIE5vcm1hbGl6ZXIge1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgYWNjZW50cyBmcm9tIHRoZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBub3JtYWxpemVkIHRleHQgd2l0aG91dCBhY2NlbnRzLlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1tcXHUwMzAwLVxcdTAzNmZdL2csICcnKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgTm9ybWFsaXplciB0aGF0IGxvd2VyY2FzZXMgdGhlIGlucHV0IHN0cmluZy5cbiAqIEBleHRlbmRzIE5vcm1hbGl6ZXJcbiAqL1xuY2xhc3MgTG93ZXJjYXNlIGV4dGVuZHMgTm9ybWFsaXplciB7XG4gICAgLyoqXG4gICAgICogTG93ZXJjYXNlcyB0aGUgaW5wdXQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIG5vcm1hbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCB0ZXh0LlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIE5vcm1hbGl6ZXIgdGhhdCBwcmVwZW5kcyBhIHN0cmluZyB0byB0aGUgaW5wdXQgc3RyaW5nLlxuICogQGV4dGVuZHMgTm9ybWFsaXplclxuICovXG5jbGFzcyBQcmVwZW5kIGV4dGVuZHMgTm9ybWFsaXplciB7XG4gICAgLyoqXG4gICAgICogUHJlcGVuZHMgdGhlIGlucHV0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBub3JtYWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgdGV4dC5cbiAgICAgKi9cbiAgICBub3JtYWxpemUodGV4dCkge1xuICAgICAgICB0ZXh0ID0gdGhpcy5jb25maWcucHJlcGVuZCArIHRleHQ7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIE5vcm1hbGl6ZXIgdGhhdCBhcHBsaWVzIGEgc2VxdWVuY2Ugb2YgTm9ybWFsaXplcnMuXG4gKiBAZXh0ZW5kcyBOb3JtYWxpemVyXG4gKi9cbmNsYXNzIE5vcm1hbGl6ZXJTZXF1ZW5jZSBleHRlbmRzIE5vcm1hbGl6ZXIge1xuICAgIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgTm9ybWFsaXplclNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3RbXX0gY29uZmlnLm5vcm1hbGl6ZXJzIEFuIGFycmF5IG9mIE5vcm1hbGl6ZXIgY29uZmlndXJhdGlvbiBvYmplY3RzLlxuICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVycyA9IGNvbmZpZy5ub3JtYWxpemVycy5tYXAoeCA9PiBOb3JtYWxpemVyLmZyb21Db25maWcoeCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFwcGx5IGEgc2VxdWVuY2Ugb2YgTm9ybWFsaXplcnMgdG8gdGhlIGlucHV0IHRleHQuXG4gICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBub3JtYWxpemUuXG4gICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbm9ybWFsaXplZCB0ZXh0LlxuICAgICovXG4gICAgbm9ybWFsaXplKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplcnMucmVkdWNlKCh0LCBub3JtYWxpemVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplci5ub3JtYWxpemUodCk7XG4gICAgICAgIH0sIHRleHQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIG5vcm1hbGl6ZXIgdXNlZCBpbiBCRVJUIHRva2VuaXphdGlvbi5cbiAqIEBleHRlbmRzIE5vcm1hbGl6ZXJcbiAqL1xuY2xhc3MgQmVydE5vcm1hbGl6ZXIgZXh0ZW5kcyBOb3JtYWxpemVyIHtcbiAgICAvKipcbiAgICAgKiBBZGRzIHdoaXRlc3BhY2UgYXJvdW5kIGFueSBDSksgKENoaW5lc2UsIEphcGFuZXNlLCBvciBLb3JlYW4pIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQgdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSBpbnB1dCB0ZXh0IHRvIHRva2VuaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0b2tlbml6ZWQgdGV4dCB3aXRoIHdoaXRlc3BhY2UgYWRkZWQgYXJvdW5kIENKSyBjaGFyYWN0ZXJzLlxuICAgICAqL1xuICAgIF90b2tlbml6ZV9jaGluZXNlX2NoYXJzKHRleHQpIHtcbiAgICAgICAgLyogQWRkcyB3aGl0ZXNwYWNlIGFyb3VuZCBhbnkgQ0pLIGNoYXJhY3Rlci4gKi9cbiAgICAgICAgbGV0IG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjaGFyID0gdGV4dFtpXTtcbiAgICAgICAgICAgIGxldCBjcCA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc19jaGluZXNlX2NoYXIoY3ApKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goXCIgXCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKFwiIFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goY2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBVbmljb2RlIGNvZGVwb2ludCByZXByZXNlbnRzIGEgQ0pLIChDaGluZXNlLCBKYXBhbmVzZSwgb3IgS29yZWFuKSBjaGFyYWN0ZXIuXG4gICAgICpcbiAgICAgKiBBIFwiY2hpbmVzZSBjaGFyYWN0ZXJcIiBpcyBkZWZpbmVkIGFzIGFueXRoaW5nIGluIHRoZSBDSksgVW5pY29kZSBibG9jazpcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DSktfVW5pZmllZF9JZGVvZ3JhcGhzXyhVbmljb2RlX2Jsb2NrKVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBDSksgVW5pY29kZSBibG9jayBpcyBOT1QgYWxsIEphcGFuZXNlIGFuZCBLb3JlYW4gY2hhcmFjdGVycywgZGVzcGl0ZSBpdHMgbmFtZS5cbiAgICAgKiBUaGUgbW9kZXJuIEtvcmVhbiBIYW5ndWwgYWxwaGFiZXQgaXMgYSBkaWZmZXJlbnQgYmxvY2ssIGFzIGlzIEphcGFuZXNlIEhpcmFnYW5hIGFuZCBLYXRha2FuYS5cbiAgICAgKiBUaG9zZSBhbHBoYWJldHMgYXJlIHVzZWQgdG8gd3JpdGUgc3BhY2Utc2VwYXJhdGVkIHdvcmRzLCBzbyB0aGV5IGFyZSBub3QgdHJlYXRlZCBzcGVjaWFsbHlcbiAgICAgKiBhbmQgYXJlIGhhbmRsZWQgbGlrZSBhbGwgb3RoZXIgbGFuZ3VhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwIFRoZSBVbmljb2RlIGNvZGVwb2ludCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29kZXBvaW50IHJlcHJlc2VudHMgYSBDSksgY2hhcmFjdGVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgX2lzX2NoaW5lc2VfY2hhcihjcCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGNwID49IDB4NEUwMCAmJiBjcCA8PSAweDlGRkYpXG4gICAgICAgICAgICB8fCAoY3AgPj0gMHgzNDAwICYmIGNwIDw9IDB4NERCRilcbiAgICAgICAgICAgIHx8IChjcCA+PSAweDIwMDAwICYmIGNwIDw9IDB4MkE2REYpXG4gICAgICAgICAgICB8fCAoY3AgPj0gMHgyQTcwMCAmJiBjcCA8PSAweDJCNzNGKVxuICAgICAgICAgICAgfHwgKGNwID49IDB4MkI3NDAgJiYgY3AgPD0gMHgyQjgxRilcbiAgICAgICAgICAgIHx8IChjcCA+PSAweDJCODIwICYmIGNwIDw9IDB4MkNFQUYpXG4gICAgICAgICAgICB8fCAoY3AgPj0gMHhGOTAwICYmIGNwIDw9IDB4RkFGRilcbiAgICAgICAgICAgIHx8IChjcCA+PSAweDJGODAwICYmIGNwIDw9IDB4MkZBMUYpXG4gICAgICAgIClcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RyaXBzIGFjY2VudHMgZnJvbSB0aGUgZ2l2ZW4gdGV4dC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzdHJpcCBhY2NlbnRzIGZyb20uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRleHQgd2l0aCBhY2NlbnRzIHJlbW92ZWQuXG4gICAgICovXG4gICAgc3RyaXBBY2NlbnRzKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQubm9ybWFsaXplKCdORkQnKS5yZXBsYWNlKC9bXFx1MDMwMC1cXHUwMzZmXS9nLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gdGV4dCBiYXNlZCBvbiB0aGUgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBub3JtYWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5vcm1hbGl6ZWQgdGV4dC5cbiAgICAgKi9cbiAgICBub3JtYWxpemUodGV4dCkge1xuICAgICAgICAvLyBUT0RPIHVzZSByZXN0IG9mIGNvbmZpZ1xuICAgICAgICAvLyBjb25maWcuY2xlYW5fdGV4dCxcbiAgICAgICAgLy8gY29uZmlnLmhhbmRsZV9jaGluZXNlX2NoYXJzLFxuICAgICAgICAvLyBjb25maWcuc3RyaXBfYWNjZW50cyxcbiAgICAgICAgLy8gY29uZmlnLmxvd2VyY2FzZSxcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuaGFuZGxlX2NoaW5lc2VfY2hhcnMpIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLl90b2tlbml6ZV9jaGluZXNlX2NoYXJzKHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvd2VyY2FzZSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnN0cmlwX2FjY2VudHMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMuc3RyaXBBY2NlbnRzKHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29uZmlnLnN0cmlwX2FjY2VudHMpIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnN0cmlwQWNjZW50cyh0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGNhbGxhYmxlIGNsYXNzIHJlcHJlc2VudGluZyBhIHByZS10b2tlbml6ZXIgdXNlZCBpbiB0b2tlbml6YXRpb24uIFN1YmNsYXNzZXNcbiAqIHNob3VsZCBpbXBsZW1lbnQgdGhlIGBwcmVfdG9rZW5pemVfdGV4dGAgbWV0aG9kIHRvIGRlZmluZSB0aGUgc3BlY2lmaWMgcHJlLXRva2VuaXphdGlvbiBsb2dpYy5cbiAqIEBleHRlbmRzIENhbGxhYmxlXG4gKi9cbmNsYXNzIFByZVRva2VuaXplciBleHRlbmRzIENhbGxhYmxlIHtcbiAgICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdGhhdCByZXR1cm5zIGFuIGluc3RhbmNlIG9mIGEgc3ViY2xhc3Mgb2YgYFByZVRva2VuaXplcmAgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgcHJlLXRva2VuaXplci5cbiAgICogQHJldHVybnMge1ByZVRva2VuaXplcn0gQW4gaW5zdGFuY2Ugb2YgYSBzdWJjbGFzcyBvZiBgUHJlVG9rZW5pemVyYC5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uIG9iamVjdCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGFueSBrbm93biBwcmUtdG9rZW5pemVyLlxuICAgKi9cbiAgICBzdGF0aWMgZnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnQmVydFByZVRva2VuaXplcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCZXJ0UHJlVG9rZW5pemVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdTZXF1ZW5jZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVUb2tlbml6ZXJTZXF1ZW5jZShjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnV2hpdGVzcGFjZVNwbGl0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFdoaXRlc3BhY2VTcGxpdChjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnTWV0YXNwYWNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1ldGFzcGFjZVByZVRva2VuaXplcihjb25maWcpO1xuXG4gICAgICAgICAgICBjYXNlICdCeXRlTGV2ZWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUxldmVsUHJlVG9rZW5pemVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdTcGxpdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGxpdFByZVRva2VuaXplcihjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnUHVuY3R1YXRpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHVuY3R1YXRpb25QcmVUb2tlbml6ZXIoY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ0RpZ2l0cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEaWdpdHNQcmVUb2tlbml6ZXIoY29uZmlnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFByZVRva2VuaXplciB0eXBlOiAke2NvbmZpZy50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAqIE1ldGhvZCB0aGF0IHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzIHRvIGRlZmluZSB0aGUgc3BlY2lmaWMgcHJlLXRva2VuaXphdGlvbiBsb2dpYy5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHByZS10b2tlbml6ZS5cbiAgICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgcHJlLXRva2VuaXplZCB0ZXh0LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIHN1YmNsYXNzLlxuICAgKi9cbiAgICBwcmVfdG9rZW5pemVfdGV4dCh0ZXh0KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwicHJlX3Rva2VuaXplX3RleHQgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRva2VuaXplcyB0aGUgZ2l2ZW4gdGV4dCBpbnRvIHByZS10b2tlbnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHRleHQgVGhlIHRleHQgb3IgYXJyYXkgb2YgdGV4dHMgdG8gcHJlLXRva2VuaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgcHJlLXRva2Vucy5cbiAgICAgKi9cbiAgICBwcmVfdG9rZW5pemUodGV4dCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRleHQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0ZXh0Lm1hcCh4ID0+IHRoaXMucHJlX3Rva2VuaXplX3RleHQoeCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByZV90b2tlbml6ZV90ZXh0KHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuZmxhdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgUHJlVG9rZW5pemVyI3ByZV90b2tlbml6ZX0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHRleHQgVGhlIHRleHQgb3IgYXJyYXkgb2YgdGV4dHMgdG8gcHJlLXRva2VuaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgcHJlLXRva2Vucy5cbiAgICAgKi9cbiAgICBfY2FsbCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZV90b2tlbml6ZSh0ZXh0KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGV4dGVuZHMgUHJlVG9rZW5pemVyXG4gKi9cbmNsYXNzIEJlcnRQcmVUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIEEgUHJlVG9rZW5pemVyIHRoYXQgc3BsaXRzIHRleHQgaW50byB3b3JkcGllY2VzIHVzaW5nIGEgYmFzaWMgdG9rZW5pemF0aW9uIHNjaGVtZVxuICAgICAqIHNpbWlsYXIgdG8gdGhhdCB1c2VkIGluIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBvZiBCRVJULlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBwYXR0ZXJuIHdoaWNoIG1hdGNoZXMgdGhlIHJ1c3QgaW1wbGVtZW50YXRpb246XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9odWdnaW5nZmFjZS90b2tlbml6ZXJzL2Jsb2IvYjRmY2M5Y2U2ZTRhZDU4MDZlODI4MjZmODE2YWNmZGZkYzRmY2M2Ny90b2tlbml6ZXJzL3NyYy9wcmVfdG9rZW5pemVycy9iZXJ0LnJzI0wxMVxuICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHJlbW92aW5nIHdoaXRlc3BhY2UgYW5kIHNwbGl0dGluZyBvbiBwdW5jdHVhdGlvbiAoYm90aCBcXHB7UH0gYW5kIG90aGVyIGFzY2lpIGNoYXJhY3RlcnMpXG4gICAgICAgIHRoaXMucGF0dGVybiA9IG5ldyBSZWdFeHAoYFteXFxcXHMke1BVTkNUVUFUSU9OX1JFR0VYfV0rfFske1BVTkNUVUFUSU9OX1JFR0VYfV1gLCAnZ3UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9rZW5pemVzIGEgc2luZ2xlIHRleHQgdXNpbmcgdGhlIEJFUlQgcHJlLXRva2VuaXphdGlvbiBzY2hlbWUuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gdG9rZW5pemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgcHJlX3Rva2VuaXplX3RleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC50cmltKCkubWF0Y2godGhpcy5wYXR0ZXJuKSB8fCBbXTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBwcmUtdG9rZW5pemVyIHRoYXQgc3BsaXRzIHRleHQgaW50byBCeXRlLVBhaXItRW5jb2RpbmcgKEJQRSkgc3Vid29yZHMuXG4gKiBAZXh0ZW5kcyBQcmVUb2tlbml6ZXJcbiAqL1xuY2xhc3MgQnl0ZUxldmVsUHJlVG9rZW5pemVyIGV4dGVuZHMgUHJlVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgQnl0ZUxldmVsUHJlVG9rZW5pemVyYCBjbGFzcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRvIGFkZCBhIGxlYWRpbmcgc3BhY2UgdG8gdGhlIGZpcnN0IHdvcmQuXG4gICAgICAgICAqIFRoaXMgYWxsb3dzIHRvIHRyZWF0IHRoZSBsZWFkaW5nIHdvcmQganVzdCBhcyBhbnkgb3RoZXIgd29yZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkX3ByZWZpeF9zcGFjZSA9IHRoaXMuY29uZmlnLmFkZF9wcmVmaXhfc3BhY2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRoZSBwb3N0IHByb2Nlc3Npbmcgc3RlcCBzaG91bGQgdHJpbSBvZmZzZXRzXG4gICAgICAgICAqIHRvIGF2b2lkIGluY2x1ZGluZyB3aGl0ZXNwYWNlcy5cbiAgICAgICAgICogQHRvZG8gVXNlIHRoaXMgaW4gdGhlIHByZXRva2VuaXphdGlvbiBzdGVwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmltX29mZnNldHMgPSB0aGlzLmNvbmZpZy50cmltX29mZnNldHM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRvIHVzZSB0aGUgc3RhbmRhcmQgR1BUMiByZWdleCBmb3Igd2hpdGVzcGFjZSBzcGxpdHRpbmcuXG4gICAgICAgICAqIFNldCBpdCB0byBGYWxzZSBpZiB5b3Ugd2FudCB0byB1c2UgeW91ciBvd24gc3BsaXR0aW5nLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VfcmVnZXggPSB0aGlzLmNvbmZpZy51c2VfcmVnZXggPz8gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gLydzfCd0fCdyZXwndmV8J218J2xsfCdkfCA/XFxwe0x9K3wgP1xccHtOfSt8ID9bXlxcc1xccHtMfVxccHtOfV0rfFxccysoPyFcXFMpfFxccysvZ3U7XG5cbiAgICAgICAgdGhpcy5ieXRlX2VuY29kZXIgPSBCWVRFU19UT19VTklDT0RFO1xuICAgICAgICB0aGlzLnRleHRfZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRva2VuaXplcyBhIHNpbmdsZSBwaWVjZSBvZiB0ZXh0IHVzaW5nIGJ5dGUtbGV2ZWwgdG9rZW5pemF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHRva2VuaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgdG9rZW5zLlxuICAgICAqL1xuICAgIHByZV90b2tlbml6ZV90ZXh0KHRleHQpIHtcbiAgICAgICAgLy8gU3BsaXQgb24gd2hpdGVzcGFjZSBhbmQgcHVuY3R1YXRpb25cbiAgICAgICAgbGV0IHRva2VucyA9IHRoaXMudXNlX3JlZ2V4ID8gKHRleHQubWF0Y2godGhpcy5wYXR0ZXJuKSB8fCBbXSkgOiBbdGV4dF07XG5cbiAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAodG9rZW4gPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkX3ByZWZpeF9zcGFjZSAmJiAhdG9rZW4uc3RhcnRzV2l0aCgnICcpKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSAnICcgKyB0b2tlbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFwcyBhbGwgb3VyIGJ5dGVzIHRvIHVuaWNvZGUgc3RyaW5ncywgYXZvaWRpbmcgY29udHJvbCB0b2tlbnMgb2YgdGhlIEJQRSAoc3BhY2VzIGluIG91ciBjYXNlKVxuICAgICAgICAgICAgdG9rZW4gPSBBcnJheS5mcm9tKHRoaXMudGV4dF9lbmNvZGVyLmVuY29kZSh0b2tlbiksIGJ5dGUgPT4gdGhpcy5ieXRlX2VuY29kZXJbYnl0ZV0pLmpvaW4oJycpO1xuXG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7J3JlbW92ZWQnfCdpc29sYXRlZCd8J21lcmdlZFdpdGhQcmV2aW91cyd8J21lcmdlZFdpdGhOZXh0J3wnY29udGlndW91cyd9IFNwbGl0RGVsaW1pdGVyQmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIFNwbGl0cyB0ZXh0IHVzaW5nIGEgZ2l2ZW4gcGF0dGVybi5cbiAqIEBleHRlbmRzIFByZVRva2VuaXplclxuICovXG5jbGFzcyBTcGxpdFByZVRva2VuaXplciBleHRlbmRzIFByZVRva2VuaXplciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgcHJlLXRva2VuaXplci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnBhdHRlcm4gVGhlIHBhdHRlcm4gdXNlZCB0byBzcGxpdCB0aGUgdGV4dC4gQ2FuIGJlIGEgc3RyaW5nIG9yIGEgcmVnZXggb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gY29uZmlnLnBhdHRlcm4uU3RyaW5nIFRoZSBzdHJpbmcgdG8gdXNlIGZvciBzcGxpdHRpbmcuIE9ubHkgZGVmaW5lZCBpZiB0aGUgcGF0dGVybiBpcyBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGNvbmZpZy5wYXR0ZXJuLlJlZ2V4IFRoZSByZWdleCB0byB1c2UgZm9yIHNwbGl0dGluZy4gT25seSBkZWZpbmVkIGlmIHRoZSBwYXR0ZXJuIGlzIGEgcmVnZXguXG4gICAgICogQHBhcmFtIHtTcGxpdERlbGltaXRlckJlaGF2aW9yfSBjb25maWcuYmVoYXZpb3IgVGhlIGJlaGF2aW9yIHRvIHVzZSB3aGVuIHNwbGl0dGluZy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmZpZy5pbnZlcnQgV2hldGhlciB0byBzcGxpdCAoaW52ZXJ0PWZhbHNlKSBvciBtYXRjaCAoaW52ZXJ0PXRydWUpIHRoZSBwYXR0ZXJuLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gVE9ETyBzdXBwb3J0IGFsbCBiZWhhdmlvdXJzIChjb25maWcuYmVoYXZpb3IpXG5cbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gY3JlYXRlUGF0dGVybih0aGlzLmNvbmZpZy5wYXR0ZXJuLCB0aGlzLmNvbmZpZy5pbnZlcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRva2VuaXplcyB0ZXh0IGJ5IHNwbGl0dGluZyBpdCB1c2luZyB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byB0b2tlbml6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IEFuIGFycmF5IG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICBwcmVfdG9rZW5pemVfdGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnBhdHRlcm4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pbnZlcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0Lm1hdGNoKHRoaXMucGF0dGVybikgfHwgW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dC5zcGxpdCh0aGlzLnBhdHRlcm4pLmZpbHRlcih4ID0+IHgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFNwbGl0cyB0ZXh0IGJhc2VkIG9uIHB1bmN0dWF0aW9uLlxuICogQGV4dGVuZHMgUHJlVG9rZW5pemVyXG4gKi9cbmNsYXNzIFB1bmN0dWF0aW9uUHJlVG9rZW5pemVyIGV4dGVuZHMgUHJlVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBwcmUtdG9rZW5pemVyLlxuICAgICAqIEBwYXJhbSB7U3BsaXREZWxpbWl0ZXJCZWhhdmlvcn0gY29uZmlnLmJlaGF2aW9yIFRoZSBiZWhhdmlvciB0byB1c2Ugd2hlbiBzcGxpdHRpbmcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBuZXcgUmVnRXhwKGBbXiR7UFVOQ1RVQVRJT05fUkVHRVh9XSt8WyR7UFVOQ1RVQVRJT05fUkVHRVh9XStgLCAnZ3UnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2tlbml6ZXMgdGV4dCBieSBzcGxpdHRpbmcgaXQgdXNpbmcgdGhlIGdpdmVuIHBhdHRlcm4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gdG9rZW5pemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBBbiBhcnJheSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgcHJlX3Rva2VuaXplX3RleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC5tYXRjaCh0aGlzLnBhdHRlcm4pIHx8IFtdO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIFNwbGl0cyB0ZXh0IGJhc2VkIG9uIGRpZ2l0cy5cbiAqIEBleHRlbmRzIFByZVRva2VuaXplclxuICovXG5jbGFzcyBEaWdpdHNQcmVUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHByZS10b2tlbml6ZXIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWcuaW5kaXZpZHVhbF9kaWdpdHMgV2hldGhlciB0byBzcGxpdCBvbiBpbmRpdmlkdWFsIGRpZ2l0cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IGEgcGF0dGVybiB3aGljaCBtYXRjaGVzIHRoZSBydXN0IGltcGxlbWVudGF0aW9uOlxuICAgICAgICBjb25zdCBkaWdpdF9wYXR0ZXJuID0gYFteXFxcXGRdK3xcXFxcZCR7dGhpcy5jb25maWcuaW5kaXZpZHVhbF9kaWdpdHMgPyAnJyA6ICcrJ31gO1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBuZXcgUmVnRXhwKGRpZ2l0X3BhdHRlcm4sICdndScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRva2VuaXplcyB0ZXh0IGJ5IHNwbGl0dGluZyBpdCB1c2luZyB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byB0b2tlbml6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IEFuIGFycmF5IG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICBwcmVfdG9rZW5pemVfdGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0Lm1hdGNoKHRoaXMucGF0dGVybikgfHwgW107XG4gICAgfVxufVxuXG4vKipcbiAqIEBleHRlbmRzIENhbGxhYmxlXG4gKi9cbmNsYXNzIFBvc3RQcm9jZXNzb3IgZXh0ZW5kcyBDYWxsYWJsZSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgcG9zdC1wcm9jZXNzb3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIFBvc3RQcm9jZXNzb3Igb2JqZWN0IGZyb20gYSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgUG9zdFByb2Nlc3Nvci5cbiAgICAgKiBAcmV0dXJucyB7UG9zdFByb2Nlc3Nvcn0gQSBQb3N0UHJvY2Vzc29yIG9iamVjdCBjcmVhdGVkIGZyb20gdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGFuIHVua25vd24gUG9zdFByb2Nlc3NvciB0eXBlIGlzIGVuY291bnRlcmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQ29uZmlnKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgc3dpdGNoIChjb25maWcudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnVGVtcGxhdGVQcm9jZXNzaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlUHJvY2Vzc2luZyhjb25maWcpO1xuXG4gICAgICAgICAgICBjYXNlICdCeXRlTGV2ZWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUxldmVsUG9zdFByb2Nlc3Nvcihjb25maWcpO1xuXG4gICAgICAgICAgICBjYXNlICdSb2JlcnRhUHJvY2Vzc2luZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSb2JlcnRhUHJvY2Vzc2luZyhjb25maWcpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBQb3N0UHJvY2Vzc29yIHR5cGU6ICR7Y29uZmlnLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3MgdG8gYXBwbHkgcG9zdC1wcm9jZXNzaW5nIG9uIHRoZSBnaXZlbiB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0b2tlbnMgVGhlIGlucHV0IHRva2VucyB0byBiZSBwb3N0LXByb2Nlc3NlZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgcmVxdWlyZWQgYnkgdGhlIHBvc3QtcHJvY2Vzc2luZyBsb2dpYy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBwb3N0LXByb2Nlc3NlZCB0b2tlbnMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlxuICAgICAqL1xuICAgIHBvc3RfcHJvY2Vzcyh0b2tlbnMsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJwb3N0X3Byb2Nlc3Mgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzLlwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgUG9zdFByb2Nlc3NvciNwb3N0X3Byb2Nlc3N9LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBUaGUgdGV4dCBvciBhcnJheSBvZiB0ZXh0cyB0byBwb3N0LXByb2Nlc3MuXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHJlcXVpcmVkIGJ5IHRoZSBwb3N0LXByb2Nlc3NpbmcgbG9naWMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBwb3N0LXByb2Nlc3NlZCB0b2tlbnMuXG4gICAgICovXG4gICAgX2NhbGwodG9rZW5zLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc3RfcHJvY2Vzcyh0b2tlbnMsIC4uLmFyZ3MpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHBvc3QtcHJvY2Vzc29yIHRoYXQgYWRkcyBzcGVjaWFsIHRva2VucyB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGlucHV0LlxuICogQGV4dGVuZHMgUG9zdFByb2Nlc3NvclxuICovXG5jbGFzcyBSb2JlcnRhUHJvY2Vzc2luZyBleHRlbmRzIFBvc3RQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBwb3N0LXByb2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBjb25maWcuY2xzIFRoZSBzcGVjaWFsIHRva2VucyB0byBhZGQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgaW5wdXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gY29uZmlnLnNlcCBUaGUgc3BlY2lhbCB0b2tlbnMgdG8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICAvLyBUT0RPIHVzZSBhbGwgb2YgY29uZmlnOiBhZGRfcHJlZml4X3NwYWNlLCB0cmltX29mZnNldHNcblxuICAgICAgICB0aGlzLmNscyA9IGNvbmZpZy5jbHNbMF07XG4gICAgICAgIHRoaXMuc2VwID0gY29uZmlnLnNlcFswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBzcGVjaWFsIHRva2VucyB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBUaGUgaW5wdXQgdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW118bnVsbH0gdG9rZW5zX3BhaXIgQW4gb3B0aW9uYWwgc2Vjb25kIHNldCBvZiBpbnB1dCB0b2tlbnMuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgaW5wdXQgdG9rZW5zIHdpdGggdGhlIHNwZWNpYWwgdG9rZW5zIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZC5cbiAgICAgKi9cbiAgICBwb3N0X3Byb2Nlc3ModG9rZW5zLCB0b2tlbnNfcGFpciA9IG51bGwpIHtcbiAgICAgICAgdG9rZW5zID0gbWVyZ2VBcnJheXMoW3RoaXMuY2xzXSwgdG9rZW5zLCBbdGhpcy5zZXBdKTtcblxuICAgICAgICAvLyBOT1RFOiBJdCBpcyBpbnRlbmRlZCB0byBhZGQgMiBFT1MgdG9rZW5zIGFmdGVyIHRoZSBmaXJzdCBzZXQgb2YgdG9rZW5zXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9odWdnaW5nZmFjZS90b2tlbml6ZXJzL2lzc3Vlcy85ODNcbiAgICAgICAgaWYgKHRva2Vuc19wYWlyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b2tlbnMgPSBtZXJnZUFycmF5cyh0b2tlbnMsIFt0aGlzLnNlcF0sIHRva2Vuc19wYWlyLCBbdGhpcy5zZXBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQb3N0IHByb2Nlc3NvciB0aGF0IHJlcGxhY2VzIHNwZWNpYWwgdG9rZW5zIGluIGEgdGVtcGxhdGUgd2l0aCBhY3R1YWwgdG9rZW5zLlxuICogQGV4dGVuZHMgUG9zdFByb2Nlc3NvclxuICovXG5jbGFzcyBUZW1wbGF0ZVByb2Nlc3NpbmcgZXh0ZW5kcyBQb3N0UHJvY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGBUZW1wbGF0ZVByb2Nlc3NpbmdgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHBvc3QgcHJvY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZy5zaW5nbGUgVGhlIHRlbXBsYXRlIGZvciBhIHNpbmdsZSBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29uZmlnLnBhaXIgVGhlIHRlbXBsYXRlIGZvciBhIHBhaXIgb2Ygc2VxdWVuY2VzIG9mIHRva2Vucy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcblxuICAgICAgICB0aGlzLnNpbmdsZSA9IGNvbmZpZy5zaW5nbGU7XG4gICAgICAgIHRoaXMucGFpciA9IGNvbmZpZy5wYWlyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHNwZWNpYWwgdG9rZW5zIGluIHRoZSB0ZW1wbGF0ZSB3aXRoIGFjdHVhbCB0b2tlbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIFRoZSBsaXN0IG9mIHRva2VucyBmb3IgdGhlIGZpcnN0IHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt0b2tlbnNfcGFpcj1udWxsXSBUaGUgbGlzdCBvZiB0b2tlbnMgZm9yIHRoZSBzZWNvbmQgc2VxdWVuY2UgKG9wdGlvbmFsKS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBsaXN0IG9mIHRva2VucyB3aXRoIHRoZSBzcGVjaWFsIHRva2VucyByZXBsYWNlZCB3aXRoIGFjdHVhbCB0b2tlbnMuXG4gICAgICovXG4gICAgcG9zdF9wcm9jZXNzKHRva2VucywgdG9rZW5zX3BhaXIgPSBudWxsKSB7XG4gICAgICAgIGxldCB0eXBlID0gdG9rZW5zX3BhaXIgPT09IG51bGwgPyB0aGlzLnNpbmdsZSA6IHRoaXMucGFpclxuXG4gICAgICAgIGxldCB0b1JldHVybiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHR5cGUpIHtcbiAgICAgICAgICAgIGlmICgnU3BlY2lhbFRva2VuJyBpbiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgdG9SZXR1cm4ucHVzaChpdGVtLlNwZWNpYWxUb2tlbi5pZCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJ1NlcXVlbmNlJyBpbiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uU2VxdWVuY2UuaWQgPT09ICdBJykge1xuICAgICAgICAgICAgICAgICAgICB0b1JldHVybiA9IG1lcmdlQXJyYXlzKHRvUmV0dXJuLCB0b2tlbnMpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLlNlcXVlbmNlLmlkID09PSAnQicpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm4gPSBtZXJnZUFycmF5cyh0b1JldHVybiwgdG9rZW5zX3BhaXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgfVxufVxuXG4vKipcbiAqIEEgUG9zdFByb2Nlc3NvciB0aGF0IHJldHVybnMgdGhlIGdpdmVuIHRva2VucyBhcyBpcy5cbiAqIEBleHRlbmRzIFBvc3RQcm9jZXNzb3JcbiAqL1xuY2xhc3MgQnl0ZUxldmVsUG9zdFByb2Nlc3NvciBleHRlbmRzIFBvc3RQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIFBvc3QgcHJvY2VzcyB0aGUgZ2l2ZW4gdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBUaGUgdG9rZW5zIHRvIGJlIHBvc3QgcHJvY2Vzc2VkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIHBvc3QgcHJvY2Vzc2VkIHRva2Vucy5cbiAgICAgKi9cbiAgICBwb3N0X3Byb2Nlc3ModG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciB0b2tlbiBkZWNvZGVycy5cbiAqIEBleHRlbmRzIENhbGxhYmxlXG4gKi9cbmNsYXNzIERlY29kZXIgZXh0ZW5kcyBDYWxsYWJsZSB7XG5cbiAgICAvKipcbiAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYERlY29kZXJgLlxuICAgICpcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuXG4gICAgICAgIHRoaXMuYWRkZWRfdG9rZW5zID0gW107XG4gICAgICAgIHRoaXMuZW5kX29mX3dvcmRfc3VmZml4ID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmltX29mZnNldHMgPSBjb25maWcudHJpbV9vZmZzZXRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgKiBDcmVhdGVzIGEgZGVjb2RlciBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtEZWNvZGVyfSBBIGRlY29kZXIgaW5zdGFuY2UuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbiB1bmtub3duIGRlY29kZXIgdHlwZSBpcyBwcm92aWRlZC5cbiAgICovXG4gICAgc3RhdGljIGZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHN3aXRjaCAoY29uZmlnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1dvcmRQaWVjZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkUGllY2VEZWNvZGVyKGNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlICdNZXRhc3BhY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWV0YXNwYWNlRGVjb2Rlcihjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnQnl0ZUxldmVsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVMZXZlbERlY29kZXIoY29uZmlnKTtcblxuICAgICAgICAgICAgY2FzZSAnUmVwbGFjZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlRGVjb2Rlcihjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnQnl0ZUZhbGxiYWNrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ5dGVGYWxsYmFjayhjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnRnVzZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdXNlRGVjb2Rlcihjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAnU3RyaXAnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaXBEZWNvZGVyKGNvbmZpZyk7XG5cbiAgICAgICAgICAgIGNhc2UgJ1NlcXVlbmNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZXJTZXF1ZW5jZShjb25maWcpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBEZWNvZGVyIHR5cGU6ICR7Y29uZmlnLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIENhbGxzIHRoZSBgZGVjb2RlYCBtZXRob2QuXG4gICAgKlxuICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9rZW5zIFRoZSBsaXN0IG9mIHRva2Vucy5cbiAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAgICAqL1xuICAgIF9jYWxsKHRva2Vucykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUodG9rZW5zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIERlY29kZXMgYSBsaXN0IG9mIHRva2Vucy5cbiAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBUaGUgbGlzdCBvZiB0b2tlbnMuXG4gICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gICAgKi9cbiAgICBkZWNvZGUodG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZV9jaGFpbih0b2tlbnMpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBkZWNvZGVyIHRvIGEgbGlzdCBvZiB0b2tlbnMuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9rZW5zIFRoZSBsaXN0IG9mIHRva2Vucy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBkZWNvZGVkIGxpc3Qgb2YgdG9rZW5zLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgYGRlY29kZV9jaGFpbmAgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgc3ViY2xhc3MuXG4gICAgICovXG4gICAgZGVjb2RlX2NoYWluKHRva2Vucykge1xuICAgICAgICB0aHJvdyBFcnJvcihcImBkZWNvZGVfY2hhaW5gIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzcy5cIilcbiAgICB9XG5cbn1cblxuY2xhc3MgUmVwbGFjZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0RlY29kZXJbJ2RlY29kZV9jaGFpbiddfSAqL1xuICAgIGRlY29kZV9jaGFpbih0b2tlbnMpIHtcbiAgICAgICAgbGV0IHBhdHRlcm4gPSBjcmVhdGVQYXR0ZXJuKHRoaXMuY29uZmlnLnBhdHRlcm4pO1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbnMubWFwKHRva2VuID0+IHRva2VuLnJlcGxhY2VBbGwocGF0dGVybiwgdGhpcy5jb25maWcuY29udGVudCkpXG4gICAgfVxufVxuXG5cbmNsYXNzIEJ5dGVGYWxsYmFjayBleHRlbmRzIERlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuXG4gICAgICAgIHRoaXMudGV4dF9kZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtEZWNvZGVyWydkZWNvZGVfY2hhaW4nXX0gKi9cbiAgICBkZWNvZGVfY2hhaW4odG9rZW5zKSB7XG5cbiAgICAgICAgbGV0IG5ld190b2tlbnMgPSBbXTtcbiAgICAgICAgbGV0IHByZXZpb3VzX2J5dGVfdG9rZW5zID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZXMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA9PT0gNiAmJiB0b2tlbi5zdGFydHNXaXRoKCc8MHgnKSAmJiB0b2tlbi5lbmRzV2l0aCgnPicpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ5dGUgPSBwYXJzZUludCh0b2tlbi5zbGljZSgzLCA1KSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oYnl0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzX2J5dGVfdG9rZW5zLnB1c2goYnl0ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNfYnl0ZV90b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RyaW5nID0gdGhpcy50ZXh0X2RlY29kZXIuZGVjb2RlKFVpbnQ4QXJyYXkuZnJvbShwcmV2aW91c19ieXRlX3Rva2VucykpO1xuICAgICAgICAgICAgICAgICAgICBuZXdfdG9rZW5zLnB1c2goc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfYnl0ZV90b2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3X3Rva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNfYnl0ZV90b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHN0cmluZyA9IHRoaXMudGV4dF9kZWNvZGVyLmRlY29kZShVaW50OEFycmF5LmZyb20ocHJldmlvdXNfYnl0ZV90b2tlbnMpKTtcbiAgICAgICAgICAgIG5ld190b2tlbnMucHVzaChzdHJpbmcpO1xuICAgICAgICAgICAgcHJldmlvdXNfYnl0ZV90b2tlbnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdfdG9rZW5zO1xuICAgIH1cbn1cblxuLyoqXG4gKiBGdXNlIHNpbXBseSBmdXNlcyBhbGwgdG9rZW5zIGludG8gb25lIGJpZyBzdHJpbmcuXG4gKiBJdCdzIHVzdWFsbHkgdGhlIGxhc3QgZGVjb2Rpbmcgc3RlcCBhbnl3YXksIGJ1dCB0aGlzIGRlY29kZXJcbiAqIGV4aXN0cyBpbmNhc2Ugc29tZSBkZWNvZGVycyBuZWVkIHRvIGhhcHBlbiBhZnRlciB0aGF0IHN0ZXBcbiAqL1xuY2xhc3MgRnVzZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0RlY29kZXJbJ2RlY29kZV9jaGFpbiddfSAqL1xuICAgIGRlY29kZV9jaGFpbih0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIFt0b2tlbnMuam9pbignJyldO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyaXBEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5jb25maWcuY29udGVudDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMuY29uZmlnLnN0YXJ0O1xuICAgICAgICB0aGlzLnN0b3AgPSB0aGlzLmNvbmZpZy5zdG9wO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7RGVjb2RlclsnZGVjb2RlX2NoYWluJ119ICovXG4gICAgZGVjb2RlX2NoYWluKHRva2Vucykge1xuICAgICAgICByZXR1cm4gdG9rZW5zLm1hcCh0b2tlbiA9PiB7XG4gICAgICAgICAgICBsZXQgc3RhcnRfY3V0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGFydDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuW2ldID09PSB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfY3V0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHN0b3BfY3V0ID0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0b3A7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdG9rZW4ubGVuZ3RoIC0gaSAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuW2luZGV4XSA9PT0gdGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BfY3V0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRva2VuLnNsaWNlKHN0YXJ0X2N1dCwgc3RvcF9jdXQpXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGRlY29kZXIgdGhhdCBkZWNvZGVzIGEgbGlzdCBvZiBXb3JkUGllY2UgdG9rZW5zIGludG8gYSBzaW5nbGUgc3RyaW5nLlxuICogQGV4dGVuZHMgRGVjb2RlclxuICovXG5jbGFzcyBXb3JkUGllY2VEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFdvcmRQaWVjZURlY29kZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5wcmVmaXggVGhlIHByZWZpeCB1c2VkIGZvciBXb3JkUGllY2UgZW5jb2RpbmcuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWcuY2xlYW51cCBXaGV0aGVyIHRvIGNsZWFudXAgdGhlIGRlY29kZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLmNsZWFudXAgPSBjb25maWcuY2xlYW51cDtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0RlY29kZXJbJ2RlY29kZV9jaGFpbiddfSAqL1xuICAgIGRlY29kZV9jaGFpbih0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRva2Vucy5tYXAoKHRva2VuLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5zdGFydHNXaXRoKHRoaXMuY29uZmlnLnByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogLnJlcGxhY2UoKSBpcyBpbnRlbmRlZDsgb25seSByZXBsYWNlIGZpcnN0IG9jY3VycmVuY2VcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5yZXBsYWNlKHRoaXMuY29uZmlnLnByZWZpeCwgJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gJyAnICsgdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2xlYW51cCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gY2xlYW5fdXBfdG9rZW5pemF0aW9uKHRva2VuKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCeXRlLWxldmVsIGRlY29kZXIgZm9yIHRva2VuaXphdGlvbiBvdXRwdXQuIEluaGVyaXRzIGZyb20gdGhlIGBEZWNvZGVyYCBjbGFzcy5cbiAqIEBleHRlbmRzIERlY29kZXJcbiAqL1xuY2xhc3MgQnl0ZUxldmVsRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgYEJ5dGVMZXZlbERlY29kZXJgIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuXG4gICAgICAgIHRoaXMuYnl0ZV9kZWNvZGVyID0gVU5JQ09ERV9UT19CWVRFUztcbiAgICAgICAgdGhpcy50ZXh0X2RlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiLCB7XG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBpZ25vcmVCT006IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZW5kX29mX3dvcmRfc3VmZml4ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIGFycmF5IG9mIHRva2VucyB0byBzdHJpbmcgYnkgZGVjb2RpbmcgZWFjaCBieXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2VucyBBcnJheSBvZiB0b2tlbnMgdG8gYmUgZGVjb2RlZC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgY29udmVydF90b2tlbnNfdG9fc3RyaW5nKHRva2Vucykge1xuICAgICAgICBsZXQgdGV4dCA9IHRva2Vucy5qb2luKCcnKTtcblxuICAgICAgICBsZXQgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoWy4uLnRleHRdLm1hcChjID0+IHRoaXMuYnl0ZV9kZWNvZGVyW2NdKSk7XG4gICAgICAgIGxldCBkZWNvZGVkX3RleHQgPSB0aGlzLnRleHRfZGVjb2Rlci5kZWNvZGUoYnl0ZUFycmF5KTtcbiAgICAgICAgcmV0dXJuIGRlY29kZWRfdGV4dDtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0RlY29kZXJbJ2RlY29kZV9jaGFpbiddfSAqL1xuICAgIGRlY29kZV9jaGFpbih0b2tlbnMpIHtcbiAgICAgICAgLy8gVE9ETyBtb3ZlIHRvIGJhc2UgY2xhc3MgKGxpa2UgSEYpXG4gICAgICAgIC8vIHRva2VucyA9PT0gZmlsdGVyZWRfdG9rZW5zXG5cbiAgICAgICAgLy8gVG8gYXZvaWQgbWl4aW5nIGJ5dGUtbGV2ZWwgYW5kIHVuaWNvZGUgZm9yIGJ5dGUtbGV2ZWwgQlBUXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gYnVpbGQgc3RyaW5nIHNlcGFyYXRlbHkgZm9yIGFkZGVkIHRva2VucyBhbmQgYnl0ZS1sZXZlbCB0b2tlbnNcbiAgICAgICAgLy8gY2YuIGh0dHBzOi8vZ2l0aHViLmNvbS9odWdnaW5nZmFjZS90cmFuc2Zvcm1lcnMvaXNzdWVzLzExMzNcbiAgICAgICAgbGV0IHN1Yl90ZXh0cyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudF9zdWJfdGV4dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIC8vIHRva2VucyBzZW50IGhlcmUgYXJlIGFscmVhZHkgZmlsdGVyZWQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gdGhpc1xuICAgICAgICAgICAgLy8gaWYgKHNraXBfc3BlY2lhbF90b2tlbnMgJiYgdGhpcy5hbGxfc3BlY2lhbF9pZHMuaW5jbHVkZXModG9rZW4pKSB7XG4gICAgICAgICAgICAvLyAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFkZGVkX3Rva2Vucy5pbmNsdWRlcyh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudF9zdWJfdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yl90ZXh0cy5wdXNoKHRoaXMuY29udmVydF90b2tlbnNfdG9fc3RyaW5nKGN1cnJlbnRfc3ViX3RleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zdWJfdGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJfdGV4dHMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfc3ViX3RleHQucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRfc3ViX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc3ViX3RleHRzLnB1c2godGhpcy5jb252ZXJ0X3Rva2Vuc190b19zdHJpbmcoY3VycmVudF9zdWJfdGV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyBhZGQgc3BhY2VzX2JldHdlZW5fc3BlY2lhbF90b2tlbnMgYW5kIGNsZWFuX3VwX3Rva2VuaXphdGlvbl9zcGFjZXMgb3B0aW9uc1xuXG4gICAgICAgIHJldHVybiBzdWJfdGV4dHM7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQXBwbHkgYSBzZXF1ZW5jZSBvZiBkZWNvZGVycy5cbiAqIEBleHRlbmRzIERlY29kZXJcbiAqL1xuY2xhc3MgRGVjb2RlclNlcXVlbmNlIGV4dGVuZHMgRGVjb2RlciB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIERlY29kZXJTZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0RlY29kZXJbXX0gY29uZmlnLmRlY29kZXJzIFRoZSBsaXN0IG9mIGRlY29kZXJzIHRvIGFwcGx5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLmRlY29kZXJzID0gY29uZmlnLmRlY29kZXJzLm1hcCh4ID0+IERlY29kZXIuZnJvbUNvbmZpZyh4KSk7XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtEZWNvZGVyWydkZWNvZGVfY2hhaW4nXX0gKi9cbiAgICBkZWNvZGVfY2hhaW4odG9rZW5zKSB7XG4gICAgICAgIC8vIFVzZSByZWR1Y2UgdG8gYXBwbHkgZWFjaCBkZWNvZGVyIHRvIHRoZSB0b2tlbnNcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlcnMucmVkdWNlKCh0b2tzLCBkZWNvZGVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGVfY2hhaW4odG9rcyk7XG4gICAgICAgIH0sIHRva2Vucyk7XG4gICAgfVxuXG59XG5cbi8qKlxuICogVGhpcyBQcmVUb2tlbml6ZXIgcmVwbGFjZXMgc3BhY2VzIHdpdGggdGhlIGdpdmVuIHJlcGxhY2VtZW50IGNoYXJhY3RlciwgYWRkcyBhIHByZWZpeCBzcGFjZSBpZiByZXF1ZXN0ZWQsXG4gKiBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgdG9rZW5zLlxuICogQGV4dGVuZHMgUHJlVG9rZW5pemVyXG4gKi9cbmNsYXNzIE1ldGFzcGFjZVByZVRva2VuaXplciBleHRlbmRzIFByZVRva2VuaXplciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBNZXRhc3BhY2VQcmVUb2tlbml6ZXIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWcuYWRkX3ByZWZpeF9zcGFjZSBXaGV0aGVyIHRvIGFkZCBhIHByZWZpeCBzcGFjZSB0byB0aGUgZmlyc3QgdG9rZW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5yZXBsYWNlbWVudCBUaGUgY2hhcmFjdGVyIHRvIHJlcGxhY2Ugc3BhY2VzIHdpdGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuc3RyX3JlcD1jb25maWcucmVwbGFjZW1lbnRdIEFuIG9wdGlvbmFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuYWRkUHJlZml4U3BhY2UgPSBjb25maWcuYWRkX3ByZWZpeF9zcGFjZTtcbiAgICAgICAgdGhpcy5yZXBsYWNlbWVudCA9IGNvbmZpZy5yZXBsYWNlbWVudDtcbiAgICAgICAgdGhpcy5zdHJSZXAgPSBjb25maWcuc3RyX3JlcCB8fCB0aGlzLnJlcGxhY2VtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIGEgbGlzdCBvZiBub3JtYWxpemVkIHRva2VucywgcmVwbGFjZXMgc3BhY2VzIHdpdGggdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlcixcbiAgICAgKiBhZGRzIGEgcHJlZml4IHNwYWNlIGlmIHJlcXVlc3RlZCwgYW5kIHJldHVybnMgYSBuZXcgbGlzdCBvZiB0b2tlbnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXXxzdHJpbmd9IG5vcm1hbGl6ZWRUb2tlbnMgVGhlIGxpc3Qgb2Ygbm9ybWFsaXplZCB0b2tlbnMgdG8gcHJlLXRva2VuaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQSBuZXcgbGlzdCBvZiBwcmUtdG9rZW5pemVkIHRva2Vucy5cbiAgICAgKi9cbiAgICBwcmVfdG9rZW5pemUobm9ybWFsaXplZFRva2Vucykge1xuICAgICAgICBpZiAodHlwZW9mIG5vcm1hbGl6ZWRUb2tlbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBNZXRhc3BhY2UgYWN0cyBvbiBhIGxpc3Qgb2YgdG9rZW5zLiBJZiBwYXNzaW5nIGluIGEgc3RyaW5nLCBmaXJzdCBzcGxpdCBvbiB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAvLyBOT1RFOiBGb3Igc29tZSByZWFzb24sIG1ldGFzcGFjZSBpbmNsdWRlcyB0cmFpbGluZyB3aGl0ZXNwYWNlLCBzbyB3ZSBvbmx5IHRyaW0gbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaHVnZ2luZ2ZhY2UvdG9rZW5pemVycy9pc3N1ZXMvMTI1MFxuICAgICAgICAgICAgbm9ybWFsaXplZFRva2VucyA9IG5vcm1hbGl6ZWRUb2tlbnMudHJpbVN0YXJ0KCkuc3BsaXQoL1xccysvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiBub3JtYWxpemVkVG9rZW5zKSB7XG4gICAgICAgICAgICBsZXQgbm9ybWFsaXplZCA9IHRva2VuLnJlcGxhY2VBbGwoJyAnLCB0aGlzLnN0clJlcCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRQcmVmaXhTcGFjZSAmJiAhbm9ybWFsaXplZC5zdGFydHNXaXRoKHRoaXMucmVwbGFjZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IHRoaXMuc3RyUmVwICsgbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIE1ldGFzcGFjZURlY29kZXIgY2xhc3MgZXh0ZW5kcyB0aGUgRGVjb2RlciBjbGFzcyBhbmQgZGVjb2RlcyBNZXRhc3BhY2UgdG9rZW5pemF0aW9uLlxuICogQGV4dGVuZHMgRGVjb2RlclxuICovXG5jbGFzcyBNZXRhc3BhY2VEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBNZXRhc3BhY2VEZWNvZGVyIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIE1ldGFzcGFjZURlY29kZXIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWcuYWRkX3ByZWZpeF9zcGFjZSBXaGV0aGVyIHRvIGFkZCBhIHByZWZpeCBzcGFjZSB0byB0aGUgZGVjb2RlZCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5yZXBsYWNlbWVudCBUaGUgc3RyaW5nIHRvIHJlcGxhY2Ugc3BhY2VzIHdpdGguXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5hZGRQcmVmaXhTcGFjZSA9IGNvbmZpZy5hZGRfcHJlZml4X3NwYWNlO1xuICAgICAgICB0aGlzLnJlcGxhY2VtZW50ID0gY29uZmlnLnJlcGxhY2VtZW50O1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7RGVjb2RlclsnZGVjb2RlX2NoYWluJ119ICovXG4gICAgZGVjb2RlX2NoYWluKHRva2Vucykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgbm9ybWFsaXplZCA9IHRva2Vuc1tpXS5yZXBsYWNlQWxsKHRoaXMucmVwbGFjZW1lbnQsICcgJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hZGRQcmVmaXhTcGFjZSAmJiBpID09IDAgJiYgbm9ybWFsaXplZC5zdGFydHNXaXRoKCcgJykpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChub3JtYWxpemVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIG5vcm1hbGl6ZXIgdGhhdCBhcHBsaWVzIGEgcHJlY29tcGlsZWQgY2hhcnNtYXAuXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgYXBwbHlpbmcgY29tcGxleCBub3JtYWxpemF0aW9ucyBpbiBDKysgYW5kIGV4cG9zaW5nIHRoZW0gdG8gSmF2YVNjcmlwdC5cbiAqIEBleHRlbmRzIE5vcm1hbGl6ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgUHJlY29tcGlsZWQgbm9ybWFsaXplci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcucHJlY29tcGlsZWRfY2hhcnNtYXAgVGhlIHByZWNvbXBpbGVkIGNoYXJzbWFwIG9iamVjdC5cbiAqL1xuY2xhc3MgUHJlY29tcGlsZWQgZXh0ZW5kcyBOb3JtYWxpemVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgUHJlY29tcGlsZWQgbm9ybWFsaXplci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2FueX0gY29uZmlnLnByZWNvbXBpbGVkX2NoYXJzbWFwIFByZWNvbXBpbGVkIGNoYXJzIG1hcHBpbmcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY2hhcnNtYXAgPSBjb25maWcucHJlY29tcGlsZWRfY2hhcnNtYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gdGV4dCBieSBhcHBseWluZyB0aGUgcHJlY29tcGlsZWQgY2hhcnNtYXAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gbm9ybWFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBub3JtYWxpemVkIHRleHQuXG4gICAgICovXG4gICAgbm9ybWFsaXplKHRleHQpIHtcbiAgICAgICAgLy8gVE9ETyB1c2UgdGhpcy5jaGFyc21hcFxuICAgICAgICAvLyBGb3Igbm93LCB3ZSBqdXN0IGFwcGx5IE5GS0Mgbm9ybWFsaXphdGlvblxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaHVnZ2luZ2ZhY2UvdG9rZW5pemVycy9ibG9iLzI5MWIyZTIzYWU4MWNmOTQ3Mzg4MzU4NTIyMTNjZTEyMDE1MmQxMjEvYmluZGluZ3MvcHl0aG9uL3B5X3NyYy90b2tlbml6ZXJzL2ltcGxlbWVudGF0aW9ucy9zZW50ZW5jZXBpZWNlX2JwZS5weSNMMzRcbiAgICAgICAgdGV4dCA9IHRleHQubm9ybWFsaXplKCdORktDJyk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHByZS10b2tlbml6ZXIgdGhhdCBhcHBsaWVzIGEgc2VxdWVuY2Ugb2YgcHJlLXRva2VuaXplcnMgdG8gdGhlIGlucHV0IHRleHQuXG4gKiBAZXh0ZW5kcyBQcmVUb2tlbml6ZXJcbiAqL1xuY2xhc3MgUHJlVG9rZW5pemVyU2VxdWVuY2UgZXh0ZW5kcyBQcmVUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUHJlVG9rZW5pemVyU2VxdWVuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBwcmUtdG9rZW5pemVyIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGNvbmZpZy5wcmV0b2tlbml6ZXJzIEFuIGFycmF5IG9mIHByZS10b2tlbml6ZXIgY29uZmlndXJhdGlvbnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudG9rZW5pemVycyA9IGNvbmZpZy5wcmV0b2tlbml6ZXJzLm1hcCh4ID0+IFByZVRva2VuaXplci5mcm9tQ29uZmlnKHgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGVhY2ggcHJlLXRva2VuaXplciBpbiB0aGUgc2VxdWVuY2UgdG8gdGhlIGlucHV0IHRleHQgaW4gdHVybi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdGV4dCBUaGUgdGV4dChzKSB0byBwcmUtdG9rZW5pemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgcHJlLXRva2VuaXplZCB0ZXh0LlxuICAgICAqL1xuICAgIHByZV90b2tlbml6ZV90ZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGV4dCA9IFt0ZXh0XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgcmVkdWNlIHRvIGFwcGx5IGVhY2ggdG9rZW5pemVyIHRvIHRoZSB0ZXh0XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuaXplcnMucmVkdWNlKChwcmVUb2tlbml6ZWRUZXh0LCB0b2tlbml6ZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbml6ZXIucHJlX3Rva2VuaXplKHByZVRva2VuaXplZFRleHQpO1xuICAgICAgICB9LCB0ZXh0KTtcbiAgICB9XG59XG5cbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIG9mIHRleHQgYnkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGludG8gaW5kaXZpZHVhbCB0b2tlbnMuXG4gKiBAZXh0ZW5kcyBQcmVUb2tlbml6ZXJcbiAqL1xuY2xhc3MgV2hpdGVzcGFjZVNwbGl0IGV4dGVuZHMgUHJlVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFdoaXRlc3BhY2VTcGxpdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHByZS10b2tlbml6ZXIgc2VxdWVuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZS10b2tlbml6ZXMgdGhlIGlucHV0IHRleHQgYnkgc3BsaXR0aW5nIGl0IG9uIHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBiZSBwcmUtdG9rZW5pemVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gQW4gYXJyYXkgb2YgdG9rZW5zIHByb2R1Y2VkIGJ5IHNwbGl0dGluZyB0aGUgaW5wdXQgdGV4dCBvbiB3aGl0ZXNwYWNlLlxuICAgICAqL1xuICAgIHByZV90b2tlbml6ZV90ZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHdoaXRlc3BhY2Vfc3BsaXQodGV4dCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHJlVHJhaW5lZFRva2VuaXplciBleHRlbmRzIENhbGxhYmxlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgUHJlVHJhaW5lZFRva2VuaXplciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9rZW5pemVySlNPTiBUaGUgSlNPTiBvZiB0aGUgdG9rZW5pemVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbml6ZXJDb25maWcgVGhlIGNvbmZpZyBvZiB0aGUgdG9rZW5pemVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRva2VuaXplckpTT04sIHRva2VuaXplckNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBwYXJ0cyBvZiB0aGUgdG9rZW5pemVyIGZyb20gdGhlIEpTT05cbiAgICAgICAgdGhpcy5ub3JtYWxpemVyID0gTm9ybWFsaXplci5mcm9tQ29uZmlnKHRva2VuaXplckpTT04ubm9ybWFsaXplcik7XG4gICAgICAgIHRoaXMucHJlX3Rva2VuaXplciA9IFByZVRva2VuaXplci5mcm9tQ29uZmlnKHRva2VuaXplckpTT04ucHJlX3Rva2VuaXplcik7XG5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgdm9jYWJ1bGFyeSB0byBhIG1hcCwgaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmICh0b2tlbml6ZXJKU09OLm1vZGVsLnZvY2FiKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9rZW5pemVySlNPTi5tb2RlbC52b2NhYikpIHtcbiAgICAgICAgICAgICAgICB0b2tlbml6ZXJKU09OLm1vZGVsLnZvY2FiID0gT2JqZWN0LmVudHJpZXModG9rZW5pemVySlNPTi5tb2RlbC52b2NhYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbml6ZXJKU09OLm1vZGVsLnZvY2FiID0gbmV3IE1hcCh0b2tlbml6ZXJKU09OLm1vZGVsLnZvY2FiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gVG9rZW5pemVyTW9kZWwuZnJvbUNvbmZpZyh0b2tlbml6ZXJKU09OLm1vZGVsLCB0b2tlbml6ZXJDb25maWcpO1xuICAgICAgICB0aGlzLnBvc3RfcHJvY2Vzc29yID0gUG9zdFByb2Nlc3Nvci5mcm9tQ29uZmlnKHRva2VuaXplckpTT04ucG9zdF9wcm9jZXNzb3IpO1xuXG4gICAgICAgIC8vIFRPRE86IG1heWJlLCBhbGxvdyB0aGlzIHRvIGJlIG51bGw7IGluIHdoaWNoIGNhc2UsIHdlIHVzZSBtb2RlbCBhcyBkZWNvZGVyIHRvbz9cbiAgICAgICAgdGhpcy5kZWNvZGVyID0gRGVjb2Rlci5mcm9tQ29uZmlnKHRva2VuaXplckpTT04uZGVjb2Rlcik7XG5cblxuICAgICAgICAvLyBBbm90aGVyIHNsaWdodCBoYWNrIHRvIGFkZCBgZW5kX29mX3dvcmRfc3VmZml4YCAoaWYgcHJlc2VudCkgdG8gdGhlIGRlY29kZXJcbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgZm9yIGNhc2VzIHdoZXJlIEJQRSBtb2RlbCBhbmQgQnl0ZUxldmVsIGRlY29kZXIgYXJlIHVzZWRcbiAgICAgICAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL2dpdGh1Yi5jb20veGVub3ZhL3RyYW5zZm9ybWVycy5qcy9pc3N1ZXMvNzRcbiAgICAgICAgLy8gVE9ETzogc2F2ZSB0aGlzIHRvIHRoZSBkZWNvZGVyIHdoZW4gZXhwb3J0aW5nP1xuICAgICAgICB0aGlzLmRlY29kZXIuZW5kX29mX3dvcmRfc3VmZml4ID0gdGhpcy5tb2RlbC5lbmRfb2Zfd29yZF9zdWZmaXg7XG5cbiAgICAgICAgLy8gQWRkIGFkZGVkX3Rva2VucyB0byBtb2RlbFxuICAgICAgICB0aGlzLnNwZWNpYWxfdG9rZW5zID0gW107XG4gICAgICAgIHRoaXMuYWxsX3NwZWNpYWxfaWRzID0gW107XG4gICAgICAgIHRoaXMuYWRkZWRfdG9rZW5zID0gW107XG4gICAgICAgIGZvciAobGV0IGFkZGVkVG9rZW4gb2YgdG9rZW5pemVySlNPTi5hZGRlZF90b2tlbnMpIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGFkZGVkVG9rZW4uaWQ7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGFkZGVkVG9rZW4uY29udGVudDtcblxuICAgICAgICAgICAgdGhpcy5hZGRlZF90b2tlbnMucHVzaChjb250ZW50KTtcblxuICAgICAgICAgICAgdGhpcy5tb2RlbC50b2tlbnNfdG9faWRzLnNldChjb250ZW50LCBpZCk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnZvY2FiW2lkXSA9IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmIChhZGRlZFRva2VuLnNwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWNpYWxfdG9rZW5zLnB1c2goY29udGVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxfc3BlY2lhbF9pZHMucHVzaChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbGlnaHQgaGFjaywgYnV0IGl0IHByZXZlbnRzIGNvZGUgZHVwbGljYXRpb246XG4gICAgICAgIHRoaXMuZGVjb2Rlci5hZGRlZF90b2tlbnMgPSB0aGlzLmFkZGVkX3Rva2VucztcblxuICAgICAgICB0aGlzLmFkZGVkX3Rva2Vuc19yZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnKCcgKyB0aGlzLmFkZGVkX3Rva2Vucy5tYXAoZXNjYXBlUmVnRXhwKS5qb2luKCd8JykgKyAnKSdcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTZXQgbWFzayB0b2tlbiBpZiBwcmVzZW50IChvdGhlcndpc2Ugd2lsbCBiZSB1bmRlZmluZWQsIHdoaWNoIGlzIGZpbmUpXG4gICAgICAgIHRoaXMubWFza190b2tlbiA9IHRoaXMuZ2V0VG9rZW4odG9rZW5pemVyQ29uZmlnLCAnbWFza190b2tlbicpO1xuICAgICAgICB0aGlzLm1hc2tfdG9rZW5faWQgPSB0aGlzLm1vZGVsLnRva2Vuc190b19pZHMuZ2V0KHRoaXMubWFza190b2tlbik7XG5cbiAgICAgICAgdGhpcy5wYWRfdG9rZW4gPSB0aGlzLmdldFRva2VuKHRva2VuaXplckNvbmZpZywgJ3BhZF90b2tlbicsICdlb3NfdG9rZW4nKTtcbiAgICAgICAgdGhpcy5wYWRfdG9rZW5faWQgPSB0aGlzLm1vZGVsLnRva2Vuc190b19pZHMuZ2V0KHRoaXMucGFkX3Rva2VuKTtcblxuICAgICAgICB0aGlzLnNlcF90b2tlbiA9IHRoaXMuZ2V0VG9rZW4odG9rZW5pemVyQ29uZmlnLCAnc2VwX3Rva2VuJyk7XG4gICAgICAgIHRoaXMuc2VwX3Rva2VuX2lkID0gdGhpcy5tb2RlbC50b2tlbnNfdG9faWRzLmdldCh0aGlzLnNlcF90b2tlbik7XG5cbiAgICAgICAgdGhpcy5tb2RlbF9tYXhfbGVuZ3RoID0gdG9rZW5pemVyQ29uZmlnLm1vZGVsX21heF9sZW5ndGg7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0byBzdHJpcCB0aGUgdGV4dCB3aGVuIHRva2VuaXppbmcgKHJlbW92aW5nIGV4Y2VzcyBzcGFjZXMgYmVmb3JlIGFuZCBhZnRlciB0aGUgc3RyaW5nKS4gKi9cbiAgICAgICAgdGhpcy5yZW1vdmVfc3BhY2UgPSB0b2tlbml6ZXJDb25maWcucmVtb3ZlX3NwYWNlO1xuXG4gICAgICAgIHRoaXMuY2xlYW5fdXBfdG9rZW5pemF0aW9uX3NwYWNlcyA9IHRva2VuaXplckNvbmZpZy5jbGVhbl91cF90b2tlbml6YXRpb25fc3BhY2VzID8/IHRydWU7XG5cbiAgICAgICAgLy8gVE9ETyBhbGxvdyB1c2VyIHRvIGNoYW5nZSB0aGlzXG4gICAgICAgIHRoaXMucGFkZGluZ19zaWRlID0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgbWF0Y2hpbmcga2V5IGluIHRoZSB0b2tlbml6ZXIgY29uZmlnIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30ga2V5cyBPbmUgb3IgbW9yZSBrZXlzIHRvIHNlYXJjaCBmb3IgaW4gdGhlIHRva2VuaXplciBjb25maWcgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmlyc3QgbWF0Y2hpbmcga2V5LCBvciBudWxsIGlmIG5vIG1hdGNoIGlzIGZvdW5kLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbiBvYmplY3QgaXMgZm91bmQgZm9yIGEgbWF0Y2hpbmcga2V5IGFuZCBpdHMgX190eXBlIHByb3BlcnR5IGlzIG5vdCBcIkFkZGVkVG9rZW5cIi5cbiAgICAgKi9cbiAgICBnZXRUb2tlbih0b2tlbml6ZXJDb25maWcsIC4uLmtleXMpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdG9rZW5pemVyQ29uZmlnW2tleV07XG5cbiAgICAgICAgICAgIGlmICghaXRlbSkgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5fX3R5cGUgPT09ICdBZGRlZFRva2VuJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5jb250ZW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBVbmtub3duIHRva2VuOiAke2l0ZW19YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHByZS10cmFpbmVkIHRva2VuaXplciBmcm9tIHRoZSBnaXZlbiBgcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGhgLiBcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGggVGhlIHBhdGggdG8gdGhlIHByZS10cmFpbmVkIHRva2VuaXplci5cbiAgICAgKiBAcGFyYW0ge1ByZXRyYWluZWRPcHRpb25zfSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbG9hZGluZyB0aGUgdG9rZW5pemVyLlxuICAgICAqIFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHRva2VuaXplci5qc29uIG9yIHRva2VuaXplcl9jb25maWcuanNvbiBmaWxlcyBhcmUgbm90IGZvdW5kIGluIHRoZSBgcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGhgLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFByZVRyYWluZWRUb2tlbml6ZXI+fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByZVRyYWluZWRUb2tlbml6ZXJgIGNsYXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tX3ByZXRyYWluZWQocHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgsIHtcbiAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2sgPSBudWxsLFxuICAgICAgICBjb25maWcgPSBudWxsLFxuICAgICAgICBjYWNoZV9kaXIgPSBudWxsLFxuICAgICAgICBsb2NhbF9maWxlc19vbmx5ID0gZmFsc2UsXG4gICAgICAgIHJldmlzaW9uID0gJ21haW4nLFxuICAgIH0gPSB7fSkge1xuXG4gICAgICAgIGxldCBpbmZvID0gYXdhaXQgbG9hZFRva2VuaXplcihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwge1xuICAgICAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2ssXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBjYWNoZV9kaXIsXG4gICAgICAgICAgICBsb2NhbF9maWxlc19vbmx5LFxuICAgICAgICAgICAgcmV2aXNpb24sXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMoLi4uaW5mbyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgb3ZlcnJpZGRlbiBieSBhIHN1YmNsYXNzIHRvIGFwcGx5IGFkZGl0aW9uYWwgcHJlcHJvY2Vzc2luZ1xuICAgICAqIHRvIGEgbW9kZWwncyBpbnB1dCBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dHMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5wdXQgZGF0YSBhcyBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBtb2RpZmllZCBpbnB1dHMgb2JqZWN0LlxuICAgICAqL1xuICAgIHByZXBhcmVfbW9kZWxfaW5wdXRzKGlucHV0cykge1xuICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZS90b2tlbml6ZSB0aGUgZ2l2ZW4gdGV4dChzKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdGV4dCBUaGUgdGV4dCB0byB0b2tlbml6ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFtvcHRpb25zLnRleHRfcGFpcj1udWxsXSBPcHRpb25hbCBzZWNvbmQgc2VxdWVuY2UgdG8gYmUgZW5jb2RlZC4gSWYgc2V0LCBtdXN0IGJlIHRoZSBzYW1lIHR5cGUgYXMgdGV4dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBhZGRpbmc9ZmFsc2VdIFdoZXRoZXIgdG8gcGFkIHRoZSBpbnB1dCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cnVuY2F0aW9uPW51bGxdIFdoZXRoZXIgdG8gdHJ1bmNhdGUgdGhlIGlucHV0IHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4X2xlbmd0aD1udWxsXSBNYXhpbXVtIGxlbmd0aCBvZiB0aGUgcmV0dXJuZWQgbGlzdCBhbmQgb3B0aW9uYWxseSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJldHVybl90ZW5zb3I9dHJ1ZV0gV2hldGhlciB0byByZXR1cm4gdGhlIHJlc3VsdHMgYXMgVGVuc29ycyBvciBhcnJheXMuXG4gICAgICogQHJldHVybnMge3sgaW5wdXRfaWRzOiBudW1iZXJbXXxudW1iZXJbXVtdfFRlbnNvciwgYXR0ZW50aW9uX21hc2s6IGFueVtdfFRlbnNvciB9fSBPYmplY3QgdG8gYmUgcGFzc2VkIHRvIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBfY2FsbChcbiAgICAgICAgLy8gUmVxdWlyZWQgcG9zaXRpb25hbCBhcmd1bWVudHNcbiAgICAgICAgdGV4dCxcblxuICAgICAgICAvLyBPcHRpb25hbCBrZXl3b3JkIGFyZ3VtZW50c1xuICAgICAgICB7XG4gICAgICAgICAgICB0ZXh0X3BhaXIgPSBudWxsLFxuICAgICAgICAgICAgLy8gYWRkX3NwZWNpYWxfdG9rZW5zID0gdHJ1ZSwgLy8gVE9ET1xuICAgICAgICAgICAgcGFkZGluZyA9IGZhbHNlLFxuICAgICAgICAgICAgdHJ1bmNhdGlvbiA9IG51bGwsXG4gICAgICAgICAgICBtYXhfbGVuZ3RoID0gbnVsbCxcbiAgICAgICAgICAgIHJldHVybl90ZW5zb3IgPSB0cnVlLCAvLyBEaWZmZXJlbnQgdG8gSEZcbiAgICAgICAgfSA9IHt9LFxuICAgICkge1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyW118bnVtYmVyW11bXXxUZW5zb3J9ICovXG4gICAgICAgIGxldCB0b2tlbnM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dCkpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCd0ZXh0IGFycmF5IG11c3QgYmUgbm9uLWVtcHR5JylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRleHRfcGFpciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0ZXh0X3BhaXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCd0ZXh0X3BhaXIgbXVzdCBhbHNvIGJlIGFuIGFycmF5JylcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dC5sZW5ndGggIT09IHRleHRfcGFpci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3RleHQgYW5kIHRleHRfcGFpciBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0b2tlbnMgPSB0ZXh0Lm1hcChcbiAgICAgICAgICAgICAgICAgICAgKHQsIGkpID0+IHRoaXMuZW5jb2RlKHQsIHRleHRfcGFpcltpXSlcbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zID0gdGV4dC5tYXAoeCA9PiB0aGlzLmVuY29kZSh4KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0ZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3RleHQgbWF5IG5vdCBiZSBudWxsJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dF9wYWlyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdXaGVuIHNwZWNpZnlpbmcgYHRleHRfcGFpcmAsIHNpbmNlIGB0ZXh0YCBpcyBhIHN0cmluZywgYHRleHRfcGFpcmAgbXVzdCBhbHNvIGJlIGEgc3RyaW5nIChpLmUuLCBub3QgYW4gYXJyYXkpLicpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciBzaW5nbGUgaW5wdXQsIHdlIGp1c3Qgd3JhcCBpbiBhbiBhcnJheSwgYW5kIHRoZW4gdW53cmFwIGxhdGVyLlxuICAgICAgICAgICAgdG9rZW5zID0gW3RoaXMuZW5jb2RlKHRleHQsIHRleHRfcGFpcildO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRva2VucyBpcyBiYXRjaGVkOiBbYmF0Y2hfc2l6ZSwgdG9rZW5zXVxuICAgICAgICAvLyBIb3dldmVyLCBhcnJheSBtYXkgYmUgamFnZ2VkLiBTbywgd2UgcGFkIHRvIG1heF9sZW5ndGhcblxuICAgICAgICBsZXQgbWF4TGVuZ3RoT2ZCYXRjaCA9IG1heCh0b2tlbnMubWFwKHggPT4geC5sZW5ndGgpKVswXTtcblxuICAgICAgICAvLyBJZiBudWxsLCB3ZSBjYWxjdWxhdGUgbWF4IGxlbmd0aCBmcm9tIHNlcXVlbmNlc1xuICAgICAgICBpZiAobWF4X2xlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbWF4X2xlbmd0aCA9IG1heExlbmd0aE9mQmF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnN1cmUgaXQgaXMgbGVzcyB0aGFuIG1vZGVsIG1heCBsZW5ndGhcbiAgICAgICAgbWF4X2xlbmd0aCA9IE1hdGgubWluKG1heF9sZW5ndGgsIHRoaXMubW9kZWxfbWF4X2xlbmd0aClcblxuICAgICAgICAvKiogQHR5cGUge2FueVtdfFRlbnNvcn0gKi9cbiAgICAgICAgbGV0IGF0dGVudGlvbl9tYXNrID0gW107XG4gICAgICAgIGlmIChwYWRkaW5nIHx8IHRydW5jYXRpb24pIHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gcGFkZGluZyBhbmQvb3IgdHJ1bmNhdGlvblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zW2ldLmxlbmd0aCA9PT0gbWF4X2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBhdHRlbnRpb25fbWFzay5wdXNoKG5ldyBBcnJheSh0b2tlbnNbaV0ubGVuZ3RoKS5maWxsKDEpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5zW2ldLmxlbmd0aCA+IG1heF9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9zc2libHkgdHJ1bmNhdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRydW5jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vuc1tpXSA9IHRva2Vuc1tpXS5zbGljZSgwLCBtYXhfbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhdHRlbnRpb25fbWFzay5wdXNoKG5ldyBBcnJheSh0b2tlbnNbaV0ubGVuZ3RoKS5maWxsKDEpKVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdC5sZW5ndGggPCBtYXhfbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlmZiA9IG1heF9sZW5ndGggLSB0b2tlbnNbaV0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYWRkaW5nX3NpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbnRpb25fbWFzay5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmV3IEFycmF5KHRva2Vuc1tpXS5sZW5ndGgpLmZpbGwoMSkpLmNvbmNhdChuZXcgQXJyYXkoZGlmZikuZmlsbCgwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zW2ldLnB1c2goLi4ubmV3IEFycmF5KGRpZmYpLmZpbGwodGhpcy5wYWRfdG9rZW5faWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gbGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVudGlvbl9tYXNrLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuZXcgQXJyYXkoZGlmZikuZmlsbCgwKSkuY29uY2F0KG5ldyBBcnJheSh0b2tlbnNbaV0ubGVuZ3RoKS5maWxsKDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNbaV0udW5zaGlmdCguLi5uZXcgQXJyYXkoZGlmZikuZmlsbCh0aGlzLnBhZF90b2tlbl9pZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVudGlvbl9tYXNrLnB1c2gobmV3IEFycmF5KHRva2Vuc1tpXS5sZW5ndGgpLmZpbGwoMSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRlbnRpb25fbWFzayA9IHRva2Vucy5tYXAoeCA9PiBuZXcgQXJyYXkoeC5sZW5ndGgpLmZpbGwoMSkpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0dXJuX3RlbnNvcikge1xuICAgICAgICAgICAgaWYgKCEocGFkZGluZyAmJiB0cnVuY2F0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCwgZ3VhcmFudGVlZCB0aGF0IGFsbCBpdGVtcyBoYXZlIHNhbWUgbGVuZ3RoLCBzb1xuICAgICAgICAgICAgICAgIC8vIHdlIHBlcmZvcm0gYWRkaXRpb25hbCBjaGVja1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5zb21lKHggPT4geC5sZW5ndGggIT09IHRva2Vuc1swXS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJVbmFibGUgdG8gY3JlYXRlIHRlbnNvciwgeW91IHNob3VsZCBwcm9iYWJseSBhY3RpdmF0ZSB0cnVuY2F0aW9uIGFuZC9vciBwYWRkaW5nIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2l0aCAncGFkZGluZz10cnVlJyBhbmQgJ3RydW5jYXRpb249dHJ1ZScgdG8gaGF2ZSBiYXRjaGVkIHRlbnNvcnMgd2l0aCB0aGUgc2FtZSBsZW5ndGguXCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm93IHdlIGFjdHVhbGx5IGNvbnZlcnQgdG8gdGVuc29yXG4gICAgICAgICAgICAvLyBOT1RFOiBJbiB0aGUgc2FtZSB3YXkgYXMgdGhlIHB5dGhvbiBsaWJyYXJ5LCB3ZSByZXR1cm4gYSBiYXRjaGVkIHRlbnNvciwgcmVnYXJkbGVzcyBvZlxuICAgICAgICAgICAgLy8gd2hldGhlciB3ZSBoYXZlIGEgc2luZ2xlIGlucHV0IG9yIG11bHRpcGxlIGlucHV0cy5cbiAgICAgICAgICAgIGxldCBkaW1zID0gW3Rva2Vucy5sZW5ndGgsIHRva2Vuc1swXS5sZW5ndGhdO1xuXG4gICAgICAgICAgICB0b2tlbnMgPSBuZXcgVGVuc29yKCdpbnQ2NCcsXG4gICAgICAgICAgICAgICAgQmlnSW50NjRBcnJheS5mcm9tKHRva2Vucy5mbGF0KCkubWFwKEJpZ0ludCkpLFxuICAgICAgICAgICAgICAgIGRpbXNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGF0dGVudGlvbl9tYXNrID0gbmV3IFRlbnNvcihcbiAgICAgICAgICAgICAgICAnaW50NjQnLFxuICAgICAgICAgICAgICAgIEJpZ0ludDY0QXJyYXkuZnJvbShhdHRlbnRpb25fbWFzay5mbGF0KCkubWFwKEJpZ0ludCkpLFxuICAgICAgICAgICAgICAgIGRpbXNcbiAgICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG5vdCByZXR1cm5pbmcgYSB0ZW5zb3IsIHdlIG1hdGNoIHRoZSBpbnB1dCB0eXBlXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnB1dCB3YXMgbm90IGJhdGNoZWQsIHNvIHdlIHVud3JhcFxuICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vuc1swXTtcbiAgICAgICAgICAgICAgICBhdHRlbnRpb25fbWFzayA9IGF0dGVudGlvbl9tYXNrWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBGaW5hbGx5LCBhZGQgYXR0ZW50aW9uIG1hc2ssIGFuZCBwb3NzaWJseSBtb2RlbC1zcGVjaWZpYyBwYXJhbWV0ZXJzXG4gICAgICAgIGxldCBtb2RlbElucHV0cyA9IHtcbiAgICAgICAgICAgIGlucHV0X2lkczogdG9rZW5zLFxuICAgICAgICAgICAgYXR0ZW50aW9uX21hc2s6IGF0dGVudGlvbl9tYXNrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbCBwb3N0LXByb2Nlc3NpbmdcbiAgICAgICAgbW9kZWxJbnB1dHMgPSB0aGlzLnByZXBhcmVfbW9kZWxfaW5wdXRzKG1vZGVsSW5wdXRzKTtcblxuICAgICAgICByZXR1cm4gbW9kZWxJbnB1dHNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGEgc2luZ2xlIHRleHQgdXNpbmcgdGhlIHByZXByb2Nlc3NvciBwaXBlbGluZSBvZiB0aGUgdG9rZW5pemVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdGV4dCBUaGUgdGV4dCB0byBlbmNvZGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfG51bGx9IFRoZSBlbmNvZGVkIHRva2Vucy5cbiAgICAgKi9cbiAgICBfZW5jb2RlX3RleHQodGV4dCkge1xuICAgICAgICBpZiAodGV4dCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gQWN0dWFsIGZ1bmN0aW9uIHdoaWNoIGRvZXMgZW5jb2RpbmcsIGZvciBhIHNpbmdsZSB0ZXh0XG4gICAgICAgIC8vIEZpcnN0LCB3ZSB0YWtlIGNhcmUgb2Ygc3BlY2lhbCB0b2tlbnMuIE5lZWRlZCB0byBhdm9pZCBpc3N1ZXMgYXJpc2luZyBmcm9tXG4gICAgICAgIC8vIG5vcm1hbGl6YXRpb24gYW5kL29yIHByZXRva2VuaXphdGlvbiAod2hpY2ggbWF5IG5vdCBwcmVzZXJ2ZSBzcGVjaWFsIHRva2VucylcbiAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSB0ZXh0LnNwbGl0KHRoaXMuYWRkZWRfdG9rZW5zX3JlZ2V4KS5maWx0ZXIoeCA9PiB4KTtcblxuICAgICAgICBsZXQgdG9rZW5zID0gc2VjdGlvbnMubWFwKHggPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkZWRfdG9rZW5zLmluY2x1ZGVzKHgpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFkZGVkIHRva2Vuc1xuICAgICAgICAgICAgICAgIHJldHVybiB4XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbW92ZV9zcGFjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0geC50cmltKCkuc3BsaXQoL1xccysvKS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9ybWFsaXplciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gdGhpcy5ub3JtYWxpemVyKHgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBzZWN0aW9uVG9rZW5zID0gKHRoaXMucHJlX3Rva2VuaXplciAhPT0gbnVsbCkgPyB0aGlzLnByZV90b2tlbml6ZXIoeCkgOiBbeF07XG5cbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5zID0gdGhpcy5tb2RlbChzZWN0aW9uVG9rZW5zKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmZsYXQoKTtcblxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYSBzaW5nbGUgdGV4dCBvciBhIHBhaXIgb2YgdGV4dHMgdXNpbmcgdGhlIG1vZGVsJ3MgdG9rZW5pemVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHRleHRfcGFpciBUaGUgb3B0aW9uYWwgc2Vjb25kIHRleHQgdG8gZW5jb2RlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gQW4gYXJyYXkgb2YgdG9rZW4gSURzIHJlcHJlc2VudGluZyB0aGUgZW5jb2RlZCB0ZXh0KHMpLlxuICAgICAqL1xuICAgIGVuY29kZSh0ZXh0LCB0ZXh0X3BhaXIgPSBudWxsKSB7XG4gICAgICAgIC8vIEZ1bmN0aW9uIGNhbGxlZCBieSB1c2VycyB0byBlbmNvZGUgcG9zc2libHkgbXVsdGlwbGUgdGV4dHNcbiAgICAgICAgbGV0IHRva2VucyA9IHRoaXMuX2VuY29kZV90ZXh0KHRleHQpO1xuICAgICAgICBsZXQgdG9rZW5zMiA9IHRoaXMuX2VuY29kZV90ZXh0KHRleHRfcGFpcik7XG5cbiAgICAgICAgbGV0IGNvbWJpbmVkVG9rZW5zID0gKHRoaXMucG9zdF9wcm9jZXNzb3IgIT09IG51bGwpXG4gICAgICAgICAgICA/IHRoaXMucG9zdF9wcm9jZXNzb3IodG9rZW5zLCB0b2tlbnMyKVxuICAgICAgICAgICAgOiBtZXJnZUFycmF5cyh0b2tlbnMgPz8gW10sIHRva2VuczIgPz8gW10pO1xuXG4gICAgICAgIGxldCBpZHMgPSB0aGlzLm1vZGVsLmNvbnZlcnRfdG9rZW5zX3RvX2lkcyhjb21iaW5lZFRva2Vucyk7XG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgYmF0Y2ggb2YgdG9rZW5pemVkIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IGJhdGNoIExpc3Qgb2YgdG9rZW5pemVkIGlucHV0IHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjb2RlX2FyZ3MgKE9wdGlvbmFsKSBPYmplY3Qgd2l0aCBkZWNvZGluZyBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBMaXN0IG9mIGRlY29kZWQgc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIGJhdGNoX2RlY29kZShiYXRjaCwgZGVjb2RlX2FyZ3MgPSB7fSkge1xuICAgICAgICByZXR1cm4gYmF0Y2gubWFwKHggPT4gdGhpcy5kZWNvZGUoeCwgZGVjb2RlX2FyZ3MpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGEgc2VxdWVuY2Ugb2YgdG9rZW4gSURzIGJhY2sgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0b2tlbl9pZHMgTGlzdCBvZiB0b2tlbiBJRHMgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZGVjb2RlX2FyZ3M9e31dXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVjb2RlX2FyZ3Muc2tpcF9zcGVjaWFsX3Rva2Vucz1mYWxzZV0gSWYgdHJ1ZSwgc3BlY2lhbCB0b2tlbnMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgb3V0cHV0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWNvZGVfYXJncy5jbGVhbl91cF90b2tlbml6YXRpb25fc3BhY2VzPXRydWVdIElmIHRydWUsIHNwYWNlcyBiZWZvcmUgcHVuY3R1YXRpb25zIGFuZCBhYmJyZXZpYXRlZCBmb3JtcyBhcmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHRva2VuX2lkc2AgaXMgbm90IGEgbm9uLWVtcHR5IGFycmF5IG9mIGludGVnZXJzLlxuICAgICAqL1xuICAgIGRlY29kZShcbiAgICAgICAgdG9rZW5faWRzLFxuICAgICAgICBkZWNvZGVfYXJncyA9IHt9LFxuICAgICkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9rZW5faWRzKSB8fCB0b2tlbl9pZHMubGVuZ3RoID09PSAwIHx8ICFpc0ludGVncmFsTnVtYmVyKHRva2VuX2lkc1swXSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwidG9rZW5faWRzIG11c3QgYmUgYSBub24tZW1wdHkgYXJyYXkgb2YgaW50ZWdlcnMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlX3NpbmdsZSh0b2tlbl9pZHMsIGRlY29kZV9hcmdzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIHNpbmdsZSBsaXN0IG9mIHRva2VuIGlkcyB0byBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0b2tlbl9pZHMgTGlzdCBvZiB0b2tlbiBpZHMgdG8gZGVjb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY29kZV9hcmdzIE9wdGlvbmFsIGFyZ3VtZW50cyBmb3IgZGVjb2RpbmdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWNvZGVfYXJncy5za2lwX3NwZWNpYWxfdG9rZW5zPWZhbHNlXSBXaGV0aGVyIHRvIHNraXAgc3BlY2lhbCB0b2tlbnMgZHVyaW5nIGRlY29kaW5nXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVjb2RlX2FyZ3MuY2xlYW5fdXBfdG9rZW5pemF0aW9uX3NwYWNlcz1udWxsXSBXaGV0aGVyIHRvIGNsZWFuIHVwIHRva2VuaXphdGlvbiBzcGFjZXMgZHVyaW5nIGRlY29kaW5nLlxuICAgICAqIElmIG51bGwsIHRoZSB2YWx1ZSBpcyBzZXQgdG8gYHRoaXMuZGVjb2Rlci5jbGVhbnVwYCBpZiBpdCBleGlzdHMsIGZhbGxpbmcgYmFjayB0byBgdGhpcy5jbGVhbl91cF90b2tlbml6YXRpb25fc3BhY2VzYCBpZiBpdCBleGlzdHMsIGZhbGxpbmcgYmFjayB0byBgdHJ1ZWAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nXG4gICAgICovXG4gICAgZGVjb2RlX3NpbmdsZShcbiAgICAgICAgdG9rZW5faWRzLFxuICAgICAgICB7XG4gICAgICAgICAgICBza2lwX3NwZWNpYWxfdG9rZW5zID0gZmFsc2UsXG4gICAgICAgICAgICBjbGVhbl91cF90b2tlbml6YXRpb25fc3BhY2VzID0gbnVsbCxcbiAgICAgICAgfVxuICAgICkge1xuICAgICAgICBsZXQgdG9rZW5zID0gdGhpcy5tb2RlbC5jb252ZXJ0X2lkc190b190b2tlbnModG9rZW5faWRzKTtcbiAgICAgICAgaWYgKHNraXBfc3BlY2lhbF90b2tlbnMpIHtcbiAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5maWx0ZXIoeCA9PiAhdGhpcy5zcGVjaWFsX3Rva2Vucy5pbmNsdWRlcyh4KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgbGV0IGRlY29kZWQgPSB0aGlzLmRlY29kZXIodG9rZW5zKTtcblxuXG4gICAgICAgIC8vIFNsaWdodCBoYWNrLCBidXQgcHJldmVudHMgaGF2aW5nIHRvIHBhc3MgYHNraXBfc3BlY2lhbF90b2tlbnNgIHRvXG4gICAgICAgIC8vIGVhY2ggY2FsbCB0byBgZGVjb2RlYCwgd2hpY2ggd291bGQgbGVhZCB0byBjb2RlIGR1cGxpY2F0aW9uLlxuICAgICAgICBpZiAodGhpcy5kZWNvZGVyLmVuZF9vZl93b3JkX3N1ZmZpeCkge1xuICAgICAgICAgICAgZGVjb2RlZCA9IGRlY29kZWQucmVwbGFjZUFsbCh0aGlzLmRlY29kZXIuZW5kX29mX3dvcmRfc3VmZml4LCAnICcpO1xuICAgICAgICAgICAgaWYgKHNraXBfc3BlY2lhbF90b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVkID0gZGVjb2RlZC50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xlYW5fdXBfdG9rZW5pemF0aW9uX3NwYWNlcyA/PyB0aGlzLmNsZWFuX3VwX3Rva2VuaXphdGlvbl9zcGFjZXMpIHtcbiAgICAgICAgICAgIGRlY29kZWQgPSBjbGVhbl91cF90b2tlbml6YXRpb24oZGVjb2RlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICB9XG5cbn1cblxuLyoqXG4qIEhlbHBlciBtZXRob2QgZm9yIGFkZGluZyBgdG9rZW5fdHlwZV9pZHNgIHRvIG1vZGVsIGlucHV0c1xuKiBAcGFyYW0ge09iamVjdH0gaW5wdXRzIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBpbnB1dCBpZHMgYW5kIGF0dGVudGlvbiBtYXNrLlxuKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJlcGFyZWQgaW5wdXRzIG9iamVjdC5cbiovXG5mdW5jdGlvbiBhZGRfdG9rZW5fdHlwZXMoaW5wdXRzKSB7XG4gICAgLy8gVE9ETyBlbnN1cmUgY29ycmVjdG5lc3Mgd2hlbiB0b2tlbiBwYWlyIGlzIHByZXNlbnRcbiAgICBpZiAoaW5wdXRzLmlucHV0X2lkcyBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICBpbnB1dHMudG9rZW5fdHlwZV9pZHMgPSBuZXcgVGVuc29yKFxuICAgICAgICAgICAgJ2ludDY0JyxcbiAgICAgICAgICAgIG5ldyBCaWdJbnQ2NEFycmF5KGlucHV0cy5pbnB1dF9pZHMuZGF0YS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5wdXRzLmlucHV0X2lkcy5kaW1zXG4gICAgICAgIClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXRzLmlucHV0X2lkcykpIHtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMuaW5wdXRfaWRzWzBdKSkge1xuICAgICAgICAgICAgLy8gVGhpcyBtZWFucyBpbnB1dCBpcyBiYXRjaGVkLCBzbyB3ZSBuZWVkIHRvIGJhdGNoIHRoZSB0b2tlbl90eXBlX2lkcyBhcyB3ZWxsXG4gICAgICAgICAgICBpbnB1dHMudG9rZW5fdHlwZV9pZHMgPSBpbnB1dHMuaW5wdXRfaWRzLm1hcChcbiAgICAgICAgICAgICAgICB4ID0+IG5ldyBBcnJheSh4Lmxlbmd0aCkuZmlsbCgwKVxuICAgICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRzLnRva2VuX3R5cGVfaWRzID0gbmV3IEFycmF5KGlucHV0cy5pbnB1dF9pZHMubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpZHMgbXVzdCBiZSBhIFRlbnNvciBvciBhbiBBcnJheScpXG4gICAgfVxuXG4gICAgcmV0dXJuIGlucHV0cztcbn1cblxuLyoqXG4gKiBCZXJ0VG9rZW5pemVyIGlzIGEgY2xhc3MgdXNlZCB0byB0b2tlbml6ZSB0ZXh0IGZvciBCRVJUIG1vZGVscy5cbiAqIEBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXJcbiAqL1xuZXhwb3J0IGNsYXNzIEJlcnRUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHtcbiAgICAvKiogQHR5cGUge2FkZF90b2tlbl90eXBlc30gKi9cbiAgICBwcmVwYXJlX21vZGVsX2lucHV0cyhpbnB1dHMpIHtcbiAgICAgICAgcmV0dXJuIGFkZF90b2tlbl90eXBlcyhpbnB1dHMpO1xuICAgIH1cbn1cbi8qKlxuICogQWxiZXJ0IHRva2VuaXplclxuICogQGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplclxuICovXG5leHBvcnQgY2xhc3MgQWxiZXJ0VG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7XG4gICAgLyoqIEB0eXBlIHthZGRfdG9rZW5fdHlwZXN9ICovXG4gICAgcHJlcGFyZV9tb2RlbF9pbnB1dHMoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhZGRfdG9rZW5fdHlwZXMoaW5wdXRzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTW9iaWxlQmVydFRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIge1xuICAgIC8qKiBAdHlwZSB7YWRkX3Rva2VuX3R5cGVzfSAqL1xuICAgIHByZXBhcmVfbW9kZWxfaW5wdXRzKGlucHV0cykge1xuICAgICAgICByZXR1cm4gYWRkX3Rva2VuX3R5cGVzKGlucHV0cyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNxdWVlemVCZXJ0VG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7XG4gICAgLyoqIEB0eXBlIHthZGRfdG9rZW5fdHlwZXN9ICovXG4gICAgcHJlcGFyZV9tb2RlbF9pbnB1dHMoaW5wdXRzKSB7XG4gICAgICAgIHJldHVybiBhZGRfdG9rZW5fdHlwZXMoaW5wdXRzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGlzdGlsQmVydFRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5leHBvcnQgY2xhc3MgVDVUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuZXhwb3J0IGNsYXNzIEdQVDJUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuZXhwb3J0IGNsYXNzIEJhcnRUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuZXhwb3J0IGNsYXNzIFJvYmVydGFUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuXG5leHBvcnQgY2xhc3MgQmxvb21Ub2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuZXhwb3J0IGNsYXNzIExsYW1hVG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7IH1cblxuZXhwb3J0IGNsYXNzIFhMTVJvYmVydGFUb2tlbml6ZXIgZXh0ZW5kcyBQcmVUcmFpbmVkVG9rZW5pemVyIHsgfVxuZXhwb3J0IGNsYXNzIE1QTmV0VG9rZW5pemVyIGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplciB7IH1cblxuZXhwb3J0IGNsYXNzIEZhbGNvblRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIge1xuICAgIC8qKiBAdHlwZSB7YWRkX3Rva2VuX3R5cGVzfSAqL1xuICAgIHByZXBhcmVfbW9kZWxfaW5wdXRzKGlucHV0cykge1xuICAgICAgICByZXR1cm4gYWRkX3Rva2VuX3R5cGVzKGlucHV0cyk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgR1BUTmVvWFRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5cbi8qKlxuICogVGhlIE5sbGJUb2tlbml6ZXIgY2xhc3MgaXMgdXNlZCB0byB0b2tlbml6ZSB0ZXh0IGZvciBOTExCIChcIk5vIExhbmd1YWdlIExlZnQgQmVoaW5kXCIpIG1vZGVscy5cbiAqIFxuICogTm8gTGFuZ3VhZ2UgTGVmdCBCZWhpbmQgKE5MTEIpIGlzIGEgZmlyc3Qtb2YtaXRzLWtpbmQsIEFJIGJyZWFrdGhyb3VnaCBwcm9qZWN0XG4gKiB0aGF0IG9wZW4tc291cmNlcyBtb2RlbHMgY2FwYWJsZSBvZiBkZWxpdmVyaW5nIGhpZ2gtcXVhbGl0eSB0cmFuc2xhdGlvbnMgZGlyZWN0bHlcbiAqIGJldHdlZW4gYW55IHBhaXIgb2YgMjAwKyBsYW5ndWFnZXMg4oCUIGluY2x1ZGluZyBsb3ctcmVzb3VyY2UgbGFuZ3VhZ2VzIGxpa2UgQXN0dXJpYW4sXG4gKiBMdWdhbmRhLCBVcmR1IGFuZCBtb3JlLiBJdCBhaW1zIHRvIGhlbHAgcGVvcGxlIGNvbW11bmljYXRlIHdpdGggYW55b25lLCBhbnl3aGVyZSxcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgbGFuZ3VhZ2UgcHJlZmVyZW5jZXMuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBjaGVjayBvdXQgdGhlaXJcbiAqIFtwYXBlcl0oaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIyMDcuMDQ2NzIpLlxuICogXG4gKiBGb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCBsYW5ndWFnZXMgKGFsb25nIHdpdGggdGhlaXIgbGFuZ3VhZ2UgY29kZXMpLFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rcmVzZWFyY2gvZmxvcmVzL2Jsb2IvbWFpbi9mbG9yZXMyMDAvUkVBRE1FLm1kI2xhbmd1YWdlcy1pbi1mbG9yZXMtMjAwfVxuICovXG5leHBvcnQgY2xhc3MgTmxsYlRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIge1xuXG4gICAgY29uc3RydWN0b3IodG9rZW5pemVySlNPTiwgdG9rZW5pemVyQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyKHRva2VuaXplckpTT04sIHRva2VuaXplckNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5sYW5ndWFnZVJlZ2V4ID0gL15bYS16XXszfV9bQS1aXVthLXpdezN9JC87XG4gICAgICAgIHRoaXMubGFuZ3VhZ2VfY29kZXMgPSB0aGlzLnNwZWNpYWxfdG9rZW5zLmZpbHRlcih4ID0+IHRoaXMubGFuZ3VhZ2VSZWdleC50ZXN0KHgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gYnVpbGQgdHJhbnNsYXRpb24gaW5wdXRzIGZvciBhbiBgTmxsYlRva2VuaXplcmAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHJhd19pbnB1dHMgVGhlIHRleHQgdG8gdG9rZW5pemUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRva2VuaXplcl9vcHRpb25zIE9wdGlvbnMgdG8gYmUgc2VudCB0byB0aGUgdG9rZW5pemVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdlbmVyYXRlX2t3YXJncyBHZW5lcmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IHRvIGJlIHBhc3NlZCB0byB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgX2J1aWxkX3RyYW5zbGF0aW9uX2lucHV0cyhyYXdfaW5wdXRzLCB0b2tlbml6ZXJfb3B0aW9ucywgZ2VuZXJhdGVfa3dhcmdzKSB7XG5cblxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSB0YXJnZXQgbGFuZ3VhZ2UgaXMgdmFsaWQ6XG4gICAgICAgIGlmICghdGhpcy5sYW5ndWFnZV9jb2Rlcy5pbmNsdWRlcyhnZW5lcmF0ZV9rd2FyZ3MudGd0X2xhbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhcmdldCBsYW5ndWFnZSBjb2RlIFwiJHtnZW5lcmF0ZV9rd2FyZ3MudGd0X2xhbmd9XCIgaXMgbm90IHZhbGlkLiBNdXN0IGJlIG9uZSBvZjogeyR7dGhpcy5sYW5ndWFnZV9jb2Rlcy5qb2luKCcsICcpfX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93IGBzcmNfbGFuZ2AgdG8gYmUgb3B0aW9uYWwuIElmIG5vdCBzZXQsIHdlJ2xsIHVzZSB0aGUgdG9rZW5pemVyJ3MgZGVmYXVsdC5cbiAgICAgICAgaWYgKGdlbmVyYXRlX2t3YXJncy5zcmNfbGFuZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBzb3VyY2UgbGFuZ3VhZ2UgaXMgdmFsaWQ6XG4gICAgICAgICAgICBpZiAoIXRoaXMubGFuZ3VhZ2VfY29kZXMuaW5jbHVkZXMoZ2VuZXJhdGVfa3dhcmdzLnNyY19sYW5nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU291cmNlIGxhbmd1YWdlIGNvZGUgXCIke2dlbmVyYXRlX2t3YXJncy5zcmNfbGFuZ31cIiBpcyBub3QgdmFsaWQuIE11c3QgYmUgb25lIG9mOiB7JHt0aGlzLmxhbmd1YWdlX2NvZGVzLmpvaW4oJywgJyl9fWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbiB0aGUgc2FtZSB3YXkgYXMgdGhlIFB5dGhvbiBsaWJyYXJ5LCB3ZSBvdmVycmlkZSB0aGUgcG9zdC1wcm9jZXNzb3JcbiAgICAgICAgICAgIC8vIHRvIGZvcmNlIHRoZSBzb3VyY2UgbGFuZ3VhZ2UgdG8gYmUgZmlyc3Q6XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMucG9zdF9wcm9jZXNzb3IuY29uZmlnLnNpbmdsZSkge1xuICAgICAgICAgICAgICAgIGlmICgnU3BlY2lhbFRva2VuJyBpbiBpdGVtICYmIHRoaXMubGFuZ3VhZ2VSZWdleC50ZXN0KGl0ZW0uU3BlY2lhbFRva2VuLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLlNwZWNpYWxUb2tlbi5pZCA9IGdlbmVyYXRlX2t3YXJncy5zcmNfbGFuZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGBmb3JjZWRfYm9zX3Rva2VuX2lkYCB0byBmb3JjZSB0aGUgY29ycmVjdCBsYW5ndWFnZVxuICAgICAgICBnZW5lcmF0ZV9rd2FyZ3MuZm9yY2VkX2Jvc190b2tlbl9pZCA9IHRoaXMubW9kZWwuY29udmVydF90b2tlbnNfdG9faWRzKFtnZW5lcmF0ZV9rd2FyZ3MudGd0X2xhbmddKVswXTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbChyYXdfaW5wdXRzLCB0b2tlbml6ZXJfb3B0aW9ucyk7XG4gICAgfVxufVxuXG5cbmNvbnN0IFdISVNQRVJfTEFOR1VBR0VTID0gW1xuICAgIFtcImVuXCIsIFwiZW5nbGlzaFwiXSxcbiAgICBbXCJ6aFwiLCBcImNoaW5lc2VcIl0sXG4gICAgW1wiZGVcIiwgXCJnZXJtYW5cIl0sXG4gICAgW1wiZXNcIiwgXCJzcGFuaXNoXCJdLFxuICAgIFtcInJ1XCIsIFwicnVzc2lhblwiXSxcbiAgICBbXCJrb1wiLCBcImtvcmVhblwiXSxcbiAgICBbXCJmclwiLCBcImZyZW5jaFwiXSxcbiAgICBbXCJqYVwiLCBcImphcGFuZXNlXCJdLFxuICAgIFtcInB0XCIsIFwicG9ydHVndWVzZVwiXSxcbiAgICBbXCJ0clwiLCBcInR1cmtpc2hcIl0sXG4gICAgW1wicGxcIiwgXCJwb2xpc2hcIl0sXG4gICAgW1wiY2FcIiwgXCJjYXRhbGFuXCJdLFxuICAgIFtcIm5sXCIsIFwiZHV0Y2hcIl0sXG4gICAgW1wiYXJcIiwgXCJhcmFiaWNcIl0sXG4gICAgW1wic3ZcIiwgXCJzd2VkaXNoXCJdLFxuICAgIFtcIml0XCIsIFwiaXRhbGlhblwiXSxcbiAgICBbXCJpZFwiLCBcImluZG9uZXNpYW5cIl0sXG4gICAgW1wiaGlcIiwgXCJoaW5kaVwiXSxcbiAgICBbXCJmaVwiLCBcImZpbm5pc2hcIl0sXG4gICAgW1widmlcIiwgXCJ2aWV0bmFtZXNlXCJdLFxuICAgIFtcImhlXCIsIFwiaGVicmV3XCJdLFxuICAgIFtcInVrXCIsIFwidWtyYWluaWFuXCJdLFxuICAgIFtcImVsXCIsIFwiZ3JlZWtcIl0sXG4gICAgW1wibXNcIiwgXCJtYWxheVwiXSxcbiAgICBbXCJjc1wiLCBcImN6ZWNoXCJdLFxuICAgIFtcInJvXCIsIFwicm9tYW5pYW5cIl0sXG4gICAgW1wiZGFcIiwgXCJkYW5pc2hcIl0sXG4gICAgW1wiaHVcIiwgXCJodW5nYXJpYW5cIl0sXG4gICAgW1widGFcIiwgXCJ0YW1pbFwiXSxcbiAgICBbXCJub1wiLCBcIm5vcndlZ2lhblwiXSxcbiAgICBbXCJ0aFwiLCBcInRoYWlcIl0sXG4gICAgW1widXJcIiwgXCJ1cmR1XCJdLFxuICAgIFtcImhyXCIsIFwiY3JvYXRpYW5cIl0sXG4gICAgW1wiYmdcIiwgXCJidWxnYXJpYW5cIl0sXG4gICAgW1wibHRcIiwgXCJsaXRodWFuaWFuXCJdLFxuICAgIFtcImxhXCIsIFwibGF0aW5cIl0sXG4gICAgW1wibWlcIiwgXCJtYW9yaVwiXSxcbiAgICBbXCJtbFwiLCBcIm1hbGF5YWxhbVwiXSxcbiAgICBbXCJjeVwiLCBcIndlbHNoXCJdLFxuICAgIFtcInNrXCIsIFwic2xvdmFrXCJdLFxuICAgIFtcInRlXCIsIFwidGVsdWd1XCJdLFxuICAgIFtcImZhXCIsIFwicGVyc2lhblwiXSxcbiAgICBbXCJsdlwiLCBcImxhdHZpYW5cIl0sXG4gICAgW1wiYm5cIiwgXCJiZW5nYWxpXCJdLFxuICAgIFtcInNyXCIsIFwic2VyYmlhblwiXSxcbiAgICBbXCJhelwiLCBcImF6ZXJiYWlqYW5pXCJdLFxuICAgIFtcInNsXCIsIFwic2xvdmVuaWFuXCJdLFxuICAgIFtcImtuXCIsIFwia2FubmFkYVwiXSxcbiAgICBbXCJldFwiLCBcImVzdG9uaWFuXCJdLFxuICAgIFtcIm1rXCIsIFwibWFjZWRvbmlhblwiXSxcbiAgICBbXCJiclwiLCBcImJyZXRvblwiXSxcbiAgICBbXCJldVwiLCBcImJhc3F1ZVwiXSxcbiAgICBbXCJpc1wiLCBcImljZWxhbmRpY1wiXSxcbiAgICBbXCJoeVwiLCBcImFybWVuaWFuXCJdLFxuICAgIFtcIm5lXCIsIFwibmVwYWxpXCJdLFxuICAgIFtcIm1uXCIsIFwibW9uZ29saWFuXCJdLFxuICAgIFtcImJzXCIsIFwiYm9zbmlhblwiXSxcbiAgICBbXCJra1wiLCBcImthemFraFwiXSxcbiAgICBbXCJzcVwiLCBcImFsYmFuaWFuXCJdLFxuICAgIFtcInN3XCIsIFwic3dhaGlsaVwiXSxcbiAgICBbXCJnbFwiLCBcImdhbGljaWFuXCJdLFxuICAgIFtcIm1yXCIsIFwibWFyYXRoaVwiXSxcbiAgICBbXCJwYVwiLCBcInB1bmphYmlcIl0sXG4gICAgW1wic2lcIiwgXCJzaW5oYWxhXCJdLFxuICAgIFtcImttXCIsIFwia2htZXJcIl0sXG4gICAgW1wic25cIiwgXCJzaG9uYVwiXSxcbiAgICBbXCJ5b1wiLCBcInlvcnViYVwiXSxcbiAgICBbXCJzb1wiLCBcInNvbWFsaVwiXSxcbiAgICBbXCJhZlwiLCBcImFmcmlrYWFuc1wiXSxcbiAgICBbXCJvY1wiLCBcIm9jY2l0YW5cIl0sXG4gICAgW1wia2FcIiwgXCJnZW9yZ2lhblwiXSxcbiAgICBbXCJiZVwiLCBcImJlbGFydXNpYW5cIl0sXG4gICAgW1widGdcIiwgXCJ0YWppa1wiXSxcbiAgICBbXCJzZFwiLCBcInNpbmRoaVwiXSxcbiAgICBbXCJndVwiLCBcImd1amFyYXRpXCJdLFxuICAgIFtcImFtXCIsIFwiYW1oYXJpY1wiXSxcbiAgICBbXCJ5aVwiLCBcInlpZGRpc2hcIl0sXG4gICAgW1wibG9cIiwgXCJsYW9cIl0sXG4gICAgW1widXpcIiwgXCJ1emJla1wiXSxcbiAgICBbXCJmb1wiLCBcImZhcm9lc2VcIl0sXG4gICAgW1wiaHRcIiwgXCJoYWl0aWFuIGNyZW9sZVwiXSxcbiAgICBbXCJwc1wiLCBcInBhc2h0b1wiXSxcbiAgICBbXCJ0a1wiLCBcInR1cmttZW5cIl0sXG4gICAgW1wibm5cIiwgXCJueW5vcnNrXCJdLFxuICAgIFtcIm10XCIsIFwibWFsdGVzZVwiXSxcbiAgICBbXCJzYVwiLCBcInNhbnNrcml0XCJdLFxuICAgIFtcImxiXCIsIFwibHV4ZW1ib3VyZ2lzaFwiXSxcbiAgICBbXCJteVwiLCBcIm15YW5tYXJcIl0sXG4gICAgW1wiYm9cIiwgXCJ0aWJldGFuXCJdLFxuICAgIFtcInRsXCIsIFwidGFnYWxvZ1wiXSxcbiAgICBbXCJtZ1wiLCBcIm1hbGFnYXN5XCJdLFxuICAgIFtcImFzXCIsIFwiYXNzYW1lc2VcIl0sXG4gICAgW1widHRcIiwgXCJ0YXRhclwiXSxcbiAgICBbXCJoYXdcIiwgXCJoYXdhaWlhblwiXSxcbiAgICBbXCJsblwiLCBcImxpbmdhbGFcIl0sXG4gICAgW1wiaGFcIiwgXCJoYXVzYVwiXSxcbiAgICBbXCJiYVwiLCBcImJhc2hraXJcIl0sXG4gICAgW1wiandcIiwgXCJqYXZhbmVzZVwiXSxcbiAgICBbXCJzdVwiLCBcInN1bmRhbmVzZVwiXSxcbl1cblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgV0hJU1BFUl9MQU5HVUFHRV9NQVBQSU5HID0gbmV3IE1hcChXSElTUEVSX0xBTkdVQUdFUyk7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBXSElTUEVSX1RPX0xBTkdVQUdFX0NPREVfTUFQUElORyA9IG5ldyBNYXAoW1xuICAgIC4uLldISVNQRVJfTEFOR1VBR0VTLm1hcCgoW2ssIHZdKSA9PiBbdiwga10pLFxuICAgIC4uLltcbiAgICAgICAgW1wiYnVybWVzZVwiLCBcIm15XCJdLFxuICAgICAgICBbXCJ2YWxlbmNpYW5cIiwgXCJjYVwiXSxcbiAgICAgICAgW1wiZmxlbWlzaFwiLCBcIm5sXCJdLFxuICAgICAgICBbXCJoYWl0aWFuXCIsIFwiaHRcIl0sXG4gICAgICAgIFtcImxldHplYnVyZ2VzY2hcIiwgXCJsYlwiXSxcbiAgICAgICAgW1wicHVzaHRvXCIsIFwicHNcIl0sXG4gICAgICAgIFtcInBhbmphYmlcIiwgXCJwYVwiXSxcbiAgICAgICAgW1wibW9sZGF2aWFuXCIsIFwicm9cIl0sXG4gICAgICAgIFtcIm1vbGRvdmFuXCIsIFwicm9cIl0sXG4gICAgICAgIFtcInNpbmhhbGVzZVwiLCBcInNpXCJdLFxuICAgICAgICBbXCJjYXN0aWxpYW5cIiwgXCJlc1wiXSxcbiAgICBdXG5dKTtcblxuLyoqXG4gKiBXaGlzcGVyVG9rZW5pemVyIHRva2VuaXplclxuICogQGV4dGVuZHMgUHJlVHJhaW5lZFRva2VuaXplclxuICovXG5leHBvcnQgY2xhc3MgV2hpc3BlclRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIge1xuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhdXRvbWF0aWMgc3BlZWNoIHJlY29nbml0aW9uIChBU1IpIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5PHt0b2tlbnM6IG51bWJlcltdLCB0b2tlbl90aW1lc3RhbXBzPzogbnVtYmVyW10sIHN0cmlkZTogbnVtYmVyW119Pn0gc2VxdWVuY2VzIFRoZSBzZXF1ZW5jZXMgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHRvIHVzZSBmb3IgZGVjb2RpbmcuXG4gICAgICogQHJldHVybnMge0FycmF5PHN0cmluZ3x7Y2h1bmtzPzogdW5kZWZpbmVkfEFycmF5PHtsYW5ndWFnZTogc3RyaW5nfG51bGwsIHRpbWVzdGFtcDogQXJyYXk8bnVtYmVyfG51bGw+LCB0ZXh0OiBzdHJpbmd9Pn0+fSBUaGUgZGVjb2RlZCBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgX2RlY29kZV9hc3Ioc2VxdWVuY2VzLCB7XG4gICAgICAgIHJldHVybl90aW1lc3RhbXBzID0gZmFsc2UsXG4gICAgICAgIHJldHVybl9sYW5ndWFnZSA9IGZhbHNlLFxuICAgICAgICB0aW1lX3ByZWNpc2lvbiA9IG51bGwsXG4gICAgICAgIGZvcmNlX2Z1bGxfc2VxdWVuY2VzID0gdHJ1ZVxuICAgIH0gPSB7fSkge1xuICAgICAgICAvLyBTZXQgZm9yY2VfZnVsbF9zZXF1ZW5jZXM9ZmFsc2UgaWYgeW91IHdhbnQgc3RyZWFtaW5nXG4gICAgICAgIC8vIFRPRE8gYWRkIHN1cHBvcnQgZm9yIGByZXR1cm5fbGFuZ3VhZ2VgXG5cbiAgICAgICAgLy8gSW50ZXJuYWwgbWV0aG9kIG1lYW50IHRvIG9ubHkgYmUgdXNlZCBieSBhc3IgcGlwZWxpbmUuXG4gICAgICAgIC8vIEhhbmRsZXMgYWxsIHRoZSBsaXR0bGUgcXVpcmtzIHNwZWNpZmljIHRvIHdoaXNwZXIgdG8gaGFuZGxlXG4gICAgICAgIC8vIHRoZSB2YXJpb3VzIG9wdGlvbnMgbm90IGFsbG93ZWQgaW4gb3RoZXIgc2VxMnNlcSBtb2RlbHNcblxuICAgICAgICAvLyA9PT09PT09PT09PSBPdmVydmlldyA9PT09PT09PT09PT1cbiAgICAgICAgLy8gLSBpdGVyYXRlIG92ZXIgYWxsIG91dHB1dHNcbiAgICAgICAgLy8gLSBhbGwgdG9rZW5zIHdpdGhpbiBvdXRwdXRcbiAgICAgICAgLy8gLSBFYWNoIHRva2VuIGNhbiBiZVxuICAgICAgICAvLyAgIC0gbGFuZ3VhZ2UgdG9rZW5cbiAgICAgICAgLy8gICAtIHNwZWNpYWwgdG9rZW5cbiAgICAgICAgLy8gICAtIHRpbWVzdGFtcCB0b2tlblxuICAgICAgICAvLyAgIC0gdGV4dCB0b2tlblxuICAgICAgICAvLyAtIFdlIGFjY3VtdWxhdGUgdGhlIHRleHQgdG9rZW5zLlxuICAgICAgICAvLyAtIFdlIHNwbGl0IG9uIGVuZCB0aW1lc3RhbXBzXG4gICAgICAgIC8vIC0gTG90cyBvZiBjb21wbGV4aXR5IGNvbWVzIGZyb20gc3RyaWRlIGFuZCB0aW1lc3RhbXBzXG5cbiAgICAgICAgaWYgKHRpbWVfcHJlY2lzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIk11c3Qgc3BlY2lmeSB0aW1lX3ByZWNpc2lvblwiKVxuICAgICAgICB9XG4gICAgICAgIGxldCBsYXN0X2xhbmd1YWdlID0gbnVsbDtcblxuICAgICAgICBjb25zdCByZXR1cm5Xb3JkVGltZXN0YW1wcyA9IHJldHVybl90aW1lc3RhbXBzID09PSBcIndvcmRcIjtcblxuICAgICAgICBmdW5jdGlvbiBuZXdfY2h1bmsoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBcImxhbmd1YWdlXCI6IGxhc3RfbGFuZ3VhZ2UsIFwidGltZXN0YW1wXCI6IFtudWxsLCBudWxsXSwgXCJ0ZXh0XCI6IFwiXCIgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlbGNvbWUgdG8gdGhlIHN0YXRlIG1hY2hpbmUhXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXdfY2h1bmsoKTtcbiAgICAgICAgbGV0IHRpbWVfb2Zmc2V0ID0gMC4wO1xuICAgICAgICBjb25zdCB0aW1lc3RhbXBfYmVnaW4gPSB0aGlzLm1vZGVsLmNvbnZlcnRfdG9rZW5zX3RvX2lkcyhbXCI8fG5vdGltZXN0YW1wc3w+XCJdKVswXSArIDE7XG5cbiAgICAgICAgbGV0IHByZXZpb3VzX3Rva2VucyA9IFtdO1xuICAgICAgICBsZXQgcHJldmlvdXNfdG9rZW5fdGltZXN0YW1wcyA9IFtdO1xuXG4gICAgICAgIGxldCBza2lwID0gZmFsc2U7XG4gICAgICAgIGxldCByaWdodF9zdHJpZGVfc3RhcnQgPSBudWxsO1xuXG5cbiAgICAgICAgY29uc3QgYWxsX3NwZWNpYWxfaWRzID0gbmV3IFNldCh0aGlzLmFsbF9zcGVjaWFsX2lkcyk7XG5cbiAgICAgICAgZm9yIChsZXQgb3V0cHV0IG9mIHNlcXVlbmNlcykge1xuICAgICAgICAgICAgLy8gTk9URTogcHl0aG9uIHZlcnNpb24gaGFzIGJhdGNoZXMsIHNvIGl0IHVzZXMgWzBdXG4gICAgICAgICAgICBjb25zdCB0b2tlbl9pZHMgPSBvdXRwdXQudG9rZW5zO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5fdGltZXN0YW1wcyA9IHJldHVybldvcmRUaW1lc3RhbXBzID8gb3V0cHV0LnRva2VuX3RpbWVzdGFtcHMgOiBudWxsO1xuXG4gICAgICAgICAgICAvLyBUaGVzZSBrZWVwIHRyYWNrIG9mIHRpbWVzdGFtcHMgd2l0aGluIHN0cmlkZXMsIHdoaWNoIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGJlIHNraXBwZWQgYW5kIHJlc29sdmUgYWxsIHRva2VucyBpbiBhIHNpbmdsZSBjaHVuay5cbiAgICAgICAgICAgIGxldCBsYXN0X3RpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZmlyc3RfdGltZXN0YW1wID0gdGltZXN0YW1wX2JlZ2luO1xuXG4gICAgICAgICAgICBpZiAoXCJzdHJpZGVcIiBpbiBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY2h1bmtfbGVuLCBzdHJpZGVfbGVmdCwgc3RyaWRlX3JpZ2h0XSA9IG91dHB1dC5zdHJpZGU7XG5cbiAgICAgICAgICAgICAgICAvLyBPZmZzZXQgdGhlIHRpbWluZ3MgdG8gYWNjb3VudCBmb3IgdGhlIG90aGVyIGBtb2RlbF9vdXRwdXRzYC5cbiAgICAgICAgICAgICAgICB0aW1lX29mZnNldCAtPSBzdHJpZGVfbGVmdDtcbiAgICAgICAgICAgICAgICByaWdodF9zdHJpZGVfc3RhcnQgPSBjaHVua19sZW4gLSBzdHJpZGVfcmlnaHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBLZWVwaW5nIHRyYWNrIG9mIHRpbWVzdGFtcHMgd2l0aGluIHN0cmlkZXNcbiAgICAgICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBOT1Qgc3BsaXQgb24gdGhvc2UsIGFuZCBkZWxheSB1bnRpbCB3ZSdyZVxuICAgICAgICAgICAgICAgIC8vIG91dCBvZiBCT1RIIHN0cmlkZS4gT3RoZXJ3aXNlIGxvdHMgb2YgaXNzdWVzIG9jY3VyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGNvcm5lciBjYXNlc1xuICAgICAgICAgICAgICAgIGlmIChzdHJpZGVfbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdF90aW1lc3RhbXAgPSBzdHJpZGVfbGVmdCAvIHRpbWVfcHJlY2lzaW9uICsgdGltZXN0YW1wX2JlZ2luO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdHJpZGVfcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRva2VuX2lkcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbl9pZHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPj0gdGltZXN0YW1wX2JlZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgY2FuIGJlIHNldmVyYWwgdG9rZW4gaW4gdGhlIHJpZ2h0IHN0cmlkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCB0aGUgbGFzdCBvbmUgaXMgQUxXQVlTIGdvaW5nIHRvIGJlIHNraXBwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF90aW1lc3RhbXAgIT09IG51bGwgJiYgKHRva2VuIC0gdGltZXN0YW1wX2JlZ2luKSAqIHRpbWVfcHJlY2lzaW9uIDwgcmlnaHRfc3RyaWRlX3N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X3RpbWVzdGFtcCA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY3VycmVudF90b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50X3Rva2VuX3RpbWVzdGFtcHMgPSBbXTtcblxuICAgICAgICAgICAgLy8gLSBhbGwgdG9rZW5zIHdpdGhpbiBvdXRwdXRcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5faWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbl9pZHNbaV07XG4gICAgICAgICAgICAgICAgLy8gNCBwb3NzaWJsZSBzdGF0ZXMgZm9yIGVhY2ggdG9rZW5cbiAgICAgICAgICAgICAgICAvLyAtIDEvIExhbmd1YWdlIGNvZGVcbiAgICAgICAgICAgICAgICAvLyAtIDIvIGFsbCBvdGhlciBzcGVjaWFsIHRva2VucyAod2hpY2ggd2UgaWdub3JlKVxuICAgICAgICAgICAgICAgIC8vIC0gMy8gVGltZXN0YW1wXG4gICAgICAgICAgICAgICAgLy8gLSA0LyBSZWd1bGFyIHRleHRcblxuICAgICAgICAgICAgICAgIGlmIChhbGxfc3BlY2lhbF9pZHMuaGFzKHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5kZWNvZGUoW3Rva2VuXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0WzBdID09PSBcIltcIiAmJiB0ZXh0W3RleHQubGVuZ3RoIC0gMV0gPT09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYW5ndWFnZSA9IFdISVNQRVJfTEFOR1VBR0VfTUFQUElORy5nZXQodGV4dC5zbGljZSgxLCAtMSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEvIEluZGVlZCBzb21lIGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBIYW5kbGUgd2hlbiBsYW5ndWFnZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmUsIGFuZCB3ZSBjYW5ub3QgdXNlIHRpbWVzdGFtcGVkIHRva2VucyB0byBjcmVhdGUgY2h1bmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RfbGFuZ3VhZ2UgIT09IG51bGwgJiYgbGFuZ3VhZ2UgIT09IGxhc3RfbGFuZ3VhZ2UgJiYgIXJldHVybl90aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rva2Vucy5wdXNoKGN1cnJlbnRfdG9rZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRfdG9rZW5zID0gdGhpcy5maW5kTG9uZ2VzdENvbW1vblNlcXVlbmNlKHByZXZpb3VzX3Rva2VucylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkX3RleHQgPSB0aGlzLmRlY29kZShyZXNvbHZlZF90b2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay50ZXh0ID0gcmVzb2x2ZWRfdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsdXNoIGFsbCBvdXIgdGVtcG9yYXJ5IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfdG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rID0gbmV3X2NodW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9sYW5ndWFnZSA9IGNodW5rLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIvIFRoaXMgaXMgYSByZWd1bGFyIHNwZWNpYWwgdG9rZW4sIGlnbm9yaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuID49IHRpbWVzdGFtcF9iZWdpbikge1xuICAgICAgICAgICAgICAgICAgICAvLyAzLyBUaW1lc3RhbXAgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZSA9ICh0b2tlbiAtIHRpbWVzdGFtcF9iZWdpbikgKiB0aW1lX3ByZWNpc2lvbiArIHRpbWVfb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3VuZGVkX3RpbWUgPSByb3VuZCh0aW1lLCAyKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdF90aW1lc3RhbXAgIT09IG51bGwgJiYgdG9rZW4gPj0gbGFzdF90aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoaXNwZXIgb3V0cHV0dGVkIGEgdGltZXN0YW1wIHRva2VuLCBidXQgaXQgZmFsbHMgd2l0aGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXIgc3RyaWRlLCBzbyB3ZSdyZSBnb2luZyB0byBza2lwIGl0IGZvciB0aGUgdGltZSBiZWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHJlc29sdmUgdGhpcyBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aW1lc3RhbXAgdG9rZW5zIGFsd2F5cyBjb21lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBwYWlyLCBzbyB3ZSBuZWVkIHRvIHNraXAgdGhlIG5leHQgb25lIHRvbyAod2hpY2ggd291bGQgbWFyayB0aGUgc3RhcnQgb2YgYW5vdGhlciBjaHVuaykuXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChza2lwIHx8IChwcmV2aW91c190b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbiA8IGZpcnN0X3RpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaHVuay50aW1lc3RhbXBbMF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnRpbWVzdGFtcFswXSA9IHJvdW5kZWRfdGltZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgdGltZXN0YW1wIGNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91bmRlZF90aW1lID09PSBjaHVuay50aW1lc3RhbXBbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgYnVnIGluIHRpbWVzdGFtcCB0b2tlbiBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZSB3ZSdyZSB0YWtpbmcgdGhlIGR1cGxpY2F0ZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIGEgc3RvcCB3aGVyZSBpdCBzaG91bGQgYmUgYSBzdGFydC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGlzc3VlIGluIHRoZSB1bmRlcmx5aW5nIG1vZGVsIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExldCdzIGp1c3Qgc2tpcCBpdCBzbyBpdCBiZWNvbWVzIGRlLWZhY3RvciBhIHN0YXJ0IGFnaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsudGltZXN0YW1wWzFdID0gcm91bmRlZF90aW1lO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxpbmcgbWVyZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfdG9rZW5zLnB1c2goY3VycmVudF90b2tlbnMpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuV29yZFRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfdG9rZW5fdGltZXN0YW1wcy5wdXNoKGN1cnJlbnRfdG9rZW5fdGltZXN0YW1wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtyZXNvbHZlZF90b2tlbnMsIHJlc29sdmVkX3Rva2VuX3RpbWVzdGFtcHNdID0gdGhpcy5maW5kTG9uZ2VzdENvbW1vblNlcXVlbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c190b2tlbnMsIHByZXZpb3VzX3Rva2VuX3RpbWVzdGFtcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZF90ZXh0ID0gdGhpcy5kZWNvZGUocmVzb2x2ZWRfdG9rZW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLnRleHQgPSByZXNvbHZlZF90ZXh0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuV29yZFRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsud29yZHMgPSB0aGlzLmNvbGxhdGVXb3JkVGltZXN0YW1wcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkX3Rva2VucywgcmVzb2x2ZWRfdG9rZW5fdGltZXN0YW1wcywgbGFzdF9sYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmx1c2ggYWxsIG91ciB0ZW1wb3JhcnkgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rva2VucyA9IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF90b2tlbnMgPSBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rva2VuX3RpbWVzdGFtcHMgPSBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW5fdGltZXN0YW1wcyA9IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBuZXdfY2h1bmsoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyA0LyBSZWd1bGFyIHRva2VuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGp1c3QgYXBwZW5kIHRvIHRoZSBsaXN0IG9mIGFsbCB0b2tlbnMgc28gd2UgY2FuIGhhbmRsZVxuICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZXMgbGF0ZXIgYW5kIGRlY29kZSBpbnRvIHRleHQuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW5zLnB1c2godG9rZW4pXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybldvcmRUaW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnRfdGltZSA9IHJvdW5kKHRva2VuX3RpbWVzdGFtcHNbaV0gKyB0aW1lX29mZnNldCwgMik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmRfdGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IHRva2VuX3RpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kX3RpbWUgPSByb3VuZCh0b2tlbl90aW1lc3RhbXBzW2kgKyAxXSArIHRpbWVfb2Zmc2V0LCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZF90aW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW5fdGltZXN0YW1wcy5wdXNoKFtzdGFydF90aW1lLCBlbmRfdGltZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgnc3RyaWRlJyBpbiBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY2h1bmtfbGVuLCBzdHJpZGVfbGVmdCwgc3RyaWRlX3JpZ2h0XSA9IG91dHB1dC5zdHJpZGU7XG4gICAgICAgICAgICAgICAgdGltZV9vZmZzZXQgKz0gY2h1bmtfbGVuIC0gc3RyaWRlX3JpZ2h0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExlZnRvdmVyIHRva2Vuc1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRfdG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c190b2tlbnMucHVzaChjdXJyZW50X3Rva2VucylcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuV29yZFRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfdG9rZW5fdGltZXN0YW1wcy5wdXNoKGN1cnJlbnRfdG9rZW5fdGltZXN0YW1wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c190b2tlbnMuZXZlcnkocCA9PiBwLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGbHVzaGluZyBwcmV2aW91cyB0b2tlbnMgKEVORClcIlxuICAgICAgICAgICAgICAgIGNodW5rID0gbmV3X2NodW5rKClcbiAgICAgICAgICAgICAgICBwcmV2aW91c190b2tlbnMgPSBbXVxuICAgICAgICAgICAgICAgIGN1cnJlbnRfdG9rZW5zID0gW11cbiAgICAgICAgICAgICAgICBwcmV2aW91c190b2tlbl90aW1lc3RhbXBzID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudF90b2tlbl90aW1lc3RhbXBzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2aW91c190b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGZvcmNlX2Z1bGxfc2VxdWVuY2VzICYmIHJldHVybl90aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgLy8gTGFzdCB0b2tlbiBzaG91bGQgYWx3YXlzIGJlIHRpbWVzdGFtcHMsIHNvIHRoZXJlIHNob3VsZG4ndCBiZVxuICAgICAgICAgICAgICAgIC8vIGxlZnRvdmVyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIldoaXNwZXIgZGlkIG5vdCBwcmVkaWN0IGFuIGVuZGluZyB0aW1lc3RhbXAsIHdoaWNoIGNhbiBoYXBwZW4gaWYgYXVkaW8gaXMgY3V0IG9mZiBpbiB0aGUgbWlkZGxlIG9mIGEgd29yZC4gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIkFsc28gbWFrZSBzdXJlIFdoaXNwZXJUaW1lU3RhbXBMb2dpdHNQcm9jZXNzb3Igd2FzIHVzZWQgZHVyaW5nIGdlbmVyYXRpb24uXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYXBwZW5zIHdoZW4gd2UgZG9uJ3QgdXNlIHRpbWVzdGFtcHNcbiAgICAgICAgICAgIGNvbnN0IFtyZXNvbHZlZF90b2tlbnMsIHJlc29sdmVkX3Rva2VuX3RpbWVzdGFtcHNdID0gdGhpcy5maW5kTG9uZ2VzdENvbW1vblNlcXVlbmNlKHByZXZpb3VzX3Rva2VucywgcHJldmlvdXNfdG9rZW5fdGltZXN0YW1wcyk7XG5cbiAgICAgICAgICAgIC8vIEZsdXNoaW5nIHByZXZpb3VzIHRva2VucyAoRklOQUwpXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZF90ZXh0ID0gdGhpcy5kZWNvZGUocmVzb2x2ZWRfdG9rZW5zKTtcbiAgICAgICAgICAgIGNodW5rLnRleHQgPSByZXNvbHZlZF90ZXh0O1xuICAgICAgICAgICAgaWYgKHJldHVybldvcmRUaW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsud29yZHMgPSB0aGlzLmNvbGxhdGVXb3JkVGltZXN0YW1wcyhcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRfdG9rZW5zLCByZXNvbHZlZF90b2tlbl90aW1lc3RhbXBzLCBsYXN0X2xhbmd1YWdlLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvcHRpb25hbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgICAgLy8gUHJlcGFyaW5nIGFuZCBjbGVhbmluZyB1cCB0aGUgcGlwZWxpbmUgb3V0cHV0XG4gICAgICAgIGNvbnN0IGZ1bGxfdGV4dCA9IGNodW5rcy5tYXAoY2h1bmsgPT4gY2h1bmsudGV4dCkuam9pbignJyk7XG4gICAgICAgIGlmIChyZXR1cm5fdGltZXN0YW1wcyB8fCByZXR1cm5fbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXR1cm5fdGltZXN0YW1wcykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2h1bmtbXCJ0aW1lc3RhbXBcIl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXR1cm5fbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNodW5rW1wibGFuZ3VhZ2VcIl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldHVybldvcmRUaW1lc3RhbXBzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld19jaHVua3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgd29yZCBvZiBjaHVuay53b3Jkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2NodW5rcy5wdXNoKHdvcmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbmFsID0geyBcImNodW5rc1wiOiBuZXdfY2h1bmtzIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbmFsID0geyBcImNodW5rc1wiOiBjaHVua3MgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2Z1bGxfdGV4dCwgb3B0aW9uYWxdO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGxvbmdlc3QgY29tbW9uIHNlcXVlbmNlIGFtb25nIHRoZSBwcm92aWRlZCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBzZXF1ZW5jZXMgQW4gYXJyYXkgb2Ygc2VxdWVuY2VzIG9mIHRva2VuIGlkcyB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXVtdfSBUaGUgbG9uZ2VzdCBjb21tb24gc2VxdWVuY2UgZm91bmQuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGEgYnVnIHdpdGhpbiB0aGUgZnVuY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaW5kTG9uZ2VzdENvbW1vblNlcXVlbmNlKHNlcXVlbmNlcywgdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlcyA9IG51bGwpIHtcbiAgICAgICAgLy8gSXQgd291bGQgYmUgbXVjaCBoYXJkZXIgdG8gZG8gTyhuKSBiZWNhdXNlIG9mIGZhdWx0IHRvbGVyYW5jZS5cbiAgICAgICAgLy8gV2UgYWN0dWFsbHkgaGF2ZSBhIHJlYWxseSBnb29kIHByb3BlcnR5IHdoaWNoIGlzIHRoYXQgdGhlIHRvdGFsIHNlcXVlbmNlXG4gICAgICAgIC8vIE1VU1QgYmUgdGhvc2Ugc3Vic2VxdWVuY2VzIGluIG9yZGVyLlxuICAgICAgICAvLyBJZiB0b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzIGlzIHByb3ZpZGVkLCB3aWxsIHNwbGl0IHRob3NlIHNlcXVlbmNlcyBpblxuICAgICAgICAvLyBleGFjdGx5IHRoZSBzYW1lIHdheS5cbiAgICAgICAgbGV0IGxlZnRTZXF1ZW5jZSA9IHNlcXVlbmNlc1swXTtcbiAgICAgICAgbGV0IGxlZnRMZW5ndGggPSBsZWZ0U2VxdWVuY2UubGVuZ3RoO1xuICAgICAgICBsZXQgdG90YWxTZXF1ZW5jZSA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHVzZV90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzID0gQXJyYXkuaXNBcnJheSh0b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzKSAmJiB0b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzLmxlbmd0aCA+IDA7XG4gICAgICAgIGxldCB0b3RhbF90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2UgPSB1c2VfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlcyA/IFtdIDogbnVsbDtcbiAgICAgICAgbGV0IGxlZnRfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlID0gdXNlX3Rva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZXMgPyB0b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VzWzBdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZXF1ZW5jZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0U2VxdWVuY2UgPSBzZXF1ZW5jZXNbaV07XG4gICAgICAgICAgICBsZXQgbWF4ID0gMC4wO1xuICAgICAgICAgICAgbGV0IG1heEluZGljZXMgPSBbbGVmdExlbmd0aCwgbGVmdExlbmd0aCwgMCwgMF07XG4gICAgICAgICAgICAvLyBIZXJlIHdlJ3JlIHNsaWRpbmcgbWF0Y2hlc1xuICAgICAgICAgICAgLy8gW2EsIGIsIGMsIGRdXG4gICAgICAgICAgICAvLyAgICAgICAgICBbYywgZCwgZl1cbiAgICAgICAgICAgIC8vID0gICAgICAgIFtjXSA9PSBbZF1cblxuICAgICAgICAgICAgLy8gW2EsIGIsIGMsIGRdXG4gICAgICAgICAgICAvLyAgICAgICBbYywgZCwgZl1cbiAgICAgICAgICAgIC8vID0gICAgIFtjLCBkXSA9PSBbYywgZF1cblxuXG4gICAgICAgICAgICAvLyBbYSwgYiwgYywgZF1cbiAgICAgICAgICAgIC8vICAgIFtjLCBkLCBmXVxuXG4gICAgICAgICAgICAvLyA9ICBbYiwgYywgZF0gPT0gW2MsIGQsIGZdXG5cbiAgICAgICAgICAgIC8vIFthLCBiLCBjLCBkXVxuICAgICAgICAgICAgLy8gW2MsIGQsIGZdXG5cbiAgICAgICAgICAgIC8vIFthLCBiLCBjXSA9PSBbYywgZCwgZl1cblxuICAgICAgICAgICAgLy8gW2EsIGIsIGMsIGRdXG4gICAgICAgICAgICAvLyBbZCwgZl1cblxuICAgICAgICAgICAgLy8gW2EsIGJdID09IFtkLCBmXVxuXG4gICAgICAgICAgICAvLyBbYSwgYiwgYywgZF1cbiAgICAgICAgICAgIC8vIFtmXVxuXG4gICAgICAgICAgICAvLyBbYV0gPT0gW2ZdXG5cbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0TGVuZ3RoID0gcmlnaHRTZXF1ZW5jZS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGxlZnRMZW5ndGggKyByaWdodExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXBzID0gaiAvIDEwMDAwLjA7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFN0YXJ0ID0gTWF0aC5tYXgoMCwgbGVmdExlbmd0aCAtIGopO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRTdG9wID0gTWF0aC5taW4obGVmdExlbmd0aCwgbGVmdExlbmd0aCArIHJpZ2h0TGVuZ3RoIC0gaik7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IGxlZnRTZXF1ZW5jZS5zbGljZShsZWZ0U3RhcnQsIGxlZnRTdG9wKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodFN0YXJ0ID0gTWF0aC5tYXgoMCwgaiAtIGxlZnRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0U3RvcCA9IE1hdGgubWluKHJpZ2h0TGVuZ3RoLCBqKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IHJpZ2h0U2VxdWVuY2Uuc2xpY2UocmlnaHRTdGFydCwgcmlnaHRTdG9wKTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBhIGJ1ZyB3aXRoaW4gd2hpc3BlciBgZGVjb2RlX2FzcmAgZnVuY3Rpb24sIHBsZWFzZSByZXBvcnQgaXQuIERyb3BwaW5nIHRvIHByZXZlbnQgYmFkIGluZmVyZW5jZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBsZWZ0LmZpbHRlcigoZWxlbSwgaWR4KSA9PiBlbGVtID09PSByaWdodFtpZHhdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBtYXRjaGVzIC8gaiArIGVwcztcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyA+IDEgJiYgbWF0Y2hpbmcgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWF0Y2hpbmc7XG4gICAgICAgICAgICAgICAgICAgIG1heEluZGljZXMgPSBbbGVmdFN0YXJ0LCBsZWZ0U3RvcCwgcmlnaHRTdGFydCwgcmlnaHRTdG9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbbGVmdFN0YXJ0LCBsZWZ0U3RvcCwgcmlnaHRTdGFydCwgcmlnaHRTdG9wXSA9IG1heEluZGljZXM7XG4gICAgICAgICAgICBjb25zdCBsZWZ0TWlkID0gTWF0aC5mbG9vcigobGVmdFN0b3AgKyBsZWZ0U3RhcnQpIC8gMik7XG4gICAgICAgICAgICBjb25zdCByaWdodE1pZCA9IE1hdGguZmxvb3IoKHJpZ2h0U3RvcCArIHJpZ2h0U3RhcnQpIC8gMik7XG4gICAgICAgICAgICB0b3RhbFNlcXVlbmNlLnB1c2goLi4ubGVmdFNlcXVlbmNlLnNsaWNlKDAsIGxlZnRNaWQpKTtcbiAgICAgICAgICAgIGxlZnRTZXF1ZW5jZSA9IHJpZ2h0U2VxdWVuY2Uuc2xpY2UocmlnaHRNaWQpO1xuICAgICAgICAgICAgbGVmdExlbmd0aCA9IGxlZnRTZXF1ZW5jZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICh1c2VfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlcykge1xuICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZS5wdXNoKC4uLmxlZnRfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlLnNsaWNlKDAsIGxlZnRNaWQpKTtcbiAgICAgICAgICAgICAgICBsZWZ0X3Rva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZSA9IHRva2VuX3RpbWVzdGFtcF9zZXF1ZW5jZXNbaV0uc2xpY2UocmlnaHRNaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvdGFsU2VxdWVuY2UucHVzaCguLi5sZWZ0U2VxdWVuY2UpO1xuXG4gICAgICAgIGlmICh1c2VfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlcykge1xuICAgICAgICAgICAgdG90YWxfdG9rZW5fdGltZXN0YW1wX3NlcXVlbmNlLnB1c2goLi4ubGVmdF90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIFt0b3RhbFNlcXVlbmNlLCB0b3RhbF90b2tlbl90aW1lc3RhbXBfc2VxdWVuY2VdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt0b3RhbFNlcXVlbmNlLCBbXV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBjb2xsYXRlV29yZFRpbWVzdGFtcHModG9rZW5zLCB0b2tlbl90aW1lc3RhbXBzLCBsYW5ndWFnZSkge1xuXG4gICAgICAgIGxldCBbd29yZHMsIF8sIHRva2VuX2luZGljZXNdID0gdGhpcy5jb21iaW5lVG9rZW5zSW50b1dvcmRzKHRva2VucywgbGFuZ3VhZ2UpO1xuXG4gICAgICAgIGxldCB0aW1pbmdzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSB0b2tlbl9pbmRpY2VzW2ldO1xuICAgICAgICAgICAgdGltaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB3b3Jkc1tpXSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IFtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5fdGltZXN0YW1wc1tpbmRpY2VzLmF0KDApXVswXSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5fdGltZXN0YW1wc1tpbmRpY2VzLmF0KC0xKV1bMV0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1pbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyB0b2tlbnMgYnkgd29yZC4gUmV0dXJucyBhIHR1cGxlIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHN0cmluZ3Mgd2l0aCB0aGUgd29yZHMsXG4gICAgICogYW5kIGEgbGlzdCBvZiBgdG9rZW5faWRgIHNlcXVlbmNlcyB3aXRoIHRoZSB0b2tlbnMgbWFraW5nIHVwIGVhY2ggd29yZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0b2tlbnMgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZV0gXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZXBlbmRfcHVuY3Rpb25hdGlvbnMgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwcGVuZF9wdW5jdHVhdGlvbnMgXG4gICAgICogXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb21iaW5lVG9rZW5zSW50b1dvcmRzKHRva2VucywgbGFuZ3VhZ2UsIHByZXBlbmRfcHVuY3Rpb25hdGlvbnMgPSBcIlxcXCIn4oCcwqHCvyhbey1cIiwgYXBwZW5kX3B1bmN0dWF0aW9ucyA9IFwiXFxcIicu44CCLO+8jCHvvIE/77yfOu+8muKAnSldfeOAgVwiKSB7XG4gICAgICAgIGxhbmd1YWdlID0gbGFuZ3VhZ2UgPz8gJ2VuZ2xpc2gnO1xuXG4gICAgICAgIGxldCB3b3Jkcywgd29yZF90b2tlbnMsIHRva2VuX2luZGljZXM7XG5cbiAgICAgICAgaWYgKFtcImNoaW5lc2VcIiwgXCJqYXBhbmVzZVwiLCBcInRoYWlcIiwgXCJsYW9cIiwgXCJteWFubWFyXCJdLmluY2x1ZGVzKGxhbmd1YWdlKSkge1xuICAgICAgICAgICAgLy8gVGhlc2UgbGFuZ3VhZ2VzIGRvbid0IHR5cGljYWxseSB1c2Ugc3BhY2VzLlxuXG4gICAgICAgICAgICBbd29yZHMsIHdvcmRfdG9rZW5zLCB0b2tlbl9pbmRpY2VzXSA9IHRoaXMuc3BsaXRUb2tlbnNPblVuaWNvZGUodG9rZW5zKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgW3dvcmRzLCB3b3JkX3Rva2VucywgdG9rZW5faW5kaWNlc10gPSB0aGlzLnNwbGl0VG9rZW5zT25TcGFjZXModG9rZW5zKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VQdW5jdHVhdGlvbnMod29yZHMsIHdvcmRfdG9rZW5zLCB0b2tlbl9pbmRpY2VzLCBwcmVwZW5kX3B1bmN0aW9uYXRpb25zLCBhcHBlbmRfcHVuY3R1YXRpb25zKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge1ByZVRyYWluZWRUb2tlbml6ZXJbJ2RlY29kZSddfSAqL1xuICAgIGRlY29kZShcbiAgICAgICAgdG9rZW5faWRzLFxuICAgICAgICBkZWNvZGVfYXJncyxcbiAgICApIHtcbiAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGRlY29kZV9hcmdzICYmIGRlY29kZV9hcmdzLmRlY29kZV93aXRoX3RpbWVzdGFtcHMpIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLmRlY29kZVdpdGhUaW1lc3RhbXBzKHRva2VuX2lkcywgZGVjb2RlX2FyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCA9IHN1cGVyLmRlY29kZSh0b2tlbl9pZHMsIGRlY29kZV9hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgb2Zmc2V0c1xuICAgICAgICAvLyBpZiAoZGVjb2RlX2FyZ3Mub3V0cHV0X29mZnNldHMpIHtcbiAgICAgICAgLy8gICAgIGxldCBvZmZzZXRzID0gdGhpcy5jb21wdXRlT2Zmc2V0c1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRva2VuX2lkcyBMaXN0IG9mIHRva2VuIElEcyB0byBkZWNvZGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY29kZV9hcmdzIE9wdGlvbmFsIGFyZ3VtZW50cyBmb3IgZGVjb2RpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRlY29kZVdpdGhUaW1lc3RhbXBzKHRva2VuX2lkcywgZGVjb2RlX2FyZ3MpIHtcbiAgICAgICAgY29uc3QgdGltZV9wcmVjaXNpb24gPSBkZWNvZGVfYXJncz8udGltZV9wcmVjaXNpb24gPz8gMC4wMjtcblxuICAgICAgICBjb25zdCB0aW1lc3RhbXBfYmVnaW4gPSBBcnJheS5mcm9tKHRoaXMuYWxsX3NwZWNpYWxfaWRzKS5hdCgtMSkgKyAxO1xuICAgICAgICAvKipAdHlwZSB7QXJyYXl9ICovXG4gICAgICAgIGxldCBvdXRwdXRzID0gW1tdXTtcbiAgICAgICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5faWRzKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPj0gdGltZXN0YW1wX2JlZ2luKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRpbWVzdGFtcCA9ICh0b2tlbiAtIHRpbWVzdGFtcF9iZWdpbikgKiB0aW1lX3ByZWNpc2lvbjtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSByb3VuZCh0aW1lc3RhbXAsIDIpO1xuICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChgPHwke3RpbWVzdGFtcH18PmApO1xuICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChbXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dHNbb3V0cHV0cy5sZW5ndGggLSAxXS5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRzID0gb3V0cHV0cy5tYXAoXG4gICAgICAgICAgICBzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5kZWNvZGUocywgZGVjb2RlX2FyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRzLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmUgdG9rZW5zIGludG8gd29yZHMgYnkgc3BsaXR0aW5nIGF0IGFueSBwb3NpdGlvbiB3aGVyZSB0aGUgdG9rZW5zIGFyZSBkZWNvZGVkIGFzIHZhbGlkIHVuaWNvZGUgcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRva2VucyBcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNwbGl0VG9rZW5zT25Vbmljb2RlKHRva2Vucykge1xuICAgICAgICBjb25zdCBkZWNvZGVkX2Z1bGwgPSB0aGlzLmRlY29kZSh0b2tlbnMsIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGRlY29kZV93aXRoX3RpbWVzdGFtcHM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudF9jaGFyID0gJ1xcdUZGRkQnO1xuXG4gICAgICAgIGxldCB3b3JkcyA9IFtdXG4gICAgICAgIGxldCB3b3JkX3Rva2VucyA9IFtdXG4gICAgICAgIGxldCB0b2tlbl9pbmRpY2VzID0gW11cbiAgICAgICAgbGV0IGN1cnJlbnRfdG9rZW5zID0gW11cbiAgICAgICAgbGV0IGN1cnJlbnRfaW5kaWNlcyA9IFtdXG4gICAgICAgIGxldCB1bmljb2RlX29mZnNldCA9IDBcblxuICAgICAgICBmb3IgKGxldCB0b2tlbl9pZHggPSAwOyB0b2tlbl9pZHggPCB0b2tlbnMubGVuZ3RoOyArK3Rva2VuX2lkeCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbdG9rZW5faWR4XTtcblxuICAgICAgICAgICAgY3VycmVudF90b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBjdXJyZW50X2luZGljZXMucHVzaCh0b2tlbl9pZHgpO1xuXG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gdGhpcy5kZWNvZGUoY3VycmVudF90b2tlbnMsIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZGVjb2RlX3dpdGhfdGltZXN0YW1wczogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWRlY29kZWQuaW5jbHVkZXMocmVwbGFjZW1lbnRfY2hhcikgfHwgZGVjb2RlZF9mdWxsW3VuaWNvZGVfb2Zmc2V0ICsgZGVjb2RlZC5pbmRleE9mKHJlcGxhY2VtZW50X2NoYXIpXSA9PT0gcmVwbGFjZW1lbnRfY2hhcikge1xuICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goZGVjb2RlZClcbiAgICAgICAgICAgICAgICB3b3JkX3Rva2Vucy5wdXNoKGN1cnJlbnRfdG9rZW5zKVxuICAgICAgICAgICAgICAgIHRva2VuX2luZGljZXMucHVzaChjdXJyZW50X2luZGljZXMpXG4gICAgICAgICAgICAgICAgY3VycmVudF90b2tlbnMgPSBbXVxuICAgICAgICAgICAgICAgIGN1cnJlbnRfaW5kaWNlcyA9IFtdXG4gICAgICAgICAgICAgICAgdW5pY29kZV9vZmZzZXQgKz0gZGVjb2RlZC5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbd29yZHMsIHdvcmRfdG9rZW5zLCB0b2tlbl9pbmRpY2VzXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmUgdG9rZW5zIGludG8gd29yZHMgYnkgc3BsaXR0aW5nIGF0IHdoaXRlc3BhY2UgYW5kIHB1bmN0dWF0aW9uIHRva2Vucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0b2tlbnMgXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzcGxpdFRva2Vuc09uU3BhY2VzKHRva2Vucykge1xuXG4gICAgICAgIGxldCBbc3Vid29yZHMsIHN1YndvcmRfdG9rZW5zX2xpc3QsIHN1YndvcmRfaW5kaWNlc19saXN0XSA9IHRoaXMuc3BsaXRUb2tlbnNPblVuaWNvZGUodG9rZW5zKTtcblxuICAgICAgICBsZXQgd29yZHMgPSBbXVxuICAgICAgICBsZXQgd29yZF90b2tlbnMgPSBbXVxuICAgICAgICBsZXQgdG9rZW5faW5kaWNlcyA9IFtdXG5cbiAgICAgICAgY29uc3QgcHVuY3R1YXRpb25SZWdleCA9IG5ldyBSZWdFeHAoYFske1BVTkNUVUFUSU9OX1JFR0VYfV1gKVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3Vid29yZHMubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgY29uc3Qgc3Vid29yZCA9IHN1YndvcmRzW2ldO1xuICAgICAgICAgICAgY29uc3Qgc3Vid29yZF90b2tlbnMgPSBzdWJ3b3JkX3Rva2Vuc19saXN0W2ldO1xuICAgICAgICAgICAgY29uc3Qgc3Vid29yZF9pbmRpY2VzID0gc3Vid29yZF9pbmRpY2VzX2xpc3RbaV07XG5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHNwZWNpYWwgPSBzdWJ3b3JkX3Rva2Vuc1swXSA+PSB0aGlzLm1vZGVsLnRva2Vuc190b19pZHMuZ2V0KCc8fGVuZG9mdGV4dHw+Jyk7XG4gICAgICAgICAgICBjb25zdCB3aXRoX3NwYWNlID0gc3Vid29yZC5zdGFydHNXaXRoKCcgJyk7XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkID0gc3Vid29yZC50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBwdW5jdHVhdGlvbiA9IHB1bmN0dWF0aW9uUmVnZXgudGVzdCh0cmltbWVkKTtcblxuICAgICAgICAgICAgaWYgKHNwZWNpYWwgfHwgd2l0aF9zcGFjZSB8fCBwdW5jdHVhdGlvbiB8fCB3b3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKHN1YndvcmQpO1xuICAgICAgICAgICAgICAgIHdvcmRfdG9rZW5zLnB1c2goc3Vid29yZF90b2tlbnMpO1xuICAgICAgICAgICAgICAgIHRva2VuX2luZGljZXMucHVzaChzdWJ3b3JkX2luZGljZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpeCA9IHdvcmRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgd29yZHNbaXhdICs9IHN1YndvcmQ7XG4gICAgICAgICAgICAgICAgd29yZF90b2tlbnNbaXhdLnB1c2goLi4uc3Vid29yZF90b2tlbnMpO1xuICAgICAgICAgICAgICAgIHRva2VuX2luZGljZXNbaXhdLnB1c2goLi4uc3Vid29yZF9pbmRpY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbd29yZHMsIHdvcmRfdG9rZW5zLCB0b2tlbl9pbmRpY2VzXTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBwdW5jdHVhdGlvbiB0b2tlbnMgd2l0aCBuZWlnaGJvcmluZyB3b3Jkcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB3b3JkcyBcbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IHRva2VucyBcbiAgICAgKiBAcGFyYW0ge251bWJlcltdW119IGluZGljZXMgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZXBlbmRlZCBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwZW5kZWQgXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtZXJnZVB1bmN0dWF0aW9ucyh3b3JkcywgdG9rZW5zLCBpbmRpY2VzLCBwcmVwZW5kZWQsIGFwcGVuZGVkKSB7XG5cbiAgICAgICAgbGV0IG5ld1dvcmRzID0gc3RydWN0dXJlZENsb25lKHdvcmRzKTtcbiAgICAgICAgbGV0IG5ld1Rva2VucyA9IHN0cnVjdHVyZWRDbG9uZSh0b2tlbnMpO1xuICAgICAgICBsZXQgbmV3SW5kaWNlcyA9IHN0cnVjdHVyZWRDbG9uZShpbmRpY2VzKTtcblxuXG4gICAgICAgIC8vIHByZXBlbmQgcHVuY3R1YXRpb25zXG4gICAgICAgIGxldCBpID0gbmV3V29yZHMubGVuZ3RoIC0gMjtcbiAgICAgICAgbGV0IGogPSBuZXdXb3Jkcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICAgIGlmIChuZXdXb3Jkc1tpXS5zdGFydHNXaXRoKCcgJykgJiYgcHJlcGVuZGVkLmluY2x1ZGVzKG5ld1dvcmRzW2ldLnRyaW0oKSkpIHtcbiAgICAgICAgICAgICAgICBuZXdXb3Jkc1tqXSA9IG5ld1dvcmRzW2ldICsgbmV3V29yZHNbal07XG4gICAgICAgICAgICAgICAgbmV3VG9rZW5zW2pdID0gbWVyZ2VBcnJheXMobmV3VG9rZW5zW2ldLCBuZXdUb2tlbnNbal0pO1xuICAgICAgICAgICAgICAgIG5ld0luZGljZXNbal0gPSBtZXJnZUFycmF5cyhuZXdJbmRpY2VzW2ldLCBuZXdJbmRpY2VzW2pdKTtcbiAgICAgICAgICAgICAgICBuZXdXb3Jkc1tpXSA9ICcnO1xuICAgICAgICAgICAgICAgIG5ld1Rva2Vuc1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgIG5ld0luZGljZXNbaV0gPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAtLWk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBlbmQgcHVuY3R1YXRpb25zXG4gICAgICAgIGkgPSAwO1xuICAgICAgICBqID0gMTtcbiAgICAgICAgd2hpbGUgKGogPCBuZXdXb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghbmV3V29yZHNbaV0uZW5kc1dpdGgoJyAnKSAmJiBhcHBlbmRlZC5pbmNsdWRlcyhuZXdXb3Jkc1tqXSkpIHtcbiAgICAgICAgICAgICAgICBuZXdXb3Jkc1tpXSArPSBuZXdXb3Jkc1tqXTtcbiAgICAgICAgICAgICAgICBuZXdUb2tlbnNbaV0gPSBtZXJnZUFycmF5cyhuZXdUb2tlbnNbaV0sIG5ld1Rva2Vuc1tqXSk7XG4gICAgICAgICAgICAgICAgbmV3SW5kaWNlc1tpXSA9IG1lcmdlQXJyYXlzKG5ld0luZGljZXNbaV0sIG5ld0luZGljZXNbal0pO1xuICAgICAgICAgICAgICAgIG5ld1dvcmRzW2pdID0gJyc7XG4gICAgICAgICAgICAgICAgbmV3VG9rZW5zW2pdID0gW107XG4gICAgICAgICAgICAgICAgbmV3SW5kaWNlc1tqXSA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsrajtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXdXb3Jkcy5maWx0ZXIoeCA9PiB4KSxcbiAgICAgICAgICAgIG5ld1Rva2Vucy5maWx0ZXIoeCA9PiB4Lmxlbmd0aCA+IDApLFxuICAgICAgICAgICAgbmV3SW5kaWNlcy5maWx0ZXIoeCA9PiB4Lmxlbmd0aCA+IDApLFxuICAgICAgICBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGJ1aWxkIHRyYW5zbGF0aW9uIGlucHV0cyBmb3IgYSBgV2hpc3BlclRva2VuaXplcmAsXG4gICAgICogZGVwZW5kaW5nIG9uIHRoZSBsYW5ndWFnZSwgdGFzaywgYW5kIHdoZXRoZXIgdG8gcHJlZGljdCB0aW1lc3RhbXAgdG9rZW5zLlxuICAgICAqIFxuICAgICAqIFVzZWQgdG8gb3ZlcnJpZGUgdGhlIHByZWZpeCB0b2tlbnMgYXBwZW5kZWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsYWJlbCBzZXF1ZW5jZS5cbiAgICAgKiBcbiAgICAgKiAqKkV4YW1wbGU6IEdldCBpZHMgZm9yIGEgbGFuZ3VhZ2UqKlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiAvLyBpbnN0YW50aWF0ZSB0aGUgdG9rZW5pemVyIGFuZCBzZXQgdGhlIHByZWZpeCB0b2tlbiB0byBTcGFuaXNoXG4gICAgICogbGV0IHRva2VuaXplciA9IGF3YWl0IFdoaXNwZXJUb2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKCdYZW5vdmEvd2hpc3Blci10aW55Jyk7XG4gICAgICogbGV0IGZvcmNlZF9kZWNvZGVyX2lkcyA9IHRva2VuaXplci5nZXRfZGVjb2Rlcl9wcm9tcHRfaWRzKHsgbGFuZ3VhZ2U6ICdzcGFuaXNoJyB9KTtcbiAgICAgKiAvLyBbKDEsIDUwMjYyKSwgKDIsIDUwMzYzKV1cbiAgICAgKiBgYGBcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIHRvIGdlbmVyYXRlIHRoZSBkZWNvZGVyIHByb21wdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2VdIFRoZSBsYW5ndWFnZSBvZiB0aGUgdHJhbnNjcmlwdGlvbiB0ZXh0LlxuICAgICAqIFRoZSBjb3JyZXNwb25kaW5nIGxhbmd1YWdlIGlkIHRva2VuIGlzIGFwcGVuZGVkIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VxdWVuY2UgZm9yIG11bHRpbGluZ3VhbFxuICAgICAqIHNwZWVjaCByZWNvZ25pdGlvbiBhbmQgc3BlZWNoIHRyYW5zbGF0aW9uIHRhc2tzLCBlLmcuIGZvciBcIlNwYW5pc2hcIiB0aGUgdG9rZW4gXCI8fGVzfD5cIiBpcyBhcHBlbmRlZFxuICAgICAqIHRvIHRoZSBzdGFydCBvZiBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGFza10gVGFzayBpZGVudGlmaWVyIHRvIGFwcGVuZCBhdCB0aGUgc3RhcnQgb2Ygc2VxdWVuY2UgKGlmIGFueSkuXG4gICAgICogVGhpcyBzaG91bGQgYmUgdXNlZCBmb3IgbXVsaXRsaW5ndWFsIGZpbmUtdHVuaW5nLCB3aXRoIFwidHJhbnNjcmliZVwiIGZvciBzcGVlY2ggcmVjb2duaXRpb24gYW5kXG4gICAgICogXCJ0cmFuc2xhdGVcIiBmb3Igc3BlZWNoIHRyYW5zbGF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9fdGltZXN0YW1wc10gV2hldGhlciB0byBhZGQgdGhlIDx8bm90aW1lc3RhbXBzfD4gdG9rZW4gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW11bXX0gVGhlIGRlY29kZXIgcHJvbXB0IGlkcy5cbiAgICAgKi9cbiAgICBnZXRfZGVjb2Rlcl9wcm9tcHRfaWRzKHtcbiAgICAgICAgbGFuZ3VhZ2UgPSBudWxsLFxuICAgICAgICB0YXNrID0gbnVsbCxcbiAgICAgICAgbm9fdGltZXN0YW1wcyA9IHRydWUsXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgLy8gPHxsYW5nX2lkfD4gPHx0YXNrfD4gPHxub3RpbWVzdGFtcHN8PlxuXG4gICAgICAgIGxldCBmb3JjZWRfZGVjb2Rlcl9pZHMgPSBbXTtcblxuICAgICAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIC8vIFVzZXIgd2lzaGVzIHRvIHNwZWNpZnkgdGhlIGxhbmd1YWdlXG4gICAgICAgICAgICBsYW5ndWFnZSA9IGxhbmd1YWdlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIC8vIE1hcCB0byBjb2RlIGZyb20gdXNlci1mcmllbmRseSBuYW1lIChlLmcuLCBcImVuZ2xpc2hcIiAtPiBcImVuXCIpXG4gICAgICAgICAgICBsZXQgbGFuZ3VhZ2VfY29kZSA9IFdISVNQRVJfVE9fTEFOR1VBR0VfQ09ERV9NQVBQSU5HLmdldChsYW5ndWFnZSk7XG5cbiAgICAgICAgICAgIGlmIChsYW5ndWFnZV9jb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIHByb3ZpZGVkIHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGxhbmd1YWdlIG5hbWVcblxuICAgICAgICAgICAgICAgIGlmIChXSElTUEVSX0xBTkdVQUdFX01BUFBJTkcuaGFzKGxhbmd1YWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2VyIHByb3ZpZGVkIHRoZSBsYW5ndWFnZSBjb2RlIGRpcmVjdGx5IChlLmcuLCBcImVuXCIpXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlX2NvZGUgPSBsYW5ndWFnZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZXIgcHJvdmlkZWQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgbGFuZ3VhZ2UgY29kZSBvciBuYW1lXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzX2xhbmd1YWdlX2NvZGUgPSBsYW5ndWFnZS5sZW5ndGggPT09IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmdzID0gaXNfbGFuZ3VhZ2VfY29kZSA/IFdISVNQRVJfTEFOR1VBR0VfTUFQUElORy5rZXlzKCkgOiBXSElTUEVSX0xBTkdVQUdFX01BUFBJTkcudmFsdWVzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYW5ndWFnZSBcIiR7bGFuZ3VhZ2V9XCIgaXMgbm90IHN1cHBvcnRlZC4gTXVzdCBiZSBvbmUgb2Y6ICR7SlNPTi5zdHJpbmdpZnkobGFuZ3MpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGxhbmd1YWdlX3Rva2VuX2lkID0gdGhpcy5tb2RlbC50b2tlbnNfdG9faWRzLmdldChgPHwke2xhbmd1YWdlX2NvZGV9fD5gKTtcbiAgICAgICAgICAgIGlmIChsYW5ndWFnZV90b2tlbl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBsYW5ndWFnZSBcIiR7bGFuZ3VhZ2VfY29kZX1cIiBpbiBtb2RlbCB2b2NhYnVsYXJ5LiBQbGVhc2UgcmVwb3J0IHRoaXMgaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3hlbm92YS90cmFuc2Zvcm1lcnMuanMvaXNzdWVzL25ldy9jaG9vc2UuYClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yY2VkX2RlY29kZXJfaWRzLnB1c2gobGFuZ3VhZ2VfdG9rZW5faWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gdG9rZW4gd2lsbCBiZSBmb3JjZWQsIHdoaWNoIGxlYXZlcyB0aGUgbW9kZWwgdG8gcHJlZGljdCB0aGUgbGFuZ3VhZ2VcbiAgICAgICAgICAgIGZvcmNlZF9kZWNvZGVyX2lkcy5wdXNoKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgIHRhc2sgPSB0YXNrLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodGFzayAhPT0gJ3RyYW5zY3JpYmUnICYmIHRhc2sgIT09ICd0cmFuc2xhdGUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYXNrIFwiJHt0YXNrfVwiIGlzIG5vdCBzdXBwb3J0ZWQuIE11c3QgYmUgb25lIG9mOiBbXCJ0cmFuc2NyaWJlXCIsIFwidHJhbnNsYXRlXCJdYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB0YXNrX3Rva2VuX2lkID0gdGhpcy5tb2RlbC50b2tlbnNfdG9faWRzLmdldChgPHwke3Rhc2t9fD5gKTtcbiAgICAgICAgICAgIGlmICh0YXNrX3Rva2VuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIHRhc2sgXCIke3Rhc2t9XCIgaW4gbW9kZWwgdm9jYWJ1bGFyeS4gUGxlYXNlIHJlcG9ydCB0aGlzIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS94ZW5vdmEvdHJhbnNmb3JtZXJzLmpzL2lzc3Vlcy9uZXcvY2hvb3NlLmApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcmNlZF9kZWNvZGVyX2lkcy5wdXNoKHRhc2tfdG9rZW5faWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gdG9rZW4gd2lsbCBiZSBmb3JjZWQsIHdoaWNoIGxlYXZlcyB0aGUgbW9kZWwgdG8gcHJlZGljdCB0aGUgdGFza1xuICAgICAgICAgICAgZm9yY2VkX2RlY29kZXJfaWRzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9fdGltZXN0YW1wcykge1xuICAgICAgICAgICAgbGV0IG5vX3RpbWVzdGFtcHNfaWQgPSB0aGlzLm1vZGVsLnRva2Vuc190b19pZHMuZ2V0KGA8fG5vdGltZXN0YW1wc3w+YCk7XG4gICAgICAgICAgICBpZiAobm9fdGltZXN0YW1wc19pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBcIjx8bm90aW1lc3RhbXBzfD5cIiBpbiBtb2RlbCB2b2NhYnVsYXJ5LiBQbGVhc2UgcmVwb3J0IHRoaXMgaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3hlbm92YS90cmFuc2Zvcm1lcnMuanMvaXNzdWVzL25ldy9jaG9vc2UuJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yY2VkX2RlY29kZXJfaWRzLnB1c2gobm9fdGltZXN0YW1wc19pZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9yY2VkX2RlY29kZXJfaWRzLm1hcCgoeCwgaSkgPT4gW2kgKyAxLCB4XSkuZmlsdGVyKHggPT4geFsxXSAhPT0gbnVsbCk7XG5cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29kZUdlblRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5leHBvcnQgY2xhc3MgQ0xJUFRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIgeyB9XG5cblxuLyoqXG4gKiBAdG9kbyBUaGlzIG1vZGVsIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGJ5IEh1Z2dpbmcgRmFjZSdzIFwiZmFzdFwiIHRva2VuaXplcnMgbGlicmFyeSAoaHR0cHM6Ly9naXRodWIuY29tL2h1Z2dpbmdmYWNlL3Rva2VuaXplcnMpLlxuICogVGhlcmVmb3JlLCB0aGlzIGltcGxlbWVudGF0aW9uICh3aGljaCBpcyBiYXNlZCBvbiBmYXN0IHRva2VuaXplcnMpIG1heSBwcm9kdWNlIHNsaWdodGx5IGluYWNjdXJhdGUgcmVzdWx0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIE1hcmlhblRva2VuaXplciBleHRlbmRzIFByZVRyYWluZWRUb2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBNYXJpYW5Ub2tlbml6ZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRva2VuaXplckpTT04gVGhlIEpTT04gb2YgdGhlIHRva2VuaXplci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdG9rZW5pemVyQ29uZmlnIFRoZSBjb25maWcgb2YgdGhlIHRva2VuaXplci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbml6ZXJKU09OLCB0b2tlbml6ZXJDb25maWcpIHtcbiAgICAgICAgc3VwZXIodG9rZW5pemVySlNPTiwgdG9rZW5pemVyQ29uZmlnKTtcblxuICAgICAgICB0aGlzLmxhbmd1YWdlUmVnZXggPSAvXig+Plxcdys8PClcXHMqL2c7XG5cbiAgICAgICAgdGhpcy5zdXBwb3J0ZWRfbGFuZ3VhZ2VfY29kZXMgPSB0aGlzLm1vZGVsLnZvY2FiLmZpbHRlcihcbiAgICAgICAgICAgIHggPT4gdGhpcy5sYW5ndWFnZVJlZ2V4LnRlc3QoeClcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBNYXJpYW5Ub2tlbml6ZXJgIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGJ5IEh1Z2dpbmcgRmFjZVxcJ3MgXCJmYXN0XCIgdG9rZW5pemVycyBsaWJyYXJ5LiBUaGVyZWZvcmUsIHlvdSBtYXkgZXhwZXJpZW5jZSBzbGlnaHRseSBpbmFjY3VyYXRlIHJlc3VsdHMuJylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGEgc2luZ2xlIHRleHQuIE92ZXJyaWRpbmcgdGhpcyBtZXRob2QgaXMgbmVjZXNzYXJ5IHNpbmNlIHRoZSBsYW5ndWFnZSBjb2Rlc1xuICAgICAqIG11c3QgYmUgcmVtb3ZlZCBiZWZvcmUgZW5jb2Rpbmcgd2l0aCBzZW50ZW5jZXBpZWNlIG1vZGVsLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2h1Z2dpbmdmYWNlL3RyYW5zZm9ybWVycy9ibG9iLzEyZDUxZGIyNDNhMDA3MjZhNTQ4YTQzY2MzMzMzOTBlYmFlNzMxZTMvc3JjL3RyYW5zZm9ybWVycy9tb2RlbHMvbWFyaWFuL3Rva2VuaXphdGlvbl9tYXJpYW4ucHkjTDIwNC1MMjEzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB0ZXh0IFRoZSB0ZXh0IHRvIGVuY29kZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBlbmNvZGVkIHRva2Vucy5cbiAgICAgKi9cbiAgICBfZW5jb2RlX3RleHQodGV4dCkge1xuICAgICAgICBpZiAodGV4dCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGV4dCBzdGFydHMgd2l0aCBsYW5ndWFnZSBjb2RlOlxuICAgICAgICBsZXQgW21hdGNoSW5mbywgLi4ucmVtYWluZGVyXSA9IHRleHQudHJpbSgpLnNwbGl0KHRoaXMubGFuZ3VhZ2VSZWdleCk7XG5cbiAgICAgICAgaWYgKHJlbWFpbmRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vIGxhbmd1YWdlIGNvZGUsIGVuY29kZSBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9lbmNvZGVfdGV4dChtYXRjaEluZm8pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVtYWluZGVyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gVGV4dCBzdGFydHMgd2l0aCBsYW5ndWFnZSBjb2RlLCBzbyB3ZSBkbyBub3QgZW5jb2RlIGl0IHdpdGggc2VudGVuY2VwaWVjZS5cbiAgICAgICAgICAgIGxldCBbbGFuZ3VhZ2UsIHRleHRdID0gcmVtYWluZGVyO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkX2xhbmd1YWdlX2NvZGVzLmluY2x1ZGVzKGxhbmd1YWdlKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5zdXBwb3J0ZWQgbGFuZ3VhZ2UgY29kZSBcIiR7bGFuZ3VhZ2V9XCIgZGV0ZWN0ZWQsIHdoaWNoIG1heSBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIFNob3VsZCBiZSBvbmUgb2Y6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5zdXBwb3J0ZWRfbGFuZ3VhZ2VfY29kZXMpfWApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VBcnJheXMoW2xhbmd1YWdlXSwgc3VwZXIuX2VuY29kZV90ZXh0KHRleHQpKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG4vKipcbiAqIEEgdHJpZSBzdHJ1Y3R1cmUgdG8gZWZmaWNpZW50bHkgc3RvcmUgYW5kIHNlYXJjaCBmb3Igc3RyaW5ncy5cbiAqL1xuY2xhc3MgQ2hhclRyaWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJvb3QgPSBDaGFyVHJpZU5vZGUuZGVmYXVsdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgYHRleHRzYCB0byB0aGUgdHJpZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0ZXh0cyBUaGUgc3RyaW5ncyB0byBhZGQgdG8gdGhlIHRyaWUuXG4gICAgICovXG4gICAgZXh0ZW5kKHRleHRzKSB7XG4gICAgICAgIGZvciAobGV0IHRleHQgb2YgdGV4dHMpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgYHRleHRzYCB0byB0aGUgdHJpZS5cbiAgICAgKiBAcGFyYW0geyp9IHRleHQgVGhlIHN0cmluZ3MgdG8gYWRkIHRvIHRoZSB0cmllLlxuICAgICAqL1xuICAgIHB1c2godGV4dCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgdGV4dCkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZHJlbi5nZXQoY2gpO1xuICAgICAgICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IENoYXJUcmllTm9kZS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zZXQoY2gsIGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmlzTGVhZiA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhlIHRyaWUgZm9yIGFsbCBzdHJpbmdzIHdpdGggYSBjb21tb24gcHJlZml4IG9mIGB0ZXh0YC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgY29tbW9uIHByZWZpeCB0byBzZWFyY2ggZm9yLlxuICAgICAqIEB5aWVsZHMge3N0cmluZ30gRWFjaCBzdHJpbmcgaW4gdGhlIHRyaWUgdGhhdCBoYXMgYHRleHRgIGFzIGEgcHJlZml4LlxuICAgICAqL1xuICAgICpjb21tb25QcmVmaXhTZWFyY2godGV4dCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdDtcbiAgICAgICAgbGV0IHByZWZpeCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGggJiYgbm9kZSAhPT0gdW5kZWZpbmVkOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gdGV4dFtpXTtcbiAgICAgICAgICAgIHByZWZpeCArPSBjaDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuLmdldChjaCk7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgcHJlZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBub2RlIGluIGEgY2hhcmFjdGVyIHRyaWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGVhZiBXaGV0aGVyIHRoZSBub2RlIGlzIGEgbGVhZiBub2RlIG9yIG5vdC5cbiAqIEBwYXJhbSB7TWFwPHN0cmluZywgQ2hhclRyaWVOb2RlPn0gY2hpbGRyZW4gQSBtYXAgY29udGFpbmluZyB0aGUgbm9kZSdzIGNoaWxkcmVuLCB3aGVyZSB0aGUga2V5IGlzIGEgY2hhcmFjdGVyIGFuZCB0aGUgdmFsdWUgaXMgYSBgQ2hhclRyaWVOb2RlYC5cbiAqL1xuY2xhc3MgQ2hhclRyaWVOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihpc0xlYWYsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuaXNMZWFmID0gaXNMZWFmO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBgQ2hhclRyaWVOb2RlYCBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtDaGFyVHJpZU5vZGV9IEEgbmV3IGBDaGFyVHJpZU5vZGVgIGluc3RhbmNlIHdpdGggYGlzTGVhZmAgc2V0IHRvIGBmYWxzZWAgYW5kIGFuIGVtcHR5IGBjaGlsZHJlbmAgbWFwLlxuICAgICAqL1xuICAgIHN0YXRpYyBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYXJUcmllTm9kZShmYWxzZSwgbmV3IE1hcCgpKTtcbiAgICB9XG59XG5cbmNsYXNzIFRva2VuTGF0dGljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUb2tlbkxhdHRpY2UgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VudGVuY2UgVGhlIGlucHV0IHNlbnRlbmNlIHRvIGJlIHRva2VuaXplZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYm9zVG9rZW5JZCBUaGUgYmVnaW5uaW5nLW9mLXNlcXVlbmNlIHRva2VuIElELlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlb3NUb2tlbklkIFRoZSBlbmQtb2Ytc2VxdWVuY2UgdG9rZW4gSUQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VudGVuY2UsIGJvc1Rva2VuSWQsIGVvc1Rva2VuSWQpIHtcbiAgICAgICAgdGhpcy5zZW50ZW5jZSA9IHNlbnRlbmNlO1xuICAgICAgICB0aGlzLmxlbiA9IHNlbnRlbmNlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5ib3NUb2tlbklkID0gYm9zVG9rZW5JZDtcbiAgICAgICAgdGhpcy5lb3NUb2tlbklkID0gZW9zVG9rZW5JZDtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmJlZ2luTm9kZXMgPSBuZXcgQXJyYXkodGhpcy5sZW4gKyAxKTtcbiAgICAgICAgdGhpcy5lbmROb2RlcyA9IG5ldyBBcnJheSh0aGlzLmxlbiArIDEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuICsgMTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmJlZ2luTm9kZXNbaV0gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZW5kTm9kZXNbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib3MgPSBuZXcgVG9rZW5MYXR0aWNlTm9kZSh0aGlzLmJvc1Rva2VuSWQsIDAsIDAsIDAsIDAuMCk7XG4gICAgICAgIGNvbnN0IGVvcyA9IG5ldyBUb2tlbkxhdHRpY2VOb2RlKHRoaXMuZW9zVG9rZW5JZCwgMSwgdGhpcy5sZW4sIDAsIDAuMCk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChib3MuY2xvbmUoKSk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChlb3MuY2xvbmUoKSk7XG4gICAgICAgIHRoaXMuYmVnaW5Ob2Rlc1t0aGlzLmxlbl0ucHVzaChlb3MpO1xuICAgICAgICB0aGlzLmVuZE5vZGVzWzBdLnB1c2goYm9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgbmV3IHRva2VuIG5vZGUgaW50byB0aGUgdG9rZW4gbGF0dGljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY29yZSBUaGUgc2NvcmUgb2YgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b2tlbklkIFRoZSB0b2tlbiBJRCBvZiB0aGUgdG9rZW4uXG4gICAgICovXG4gICAgaW5zZXJ0KHBvcywgbGVuZ3RoLCBzY29yZSwgdG9rZW5JZCkge1xuICAgICAgICBjb25zdCBub2RlSWQgPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUb2tlbkxhdHRpY2VOb2RlKHRva2VuSWQsIG5vZGVJZCwgcG9zLCBsZW5ndGgsIHNjb3JlKTtcbiAgICAgICAgdGhpcy5iZWdpbk5vZGVzW3Bvc10ucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5lbmROb2Rlc1twb3MgKyBsZW5ndGhdLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBWaXRlcmJpIGFsZ29yaXRobSB0byBjb21wdXRlIHRoZSBtb3N0IGxpa2VseSBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7VG9rZW5MYXR0aWNlTm9kZVtdfSBUaGUgYXJyYXkgb2Ygbm9kZXMgcmVwcmVzZW50aW5nIHRoZSBtb3N0IGxpa2VseSBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgdml0ZXJiaSgpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW47XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICB3aGlsZSAocG9zIDw9IGxlbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmVnaW5Ob2Rlc1twb3NdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgcm5vZGUgb2YgdGhpcy5iZWdpbk5vZGVzW3Bvc10pIHtcbiAgICAgICAgICAgICAgICBybm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgYmVzdFNjb3JlID0gMC4wO1xuICAgICAgICAgICAgICAgIGxldCBiZXN0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbG5vZGUgb2YgdGhpcy5lbmROb2Rlc1twb3NdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gbG5vZGUuYmFja3RyYWNlU2NvcmUgKyBybm9kZS5zY29yZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3ROb2RlID09PSBudWxsIHx8IHNjb3JlID4gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0Tm9kZSA9IGxub2RlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChiZXN0Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBybm9kZS5wcmV2ID0gYmVzdE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHJub2RlLmJhY2t0cmFjZVNjb3JlID0gYmVzdFNjb3JlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK3BvcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuYmVnaW5Ob2Rlc1tsZW5dWzBdO1xuICAgICAgICBjb25zdCBwcmV2ID0gcm9vdC5wcmV2O1xuICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5vZGUgPSBwcmV2LmNsb25lKCk7XG4gICAgICAgIHdoaWxlIChub2RlLnByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlLmNsb25lKCkpO1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGUuY2xvbmUoKTtcbiAgICAgICAgICAgIG5vZGUgPSBuLnByZXYuY2xvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdHMucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1Rva2VuTGF0dGljZU5vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYXJyYXkgb2Ygbm9kZXMgcmVwcmVzZW50aW5nIHRoZSBtb3N0IGxpa2VseSBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgcGllY2Uobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW50ZW5jZS5zbGljZShub2RlLnBvcywgbm9kZS5wb3MgKyBub2RlLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2Ygbm9kZXMgcmVwcmVzZW50aW5nIHRoZSBtb3N0IGxpa2VseSBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgdG9rZW5zKCkge1xuICAgICAgICBjb25zdCBub2RlcyA9IHRoaXMudml0ZXJiaSgpO1xuICAgICAgICByZXR1cm4gbm9kZXMubWFwKHggPT4gdGhpcy5waWVjZSh4KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2Ygbm9kZXMgcmVwcmVzZW50aW5nIHRoZSBtb3N0IGxpa2VseSBzZXF1ZW5jZSBvZiB0b2tlbnMuXG4gICAgICovXG4gICAgdG9rZW5JZHMoKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy52aXRlcmJpKCk7XG4gICAgICAgIHJldHVybiBub2Rlcy5tYXAoeCA9PiB4LnRva2VuSWQpO1xuICAgIH1cbn1cbmNsYXNzIFRva2VuTGF0dGljZU5vZGUge1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBub2RlIGluIGEgdG9rZW4gbGF0dGljZSBmb3IgYSBnaXZlbiBzZW50ZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9rZW5JZCBUaGUgSUQgb2YgdGhlIHRva2VuIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vZGVJZCBUaGUgSUQgb2YgdGhpcyBub2RlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIG9mIHRoZSB0b2tlbiBpbiB0aGUgc2VudGVuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NvcmUgVGhlIHNjb3JlIGFzc29jaWF0ZWQgd2l0aCB0aGUgdG9rZW4uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodG9rZW5JZCwgbm9kZUlkLCBwb3MsIGxlbmd0aCwgc2NvcmUpIHtcbiAgICAgICAgdGhpcy50b2tlbklkID0gdG9rZW5JZDtcbiAgICAgICAgdGhpcy5ub2RlSWQgPSBub2RlSWQ7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLmJhY2t0cmFjZVNjb3JlID0gMC4wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIG5vZGUuXG4gICAgICogQHJldHVybnMge1Rva2VuTGF0dGljZU5vZGV9IEEgY2xvbmUgb2YgdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBuID0gbmV3IFRva2VuTGF0dGljZU5vZGUodGhpcy50b2tlbklkLCB0aGlzLm5vZGVJZCwgdGhpcy5wb3MsIHRoaXMubGVuZ3RoLCB0aGlzLnNjb3JlKTtcbiAgICAgICAgbi5wcmV2ID0gdGhpcy5wcmV2O1xuICAgICAgICBuLmJhY2t0cmFjZVNjb3JlID0gdGhpcy5iYWNrdHJhY2VTY29yZTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyB3aGljaCBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIHByZXRyYWluZWQgdG9rZW5pemVycyB3aXRoIHRoZSBgZnJvbV9wcmV0cmFpbmVkYCBmdW5jdGlvbi5cbiAqIFRoZSBjaG9zZW4gdG9rZW5pemVyIGNsYXNzIGlzIGRldGVybWluZWQgYnkgdGhlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSB0b2tlbml6ZXIgY29uZmlnLlxuICogXG4gKiBAZXhhbXBsZVxuICogbGV0IHRva2VuaXplciA9IGF3YWl0IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKCdiZXJ0LWJhc2UtdW5jYXNlZCcpO1xuICovXG5leHBvcnQgY2xhc3MgQXV0b1Rva2VuaXplciB7XG4gICAgc3RhdGljIFRPS0VOSVpFUl9DTEFTU19NQVBQSU5HID0ge1xuICAgICAgICAnVDVUb2tlbml6ZXInOiBUNVRva2VuaXplcixcbiAgICAgICAgJ0Rpc3RpbEJlcnRUb2tlbml6ZXInOiBEaXN0aWxCZXJ0VG9rZW5pemVyLFxuICAgICAgICAnQmVydFRva2VuaXplcic6IEJlcnRUb2tlbml6ZXIsXG4gICAgICAgICdNb2JpbGVCZXJ0VG9rZW5pemVyJzogTW9iaWxlQmVydFRva2VuaXplcixcbiAgICAgICAgJ1NxdWVlemVCZXJ0VG9rZW5pemVyJzogU3F1ZWV6ZUJlcnRUb2tlbml6ZXIsXG4gICAgICAgICdBbGJlcnRUb2tlbml6ZXInOiBBbGJlcnRUb2tlbml6ZXIsXG4gICAgICAgICdHUFQyVG9rZW5pemVyJzogR1BUMlRva2VuaXplcixcbiAgICAgICAgJ0JhcnRUb2tlbml6ZXInOiBCYXJ0VG9rZW5pemVyLFxuICAgICAgICAnUm9iZXJ0YVRva2VuaXplcic6IFJvYmVydGFUb2tlbml6ZXIsXG4gICAgICAgICdXaGlzcGVyVG9rZW5pemVyJzogV2hpc3BlclRva2VuaXplcixcbiAgICAgICAgJ0NvZGVHZW5Ub2tlbml6ZXInOiBDb2RlR2VuVG9rZW5pemVyLFxuICAgICAgICAnQ0xJUFRva2VuaXplcic6IENMSVBUb2tlbml6ZXIsXG4gICAgICAgICdNYXJpYW5Ub2tlbml6ZXInOiBNYXJpYW5Ub2tlbml6ZXIsXG4gICAgICAgICdCbG9vbVRva2VuaXplcic6IEJsb29tVG9rZW5pemVyLFxuICAgICAgICAnTmxsYlRva2VuaXplcic6IE5sbGJUb2tlbml6ZXIsXG4gICAgICAgICdMbGFtYVRva2VuaXplcic6IExsYW1hVG9rZW5pemVyLFxuICAgICAgICAnWExNUm9iZXJ0YVRva2VuaXplcic6IFhMTVJvYmVydGFUb2tlbml6ZXIsXG4gICAgICAgICdNUE5ldFRva2VuaXplcic6IE1QTmV0VG9rZW5pemVyLFxuICAgICAgICAnRmFsY29uVG9rZW5pemVyJzogRmFsY29uVG9rZW5pemVyLFxuICAgICAgICAnR1BUTmVvWFRva2VuaXplcic6IEdQVE5lb1hUb2tlbml6ZXIsXG5cbiAgICAgICAgLy8gQmFzZSBjYXNlOlxuICAgICAgICAnUHJlVHJhaW5lZFRva2VuaXplcic6IFByZVRyYWluZWRUb2tlbml6ZXIsXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBvbmUgb2YgdGhlIHRva2VuaXplciBjbGFzc2VzIG9mIHRoZSBsaWJyYXJ5IGZyb20gYSBwcmV0cmFpbmVkIG1vZGVsLlxuICAgICAqIFxuICAgICAqIFRoZSB0b2tlbml6ZXIgY2xhc3MgdG8gaW5zdGFudGlhdGUgaXMgc2VsZWN0ZWQgYmFzZWQgb24gdGhlIGB0b2tlbml6ZXJfY2xhc3NgIHByb3BlcnR5IG9mIHRoZSBjb25maWcgb2JqZWN0XG4gICAgICogKGVpdGhlciBwYXNzZWQgYXMgYW4gYXJndW1lbnQgb3IgbG9hZGVkIGZyb20gYHByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoYCBpZiBwb3NzaWJsZSlcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGggVGhlIG5hbWUgb3IgcGF0aCBvZiB0aGUgcHJldHJhaW5lZCBtb2RlbC4gQ2FuIGJlIGVpdGhlcjpcbiAgICAgKiAtIEEgc3RyaW5nLCB0aGUgKm1vZGVsIGlkKiBvZiBhIHByZXRyYWluZWQgdG9rZW5pemVyIGhvc3RlZCBpbnNpZGUgYSBtb2RlbCByZXBvIG9uIGh1Z2dpbmdmYWNlLmNvLlxuICAgICAqICAgVmFsaWQgbW9kZWwgaWRzIGNhbiBiZSBsb2NhdGVkIGF0IHRoZSByb290LWxldmVsLCBsaWtlIGBiZXJ0LWJhc2UtdW5jYXNlZGAsIG9yIG5hbWVzcGFjZWQgdW5kZXIgYVxuICAgICAqICAgdXNlciBvciBvcmdhbml6YXRpb24gbmFtZSwgbGlrZSBgZGJtZHovYmVydC1iYXNlLWdlcm1hbi1jYXNlZGAuXG4gICAgICogLSBBIHBhdGggdG8gYSAqZGlyZWN0b3J5KiBjb250YWluaW5nIHRva2VuaXplciBmaWxlcywgZS5nLiwgYC4vbXlfbW9kZWxfZGlyZWN0b3J5L2AuXG4gICAgICogQHBhcmFtIHtQcmV0cmFpbmVkT3B0aW9uc30gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGxvYWRpbmcgdGhlIHRva2VuaXplci5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxQcmVUcmFpbmVkVG9rZW5pemVyPn0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFByZVRyYWluZWRUb2tlbml6ZXIgY2xhc3MuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21fcHJldHJhaW5lZChwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwge1xuICAgICAgICBxdWFudGl6ZWQgPSB0cnVlLFxuICAgICAgICBwcm9ncmVzc19jYWxsYmFjayA9IG51bGwsXG4gICAgICAgIGNvbmZpZyA9IG51bGwsXG4gICAgICAgIGNhY2hlX2RpciA9IG51bGwsXG4gICAgICAgIGxvY2FsX2ZpbGVzX29ubHkgPSBmYWxzZSxcbiAgICAgICAgcmV2aXNpb24gPSAnbWFpbicsXG4gICAgfSA9IHt9KSB7XG5cbiAgICAgICAgbGV0IFt0b2tlbml6ZXJKU09OLCB0b2tlbml6ZXJDb25maWddID0gYXdhaXQgbG9hZFRva2VuaXplcihwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCwge1xuICAgICAgICAgICAgcXVhbnRpemVkLFxuICAgICAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2ssXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBjYWNoZV9kaXIsXG4gICAgICAgICAgICBsb2NhbF9maWxlc19vbmx5LFxuICAgICAgICAgICAgcmV2aXNpb24sXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gU29tZSB0b2tlbml6ZXJzIGFyZSBzYXZlZCB3aXRoIHRoZSBcIkZhc3RcIiBzdWZmaXgsIHNvIHdlIHJlbW92ZSB0aGF0IGlmIHByZXNlbnQuXG4gICAgICAgIGxldCB0b2tlbml6ZXJOYW1lID0gdG9rZW5pemVyQ29uZmlnLnRva2VuaXplcl9jbGFzcy5yZXBsYWNlKC9GYXN0JC8sICcnKTtcblxuICAgICAgICBsZXQgY2xzID0gdGhpcy5UT0tFTklaRVJfQ0xBU1NfTUFQUElOR1t0b2tlbml6ZXJOYW1lXTtcbiAgICAgICAgaWYgKCFjbHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biB0b2tlbml6ZXIgY2xhc3MgXCIke3Rva2VuaXplck5hbWV9XCIsIGF0dGVtcHRpbmcgdG8gY29uc3RydWN0IGZyb20gYmFzZSBjbGFzcy5gKTtcbiAgICAgICAgICAgIGNscyA9IFByZVRyYWluZWRUb2tlbml6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjbHModG9rZW5pemVySlNPTiwgdG9rZW5pemVyQ29uZmlnKTtcbiAgICB9XG59XG4iLCIvLyBAdHMtbm9jaGVja1xuXG4vKipcbiAqIEBmaWxlIEVudHJ5IHBvaW50IGZvciB0aGUgVHJhbnNmb3JtZXJzLmpzIGxpYnJhcnkuIE9ubHkgdGhlIGV4cG9ydHMgZnJvbSB0aGlzIGZpbGVcbiAqIGFyZSBhdmFpbGFibGUgdG8gdGhlIGVuZCB1c2VyLCBhbmQgYXJlIGdyb3VwZWQgYXMgZm9sbG93czpcbiAqIFxuICogMS4gW1BpcGVsaW5lc10oLi9waXBlbGluZXMpXG4gKiAyLiBbRW52aXJvbm1lbnQgdmFyaWFibGVzXSguL2VudilcbiAqIDMuIFtNb2RlbHNdKC4vbW9kZWxzKVxuICogNC4gW1Rva2VuaXplcnNdKC4vdG9rZW5pemVycylcbiAqIDUuIFtQcm9jZXNzb3JzXSguL3Byb2Nlc3NvcnMpXG4gKiBcbiAqIEBtb2R1bGUgdHJhbnNmb3JtZXJzXG4gKi9cblxuZXhwb3J0ICogZnJvbSAnLi9waXBlbGluZXMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbnYuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9tb2RlbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90b2tlbml6ZXJzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcHJvY2Vzc29ycy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbmZpZ3MuanMnO1xuXG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL2F1ZGlvLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvaW1hZ2UuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy90ZW5zb3IuanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9tYXRocy5qcyc7XG4iLCIvKipcbiAqIEBmaWxlIEhlbHBlciBtb2R1bGUgZm9yIGF1ZGlvIHByb2Nlc3NpbmcuIFxuICogXG4gKiBUaGVzZSBmdW5jdGlvbnMgYW5kIGNsYXNzZXMgYXJlIG9ubHkgdXNlZCBpbnRlcm5hbGx5LCBcbiAqIG1lYW5pbmcgYW4gZW5kLXVzZXIgc2hvdWxkbid0IG5lZWQgdG8gYWNjZXNzIGFueXRoaW5nIGhlcmUuXG4gKiBcbiAqIEBtb2R1bGUgdXRpbHMvYXVkaW9cbiAqL1xuXG5pbXBvcnQge1xuICAgIGdldEZpbGUsXG59IGZyb20gJy4vaHViLmpzJztcbmltcG9ydCB7IHJmZnRmcmVxIH0gZnJvbSAnLi9tYXRocy5qcyc7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHJlYWQgYXVkaW8gZnJvbSBhIHBhdGgvVVJMLlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSB1cmwgVGhlIHBhdGgvVVJMIHRvIGxvYWQgdGhlIGF1ZGlvIGZyb20uXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxpbmdfcmF0ZSBUaGUgc2FtcGxpbmcgcmF0ZSB0byB1c2Ugd2hlbiBkZWNvZGluZyB0aGUgYXVkaW8uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGbG9hdDMyQXJyYXk+fSBUaGUgZGVjb2RlZCBhdWRpbyBhcyBhIGBGbG9hdDMyQXJyYXlgLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZF9hdWRpbyh1cmwsIHNhbXBsaW5nX3JhdGUpIHtcbiAgICBpZiAodHlwZW9mIEF1ZGlvQ29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gUnVubmluZyBpbiBub2RlIG9yIGFuIGVudmlyb25tZW50IHdpdGhvdXQgQXVkaW9Db250ZXh0XG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJVbmFibGUgdG8gbG9hZCBhdWRpbyBmcm9tIHBhdGgvVVJMIHNpbmNlIGBBdWRpb0NvbnRleHRgIGlzIG5vdCBhdmFpbGFibGUgaW4geW91ciBlbnZpcm9ubWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCBhdWRpbyBkYXRhIHNob3VsZCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIHBpcGVsaW5lL3Byb2Nlc3Nvci4gXCIgK1xuICAgICAgICAgICAgXCJGb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgc29tZSBleGFtcGxlIGNvZGUsIHNlZSBodHRwczovL2h1Z2dpbmdmYWNlLmNvL2RvY3MvdHJhbnNmb3JtZXJzLmpzL3R1dG9yaWFscy9ub2RlLWF1ZGlvLXByb2Nlc3NpbmcuXCJcbiAgICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKGF3YWl0IGdldEZpbGUodXJsKSkuYXJyYXlCdWZmZXIoKTtcbiAgICBjb25zdCBhdWRpb0NUWCA9IG5ldyBBdWRpb0NvbnRleHQoeyBzYW1wbGVSYXRlOiBzYW1wbGluZ19yYXRlIH0pO1xuICAgIGlmICh0eXBlb2Ygc2FtcGxpbmdfcmF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBObyBzYW1wbGluZyByYXRlIHByb3ZpZGVkLCB1c2luZyBkZWZhdWx0IG9mICR7YXVkaW9DVFguc2FtcGxlUmF0ZX1Iei5gKVxuICAgIH1cbiAgICBjb25zdCBkZWNvZGVkID0gYXdhaXQgYXVkaW9DVFguZGVjb2RlQXVkaW9EYXRhKHJlc3BvbnNlKTtcbiAgICBsZXQgYXVkaW87XG5cbiAgICAvLyBXZSBub3cgcmVwbGljYXRlIEh1Z2dpbmdGYWNlJ3MgYGZmbXBlZ19yZWFkYCBtZXRob2Q6XG4gICAgaWYgKGRlY29kZWQubnVtYmVyT2ZDaGFubmVscyA9PT0gMikge1xuICAgICAgICAvLyBXaGVuIGRvd25taXhpbmcgYSBzdGVyZW8gYXVkaW8gZmlsZSB0byBtb25vIHVzaW5nIHRoZSAtYWMgMSBvcHRpb24gaW4gRkZtcGVnLFxuICAgICAgICAvLyB0aGUgYXVkaW8gc2lnbmFsIGlzIHN1bW1lZCBhY3Jvc3MgYm90aCBjaGFubmVscyB0byBjcmVhdGUgYSBzaW5nbGUgbW9ubyBjaGFubmVsLlxuICAgICAgICAvLyBIb3dldmVyLCBpZiB0aGUgYXVkaW8gaXMgYXQgZnVsbCBzY2FsZSAoaS5lLiB0aGUgaGlnaGVzdCBwb3NzaWJsZSB2b2x1bWUgbGV2ZWwpLFxuICAgICAgICAvLyB0aGUgc3VtbWluZyBvZiB0aGUgdHdvIGNoYW5uZWxzIGNhbiBjYXVzZSB0aGUgYXVkaW8gc2lnbmFsIHRvIGNsaXAgb3IgZGlzdG9ydC5cblxuICAgICAgICAvLyBUbyBwcmV2ZW50IHRoaXMgY2xpcHBpbmcsIEZGbXBlZyBhcHBsaWVzIGEgc2NhbGluZyBmYWN0b3Igb2YgMS9zcXJ0KDIpICh+IDAuNzA3KVxuICAgICAgICAvLyB0byB0aGUgYXVkaW8gc2lnbmFsIGJlZm9yZSBzdW1taW5nIHRoZSB0d28gY2hhbm5lbHMuIFRoaXMgc2NhbGluZyBmYWN0b3IgZW5zdXJlc1xuICAgICAgICAvLyB0aGF0IHRoZSBjb21iaW5lZCBhdWRpbyBzaWduYWwgd2lsbCBub3QgZXhjZWVkIHRoZSBtYXhpbXVtIHBvc3NpYmxlIGxldmVsLCBldmVuXG4gICAgICAgIC8vIGlmIGJvdGggY2hhbm5lbHMgYXJlIGF0IGZ1bGwgc2NhbGUuXG5cbiAgICAgICAgLy8gQWZ0ZXIgYXBwbHlpbmcgdGhpcyBzY2FsaW5nIGZhY3RvciwgdGhlIGF1ZGlvIHNpZ25hbCBmcm9tIGJvdGggY2hhbm5lbHMgaXMgc3VtbWVkXG4gICAgICAgIC8vIHRvIGNyZWF0ZSBhIHNpbmdsZSBtb25vIGNoYW5uZWwuIEl0J3Mgd29ydGggbm90aW5nIHRoYXQgdGhpcyBzY2FsaW5nIGZhY3RvciBpc1xuICAgICAgICAvLyBvbmx5IGFwcGxpZWQgd2hlbiBkb3dubWl4aW5nIHN0ZXJlbyBhdWRpbyB0byBtb25vIHVzaW5nIHRoZSAtYWMgMSBvcHRpb24gaW4gRkZtcGVnLlxuICAgICAgICAvLyBJZiB5b3UncmUgdXNpbmcgYSBkaWZmZXJlbnQgZG93bm1peGluZyBtZXRob2QsIG9yIGlmIHlvdSdyZSBub3QgZG93bm1peGluZyB0aGVcbiAgICAgICAgLy8gYXVkaW8gYXQgYWxsLCB0aGlzIHNjYWxpbmcgZmFjdG9yIG1heSBub3QgYmUgbmVlZGVkLlxuICAgICAgICBjb25zdCBTQ0FMSU5HX0ZBQ1RPUiA9IE1hdGguc3FydCgyKTtcblxuICAgICAgICBsZXQgbGVmdCA9IGRlY29kZWQuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgIGxldCByaWdodCA9IGRlY29kZWQuZ2V0Q2hhbm5lbERhdGEoMSk7XG5cbiAgICAgICAgYXVkaW8gPSBuZXcgRmxvYXQzMkFycmF5KGxlZnQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhdWRpb1tpXSA9IFNDQUxJTkdfRkFDVE9SICogKGxlZnRbaV0gKyByaWdodFtpXSkgLyAyO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgYXVkaW8gaXMgbm90IHN0ZXJlbywgd2UgY2FuIGp1c3QgdXNlIHRoZSBmaXJzdCBjaGFubmVsOlxuICAgICAgICBhdWRpbyA9IGRlY29kZWQuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF1ZGlvO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmcmVxdWVuY3kgYmluIGNvbnZlcnNpb24gbWF0cml4IHVzZWQgdG8gb2J0YWluIGEgbWVsIHNwZWN0cm9ncmFtLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyIFNhbXBsZSByYXRlIG9mIHRoZSBhdWRpbyB3YXZlZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBuX2ZmdCBOdW1iZXIgb2YgZnJlcXVlbmNpZXMgdXNlZCB0byBjb21wdXRlIHRoZSBzcGVjdHJvZ3JhbSAoc2hvdWxkIGJlIHRoZSBzYW1lIGFzIGluIGBzdGZ0YCkuXG4gKiBAcGFyYW0ge251bWJlcn0gbl9tZWxzIE51bWJlciBvZiBtZWwgZmlsdGVycyB0byBnZW5lcmF0ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJbXVtdfSBQcm9qZWN0aW9uIG1hdHJpeCB0byBnbyBmcm9tIGEgc3BlY3Ryb2dyYW0gdG8gYSBtZWwgc3BlY3Ryb2dyYW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZWxGaWx0ZXJzKHNyLCBuX2ZmdCwgbl9tZWxzID0gMTI4KSB7XG4gICAgbl9tZWxzID0gTWF0aC5mbG9vcihuX21lbHMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgd2VpZ2h0c1xuICAgIGNvbnN0IG1lbF9zaXplID0gTWF0aC5mbG9vcigxICsgbl9mZnQgLyAyKTtcbiAgICBjb25zdCB3ZWlnaHRzID0gbmV3IEFycmF5KG5fbWVscyk7XG5cbiAgICAvLyBDZW50ZXIgZnJlcXMgb2YgZWFjaCBGRlQgYmluXG4gICAgY29uc3QgZmZ0ZnJlcXMgPSByZmZ0ZnJlcShuX2ZmdCwgMSAvIHNyKTtcblxuICAgIC8vICdDZW50ZXIgZnJlcXMnIG9mIG1lbCBiYW5kcyAtIHVuaWZvcm1seSBzcGFjZWQgYmV0d2VlbiBsaW1pdHNcbiAgICBjb25zdCBtaW5fbWVsID0gMC4wO1xuICAgIGNvbnN0IG1heF9tZWwgPSA0NS4yNDU2NDA0NzE5MjQ5NjU7XG4gICAgY29uc3QgbWVsX3JhbmdlID0gbWF4X21lbCAtIG1pbl9tZWw7XG4gICAgY29uc3QgbWVsX3NjYWxlID0gbWVsX3JhbmdlIC8gKG5fbWVscyArIDEpO1xuXG4gICAgLy8gRmlsbCBpbiB0aGUgbGluZWFyIHNjYWxlXG4gICAgY29uc3QgZl9taW4gPSAwLjA7XG4gICAgY29uc3QgZl9zcCA9IDIwMC4wIC8gMztcbiAgICBjb25zdCBmcmVxcyA9IG5ldyBBcnJheShuX21lbHMgKyAyKTtcblxuICAgIC8vIEFuZCBub3cgdGhlIG5vbmxpbmVhciBzY2FsZVxuICAgIGNvbnN0IG1pbl9sb2dfaHogPSAxMDAwLjA7IC8vIGJlZ2lubmluZyBvZiBsb2cgcmVnaW9uIChIeilcbiAgICBjb25zdCBtaW5fbG9nX21lbCA9IChtaW5fbG9nX2h6IC0gZl9taW4pIC8gZl9zcDsgLy8gc2FtZSAoTWVscylcbiAgICBjb25zdCBsb2dzdGVwID0gTWF0aC5sb2coNi40KSAvIDI3LjA7IC8vIHN0ZXAgc2l6ZSBmb3IgbG9nIHJlZ2lvblxuXG4gICAgY29uc3QgcmFtcHMgPSBuZXcgQXJyYXkoZnJlcXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyZXFzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IG1lbCA9IGkgKiBtZWxfc2NhbGUgKyBtaW5fbWVsO1xuICAgICAgICBpZiAobWVsID49IG1pbl9sb2dfbWVsKSB7XG4gICAgICAgICAgICBmcmVxc1tpXSA9IG1pbl9sb2dfaHogKiBNYXRoLmV4cChsb2dzdGVwICogKG1lbCAtIG1pbl9sb2dfbWVsKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmVxc1tpXSA9IGZfbWluICsgZl9zcCAqIG1lbDtcbiAgICAgICAgfVxuICAgICAgICByYW1wc1tpXSA9IGZmdGZyZXFzLm1hcChrID0+IGZyZXFzW2ldIC0gayk7XG4gICAgfVxuXG4gICAgY29uc3QgZmRpZmZpbnYgPSBmcmVxcy5zbGljZSgxKS5tYXAoKHYsIGkpID0+IDEgLyAodiAtIGZyZXFzW2ldKSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdlaWdodHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgd2VpZ2h0c1tpXSA9IG5ldyBBcnJheShtZWxfc2l6ZSk7XG5cbiAgICAgICAgY29uc3QgYSA9IGZkaWZmaW52W2ldO1xuICAgICAgICBjb25zdCBiID0gZmRpZmZpbnZbaSArIDFdO1xuICAgICAgICBjb25zdCBjID0gcmFtcHNbaV07XG4gICAgICAgIGNvbnN0IGQgPSByYW1wc1tpICsgMl07XG5cbiAgICAgICAgLy8gU2xhbmV5LXN0eWxlIG1lbCBpcyBzY2FsZWQgdG8gYmUgYXBwcm94IGNvbnN0YW50IGVuZXJneSBwZXIgY2hhbm5lbFxuICAgICAgICBjb25zdCBlbm9ybSA9IDIuMCAvIChmcmVxc1tpICsgMl0gLSBmcmVxc1tpXSk7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3ZWlnaHRzW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAvLyBsb3dlciBhbmQgdXBwZXIgc2xvcGVzIGZvciBhbGwgYmluc1xuICAgICAgICAgICAgY29uc3QgbG93ZXIgPSAtY1tqXSAqIGE7XG4gICAgICAgICAgICBjb25zdCB1cHBlciA9IGRbal0gKiBiO1xuICAgICAgICAgICAgd2VpZ2h0c1tpXVtqXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxvd2VyLCB1cHBlcikpICogZW5vcm07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd2VpZ2h0cztcbn1cbiIsIlxuLyoqXG4gKiBAZmlsZSBDb3JlIHV0aWxpdHkgZnVuY3Rpb25zL2NsYXNzZXMgZm9yIFRyYW5zZm9ybWVycy5qcy5cbiAqIFxuICogVGhlc2UgYXJlIG9ubHkgdXNlZCBpbnRlcm5hbGx5LCBtZWFuaW5nIGFuIGVuZC11c2VyIHNob3VsZG4ndFxuICogbmVlZCB0byBhY2Nlc3MgYW55dGhpbmcgaGVyZS5cbiAqIFxuICogQG1vZHVsZSB1dGlscy9jb3JlXG4gKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGlzcGF0Y2ggcHJvZ3Jlc3MgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb2dyZXNzX2NhbGxiYWNrIFRoZSBwcm9ncmVzcyBjYWxsYmFjayBmdW5jdGlvbiB0byBkaXNwYXRjaC5cbiAqIEBwYXJhbSB7YW55fSBkYXRhIFRoZSBkYXRhIHRvIHBhc3MgdG8gdGhlIHByb2dyZXNzIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2hDYWxsYmFjayhwcm9ncmVzc19jYWxsYmFjaywgZGF0YSkge1xuICAgIGlmIChwcm9ncmVzc19jYWxsYmFjayAhPT0gbnVsbCkgcHJvZ3Jlc3NfY2FsbGJhY2soZGF0YSk7XG59XG5cbi8qKlxuICogUmV2ZXJzZXMgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIG9iamVjdCB0byByZXZlcnNlLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIHJldmVyc2VkIG9iamVjdC5cbiAqIEBzZWUgaHR0cHM6Ly91bHRpbWF0ZWNvdXJzZXMuY29tL2Jsb2cvcmV2ZXJzZS1vYmplY3Qta2V5cy1hbmQtdmFsdWVzLWluLWphdmFzY3JpcHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VEaWN0aW9uYXJ5KGRhdGEpIHtcbiAgICAvLyBodHRwczovL3VsdGltYXRlY291cnNlcy5jb20vYmxvZy9yZXZlcnNlLW9iamVjdC1rZXlzLWFuZC12YWx1ZXMtaW4tamF2YXNjcmlwdFxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZGF0YSkubWFwKChba2V5LCB2YWx1ZV0pID0+IFt2YWx1ZSwga2V5XSkpO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgcmVndWxhciBleHByZXNzaW9uIHNwZWNpYWwgY2hhcmFjdGVycyBmcm9tIGEgc3RyaW5nIGJ5IHJlcGxhY2luZyB0aGVtIHdpdGggdGhlaXIgZXNjYXBlZCBjb3VudGVycGFydHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuXG4vKipcbiAqIEEgYmFzZSBjbGFzcyBmb3IgY3JlYXRpbmcgY2FsbGFibGUgb2JqZWN0cy5cbiAqIFxuICogQHR5cGUge25ldyAoKSA9PiB7KC4uLmFyZ3M6IGFueVtdKTogYW55LCBfY2FsbCguLi5hcmdzOiBhbnlbXSk6IGFueX19XG4gKi9cbmV4cG9ydCBjb25zdCBDYWxsYWJsZSA9IC8qKiBAdHlwZSB7YW55fSAqLyAoY2xhc3Mge1xuICAgIC8qKlxuICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ2FsbGFibGUgY2xhc3MuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBjbG9zdXJlIHRoYXQgZGVsZWdhdGVzIHRvIGEgcHJpdmF0ZSBtZXRob2QgJ19jYWxsJyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gICAgICAgICAqIEB0eXBlIHthbnl9XG4gICAgICAgICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzIFplcm8gb3IgbW9yZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgJ19jYWxsJyBtZXRob2QuXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlICdfY2FsbCcgbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGNsb3N1cmUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGNsb3N1cmUuX2NhbGwoLi4uYXJncylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mKGNsb3N1cmUsIG5ldy50YXJnZXQucHJvdG90eXBlKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzIHRvIHByb3ZpZGUgdGhlXG4gICAgICogZnVuY3Rpb25hbGl0eSBvZiB0aGUgY2FsbGFibGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc3ViY2xhc3MgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBgX2NhbGxgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBfY2FsbCguLi5hcmdzKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdNdXN0IGltcGxlbWVudCBfY2FsbCBtZXRob2QgaW4gc3ViY2xhc3MnKVxuICAgIH1cbn0pO1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdGV4dCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHRleHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRleHQgPT09ICdzdHJpbmcnIHx8IHRleHQgaW5zdGFuY2VvZiBTdHJpbmdcbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSB0eXBlZCBhcnJheS5cbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGBUeXBlZEFycmF5YCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxMDkxMzM4LzEzOTg5MDQzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsKSB7XG4gICAgcmV0dXJuIHZhbD8ucHJvdG90eXBlPy5fX3Byb3RvX18/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnVHlwZWRBcnJheSc7XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVncmFsTnVtYmVyKHgpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih4KSB8fCB0eXBlb2YgeCA9PT0gJ2JpZ2ludCdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGV4aXN0cy5cbiAqIEBwYXJhbSB7Kn0geCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGlzdHMoeCkge1xuICAgIHJldHVybiB4ICE9PSB1bmRlZmluZWQgJiYgeCAhPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkaW1lbnNpb25zIG9mIGEgbmVzdGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgbmVzdGVkIGFycmF5IHRvIGNhbGN1bGF0ZSBkaW1lbnNpb25zIGZvci5cbiAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgaW5wdXQgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEaW1lbnNpb25zKGFycikge1xuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBbXTtcbiAgICBsZXQgY3VycmVudCA9IGFycjtcbiAgICB3aGlsZSAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgICBkaW1lbnNpb25zLnB1c2goY3VycmVudC5sZW5ndGgpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudFswXTtcbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvbnM7XG59XG5cbi8qKlxuICogUmVwbGljYXRlIHB5dGhvbidzIC5wb3AoKSBtZXRob2QgZm9yIG9iamVjdHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcG9wIGZyb20uXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gcG9wLlxuICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QuXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIG9mIHRoZSBwb3BwZWQga2V5LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QgYW5kIG5vIGRlZmF1bHQgdmFsdWUgaXMgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3Aob2JqLCBrZXksIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgS2V5ICR7a2V5fSBkb2VzIG5vdCBleGlzdCBpbiBvYmplY3QuYClcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuLyoqXG4gKiBFZmZpY2llbnRseSBtZXJnZSBhcnJheXMsIGNyZWF0aW5nIGEgbmV3IGNvcHkuXG4gKiBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY3Njg2NDIvMTM5ODkwNDNcbiAqIEBwYXJhbSAgey4uLmFueX0gYXJycyBBcnJheXMgdG8gbWVyZ2UuXG4gKiBAcmV0dXJucyBUaGUgbWVyZ2VkIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBcnJheXMoLi4uYXJycykge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnJzKTtcbn1cbiIsIlxuLyoqXG4gKiBAZmlsZSBDbGFzc2VzLCBmdW5jdGlvbnMsIGFuZCB1dGlsaXRpZXMgZm9yIGdlbmVyYXRpb24uXG4gKiBcbiAqIEB0b2RvIERlc2NyaWJlIGhvdyB0byBjcmVhdGUgYSBjdXN0b20gYEdlbmVyYXRpb25Db25maWdgLlxuICogXG4gKiBAbW9kdWxlIHV0aWxzL2dlbmVyYXRpb25cbiAqL1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuaW1wb3J0IHtcbiAgICBDYWxsYWJsZSxcbiAgICBleGlzdHMsXG59IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQge1xuICAgIG1heCxcbiAgICBzb2Z0bWF4LFxuICAgIGxvZ19zb2Z0bWF4LFxuICAgIGdldFRvcEl0ZW1zLFxufSBmcm9tICcuL21hdGhzLmpzJztcblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIGxpc3Qgb2YgbG9naXRzIHByb2Nlc3NvcnMuIEEgbG9naXRzIHByb2Nlc3NvciBpcyBhIGZ1bmN0aW9uIHRoYXQgbW9kaWZpZXMgdGhlIGxvZ2l0c1xuICogb3V0cHV0IG9mIGEgbGFuZ3VhZ2UgbW9kZWwuIFRoaXMgY2xhc3MgcHJvdmlkZXMgbWV0aG9kcyBmb3IgYWRkaW5nIG5ldyBwcm9jZXNzb3JzIGFuZCBhcHBseWluZyBhbGwgcHJvY2Vzc29ycyB0byBhXG4gKiBiYXRjaCBvZiBsb2dpdHMuXG4gKlxuICogQGV4dGVuZHMgQ2FsbGFibGVcbiAqL1xuZXhwb3J0IGNsYXNzIExvZ2l0c1Byb2Nlc3Nvckxpc3QgZXh0ZW5kcyBDYWxsYWJsZSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiBgTG9naXRzUHJvY2Vzc29yTGlzdGAuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29ycyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgbG9naXRzIHByb2Nlc3NvciB0byB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9naXRzUHJvY2Vzc29yfSBpdGVtIFRoZSBsb2dpdHMgcHJvY2Vzc29yIGZ1bmN0aW9uIHRvIGFkZC5cbiAgICAgKi9cbiAgICBwdXNoKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JzLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBtdWx0aXBsZSBsb2dpdHMgcHJvY2Vzc29ycyB0byB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9naXRzUHJvY2Vzc29yW119IGl0ZW1zIFRoZSBsb2dpdHMgcHJvY2Vzc29yIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICovXG4gICAgZXh0ZW5kKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc29ycy5wdXNoKC4uLml0ZW1zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFsbCBsb2dpdHMgcHJvY2Vzc29ycyBpbiB0aGUgbGlzdCB0byBhIGJhdGNoIG9mIGxvZ2l0cywgbW9kaWZ5aW5nIHRoZW0gaW4tcGxhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbnB1dF9pZHMgVGhlIGlucHV0IElEcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gYmF0Y2hlZExvZ2l0cyBBIDJEIGFycmF5IG9mIGxvZ2l0cywgd2hlcmUgZWFjaCByb3cgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0IHNlcXVlbmNlIGluIHRoZSBiYXRjaC5cbiAgICAgKi9cbiAgICBfY2FsbChpbnB1dF9pZHMsIGJhdGNoZWRMb2dpdHMpIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgUHl0aG9uIGNvZGUsIHNpbmNlIHZhbmlsbGEgSlMgZG9lcyBub3Qgc3VwcG9ydCB2ZWN0b3JpemVkIG9wZXJhdGlvbnMuIFxuICAgICAgICAvLyBBcyBhIHJlc3VsdCwgd2UgYXBwbHkgZWFjaCBwcm9jZXNzb3IgdG8gZWFjaCBpdGVtIGluIHRoZSBiYXRjaC5cbiAgICAgICAgZm9yIChsZXQgbG9naXRzIG9mIGJhdGNoZWRMb2dpdHMpIHtcbiAgICAgICAgICAgIC8vIE1vZGlmaWVzIGxvZ2l0cyBpbnBsYWNlXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NvcnMuZm9yRWFjaChcbiAgICAgICAgICAgICAgICBmdW5jID0+IGZ1bmMoaW5wdXRfaWRzLCBsb2dpdHMpXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc29ycy52YWx1ZXMoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgcHJvY2Vzc2luZyBsb2dpdHMuXG4gKiBAZXh0ZW5kcyBDYWxsYWJsZVxuICovXG5leHBvcnQgY2xhc3MgTG9naXRzUHJvY2Vzc29yIGV4dGVuZHMgQ2FsbGFibGUge1xuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBwcm9jZXNzb3IgdG8gdGhlIGlucHV0IGxvZ2l0cy5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0X2lkcyBUaGUgaW5wdXQgaWRzLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBsb2dpdHMgVGhlIGxvZ2l0cyB0byBwcm9jZXNzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgYF9jYWxsYCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhlIHN1YmNsYXNzLlxuICAgICAqL1xuICAgIF9jYWxsKGlucHV0X2lkcywgbG9naXRzKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiYF9jYWxsYCBzaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gYSBzdWJjbGFzc1wiKVxuICAgIH1cbn1cblxuLyoqXG4gKiBBIGxvZ2l0cyBwcm9jZXNzb3IgdGhhdCBmb3JjZXMgYSBzcGVjaWZpYyB0b2tlbiB0byBiZSBnZW5lcmF0ZWQgYnkgdGhlIGRlY29kZXIuXG4gKiBcbiAqIEBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvclxuICovXG5leHBvcnQgY2xhc3MgRm9yY2VUb2tlbnNMb2dpdHNQcm9jZXNzb3IgZXh0ZW5kcyBMb2dpdHNQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2YgYEZvcmNlVG9rZW5zTG9naXRzUHJvY2Vzc29yYC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmb3JjZWRfZGVjb2Rlcl9pZHMgVGhlIGlkcyBvZiB0b2tlbnMgdGhhdCBzaG91bGQgYmUgZm9yY2VkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZvcmNlZF9kZWNvZGVyX2lkcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZvcmNlX3Rva2VuX21hcCA9IE9iamVjdC5mcm9tRW50cmllcyhmb3JjZWRfZGVjb2Rlcl9pZHMgPz8gW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBwcm9jZXNzb3IgdG8gdGhlIGlucHV0IGxvZ2l0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0X2lkcyBUaGUgaW5wdXQgaWRzLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBsb2dpdHMgVGhlIGxvZ2l0cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBwcm9jZXNzZWQgbG9naXRzLlxuICAgICAqL1xuICAgIF9jYWxsKGlucHV0X2lkcywgbG9naXRzKSB7XG4gICAgICAgIGxldCBtYXAgPSB0aGlzLmZvcmNlX3Rva2VuX21hcFtpbnB1dF9pZHMubGVuZ3RoXTtcbiAgICAgICAgaWYgKGV4aXN0cyhtYXApKSB7IC8vIFRoZXJlIGV4aXN0cyBhIG1hcHBpbmdcbiAgICAgICAgICAgIGxvZ2l0cy5kYXRhLmZpbGwoLUluZmluaXR5KVxuICAgICAgICAgICAgbG9naXRzLmRhdGFbbWFwXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2l0cztcbiAgICB9XG59XG5cbi8qKlxuICogQSBMb2dpdHNQcm9jZXNzb3IgdGhhdCBmb3JjZXMgYSBCT1MgdG9rZW4gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2VuZXJhdGVkIHNlcXVlbmNlLlxuICogQGV4dGVuZHMgTG9naXRzUHJvY2Vzc29yXG4gKi9cbmV4cG9ydCBjbGFzcyBGb3JjZWRCT1NUb2tlbkxvZ2l0c1Byb2Nlc3NvciBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRm9yY2VkQk9TVG9rZW5Mb2dpdHNQcm9jZXNzb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJvc190b2tlbl9pZCBUaGUgSUQgb2YgdGhlIGJlZ2lubmluZy1vZi1zZXF1ZW5jZSB0b2tlbiB0byBiZSBmb3JjZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYm9zX3Rva2VuX2lkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYm9zX3Rva2VuX2lkID0gYm9zX3Rva2VuX2lkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCT1MgdG9rZW4gZm9yY2luZyB0byB0aGUgbG9naXRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0X2lkcyBUaGUgaW5wdXQgSURzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsb2dpdHMgVGhlIGxvZ2l0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbG9naXRzIHdpdGggQk9TIHRva2VuIGZvcmNpbmcuXG4gICAgICovXG4gICAgX2NhbGwoaW5wdXRfaWRzLCBsb2dpdHMpIHtcbiAgICAgICAgaWYgKGlucHV0X2lkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxvZ2l0cy5kYXRhLmZpbGwoLUluZmluaXR5KVxuICAgICAgICAgICAgbG9naXRzLmRhdGFbdGhpcy5ib3NfdG9rZW5faWRdID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9naXRzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGxvZ2l0cyBwcm9jZXNzb3IgdGhhdCBmb3JjZXMgZW5kLW9mLXNlcXVlbmNlIHRva2VuIHByb2JhYmlsaXR5IHRvIDEuXG4gKiBcbiAqIEBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvclxuICovXG5leHBvcnQgY2xhc3MgRm9yY2VkRU9TVG9rZW5Mb2dpdHNQcm9jZXNzb3IgZXh0ZW5kcyBMb2dpdHNQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEZvcmNlZEVPU1Rva2VuTG9naXRzUHJvY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhfbGVuZ3RoIE1heCBsZW5ndGggb2YgdGhlIHNlcXVlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBmb3JjZWRfZW9zX3Rva2VuX2lkIFRoZSBJRCBvZiB0aGUgZW5kLW9mLXNlcXVlbmNlIHRva2VuIHRvIGJlIGZvcmNlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXhfbGVuZ3RoLCBmb3JjZWRfZW9zX3Rva2VuX2lkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWF4X2xlbmd0aCA9IG1heF9sZW5ndGg7XG4gICAgICAgIHRoaXMuZm9yY2VkX2Vvc190b2tlbl9pZCA9IGZvcmNlZF9lb3NfdG9rZW5faWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIHByb2Nlc3NvciB0byBpbnB1dF9pZHMgYW5kIGxvZ2l0cy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbnB1dF9pZHMgVGhlIGlucHV0IGlkcy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbG9naXRzIFRoZSBsb2dpdHMgdGVuc29yLlxuICAgICAqL1xuICAgIF9jYWxsKGlucHV0X2lkcywgbG9naXRzKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdjYWxsIEZvcmNlZEVPU1Rva2VuTG9naXRzUHJvY2Vzc29yJylcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIExvZ2l0c1Byb2Nlc3NvciB0aGF0IHN1cHByZXNzZXMgYSBsaXN0IG9mIHRva2VucyBhcyBzb29uIGFzIHRoZSBgZ2VuZXJhdGVgIGZ1bmN0aW9uIHN0YXJ0c1xuICogZ2VuZXJhdGluZyB1c2luZyBgYmVnaW5faW5kZXhgIHRva2Vucy4gVGhpcyBzaG91bGQgZW5zdXJlIHRoYXQgdGhlIHRva2VucyBkZWZpbmVkIGJ5XG4gKiBgYmVnaW5fc3VwcHJlc3NfdG9rZW5zYCBhdCBub3Qgc2FtcGxlZCBhdCB0aGUgYmVnaW5pbmcgb2YgdGhlIGdlbmVyYXRpb24uXG4gKiBAZXh0ZW5kcyBMb2dpdHNQcm9jZXNzb3JcbiAqL1xuZXhwb3J0IGNsYXNzIFN1cHByZXNzVG9rZW5zQXRCZWdpbkxvZ2l0c1Byb2Nlc3NvciBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgU3VwcHJlc3NUb2tlbnNBdEJlZ2luTG9naXRzUHJvY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGJlZ2luX3N1cHByZXNzX3Rva2VucyBUaGUgSURzIG9mIHRoZSB0b2tlbnMgdG8gc3VwcHJlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luX2luZGV4IFRoZSBudW1iZXIgb2YgdG9rZW5zIHRvIGdlbmVyYXRlIGJlZm9yZSBzdXBwcmVzc2luZyB0b2tlbnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmVnaW5fc3VwcHJlc3NfdG9rZW5zLCBiZWdpbl9pbmRleCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJlZ2luX3N1cHByZXNzX3Rva2VucyA9IGJlZ2luX3N1cHByZXNzX3Rva2VucztcbiAgICAgICAgdGhpcy5iZWdpbl9pbmRleCA9IGJlZ2luX2luZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCT1MgdG9rZW4gZm9yY2luZyB0byB0aGUgbG9naXRzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0X2lkcyBUaGUgaW5wdXQgSURzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsb2dpdHMgVGhlIGxvZ2l0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbG9naXRzIHdpdGggQk9TIHRva2VuIGZvcmNpbmcuXG4gICAgICovXG4gICAgX2NhbGwoaW5wdXRfaWRzLCBsb2dpdHMpIHtcbiAgICAgICAgaWYgKGlucHV0X2lkcy5sZW5ndGggPT09IHRoaXMuYmVnaW5faW5kZXgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRva2VuX2lkIG9mIHRoaXMuYmVnaW5fc3VwcHJlc3NfdG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgbG9naXRzLmRhdGFbdG9rZW5faWRdID0gLUluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dpdHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgTG9naXRzUHJvY2Vzc29yIHRoYXQgaGFuZGxlcyBhZGRpbmcgdGltZXN0YW1wcyB0byBnZW5lcmF0ZWQgdGV4dC5cbiAqIEBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvclxuICovXG5leHBvcnQgY2xhc3MgV2hpc3BlclRpbWVTdGFtcExvZ2l0c1Byb2Nlc3NvciBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBXaGlzcGVyVGltZVN0YW1wTG9naXRzUHJvY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBnZW5lcmF0ZV9jb25maWcgVGhlIGNvbmZpZyBvYmplY3QgcGFzc2VkIHRvIHRoZSBgZ2VuZXJhdGUoKWAgbWV0aG9kIG9mIGEgdHJhbnNmb3JtZXIgbW9kZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdlbmVyYXRlX2NvbmZpZy5lb3NfdG9rZW5faWQgVGhlIElEIG9mIHRoZSBlbmQtb2Ytc2VxdWVuY2UgdG9rZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdlbmVyYXRlX2NvbmZpZy5ub190aW1lc3RhbXBzX3Rva2VuX2lkIFRoZSBJRCBvZiB0aGUgdG9rZW4gdXNlZCB0byBpbmRpY2F0ZSB0aGF0IGEgdG9rZW4gc2hvdWxkIG5vdCBoYXZlIGEgdGltZXN0YW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gW2dlbmVyYXRlX2NvbmZpZy5mb3JjZWRfZGVjb2Rlcl9pZHNdIEFuIGFycmF5IG9mIHR3by1lbGVtZW50IGFycmF5cyByZXByZXNlbnRpbmcgZGVjb2RlciBJRHMgdGhhdCBhcmUgZm9yY2VkIHRvIGFwcGVhciBpbiB0aGUgb3V0cHV0LiBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgZWFjaCBhcnJheSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgdG9rZW4gaXMgYSB0aW1lc3RhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtnZW5lcmF0ZV9jb25maWcubWF4X2luaXRpYWxfdGltZXN0YW1wX2luZGV4XSBUaGUgbWF4aW11bSBpbmRleCBhdCB3aGljaCBhbiBpbml0aWFsIHRpbWVzdGFtcCBjYW4gYXBwZWFyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdlbmVyYXRlX2NvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVvc190b2tlbl9pZCA9IGdlbmVyYXRlX2NvbmZpZy5lb3NfdG9rZW5faWQ7XG4gICAgICAgIHRoaXMubm9fdGltZXN0YW1wc190b2tlbl9pZCA9IGdlbmVyYXRlX2NvbmZpZy5ub190aW1lc3RhbXBzX3Rva2VuX2lkO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcF9iZWdpbiA9IHRoaXMubm9fdGltZXN0YW1wc190b2tlbl9pZCArIDE7XG5cbiAgICAgICAgdGhpcy5iZWdpbl9pbmRleCA9IChnZW5lcmF0ZV9jb25maWcuZm9yY2VkX2RlY29kZXJfaWRzIHx8IFtdKS5sZW5ndGggKyAyO1xuICAgICAgICBpZiAoZ2VuZXJhdGVfY29uZmlnLmZvcmNlZF9kZWNvZGVyX2lkcy5zbGljZSgtMSlbMF1bMV0gPT09IHRoaXMubm9fdGltZXN0YW1wc190b2tlbl9pZCkge1xuICAgICAgICAgICAgdGhpcy5iZWdpbl9pbmRleCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF4X2luaXRpYWxfdGltZXN0YW1wX2luZGV4ID0gZ2VuZXJhdGVfY29uZmlnLm1heF9pbml0aWFsX3RpbWVzdGFtcF9pbmRleDtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgbG9naXRzIHRvIGhhbmRsZSB0aW1lc3RhbXAgdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0X2lkcyBUaGUgaW5wdXQgc2VxdWVuY2Ugb2YgdG9rZW5zLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBsb2dpdHMgVGhlIGxvZ2l0cyBvdXRwdXQgYnkgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBtb2RpZmllZCBsb2dpdHMuXG4gICAgICovXG4gICAgX2NhbGwoaW5wdXRfaWRzLCBsb2dpdHMpIHtcbiAgICAgICAgLy8gc3VwcHJlc3MgPHxub3RpbWVzdGFtcHN8PiB3aGljaCBpcyBoYW5kbGVkIGJ5IHdpdGhvdXRfdGltZXN0YW1wc1xuICAgICAgICBsb2dpdHMuZGF0YVt0aGlzLm5vX3RpbWVzdGFtcHNfdG9rZW5faWRdID0gLUluZmluaXR5O1xuXG4gICAgICAgIGlmIChpbnB1dF9pZHMubGVuZ3RoID09PSB0aGlzLmJlZ2luX2luZGV4IC0gMSkge1xuICAgICAgICAgICAgbG9naXRzLmRhdGEuZmlsbCgtSW5maW5pdHkpO1xuICAgICAgICAgICAgbG9naXRzLmRhdGFbdGhpcy50aW1lc3RhbXBfYmVnaW5dID0gMDtcbiAgICAgICAgICAgIHJldHVybiBsb2dpdHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aW1lc3RhbXBzIGhhdmUgdG8gYXBwZWFyIGluIHBhaXJzLCBleGNlcHQgZGlyZWN0bHkgYmVmb3JlIGVvc190b2tlbjsgbWFzayBsb2dpdHMgYWNjb3JkaW5nbHlcbiAgICAgICAgY29uc3Qgc2VxID0gaW5wdXRfaWRzLnNsaWNlKHRoaXMuYmVnaW5faW5kZXgpO1xuICAgICAgICBjb25zdCBsYXN0X3dhc190aW1lc3RhbXAgPSBzZXEubGVuZ3RoID49IDEgJiYgc2VxW3NlcS5sZW5ndGggLSAxXSA+PSB0aGlzLnRpbWVzdGFtcF9iZWdpbjtcbiAgICAgICAgY29uc3QgcGVudWx0aW1hdGVfd2FzX3RpbWVzdGFtcCA9IHNlcS5sZW5ndGggPCAyIHx8IHNlcVtzZXEubGVuZ3RoIC0gMl0gPj0gdGhpcy50aW1lc3RhbXBfYmVnaW47XG5cbiAgICAgICAgaWYgKGxhc3Rfd2FzX3RpbWVzdGFtcCkge1xuICAgICAgICAgICAgaWYgKHBlbnVsdGltYXRlX3dhc190aW1lc3RhbXApIHsgLy8gaGFzIHRvIGJlIG5vbi10aW1lc3RhbXBcbiAgICAgICAgICAgICAgICBsb2dpdHMuZGF0YS5zdWJhcnJheSh0aGlzLnRpbWVzdGFtcF9iZWdpbikuZmlsbCgtSW5maW5pdHkpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gY2Fubm90IGJlIG5vcm1hbCB0ZXh0IHRva2Vuc1xuICAgICAgICAgICAgICAgIGxvZ2l0cy5kYXRhLnN1YmFycmF5KDAsIHRoaXMuZW9zX3Rva2VuX2lkKS5maWxsKC1JbmZpbml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgYG1heF9pbml0aWFsX3RpbWVzdGFtcGAgb3B0aW9uXG4gICAgICAgIGlmIChpbnB1dF9pZHMubGVuZ3RoID09PSB0aGlzLmJlZ2luX2luZGV4ICYmIHRoaXMubWF4X2luaXRpYWxfdGltZXN0YW1wX2luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0X2FsbG93ZWQgPSB0aGlzLnRpbWVzdGFtcF9iZWdpbiArIHRoaXMubWF4X2luaXRpYWxfdGltZXN0YW1wX2luZGV4O1xuICAgICAgICAgICAgbG9naXRzLmRhdGEuc3ViYXJyYXkobGFzdF9hbGxvd2VkICsgMSkuZmlsbCgtSW5maW5pdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgc3VtIG9mIHByb2JhYmlsaXR5IG92ZXIgdGltZXN0YW1wcyBpcyBhYm92ZSBhbnkgb3RoZXIgdG9rZW4sIHNhbXBsZSB0aW1lc3RhbXBcbiAgICAgICAgY29uc3QgbG9ncHJvYnMgPSBsb2dfc29mdG1heChsb2dpdHMuZGF0YSk7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcF9sb2dwcm9iID0gTWF0aC5sb2cobG9ncHJvYnMuc3ViYXJyYXkodGhpcy50aW1lc3RhbXBfYmVnaW4pLm1hcChNYXRoLmV4cCkucmVkdWNlKChhLCBiKSA9PiBhICsgYikpO1xuICAgICAgICBjb25zdCBtYXhfdGV4dF90b2tlbl9sb2dwcm9iID0gbWF4KGxvZ3Byb2JzLnN1YmFycmF5KDAsIHRoaXMudGltZXN0YW1wX2JlZ2luKSlbMF07XG5cbiAgICAgICAgaWYgKHRpbWVzdGFtcF9sb2dwcm9iID4gbWF4X3RleHRfdG9rZW5fbG9ncHJvYikge1xuICAgICAgICAgICAgbG9naXRzLmRhdGEuc3ViYXJyYXkoMCwgdGhpcy50aW1lc3RhbXBfYmVnaW4pLmZpbGwoLUluZmluaXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2dpdHM7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgbG9naXRzIHByb2Nlc3NvciB0aGF0IGRpc2FsbG93cyBuZ3JhbXMgb2YgYSBjZXJ0YWluIHNpemUgdG8gYmUgcmVwZWF0ZWQuXG4gKiBcbiAqIEBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvclxuICovXG5leHBvcnQgY2xhc3MgTm9SZXBlYXROR3JhbUxvZ2l0c1Byb2Nlc3NvciBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgTm9SZXBlYXROR3JhbUxvZ2l0c1Byb2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbm9fcmVwZWF0X25ncmFtX3NpemUgVGhlIG5vLXJlcGVhdC1uZ3JhbSBzaXplLiBBbGwgbmdyYW1zIG9mIHRoaXMgc2l6ZSBjYW4gb25seSBvY2N1ciBvbmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vX3JlcGVhdF9uZ3JhbV9zaXplKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubm9fcmVwZWF0X25ncmFtX3NpemUgPSBub19yZXBlYXRfbmdyYW1fc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBuLWdyYW1zIGZyb20gYSBzZXF1ZW5jZSBvZiB0b2tlbiBpZHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcHJldklucHV0SWRzIExpc3Qgb2YgcHJldmlvdXMgaW5wdXQgaWRzXG4gICAgICogQHJldHVybnMge01hcDxzdHJpbmcsIG51bWJlcltdPn0gTWFwIG9mIGdlbmVyYXRlZCBuLWdyYW1zXG4gICAgICovXG4gICAgZ2V0TmdyYW1zKHByZXZJbnB1dElkcykge1xuICAgICAgICBjb25zdCBjdXJMZW4gPSBwcmV2SW5wdXRJZHMubGVuZ3RoO1xuXG4gICAgICAgIC8qKkB0eXBlIHtudW1iZXJbXVtdfSAqL1xuICAgICAgICBjb25zdCBuZ3JhbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJMZW4gKyAxIC0gdGhpcy5ub19yZXBlYXRfbmdyYW1fc2l6ZTsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBuZ3JhbSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0aGlzLm5vX3JlcGVhdF9uZ3JhbV9zaXplOyArK2spIHtcbiAgICAgICAgICAgICAgICBuZ3JhbS5wdXNoKHByZXZJbnB1dElkc1tqICsga10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmdyYW1zLnB1c2gobmdyYW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXJbXT59ICovXG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZE5ncmFtID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5ncmFtIG9mIG5ncmFtcykge1xuICAgICAgICAgICAgY29uc3QgcHJldk5ncmFtID0gbmdyYW0uc2xpY2UoMCwgbmdyYW0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBwcmV2TmdyYW1LZXkgPSBKU09OLnN0cmluZ2lmeShwcmV2TmdyYW0pO1xuICAgICAgICAgICAgY29uc3QgcHJldk5ncmFtVmFsdWUgPSBnZW5lcmF0ZWROZ3JhbS5nZXQocHJldk5ncmFtS2V5KSA/PyBbXTtcbiAgICAgICAgICAgIHByZXZOZ3JhbVZhbHVlLnB1c2gobmdyYW1bbmdyYW0ubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgZ2VuZXJhdGVkTmdyYW0uc2V0KHByZXZOZ3JhbUtleSwgcHJldk5ncmFtVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZWROZ3JhbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBuLWdyYW1zIGZyb20gYSBzZXF1ZW5jZSBvZiB0b2tlbiBpZHMuXG4gICAgICogQHBhcmFtIHtNYXA8c3RyaW5nLCBudW1iZXJbXT59IGJhbm5lZE5ncmFtcyBNYXAgb2YgYmFubmVkIG4tZ3JhbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwcmV2SW5wdXRJZHMgTGlzdCBvZiBwcmV2aW91cyBpbnB1dCBpZHNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IE1hcCBvZiBnZW5lcmF0ZWQgbi1ncmFtc1xuICAgICAqL1xuICAgIGdldEdlbmVyYXRlZE5ncmFtcyhiYW5uZWROZ3JhbXMsIHByZXZJbnB1dElkcykge1xuICAgICAgICBjb25zdCBuZ3JhbUlkeCA9IHByZXZJbnB1dElkcy5zbGljZShwcmV2SW5wdXRJZHMubGVuZ3RoICsgMSAtIHRoaXMubm9fcmVwZWF0X25ncmFtX3NpemUsIHByZXZJbnB1dElkcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBiYW5uZWQgPSBiYW5uZWROZ3JhbXMuZ2V0KEpTT04uc3RyaW5naWZ5KG5ncmFtSWR4KSkgPz8gW107XG4gICAgICAgIHJldHVybiBiYW5uZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGJhbm5lZCBuLWdyYW0gdG9rZW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcHJldklucHV0SWRzIExpc3Qgb2YgcHJldmlvdXMgaW5wdXQgaWRzXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBNYXAgb2YgZ2VuZXJhdGVkIG4tZ3JhbXNcbiAgICAgKi9cbiAgICBjYWxjQmFubmVkTmdyYW1Ub2tlbnMocHJldklucHV0SWRzKSB7XG4gICAgICAgIGNvbnN0IGJhbm5lZFRva2VucyA9IFtdO1xuICAgICAgICBpZiAocHJldklucHV0SWRzLmxlbmd0aCArIDEgPCB0aGlzLm5vX3JlcGVhdF9uZ3JhbV9zaXplKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gbm8gYmFubmVkIHRva2VucyBpZiB3ZSBoYXZlbid0IGdlbmVyYXRlZCBub19yZXBlYXRfbmdyYW1fc2l6ZSB0b2tlbnMgeWV0XG4gICAgICAgICAgICByZXR1cm4gYmFubmVkVG9rZW5zO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWROZ3JhbXMgPSB0aGlzLmdldE5ncmFtcyhwcmV2SW5wdXRJZHMpO1xuICAgICAgICAgICAgY29uc3QgYmFubmVkVG9rZW5zID0gdGhpcy5nZXRHZW5lcmF0ZWROZ3JhbXMoZ2VuZXJhdGVkTmdyYW1zLCBwcmV2SW5wdXRJZHMpO1xuICAgICAgICAgICAgcmV0dXJuIGJhbm5lZFRva2VucztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBuby1yZXBlYXQtbmdyYW0gcHJvY2Vzc29yIHRvIHRoZSBsb2dpdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5wdXRfaWRzIFRoZSBpbnB1dCBJRHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvZ2l0cyBUaGUgbG9naXRzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBsb2dpdHMgd2l0aCBuby1yZXBlYXQtbmdyYW0gcHJvY2Vzc2luZy5cbiAgICAgKi9cbiAgICBfY2FsbChpbnB1dF9pZHMsIGxvZ2l0cykge1xuICAgICAgICBjb25zdCBiYW5uZWRUb2tlbnMgPSB0aGlzLmNhbGNCYW5uZWROZ3JhbVRva2VucyhpbnB1dF9pZHMpO1xuXG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgYmFubmVkVG9rZW5zKSB7XG4gICAgICAgICAgICBsb2dpdHMuZGF0YVt0b2tlbl0gPSAtSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2l0cztcbiAgICB9XG59XG5cbi8qKlxuICogQSBsb2dpdHMgcHJvY2Vzc29yIHRoYXQgcGVuYWxpc2VzIHJlcGVhdGVkIG91dHB1dCB0b2tlbnMuXG4gKiBcbiAqIEBleHRlbmRzIExvZ2l0c1Byb2Nlc3NvclxuICovXG5leHBvcnQgY2xhc3MgUmVwZXRpdGlvblBlbmFsdHlMb2dpdHNQcm9jZXNzb3IgZXh0ZW5kcyBMb2dpdHNQcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFJlcGV0aXRpb25QZW5hbHR5TG9naXRzUHJvY2Vzc29yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwZW5hbHR5IFRoZSBwZW5hbHR5IHRvIGFwcGx5IGZvciByZXBlYXRlZCB0b2tlbnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGVuYWx0eSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBlbmFsdHkgPSBwZW5hbHR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSByZXBldGl0aW9uIHBlbmFsdHkgdG8gdGhlIGxvZ2l0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbnB1dF9pZHMgVGhlIGlucHV0IElEcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbG9naXRzIFRoZSBsb2dpdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGxvZ2l0cyB3aXRoIHJlcGV0aXRpb24gcGVuYWx0eSBwcm9jZXNzaW5nLlxuICAgICAqL1xuICAgIF9jYWxsKGlucHV0X2lkcywgbG9naXRzKSB7XG4gICAgICAgIC8vIE1vZGlmeSB0aGUgbG9naXRzIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBlbGVtZW50IGluIGBpbnB1dF9pZHNgLlxuICAgICAgICAvLyBBcyBhIGNvbnNlcXVlbmNlLCB0aGUgbG9naXRzIGNvcnJlc3BvbmRpbmcgdG8gdG9rZW5zIHRoYXQgYXBwZWFyXG4gICAgICAgIC8vIG1hbnkgdGltZXMgaW4gdGhlIG91dHB1dCB3aWxsIGJlIHBlbmFsaXNlZCBtb3JlLlxuICAgICAgICBmb3IgKGNvbnN0IGlucHV0X2lkIG9mIGlucHV0X2lkcykge1xuICAgICAgICAgICAgaWYgKGxvZ2l0cy5kYXRhW2lucHV0X2lkXSA8IDApIHtcbiAgICAgICAgICAgICAgICBsb2dpdHMuZGF0YVtpbnB1dF9pZF0gKj0gdGhpcy5wZW5hbHR5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dpdHMuZGF0YVtpbnB1dF9pZF0gLz0gdGhpcy5wZW5hbHR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dpdHNcbiAgICB9XG59XG5cbi8qKlxuICogQ2xhc3MgdGhhdCBob2xkcyBhIGNvbmZpZ3VyYXRpb24gZm9yIGEgZ2VuZXJhdGlvbiB0YXNrLlxuICovXG5leHBvcnQgY2xhc3MgR2VuZXJhdGlvbkNvbmZpZyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgR2VuZXJhdGlvbkNvbmZpZyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2t3YXJncz17fV0gVGhlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycy4gSWYgbm90IHNldCwgdGhlIGRlZmF1bHQgdmFsdWVzIGFyZSB1c2VkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLm1heF9sZW5ndGg9MjBdIFRoZSBtYXhpbXVtIGxlbmd0aCB0aGUgZ2VuZXJhdGVkIHRva2VucyBjYW4gaGF2ZS4gQ29ycmVzcG9uZHMgdG8gdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgcHJvbXB0ICsgYG1heF9uZXdfdG9rZW5zYC4gSXRzIGVmZmVjdCBpcyBvdmVycmlkZGVuIGJ5IGBtYXhfbmV3X3Rva2Vuc2AsIGlmIGFsc28gc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLm1heF9uZXdfdG9rZW5zPW51bGxdIFRoZSBtYXhpbXVtIG51bWJlcnMgb2YgdG9rZW5zIHRvIGdlbmVyYXRlLCBpZ25vcmluZyB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiB0aGUgcHJvbXB0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLm1pbl9sZW5ndGg9MF0gVGhlIG1pbmltdW0gbGVuZ3RoIG9mIHRoZSBzZXF1ZW5jZSB0byBiZSBnZW5lcmF0ZWQuIENvcnJlc3BvbmRzIHRvIHRoZSBsZW5ndGggb2YgdGhlIGlucHV0IHByb21wdCArIGBtaW5fbmV3X3Rva2Vuc2AuIEl0cyBlZmZlY3QgaXMgb3ZlcnJpZGRlbiBieSBgbWluX25ld190b2tlbnNgLCBpZiBhbHNvIHNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5taW5fbmV3X3Rva2Vucz1udWxsXSBUaGUgbWluaW11bSBudW1iZXJzIG9mIHRva2VucyB0byBnZW5lcmF0ZSwgaWdub3JpbmcgdGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIHByb21wdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58XCJuZXZlclwifSBba3dhcmdzLmVhcmx5X3N0b3BwaW5nPWZhbHNlXSBDb250cm9scyB0aGUgc3RvcHBpbmcgY29uZGl0aW9uIGZvciBiZWFtLWJhc2VkIG1ldGhvZHMsIGxpa2UgYmVhbS1zZWFyY2guIEl0IGFjY2VwdHMgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gICAgICogLSBgdHJ1ZWAsIHdoZXJlIHRoZSBnZW5lcmF0aW9uIHN0b3BzIGFzIHNvb24gYXMgdGhlcmUgYXJlIGBudW1fYmVhbXNgIGNvbXBsZXRlIGNhbmRpZGF0ZXM7XG4gICAgICogLSBgZmFsc2VgLCB3aGVyZSBhbiBoZXVyaXN0aWMgaXMgYXBwbGllZCBhbmQgdGhlIGdlbmVyYXRpb24gc3RvcHMgd2hlbiBpcyBpdCB2ZXJ5IHVubGlrZWx5IHRvIGZpbmQgYmV0dGVyIGNhbmRpZGF0ZXM7XG4gICAgICogLSBgXCJuZXZlclwiYCwgd2hlcmUgdGhlIGJlYW0gc2VhcmNoIHByb2NlZHVyZSBvbmx5IHN0b3BzIHdoZW4gdGhlcmUgY2Fubm90IGJlIGJldHRlciBjYW5kaWRhdGVzIChjYW5vbmljYWwgYmVhbSBzZWFyY2ggYWxnb3JpdGhtKS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5tYXhfdGltZT1udWxsXSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB5b3UgYWxsb3cgdGhlIGNvbXB1dGF0aW9uIHRvIHJ1biBmb3IgaW4gc2Vjb25kcy4gR2VuZXJhdGlvbiB3aWxsIHN0aWxsIGZpbmlzaCB0aGUgY3VycmVudCBwYXNzIGFmdGVyIGFsbG9jYXRlZCB0aW1lIGhhcyBiZWVuIHBhc3NlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5kb19zYW1wbGU9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIHVzZSBzYW1wbGluZzsgdXNlIGdyZWVkeSBkZWNvZGluZyBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MubnVtX2JlYW1zPTFdIE51bWJlciBvZiBiZWFtcyBmb3IgYmVhbSBzZWFyY2guIDEgbWVhbnMgbm8gYmVhbSBzZWFyY2guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MubnVtX2JlYW1fZ3JvdXBzPTFdIE51bWJlciBvZiBncm91cHMgdG8gZGl2aWRlIGBudW1fYmVhbXNgIGludG8gaW4gb3JkZXIgdG8gZW5zdXJlIGRpdmVyc2l0eSBhbW9uZyBkaWZmZXJlbnQgZ3JvdXBzIG9mIGJlYW1zLiBTZWUgW3RoaXMgcGFwZXJdKGh0dHBzOi8vYXJ4aXYub3JnL3BkZi8xNjEwLjAyNDI0LnBkZikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5wZW5hbHR5X2FscGhhPW51bGxdIFRoZSB2YWx1ZXMgYmFsYW5jZSB0aGUgbW9kZWwgY29uZmlkZW5jZSBhbmQgdGhlIGRlZ2VuZXJhdGlvbiBwZW5hbHR5IGluIGNvbnRyYXN0aXZlIHNlYXJjaCBkZWNvZGluZy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtrd2FyZ3MudXNlX2NhY2hlPXRydWVdIFdoZXRoZXIgb3Igbm90IHRoZSBtb2RlbCBzaG91bGQgdXNlIHRoZSBwYXN0IGxhc3Qga2V5L3ZhbHVlcyBhdHRlbnRpb25zIChpZiBhcHBsaWNhYmxlIHRvIHRoZSBtb2RlbCkgdG8gc3BlZWQgdXAgZGVjb2RpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy50ZW1wZXJhdHVyZT0xLjBdIFRoZSB2YWx1ZSB1c2VkIHRvIG1vZHVsYXRlIHRoZSBuZXh0IHRva2VuIHByb2JhYmlsaXRpZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MudG9wX2s9NTBdIFRoZSBudW1iZXIgb2YgaGlnaGVzdCBwcm9iYWJpbGl0eSB2b2NhYnVsYXJ5IHRva2VucyB0byBrZWVwIGZvciB0b3Atay1maWx0ZXJpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MudG9wX3A9MS4wXSBJZiBzZXQgdG8gZmxvYXQgPCAxLCBvbmx5IHRoZSBzbWFsbGVzdCBzZXQgb2YgbW9zdCBwcm9iYWJsZSB0b2tlbnMgd2l0aCBwcm9iYWJpbGl0aWVzIHRoYXQgYWRkIHVwIHRvIGB0b3BfcGAgb3IgaGlnaGVyIGFyZSBrZXB0IGZvciBnZW5lcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLnR5cGljYWxfcD0xLjBdIExvY2FsIHR5cGljYWxpdHkgbWVhc3VyZXMgaG93IHNpbWlsYXIgdGhlIGNvbmRpdGlvbmFsIHByb2JhYmlsaXR5IG9mIHByZWRpY3RpbmcgYSB0YXJnZXQgdG9rZW4gbmV4dCBpcyB0byB0aGUgZXhwZWN0ZWQgY29uZGl0aW9uYWwgcHJvYmFiaWxpdHkgb2YgcHJlZGljdGluZyBhIHJhbmRvbSB0b2tlbiBuZXh0LCBnaXZlbiB0aGUgcGFydGlhbCB0ZXh0IGFscmVhZHkgZ2VuZXJhdGVkLiBJZiBzZXQgdG8gZmxvYXQgPCAxLCB0aGUgc21hbGxlc3Qgc2V0IG9mIHRoZSBtb3N0IGxvY2FsbHkgdHlwaWNhbCB0b2tlbnMgd2l0aCBwcm9iYWJpbGl0aWVzIHRoYXQgYWRkIHVwIHRvIGB0eXBpY2FsX3BgIG9yIGhpZ2hlciBhcmUga2VwdCBmb3IgZ2VuZXJhdGlvbi4gU2VlIFt0aGlzIHBhcGVyXShodHRwczovL2FyeGl2Lm9yZy9wZGYvMjIwMi4wMDY2Ni5wZGYpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuZXBzaWxvbl9jdXRvZmY9MC4wXSBJZiBzZXQgdG8gZmxvYXQgc3RyaWN0bHkgYmV0d2VlbiAwIGFuZCAxLCBvbmx5IHRva2VucyB3aXRoIGEgY29uZGl0aW9uYWwgcHJvYmFiaWxpdHkgZ3JlYXRlciB0aGFuIGBlcHNpbG9uX2N1dG9mZmAgd2lsbCBiZSBzYW1wbGVkLiBJbiB0aGUgcGFwZXIsIHN1Z2dlc3RlZCB2YWx1ZXMgcmFuZ2UgZnJvbSAzZS00IHRvIDllLTQsIGRlcGVuZGluZyBvbiB0aGUgc2l6ZSBvZiB0aGUgbW9kZWwuIFNlZSBbVHJ1bmNhdGlvbiBTYW1wbGluZyBhcyBMYW5ndWFnZSBNb2RlbCBEZXNtb290aGluZ10oaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIyMTAuMTUxOTEpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuZXRhX2N1dG9mZj0wLjBdIEV0YSBzYW1wbGluZyBpcyBhIGh5YnJpZCBvZiBsb2NhbGx5IHR5cGljYWwgc2FtcGxpbmcgYW5kIGVwc2lsb24gc2FtcGxpbmcuIElmIHNldCB0byBmbG9hdCBzdHJpY3RseSBiZXR3ZWVuIDAgYW5kIDEsIGEgdG9rZW4gaXMgb25seSBjb25zaWRlcmVkIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiBlaXRoZXIgYGV0YV9jdXRvZmZgIG9yIGBzcXJ0KGV0YV9jdXRvZmYpICogZXhwKC1lbnRyb3B5KHNvZnRtYXgobmV4dF90b2tlbl9sb2dpdHMpKSlgLiBUaGUgbGF0dGVyIHRlcm0gaXMgaW50dWl0aXZlbHkgdGhlIGV4cGVjdGVkIG5leHQgdG9rZW4gcHJvYmFiaWxpdHksIHNjYWxlZCBieSBgc3FydChldGFfY3V0b2ZmKWAuIEluIHRoZSBwYXBlciwgc3VnZ2VzdGVkIHZhbHVlcyByYW5nZSBmcm9tIDNlLTQgdG8gMmUtMywgZGVwZW5kaW5nIG9uIHRoZSBzaXplIG9mIHRoZSBtb2RlbC4gU2VlIFtUcnVuY2F0aW9uIFNhbXBsaW5nIGFzIExhbmd1YWdlIE1vZGVsIERlc21vb3RoaW5nXShodHRwczovL2FyeGl2Lm9yZy9hYnMvMjIxMC4xNTE5MSkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5kaXZlcnNpdHlfcGVuYWx0eT0wLjBdIFRoaXMgdmFsdWUgaXMgc3VidHJhY3RlZCBmcm9tIGEgYmVhbSdzIHNjb3JlIGlmIGl0IGdlbmVyYXRlcyBhIHRva2VuIHNhbWUgYXMgYW55IGJlYW0gZnJvbSBvdGhlciBncm91cCBhdCBhIHBhcnRpY3VsYXIgdGltZS4gTm90ZSB0aGF0IGBkaXZlcnNpdHlfcGVuYWx0eWAgaXMgb25seSBlZmZlY3RpdmUgaWYgYGdyb3VwIGJlYW0gc2VhcmNoYCBpcyBlbmFibGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLnJlcGV0aXRpb25fcGVuYWx0eT0xLjBdIFRoZSBwYXJhbWV0ZXIgZm9yIHJlcGV0aXRpb24gcGVuYWx0eS4gMS4wIG1lYW5zIG5vIHBlbmFsdHkuIFNlZSBbdGhpcyBwYXBlcl0oaHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE5MDkuMDU4NTgucGRmKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLmVuY29kZXJfcmVwZXRpdGlvbl9wZW5hbHR5PTEuMF0gVGhlIHBhcmFtYXRlciBmb3IgZW5jb2Rlcl9yZXBldGl0aW9uX3BlbmFsdHkuIEFuIGV4cG9uZW50aWFsIHBlbmFsdHkgb24gc2VxdWVuY2VzIHRoYXQgYXJlIG5vdCBpbiB0aGUgb3JpZ2luYWwgaW5wdXQuIDEuMCBtZWFucyBubyBwZW5hbHR5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLmxlbmd0aF9wZW5hbHR5PTEuMF0gRXhwb25lbnRpYWwgcGVuYWx0eSB0byB0aGUgbGVuZ3RoIHRoYXQgaXMgdXNlZCB3aXRoIGJlYW0tYmFzZWQgZ2VuZXJhdGlvbi4gSXQgaXMgYXBwbGllZCBhcyBhbiBleHBvbmVudCB0byB0aGUgc2VxdWVuY2UgbGVuZ3RoLCB3aGljaCBpbiB0dXJuIGlzIHVzZWQgdG8gZGl2aWRlIHRoZSBzY29yZSBvZiB0aGUgc2VxdWVuY2UuIFNpbmNlIHRoZSBzY29yZSBpcyB0aGUgbG9nIGxpa2VsaWhvb2Qgb2YgdGhlIHNlcXVlbmNlIChpLmUuIG5lZ2F0aXZlKSwgYGxlbmd0aF9wZW5hbHR5YCA+IDAuMCBwcm9tb3RlcyBsb25nZXIgc2VxdWVuY2VzLCB3aGlsZSBgbGVuZ3RoX3BlbmFsdHlgIDwgMC4wIGVuY291cmFnZXMgc2hvcnRlciBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3Mubm9fcmVwZWF0X25ncmFtX3NpemU9MF0gSWYgc2V0IHRvIGludCA+IDAsIGFsbCBuZ3JhbXMgb2YgdGhhdCBzaXplIGNhbiBvbmx5IG9jY3VyIG9uY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBba3dhcmdzLmJhZF93b3Jkc19pZHM9bnVsbF0gTGlzdCBvZiB0b2tlbiBpZHMgdGhhdCBhcmUgbm90IGFsbG93ZWQgdG8gYmUgZ2VuZXJhdGVkLiBJbiBvcmRlciB0byBnZXQgdGhlIHRva2VuIGlkcyBvZiB0aGUgd29yZHMgdGhhdCBzaG91bGQgbm90IGFwcGVhciBpbiB0aGUgZ2VuZXJhdGVkIHRleHQsIHVzZSBgKGF3YWl0IHRva2VuaXplcihiYWRfd29yZHMsIHthZGRfcHJlZml4X3NwYWNlOiB0cnVlLCBhZGRfc3BlY2lhbF90b2tlbnM6IGZhbHNlfSkpLmlucHV0X2lkc2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXVtdfG51bWJlcltdW11bXX0gW2t3YXJncy5mb3JjZV93b3Jkc19pZHM9bnVsbF0gTGlzdCBvZiB0b2tlbiBpZHMgdGhhdCBtdXN0IGJlIGdlbmVyYXRlZC4gSWYgZ2l2ZW4gYSBgbnVtYmVyW11bXWAsIHRoaXMgaXMgdHJlYXRlZCBhcyBhIHNpbXBsZSBsaXN0IG9mIHdvcmRzIHRoYXQgbXVzdCBiZSBpbmNsdWRlZCwgdGhlIG9wcG9zaXRlIHRvIGBiYWRfd29yZHNfaWRzYC4gSWYgZ2l2ZW4gYG51bWJlcltdW11bXWAsIHRoaXMgdHJpZ2dlcnMgYSBbZGlzanVuY3RpdmUgY29uc3RyYWludF0oaHR0cHM6Ly9naXRodWIuY29tL2h1Z2dpbmdmYWNlL3RyYW5zZm9ybWVycy9pc3N1ZXMvMTQwODEpLCB3aGVyZSBvbmUgY2FuIGFsbG93IGRpZmZlcmVudCBmb3JtcyBvZiBlYWNoIHdvcmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBba3dhcmdzLnJlbm9ybWFsaXplX2xvZ2l0cz1mYWxzZV0gV2hldGhlciB0byByZW5vcm1hbGl6ZSB0aGUgbG9naXRzIGFmdGVyIGFwcGx5aW5nIGFsbCB0aGUgbG9naXRzIHByb2Nlc3NvcnMgb3Igd2FycGVycyAoaW5jbHVkaW5nIHRoZSBjdXN0b20gb25lcykuIEl0J3MgaGlnaGx5IHJlY29tbWVuZGVkIHRvIHNldCB0aGlzIGZsYWcgdG8gYHRydWVgIGFzIHRoZSBzZWFyY2ggYWxnb3JpdGhtcyBzdXBwb3NlIHRoZSBzY29yZSBsb2dpdHMgYXJlIG5vcm1hbGl6ZWQgYnV0IHNvbWUgbG9naXQgcHJvY2Vzc29ycyBvciB3YXJwZXJzIGJyZWFrIHRoZSBub3JtYWxpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IFtrd2FyZ3MuY29uc3RyYWludHM9bnVsbF0gQ3VzdG9tIGNvbnN0cmFpbnRzIHRoYXQgY2FuIGJlIGFkZGVkIHRvIHRoZSBnZW5lcmF0aW9uIHRvIGVuc3VyZSB0aGF0IHRoZSBvdXRwdXQgd2lsbCBjb250YWluIHRoZSB1c2Ugb2YgY2VydGFpbiB0b2tlbnMgYXMgZGVmaW5lZCBieSBgQ29uc3RyYWludGAgb2JqZWN0cywgaW4gdGhlIG1vc3Qgc2Vuc2libGUgd2F5IHBvc3NpYmxlLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLmZvcmNlZF9ib3NfdG9rZW5faWQ9bnVsbF0gVGhlIGlkIG9mIHRoZSB0b2tlbiB0byBmb3JjZSBhcyB0aGUgZmlyc3QgZ2VuZXJhdGVkIHRva2VuIGFmdGVyIHRoZSBgZGVjb2Rlcl9zdGFydF90b2tlbl9pZGAuIFVzZWZ1bCBmb3IgbXVsdGlsaW5ndWFsIG1vZGVscyBsaWtlIG1CQVJUIHdoZXJlIHRoZSBmaXJzdCBnZW5lcmF0ZWQgdG9rZW4gbmVlZHMgdG8gYmUgdGhlIHRhcmdldCBsYW5ndWFnZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW2t3YXJncy5mb3JjZWRfZW9zX3Rva2VuX2lkPW51bGxdIFRoZSBpZCBvZiB0aGUgdG9rZW4gdG8gZm9yY2UgYXMgdGhlIGxhc3QgZ2VuZXJhdGVkIHRva2VuIHdoZW4gYG1heF9sZW5ndGhgIGlzIHJlYWNoZWQuIE9wdGlvbmFsbHksIHVzZSBhIGxpc3QgdG8gc2V0IG11bHRpcGxlICplbmQtb2Ytc2VxdWVuY2UqIHRva2Vucy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtrd2FyZ3MucmVtb3ZlX2ludmFsaWRfdmFsdWVzPWZhbHNlXSBXaGV0aGVyIHRvIHJlbW92ZSBwb3NzaWJsZSAqbmFuKiBhbmQgKmluZiogb3V0cHV0cyBvZiB0aGUgbW9kZWwgdG8gcHJldmVudCB0aGUgZ2VuZXJhdGlvbiBtZXRob2QgdG8gY3Jhc2guIE5vdGUgdGhhdCB1c2luZyBgcmVtb3ZlX2ludmFsaWRfdmFsdWVzYCBjYW4gc2xvdyBkb3duIGdlbmVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gW2t3YXJncy5leHBvbmVudGlhbF9kZWNheV9sZW5ndGhfcGVuYWx0eT1udWxsXSBUaGlzIFR1cGxlIGFkZHMgYW4gZXhwb25lbnRpYWxseSBpbmNyZWFzaW5nIGxlbmd0aCBwZW5hbHR5LCBhZnRlciBhIGNlcnRhaW4gYW1vdW50IG9mIHRva2VucyBoYXZlIGJlZW4gZ2VuZXJhdGVkLiBUaGUgdHVwbGUgc2hhbGwgY29uc2lzdCBvZjogYChzdGFydF9pbmRleCwgZGVjYXlfZmFjdG9yKWAgd2hlcmUgYHN0YXJ0X2luZGV4YCBpbmRpY2F0ZXMgd2hlcmUgcGVuYWx0eSBzdGFydHMgYW5kIGBkZWNheV9mYWN0b3JgIHJlcHJlc2VudHMgdGhlIGZhY3RvciBvZiBleHBvbmVudGlhbCBkZWNheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBba3dhcmdzLnN1cHByZXNzX3Rva2Vucz1udWxsXSBBIGxpc3Qgb2YgdG9rZW5zIHRoYXQgd2lsbCBiZSBzdXBwcmVzc2VkIGF0IGdlbmVyYXRpb24uIFRoZSBgU3VwcmVzc1Rva2Vuc2AgbG9naXQgcHJvY2Vzc29yIHdpbGwgc2V0IHRoZWlyIGxvZyBwcm9icyB0byBgLWluZmAgc28gdGhhdCB0aGV5IGFyZSBub3Qgc2FtcGxlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBba3dhcmdzLmJlZ2luX3N1cHByZXNzX3Rva2Vucz1udWxsXSBBIGxpc3Qgb2YgdG9rZW5zIHRoYXQgd2lsbCBiZSBzdXBwcmVzc2VkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGdlbmVyYXRpb24uIFRoZSBgU3VwcmVzc0JlZ2luVG9rZW5zYCBsb2dpdCBwcm9jZXNzb3Igd2lsbCBzZXQgdGhlaXIgbG9nIHByb2JzIHRvIGAtaW5mYCBzbyB0aGF0IHRoZXkgYXJlIG5vdCBzYW1wbGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW11bXX0gW2t3YXJncy5mb3JjZWRfZGVjb2Rlcl9pZHM9bnVsbF0gQSBsaXN0IG9mIHBhaXJzIG9mIGludGVnZXJzIHdoaWNoIGluZGljYXRlcyBhIG1hcHBpbmcgZnJvbSBnZW5lcmF0aW9uIGluZGljZXMgdG8gdG9rZW4gaW5kaWNlcyB0aGF0IHdpbGwgYmUgZm9yY2VkIGJlZm9yZSBzYW1wbGluZy4gRm9yIGV4YW1wbGUsIGBbWzEsIDEyM11dYCBtZWFucyB0aGUgc2Vjb25kIGdlbmVyYXRlZCB0b2tlbiB3aWxsIGFsd2F5cyBiZSBhIHRva2VuIG9mIGluZGV4IDEyMy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2t3YXJncy5udW1fcmV0dXJuX3NlcXVlbmNlcz0xXSBUaGUgbnVtYmVyIG9mIGluZGVwZW5kZW50bHkgY29tcHV0ZWQgcmV0dXJuZWQgc2VxdWVuY2VzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGJhdGNoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5vdXRwdXRfYXR0ZW50aW9ucz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gcmV0dXJuIHRoZSBhdHRlbnRpb25zIHRlbnNvcnMgb2YgYWxsIGF0dGVudGlvbiBsYXllcnMuIFNlZSBgYXR0ZW50aW9uc2AgdW5kZXIgcmV0dXJuZWQgdGVuc29ycyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5vdXRwdXRfaGlkZGVuX3N0YXRlcz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gcmV0dXJuIHRoZSBoaWRkZW4gc3RhdGVzIG9mIGFsbCBsYXllcnMuIFNlZSBgaGlkZGVuX3N0YXRlc2AgdW5kZXIgcmV0dXJuZWQgdGVuc29ycyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5vdXRwdXRfc2NvcmVzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byByZXR1cm4gdGhlIHByZWRpY3Rpb24gc2NvcmVzLiBTZWUgYHNjb3Jlc2AgdW5kZXIgcmV0dXJuZWQgdGVuc29ycyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2t3YXJncy5yZXR1cm5fZGljdF9pbl9nZW5lcmF0ZT1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gcmV0dXJuIGEgYE1vZGVsT3V0cHV0YCBpbnN0ZWFkIG9mIGEgcGxhaW4gdHVwbGUuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MucGFkX3Rva2VuX2lkPW51bGxdIFRoZSBpZCBvZiB0aGUgKnBhZGRpbmcqIHRva2VuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBba3dhcmdzLmJvc190b2tlbl9pZD1udWxsXSBUaGUgaWQgb2YgdGhlICpiZWdpbm5pbmctb2Ytc2VxdWVuY2UqIHRva2VuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBba3dhcmdzLmVvc190b2tlbl9pZD1udWxsXSBUaGUgaWQgb2YgdGhlICplbmQtb2Ytc2VxdWVuY2UqIHRva2VuLiBPcHRpb25hbGx5LCB1c2UgYSBsaXN0IHRvIHNldCBtdWx0aXBsZSAqZW5kLW9mLXNlcXVlbmNlKiB0b2tlbnMuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuZW5jb2Rlcl9ub19yZXBlYXRfbmdyYW1fc2l6ZT0wXSBJZiBzZXQgdG8gaW50ID4gMCwgYWxsIG5ncmFtcyBvZiB0aGF0IHNpemUgdGhhdCBvY2N1ciBpbiB0aGUgYGVuY29kZXJfaW5wdXRfaWRzYCBjYW5ub3Qgb2NjdXIgaW4gdGhlIGBkZWNvZGVyX2lucHV0X2lkc2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrd2FyZ3MuZGVjb2Rlcl9zdGFydF90b2tlbl9pZD1udWxsXSBJZiBhbiBlbmNvZGVyLWRlY29kZXIgbW9kZWwgc3RhcnRzIGRlY29kaW5nIHdpdGggYSBkaWZmZXJlbnQgdG9rZW4gdGhhbiAqYm9zKiwgdGhlIGlkIG9mIHRoYXQgdG9rZW4uXG4gICAgICogXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtrd2FyZ3MuZ2VuZXJhdGlvbl9rd2FyZ3M9e31dIEFkZGl0aW9uYWwgZ2VuZXJhdGlvbiBrd2FyZ3Mgd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGhlIGBnZW5lcmF0ZWAgZnVuY3Rpb24gb2YgdGhlIG1vZGVsLiBLd2FyZ3MgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gYGdlbmVyYXRlYCdzIHNpZ25hdHVyZSB3aWxsIGJlIHVzZWQgaW4gdGhlIG1vZGVsIGZvcndhcmQgcGFzcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihrd2FyZ3MgPSB7fSkge1xuICAgICAgICAvLyBQYXJhbWV0ZXJzIHRoYXQgY29udHJvbCB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXRcbiAgICAgICAgdGhpcy5tYXhfbGVuZ3RoID0ga3dhcmdzLm1heF9sZW5ndGggPz8gMjA7XG4gICAgICAgIHRoaXMubWF4X25ld190b2tlbnMgPSBrd2FyZ3MubWF4X25ld190b2tlbnMgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5taW5fbGVuZ3RoID0ga3dhcmdzLm1pbl9sZW5ndGggPz8gMDtcbiAgICAgICAgdGhpcy5taW5fbmV3X3Rva2VucyA9IGt3YXJncy5taW5fbmV3X3Rva2VucyA/PyBudWxsO1xuICAgICAgICB0aGlzLmVhcmx5X3N0b3BwaW5nID0ga3dhcmdzLmVhcmx5X3N0b3BwaW5nID8/IGZhbHNlO1xuICAgICAgICB0aGlzLm1heF90aW1lID0ga3dhcmdzLm1heF90aW1lID8/IG51bGw7XG5cbiAgICAgICAgLy8gUGFyYW1ldGVycyB0aGF0IGNvbnRyb2wgdGhlIGdlbmVyYXRpb24gc3RyYXRlZ3kgdXNlZFxuICAgICAgICB0aGlzLmRvX3NhbXBsZSA9IGt3YXJncy5kb19zYW1wbGUgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMubnVtX2JlYW1zID0ga3dhcmdzLm51bV9iZWFtcyA/PyAxO1xuICAgICAgICB0aGlzLm51bV9iZWFtX2dyb3VwcyA9IGt3YXJncy5udW1fYmVhbV9ncm91cHMgPz8gMTtcbiAgICAgICAgdGhpcy5wZW5hbHR5X2FscGhhID0ga3dhcmdzLnBlbmFsdHlfYWxwaGEgPz8gbnVsbDtcbiAgICAgICAgdGhpcy51c2VfY2FjaGUgPSBrd2FyZ3MudXNlX2NhY2hlID8/IHRydWU7XG5cbiAgICAgICAgLy8gUGFyYW1ldGVycyBmb3IgbWFuaXB1bGF0aW9uIG9mIHRoZSBtb2RlbCBvdXRwdXQgbG9naXRzXG4gICAgICAgIHRoaXMudGVtcGVyYXR1cmUgPSBrd2FyZ3MudGVtcGVyYXR1cmUgPz8gMS4wO1xuICAgICAgICB0aGlzLnRvcF9rID0ga3dhcmdzLnRvcF9rID8/IDUwO1xuICAgICAgICB0aGlzLnRvcF9wID0ga3dhcmdzLnRvcF9wID8/IDEuMDtcbiAgICAgICAgdGhpcy50eXBpY2FsX3AgPSBrd2FyZ3MudHlwaWNhbF9wID8/IDEuMDtcbiAgICAgICAgdGhpcy5lcHNpbG9uX2N1dG9mZiA9IGt3YXJncy5lcHNpbG9uX2N1dG9mZiA/PyAwLjA7XG4gICAgICAgIHRoaXMuZXRhX2N1dG9mZiA9IGt3YXJncy5ldGFfY3V0b2ZmID8/IDAuMDtcbiAgICAgICAgdGhpcy5kaXZlcnNpdHlfcGVuYWx0eSA9IGt3YXJncy5kaXZlcnNpdHlfcGVuYWx0eSA/PyAwLjA7XG4gICAgICAgIHRoaXMucmVwZXRpdGlvbl9wZW5hbHR5ID0ga3dhcmdzLnJlcGV0aXRpb25fcGVuYWx0eSA/PyAxLjA7XG4gICAgICAgIHRoaXMuZW5jb2Rlcl9yZXBldGl0aW9uX3BlbmFsdHkgPSBrd2FyZ3MuZW5jb2Rlcl9yZXBldGl0aW9uX3BlbmFsdHkgPz8gMS4wO1xuICAgICAgICB0aGlzLmxlbmd0aF9wZW5hbHR5ID0ga3dhcmdzLmxlbmd0aF9wZW5hbHR5ID8/IDEuMDtcbiAgICAgICAgdGhpcy5ub19yZXBlYXRfbmdyYW1fc2l6ZSA9IGt3YXJncy5ub19yZXBlYXRfbmdyYW1fc2l6ZSA/PyAwO1xuICAgICAgICB0aGlzLmJhZF93b3Jkc19pZHMgPSBrd2FyZ3MuYmFkX3dvcmRzX2lkcyA/PyBudWxsO1xuICAgICAgICB0aGlzLmZvcmNlX3dvcmRzX2lkcyA9IGt3YXJncy5mb3JjZV93b3Jkc19pZHMgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5vcm1hbGl6ZV9sb2dpdHMgPSBrd2FyZ3MucmVub3JtYWxpemVfbG9naXRzID8/IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0ga3dhcmdzLmNvbnN0cmFpbnRzID8/IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VkX2Jvc190b2tlbl9pZCA9IGt3YXJncy5mb3JjZWRfYm9zX3Rva2VuX2lkID8/IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VkX2Vvc190b2tlbl9pZCA9IGt3YXJncy5mb3JjZWRfZW9zX3Rva2VuX2lkID8/IG51bGw7XG4gICAgICAgIHRoaXMucmVtb3ZlX2ludmFsaWRfdmFsdWVzID0ga3dhcmdzLnJlbW92ZV9pbnZhbGlkX3ZhbHVlcyA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy5leHBvbmVudGlhbF9kZWNheV9sZW5ndGhfcGVuYWx0eSA9IGt3YXJncy5leHBvbmVudGlhbF9kZWNheV9sZW5ndGhfcGVuYWx0eSA/PyBudWxsO1xuICAgICAgICB0aGlzLnN1cHByZXNzX3Rva2VucyA9IGt3YXJncy5zdXBwcmVzc190b2tlbnMgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5iZWdpbl9zdXBwcmVzc190b2tlbnMgPSBrd2FyZ3MuYmVnaW5fc3VwcHJlc3NfdG9rZW5zID8/IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VkX2RlY29kZXJfaWRzID0ga3dhcmdzLmZvcmNlZF9kZWNvZGVyX2lkcyA/PyBudWxsO1xuXG4gICAgICAgIC8vIFBhcmFtZXRlcnMgdGhhdCBkZWZpbmUgdGhlIG91dHB1dCB2YXJpYWJsZXMgb2YgYGdlbmVyYXRlYFxuICAgICAgICB0aGlzLm51bV9yZXR1cm5fc2VxdWVuY2VzID0ga3dhcmdzLm51bV9yZXR1cm5fc2VxdWVuY2VzID8/IDE7XG4gICAgICAgIHRoaXMub3V0cHV0X2F0dGVudGlvbnMgPSBrd2FyZ3Mub3V0cHV0X2F0dGVudGlvbnMgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMub3V0cHV0X2hpZGRlbl9zdGF0ZXMgPSBrd2FyZ3Mub3V0cHV0X2hpZGRlbl9zdGF0ZXMgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMub3V0cHV0X3Njb3JlcyA9IGt3YXJncy5vdXRwdXRfc2NvcmVzID8/IGZhbHNlO1xuICAgICAgICB0aGlzLnJldHVybl9kaWN0X2luX2dlbmVyYXRlID0ga3dhcmdzLnJldHVybl9kaWN0X2luX2dlbmVyYXRlID8/IGZhbHNlO1xuXG4gICAgICAgIC8vIFNwZWNpYWwgdG9rZW5zIHRoYXQgY2FuIGJlIHVzZWQgYXQgZ2VuZXJhdGlvbiB0aW1lXG4gICAgICAgIHRoaXMucGFkX3Rva2VuX2lkID0ga3dhcmdzLnBhZF90b2tlbl9pZCA/PyBudWxsO1xuICAgICAgICB0aGlzLmJvc190b2tlbl9pZCA9IGt3YXJncy5ib3NfdG9rZW5faWQgPz8gbnVsbDtcbiAgICAgICAgdGhpcy5lb3NfdG9rZW5faWQgPSBrd2FyZ3MuZW9zX3Rva2VuX2lkID8/IG51bGw7XG5cbiAgICAgICAgLy8gR2VuZXJhdGlvbiBwYXJhbWV0ZXJzIGV4Y2x1c2l2ZSB0byBlbmNvZGVyLWRlY29kZXIgbW9kZWxzXG4gICAgICAgIHRoaXMuZW5jb2Rlcl9ub19yZXBlYXRfbmdyYW1fc2l6ZSA9IGt3YXJncy5lbmNvZGVyX25vX3JlcGVhdF9uZ3JhbV9zaXplID8/IDA7XG4gICAgICAgIHRoaXMuZGVjb2Rlcl9zdGFydF90b2tlbl9pZCA9IGt3YXJncy5kZWNvZGVyX3N0YXJ0X3Rva2VuX2lkID8/IG51bGw7XG5cbiAgICAgICAgLy8gV2lsZCBjYXJkXG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbl9rd2FyZ3MgPSBrd2FyZ3MuZ2VuZXJhdGlvbl9rd2FyZ3MgPz8ge307XG4gICAgfVxufVxuXG5cbi8qKlxuICogU2FtcGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGFsbCBzYW1wbGluZyBtZXRob2RzIHVzZWQgZm9yIHRleHQgZ2VuZXJhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFNhbXBsZXIgZXh0ZW5kcyBDYWxsYWJsZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTYW1wbGVyIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgZ2VuZXJhdGlvbiBjb25maWcuXG4gICAgICogQHBhcmFtIHtHZW5lcmF0aW9uQ29uZmlnfSBnZW5lcmF0aW9uX2NvbmZpZyBUaGUgZ2VuZXJhdGlvbiBjb25maWcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2VuZXJhdGlvbl9jb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0aW9uX2NvbmZpZyA9IGdlbmVyYXRpb25fY29uZmlnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBzYW1wbGVyLCB1c2luZyB0aGUgc3BlY2lmaWVkIGxvZ2l0cy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbG9naXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgX2NhbGwobG9naXRzLCBpbmRleCA9IC0xKSB7XG4gICAgICAgIC8vIFNhbXBsZSBmcm9tIGxvZ2l0cywgb2YgZGltcyBbYmF0Y2gsIHNlcXVlbmNlX2xlbmd0aCwgdm9jYWJfc2l6ZV0uXG4gICAgICAgIC8vIElmIGluZGV4IGlzIHNwZWNpZmllZCwgc2FtcGxlIGZyb20gW2JhdGNoLCBpbmRleCwgdm9jYWJfc2l6ZV0uXG4gICAgICAgIHJldHVybiB0aGlzLnNhbXBsZShsb2dpdHMsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCBtZXRob2QgZm9yIHNhbXBsaW5nIHRoZSBsb2dpdHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGxvZ2l0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqL1xuICAgIHNhbXBsZShsb2dpdHMsIGluZGV4KSB7XG4gICAgICAgIHRocm93IEVycm9yKFwic2FtcGxlIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzLlwiKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCBsb2dpdHMgYXMgYW4gYXJyYXksIHdpdGggdGVtcGVyYXR1cmUgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbG9naXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldExvZ2l0cyhsb2dpdHMsIGluZGV4KSB7XG4gICAgICAgIGxldCB2b2NhYlNpemUgPSBsb2dpdHMuZGltcy5hdCgtMSk7XG5cbiAgICAgICAgbGV0IGxvZ3MgPSBsb2dpdHMuZGF0YTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBsb2dzID0gbG9ncy5zbGljZSgtdm9jYWJTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXggKiB2b2NhYlNpemU7XG4gICAgICAgICAgICBsb2dzID0gbG9ncy5zbGljZShzdGFydEluZGV4LCBzdGFydEluZGV4ICsgdm9jYWJTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0ZW1wZXJhdHVyZVxuICAgICAgICBpZiAodGhpcy5nZW5lcmF0aW9uX2NvbmZpZy50ZW1wZXJhdHVyZSA+IDApIHtcbiAgICAgICAgICAgIGxvZ3MgPSBsb2dzLm1hcCh4ID0+IHggLyB0aGlzLmdlbmVyYXRpb25fY29uZmlnLnRlbXBlcmF0dXJlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYW4gaXRlbSByYW5kb21seSBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIHByb2JhYmlsaXRpZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvYmFiaWxpdGllcyBBbiBhcnJheSBvZiBwcm9iYWJpbGl0aWVzIHRvIHVzZSBmb3Igc2VsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgaXRlbS5cbiAgICAgKi9cbiAgICByYW5kb21TZWxlY3QocHJvYmFiaWxpdGllcykge1xuICAgICAgICAvLyBSZXR1cm4gaW5kZXggb2YgY2hvc2VuIGl0ZW1cbiAgICAgICAgbGV0IHN1bVByb2JhYmlsaXRpZXMgPSBwcm9iYWJpbGl0aWVzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLCAwKTtcblxuICAgICAgICBsZXQgciA9IE1hdGgucmFuZG9tKCkgKiBzdW1Qcm9iYWJpbGl0aWVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2JhYmlsaXRpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHIgLT0gcHJvYmFiaWxpdGllc1tpXTtcbiAgICAgICAgICAgIGlmIChyIDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDsgLy8gcmV0dXJuIGZpcnN0IChtb3N0IHByb2JhYmxlKSBhcyBhIGZhbGxiYWNrXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFNhbXBsZXIgb2JqZWN0IGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0dlbmVyYXRpb25Db25maWd9IGdlbmVyYXRpb25fY29uZmlnIEFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHRoZSBzYW1wbGVyLlxuICAgICAqIEByZXR1cm5zIHtTYW1wbGVyfSBBIFNhbXBsZXIgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTYW1wbGVyKGdlbmVyYXRpb25fY29uZmlnKSB7XG4gICAgICAgIC8vIC0gKmdyZWVkeSBkZWNvZGluZyo6IGBudW1fYmVhbXM9MWAgYW5kIGBkb19zYW1wbGU9RmFsc2VgXG4gICAgICAgIC8vIC0gKmNvbnRyYXN0aXZlIHNlYXJjaCo6IGBwZW5hbHR5X2FscGhhPjBgIGFuZCBgdG9wX2s+MWBcbiAgICAgICAgLy8gLSAqbXVsdGlub21pYWwgc2FtcGxpbmcqOiBgbnVtX2JlYW1zPTFgIGFuZCBgZG9fc2FtcGxlPVRydWVgXG4gICAgICAgIC8vIC0gKmJlYW0tc2VhcmNoIGRlY29kaW5nKjogYG51bV9iZWFtcz4xYCBhbmQgYGRvX3NhbXBsZT1GYWxzZWBcbiAgICAgICAgLy8gLSAqYmVhbS1zZWFyY2ggbXVsdGlub21pYWwgc2FtcGxpbmcqOiBgbnVtX2JlYW1zPjFgIGFuZCBgZG9fc2FtcGxlPVRydWVgXG4gICAgICAgIC8vIC0gKmRpdmVyc2UgYmVhbS1zZWFyY2ggZGVjb2RpbmcqOiBgbnVtX2JlYW1zPjFgIGFuZCBgbnVtX2JlYW1fZ3JvdXBzPjFgXG4gICAgICAgIC8vIC0gKmNvbnN0cmFpbmVkIGJlYW0tc2VhcmNoIGRlY29kaW5nKjogYGNvbnN0cmFpbnRzIT1Ob25lYCBvciBgZm9yY2Vfd29yZHNfaWRzIT1Ob25lYFxuXG4gICAgICAgIC8vIE5PVEU6IGJlYW0gc2VhcmNoIGlzIGltcGxlbWVudGVkIGRpcmVjdGx5IGludG8gdGhlIGdlbmVyYXRpb24gZnVuY3Rpb25cbiAgICAgICAgaWYgKGdlbmVyYXRpb25fY29uZmlnLmRvX3NhbXBsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aW5vbWlhbFNhbXBsZXIoZ2VuZXJhdGlvbl9jb25maWcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZ2VuZXJhdGlvbl9jb25maWcubnVtX2JlYW1zID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCZWFtU2VhcmNoU2FtcGxlcihnZW5lcmF0aW9uX2NvbmZpZyk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0aW9uX2NvbmZpZy5udW1fcmV0dXJuX3NlcXVlbmNlcyA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgbnVtX3JldHVybl9zZXF1ZW5jZXMgaGFzIHRvIGJlIDEgd2hlbiBkb2luZyBncmVlZHkgc2VhcmNoLCBidXQgaXMgJHtnZW5lcmF0aW9uX2NvbmZpZy5udW1fcmV0dXJuX3NlcXVlbmNlc30uYClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgR3JlZWR5U2FtcGxlcihnZW5lcmF0aW9uX2NvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgR3JlZWR5IFNhbXBsZXIuXG4gKiBAZXh0ZW5kcyBTYW1wbGVyXG4gKi9cbmNsYXNzIEdyZWVkeVNhbXBsZXIgZXh0ZW5kcyBTYW1wbGVyIHtcbiAgICAvKipcbiAgICAgKiBTYW1wbGUgdGhlIG1heGltdW0gcHJvYmFiaWxpdHkgb2YgYSBnaXZlbiBsb2dpdHMgdGVuc29yLlxuICAgICAqIEBwYXJhbSB7VGVuc29yfSBsb2dpdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PS0xXVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgd2l0aCBhIHNpbmdsZSB0dXBsZSwgY29udGFpbmluZyB0aGUgaW5kZXggb2YgdGhlIG1heGltdW0gdmFsdWUgYW5kIGEgbWVhbmluZ2xlc3Mgc2NvcmUgKHNpbmNlIHRoaXMgaXMgYSBncmVlZHkgc2VhcmNoKS5cbiAgICAgKi9cbiAgICBzYW1wbGUobG9naXRzLCBpbmRleCA9IC0xKSB7XG4gICAgICAgIC8vIE5PVEU6IG5vIG5lZWQgdG8gZG8gbG9nX3NvZnRtYXggaGVyZSBzaW5jZSB3ZSBvbmx5IHRha2UgdGhlIG1heGltdW1cbiAgICAgICAgbGV0IGxvZ3MgPSB0aGlzLmdldExvZ2l0cyhsb2dpdHMsIGluZGV4KTtcbiAgICAgICAgbGV0IGFyZ21heCA9IG1heChsb2dzKVsxXTtcblxuICAgICAgICAvLyBOb3RlOiBzY29yZSBpcyBtZWFuaW5nbGVzcyBpbiB0aGlzIGNvbnRleHQsIHNpbmNlIHdlIGFyZSBwZXJmb3JtaW5nXG4gICAgICAgIC8vIGdyZWVkeSBzZWFyY2ggKHAgPSAxID0+IGxvZyhwKSA9IDApXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbYXJnbWF4LCAwXVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBNdWx0aW5vbWlhbFNhbXBsZXIuXG4gKiBAZXh0ZW5kcyBTYW1wbGVyXG4gKi9cbmNsYXNzIE11bHRpbm9taWFsU2FtcGxlciBleHRlbmRzIFNhbXBsZXIge1xuXG4gICAgLyoqXG4gICAgICogU2FtcGxlIGZyb20gdGhlIGxvZ2l0cy5cbiAgICAgKiBAcGFyYW0ge1RlbnNvcn0gbG9naXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHNhbXBsZShsb2dpdHMsIGluZGV4ID0gLTEpIHtcbiAgICAgICAgbGV0IGsgPSBsb2dpdHMuZGltcy5hdCgtMSk7IC8vIGRlZmF1bHRzIHRvIHZvY2FiIHNpemVcbiAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdGlvbl9jb25maWcudG9wX2sgPiAwKSB7XG4gICAgICAgICAgICBrID0gTWF0aC5taW4odGhpcy5nZW5lcmF0aW9uX2NvbmZpZy50b3Bfaywgayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgbG9naXRzIG9mIG50aCB0b2tlblxuICAgICAgICBjb25zdCBsb2dzID0gdGhpcy5nZXRMb2dpdHMobG9naXRzLCBpbmRleCk7XG5cbiAgICAgICAgLy8gR2V0IHRvcCBrIHRva2Vuc1xuICAgICAgICBjb25zdCB0b3BMb2dpdHMgPSBnZXRUb3BJdGVtcyhsb2dzLCBrKTtcblxuICAgICAgICAvLyBDb21wdXRlIHNvZnRtYXggb3ZlciBsb2dpdHNcbiAgICAgICAgY29uc3QgcHJvYmFiaWxpdGllcyA9IHNvZnRtYXgodG9wTG9naXRzLm1hcCh4ID0+IHhbMV0pKTtcblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5nZW5lcmF0aW9uX2NvbmZpZy5udW1fYmVhbXMgfSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlZEluZGV4ID0gdGhpcy5yYW5kb21TZWxlY3QocHJvYmFiaWxpdGllcyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRvcExvZ2l0c1tzYW1wbGVkSW5kZXhdWzBdLCAvLyB0b2tlbiBpZFxuICAgICAgICAgICAgICAgIE1hdGgubG9nKHByb2JhYmlsaXRpZXNbc2FtcGxlZEluZGV4XSksIC8vIHNjb3JlXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBCZWFtU2VhcmNoU2FtcGxlci5cbiAqIEBleHRlbmRzIFNhbXBsZXJcbiAqL1xuY2xhc3MgQmVhbVNlYXJjaFNhbXBsZXIgZXh0ZW5kcyBTYW1wbGVyIHtcblxuICAgIC8qKlxuICAgICAqIFNhbXBsZSBmcm9tIHRoZSBsb2dpdHMuXG4gICAgICogQHBhcmFtIHtUZW5zb3J9IGxvZ2l0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBzYW1wbGUobG9naXRzLCBpbmRleCA9IC0xKSB7XG4gICAgICAgIGxldCBrID0gbG9naXRzLmRpbXMuYXQoLTEpOyAvLyBkZWZhdWx0cyB0byB2b2NhYiBzaXplXG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRpb25fY29uZmlnLnRvcF9rID4gMCkge1xuICAgICAgICAgICAgayA9IE1hdGgubWluKHRoaXMuZ2VuZXJhdGlvbl9jb25maWcudG9wX2ssIGspO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGxvZ2l0cyBvZiBudGggdG9rZW5cbiAgICAgICAgY29uc3QgbG9ncyA9IHRoaXMuZ2V0TG9naXRzKGxvZ2l0cywgaW5kZXgpO1xuXG4gICAgICAgIC8vIEdldCB0b3AgayB0b2tlbnNcbiAgICAgICAgY29uc3QgdG9wTG9naXRzID0gZ2V0VG9wSXRlbXMobG9ncywgayk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBzb2Z0bWF4IG92ZXIgbG9naXRzXG4gICAgICAgIGNvbnN0IHByb2JhYmlsaXRpZXMgPSBzb2Z0bWF4KHRvcExvZ2l0cy5tYXAoeCA9PiB4WzFdKSk7XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IHRoaXMuZ2VuZXJhdGlvbl9jb25maWcubnVtX2JlYW1zIH0sIChfLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRvcExvZ2l0c1tpXVswXSwgLy8gdG9rZW4gaWRcbiAgICAgICAgICAgICAgICBNYXRoLmxvZyhwcm9iYWJpbGl0aWVzW2ldKSwgLy8gc2NvcmVcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIlxuLyoqXG4gKiBAZmlsZSBVdGlsaXR5IGZ1bmN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBIdWdnaW5nIEZhY2UgSHViIChodHRwczovL2h1Z2dpbmdmYWNlLmNvL21vZGVscylcbiAqIFxuICogQG1vZHVsZSB1dGlscy9odWJcbiAqL1xuXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc3RyZWFtIGZyb20gJ3N0cmVhbS93ZWInO1xuXG5pbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYuanMnO1xuaW1wb3J0IHsgZGlzcGF0Y2hDYWxsYmFjayB9IGZyb20gJy4vY29yZS5qcyc7XG5cbmlmICghZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtID0gc3RyZWFtLlJlYWRhYmxlU3RyZWFtOyAvLyBSZWFkYWJsZVN0cmVhbSBpcyBub3QgYSBnbG9iYWwgd2l0aCBOb2RlIDE2XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJldHJhaW5lZE9wdGlvbnMgT3B0aW9ucyBmb3IgbG9hZGluZyBhIHByZXRyYWluZWQgbW9kZWwuICAgICBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbj99IFtvcHRpb25zLnF1YW50aXplZD10cnVlXSBXaGV0aGVyIHRvIGxvYWQgdGhlIDgtYml0IHF1YW50aXplZCB2ZXJzaW9uIG9mIHRoZSBtb2RlbCAob25seSBhcHBsaWNhYmxlIHdoZW4gbG9hZGluZyBtb2RlbCBmaWxlcykuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbb3B0aW9ucy5wcm9ncmVzc19jYWxsYmFjaz1udWxsXSBJZiBzcGVjaWZpZWQsIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZHVyaW5nIG1vZGVsIGNvbnN0cnVjdGlvbiwgdG8gcHJvdmlkZSB0aGUgdXNlciB3aXRoIHByb2dyZXNzIHVwZGF0ZXMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gW29wdGlvbnMuY29uZmlnPW51bGxdIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBtb2RlbCB0byB1c2UgaW5zdGVhZCBvZiBhbiBhdXRvbWF0aWNhbGx5IGxvYWRlZCBjb25maWd1cmF0aW9uLiBDb25maWd1cmF0aW9uIGNhbiBiZSBhdXRvbWF0aWNhbGx5IGxvYWRlZCB3aGVuOlxuICogLSBUaGUgbW9kZWwgaXMgYSBtb2RlbCBwcm92aWRlZCBieSB0aGUgbGlicmFyeSAobG9hZGVkIHdpdGggdGhlICptb2RlbCBpZCogc3RyaW5nIG9mIGEgcHJldHJhaW5lZCBtb2RlbCkuXG4gKiAtIFRoZSBtb2RlbCBpcyBsb2FkZWQgYnkgc3VwcGx5aW5nIGEgbG9jYWwgZGlyZWN0b3J5IGFzIGBwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aGAgYW5kIGEgY29uZmlndXJhdGlvbiBKU09OIGZpbGUgbmFtZWQgKmNvbmZpZy5qc29uKiBpcyBmb3VuZCBpbiB0aGUgZGlyZWN0b3J5LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtvcHRpb25zLmNhY2hlX2Rpcj1udWxsXSBQYXRoIHRvIGEgZGlyZWN0b3J5IGluIHdoaWNoIGEgZG93bmxvYWRlZCBwcmV0cmFpbmVkIG1vZGVsIGNvbmZpZ3VyYXRpb24gc2hvdWxkIGJlIGNhY2hlZCBpZiB0aGUgc3RhbmRhcmQgY2FjaGUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3B0aW9ucy5sb2NhbF9maWxlc19vbmx5PWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBvbmx5IGxvb2sgYXQgbG9jYWwgZmlsZXMgKGUuZy4sIG5vdCB0cnkgZG93bmxvYWRpbmcgdGhlIG1vZGVsKS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3B0aW9ucy5yZXZpc2lvbj0nbWFpbiddIFRoZSBzcGVjaWZpYyBtb2RlbCB2ZXJzaW9uIHRvIHVzZS4gSXQgY2FuIGJlIGEgYnJhbmNoIG5hbWUsIGEgdGFnIG5hbWUsIG9yIGEgY29tbWl0IGlkLFxuICogc2luY2Ugd2UgdXNlIGEgZ2l0LWJhc2VkIHN5c3RlbSBmb3Igc3RvcmluZyBtb2RlbHMgYW5kIG90aGVyIGFydGlmYWN0cyBvbiBodWdnaW5nZmFjZS5jbywgc28gYHJldmlzaW9uYCBjYW4gYmUgYW55IGlkZW50aWZpZXIgYWxsb3dlZCBieSBnaXQuXG4gKiBOT1RFOiBUaGlzIHNldHRpbmcgaXMgaWdub3JlZCBmb3IgbG9jYWwgcmVxdWVzdHMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW29wdGlvbnMubW9kZWxfZmlsZV9uYW1lPW51bGxdIElmIHNwZWNpZmllZCwgbG9hZCB0aGUgbW9kZWwgd2l0aCB0aGlzIG5hbWUgKGV4Y2x1ZGluZyB0aGUgLm9ubnggc3VmZml4KS4gQ3VycmVudGx5IG9ubHkgdmFsaWQgZm9yIGVuY29kZXItIG9yIGRlY29kZXItb25seSBtb2RlbHMuXG4gKi9cblxuY2xhc3MgRmlsZVJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiBNYXBwaW5nIGZyb20gZmlsZSBleHRlbnNpb25zIHRvIE1JTUUgdHlwZXMuXG4gICAgICovXG4gICAgX0NPTlRFTlRfVFlQRV9NQVAgPSB7XG4gICAgICAgICd0eHQnOiAndGV4dC9wbGFpbicsXG4gICAgICAgICdodG1sJzogJ3RleHQvaHRtbCcsXG4gICAgICAgICdjc3MnOiAndGV4dC9jc3MnLFxuICAgICAgICAnanMnOiAndGV4dC9qYXZhc2NyaXB0JyxcbiAgICAgICAgJ2pzb24nOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdwbmcnOiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgJ2pwZyc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgJ2pwZWcnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICdnaWYnOiAnaW1hZ2UvZ2lmJyxcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgRmlsZVJlc3BvbnNlYCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd8VVJMfSBmaWxlUGF0aFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZpbGVQYXRoKSB7XG4gICAgICAgIHRoaXMuZmlsZVBhdGggPSBmaWxlUGF0aDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcblxuICAgICAgICB0aGlzLmV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpO1xuICAgICAgICBpZiAodGhpcy5leGlzdHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gJ09LJztcblxuICAgICAgICAgICAgbGV0IHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZVBhdGgpO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC1sZW5ndGgnLCBzdGF0cy5zaXplLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRlbnRUeXBlKCk7XG5cbiAgICAgICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFycmF5QnVmZmVyKCkudGhlbihidWZmZXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSA0MDQ7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c1RleHQgPSAnTm90IEZvdW5kJztcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgcHJvcGVydHkgb2YgdGhlIHJlc3BvbnNlIGJhc2VkIG9uIHRoZSBleHRlbnNpb24gb2ZcbiAgICAgKiB0aGUgZmlsZSBzcGVjaWZpZWQgYnkgdGhlIGZpbGVQYXRoIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVDb250ZW50VHlwZSgpIHtcbiAgICAgICAgLy8gU2V0IGNvbnRlbnQtdHlwZSBoZWFkZXIgYmFzZWQgb24gZmlsZSBleHRlbnNpb25cbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5maWxlUGF0aC50b1N0cmluZygpLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fQ09OVEVOVF9UWVBFX01BUFtleHRlbnNpb25dID8/ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZSB0aGUgY3VycmVudCBGaWxlUmVzcG9uc2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGaWxlUmVzcG9uc2V9IEEgbmV3IEZpbGVSZXNwb25zZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gbmV3IEZpbGVSZXNwb25zZSh0aGlzLmZpbGVQYXRoKTtcbiAgICAgICAgcmVzcG9uc2UuZXhpc3RzID0gdGhpcy5leGlzdHM7XG4gICAgICAgIHJlc3BvbnNlLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICAgICAgICByZXNwb25zZS5zdGF0dXNUZXh0ID0gdGhpcy5zdGF0dXNUZXh0O1xuICAgICAgICByZXNwb25zZS5oZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBzcGVjaWZpZWQgYnkgdGhlIGZpbGVQYXRoIHByb3BlcnR5IGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0XG4gICAgICogcmVzb2x2ZXMgd2l0aCBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIHRoZSBmaWxlJ3MgY29udGVudHMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXlCdWZmZXI+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIGZpbGUncyBjb250ZW50cy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpbGUgY2Fubm90IGJlIHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMgYXJyYXlCdWZmZXIoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZSh0aGlzLmZpbGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBjb250ZW50cyBvZiB0aGUgZmlsZSBzcGVjaWZpZWQgYnkgdGhlIGZpbGVQYXRoIHByb3BlcnR5IGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0XG4gICAgICogcmVzb2x2ZXMgd2l0aCBhIEJsb2IgY29udGFpbmluZyB0aGUgZmlsZSdzIGNvbnRlbnRzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEJsb2I+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgQmxvYiBjb250YWluaW5nIHRoZSBmaWxlJ3MgY29udGVudHMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBmaWxlIGNhbm5vdCBiZSByZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGJsb2IoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZSh0aGlzLmZpbGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtkYXRhXSwgeyB0eXBlOiB0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgY29udGVudHMgb2YgdGhlIGZpbGUgc3BlY2lmaWVkIGJ5IHRoZSBmaWxlUGF0aCBwcm9wZXJ0eSBhbmQgcmV0dXJucyBhIFByb21pc2UgdGhhdFxuICAgICAqIHJlc29sdmVzIHdpdGggYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZmlsZSdzIGNvbnRlbnRzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZmlsZSdzIGNvbnRlbnRzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmlsZSBjYW5ub3QgYmUgcmVhZC5cbiAgICAgKi9cbiAgICBhc3luYyB0ZXh0KCkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUodGhpcy5maWxlUGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBmaWxlIHNwZWNpZmllZCBieSB0aGUgZmlsZVBhdGggcHJvcGVydHkgYW5kIHJldHVybnMgYSBQcm9taXNlIHRoYXRcbiAgICAgKiByZXNvbHZlcyB3aXRoIGEgcGFyc2VkIEphdmFTY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpbGUncyBjb250ZW50cy5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgcGFyc2VkIEphdmFTY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpbGUncyBjb250ZW50cy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpbGUgY2Fubm90IGJlIHJlYWQuXG4gICAgICovXG4gICAgYXN5bmMganNvbigpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYXdhaXQgdGhpcy50ZXh0KCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHN0cmluZyBpcyBhIHZhbGlkIEhUVFAgb3IgSFRUUFMgVVJMLlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0ZXN0IGZvciB2YWxpZGl0eSBhcyBhbiBIVFRQIG9yIEhUVFBTIFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IFt2YWxpZEhvc3RzPW51bGxdIEEgbGlzdCBvZiB2YWxpZCBob3N0bmFtZXMuIElmIHNwZWNpZmllZCwgdGhlIFVSTCdzIGhvc3RuYW1lIG11c3QgYmUgaW4gdGhpcyBsaXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIHZhbGlkIEhUVFAgb3IgSFRUUFMgVVJMLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIdHRwVXJsKHN0cmluZywgdmFsaWRIb3N0cyA9IG51bGwpIHtcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDM0NjcxNDRcbiAgICBsZXQgdXJsO1xuICAgIHRyeSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwoc3RyaW5nKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbGlkSG9zdHMgJiYgIXZhbGlkSG9zdHMuaW5jbHVkZXModXJsLmhvc3RuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB1cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCB1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhIGZpbGUsIHVzaW5nIGVpdGhlciB0aGUgRmV0Y2ggQVBJIG9yIEZpbGVTeXN0ZW0gQVBJLlxuICpcbiAqIEBwYXJhbSB7VVJMfHN0cmluZ30gdXJsT3JQYXRoIFRoZSBVUkwvcGF0aCBvZiB0aGUgZmlsZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGaWxlUmVzcG9uc2V8UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEZpbGVSZXNwb25zZSBvYmplY3QgKGlmIHRoZSBmaWxlIGlzIHJldHJpZXZlZCB1c2luZyB0aGUgRmlsZVN5c3RlbSBBUEkpLCBvciBhIFJlc3BvbnNlIG9iamVjdCAoaWYgdGhlIGZpbGUgaXMgcmV0cmlldmVkIHVzaW5nIHRoZSBGZXRjaCBBUEkpLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZSh1cmxPclBhdGgpIHtcblxuICAgIGlmIChlbnYudXNlRlMgJiYgIWlzVmFsaWRIdHRwVXJsKHVybE9yUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlUmVzcG9uc2UodXJsT3JQYXRoKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3M/LnJlbGVhc2U/Lm5hbWUgPT09ICdub2RlJykge1xuICAgICAgICBjb25zdCBJU19DSSA9ICEhcHJvY2Vzcy5lbnY/LlRFU1RJTkdfUkVNT1RFTFk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBlbnYudmVyc2lvbjtcblxuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ1VzZXItQWdlbnQnLCBgdHJhbnNmb3JtZXJzLmpzLyR7dmVyc2lvbn07IGlzX2NpLyR7SVNfQ0l9O2ApO1xuXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgd2UgYXJlIG1ha2luZyBhIHJlcXVlc3QgdG8gdGhlIEh1Z2dpbmcgRmFjZSBIdWIuXG4gICAgICAgIGNvbnN0IGlzSEZVUkwgPSBpc1ZhbGlkSHR0cFVybCh1cmxPclBhdGgsIFsnaHVnZ2luZ2ZhY2UuY28nLCAnaGYuY28nXSk7XG4gICAgICAgIGlmIChpc0hGVVJMKSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBhY2Nlc3MgdG9rZW4gaXMgcHJlc2VudCBpbiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLFxuICAgICAgICAgICAgLy8gd2UgYWRkIGl0IHRvIHRoZSByZXF1ZXN0IGhlYWRlcnMuXG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHByb2Nlc3MuZW52Py5IRl9BQ0NFU1NfVE9LRU47XG4gICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt0b2tlbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmV0Y2godXJsT3JQYXRoLCB7IGhlYWRlcnMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUnVubmluZyBpbiBhIGJyb3dzZXItZW52aXJvbm1lbnQsIHNvIHdlIHVzZSBkZWZhdWx0IGhlYWRlcnNcbiAgICAgICAgLy8gTk9URTogV2UgZG8gbm90IGFsbG93IHBhc3NpbmcgYXV0aG9yaXphdGlvbiBoZWFkZXJzIGluIHRoZSBicm93c2VyLFxuICAgICAgICAvLyBzaW5jZSB0aGlzIHdvdWxkIHJlcXVpcmUgZXhwb3NpbmcgdGhlIHRva2VuIHRvIHRoZSBjbGllbnQuXG4gICAgICAgIHJldHVybiBmZXRjaCh1cmxPclBhdGgpO1xuICAgIH1cbn1cblxuY29uc3QgRVJST1JfTUFQUElORyA9IHtcbiAgICAvLyA0eHggZXJyb3JzIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cyNjbGllbnRfZXJyb3JfcmVzcG9uc2VzKVxuICAgIDQwMDogJ0JhZCByZXF1ZXN0IGVycm9yIG9jY3VycmVkIHdoaWxlIHRyeWluZyB0byBsb2FkIGZpbGUnLFxuICAgIDQwMTogJ1VuYXV0aG9yaXplZCBhY2Nlc3MgdG8gZmlsZScsXG4gICAgNDAzOiAnRm9yYmlkZGVuIGFjY2VzcyB0byBmaWxlJyxcbiAgICA0MDQ6ICdDb3VsZCBub3QgbG9jYXRlIGZpbGUnLFxuICAgIDQwODogJ1JlcXVlc3QgdGltZW91dCBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gbG9hZCBmaWxlJyxcblxuICAgIC8vIDV4eCBlcnJvcnMgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzI3NlcnZlcl9lcnJvcl9yZXNwb25zZXMpXG4gICAgNTAwOiAnSW50ZXJuYWwgc2VydmVyIGVycm9yIGVycm9yIG9jY3VycmVkIHdoaWxlIHRyeWluZyB0byBsb2FkIGZpbGUnLFxuICAgIDUwMjogJ0JhZCBnYXRld2F5IGVycm9yIG9jY3VycmVkIHdoaWxlIHRyeWluZyB0byBsb2FkIGZpbGUnLFxuICAgIDUwMzogJ1NlcnZpY2UgdW5hdmFpbGFibGUgZXJyb3Igb2NjdXJyZWQgd2hpbGUgdHJ5aW5nIHRvIGxvYWQgZmlsZScsXG4gICAgNTA0OiAnR2F0ZXdheSB0aW1lb3V0IGVycm9yIG9jY3VycmVkIHdoaWxlIHRyeWluZyB0byBsb2FkIGZpbGUnLFxufVxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHRvIGhhbmRsZSBmYXRhbCBlcnJvcnMgdGhhdCBvY2N1ciB3aGlsZSB0cnlpbmcgdG8gbG9hZCBhIGZpbGUgZnJvbSB0aGUgSHVnZ2luZyBGYWNlIEh1Yi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXMgVGhlIEhUVFAgc3RhdHVzIGNvZGUgb2YgdGhlIGVycm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVVSTCBUaGUgVVJMIG9mIHRoZSBmaWxlIHRoYXQgY291bGQgbm90IGJlIGxvYWRlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZmF0YWwgV2hldGhlciB0byByYWlzZSBhbiBlcnJvciBpZiB0aGUgZmlsZSBjb3VsZCBub3QgYmUgbG9hZGVkLlxuICogQHJldHVybnMge251bGx9IFJldHVybnMgYG51bGxgIGlmIGBmYXRhbCA9IHRydWVgLlxuICogQHRocm93cyB7RXJyb3J9IElmIGBmYXRhbCA9IGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRXJyb3Ioc3RhdHVzLCByZW1vdGVVUkwsIGZhdGFsKSB7XG4gICAgaWYgKCFmYXRhbCkge1xuICAgICAgICAvLyBGaWxlIHdhcyBub3QgbG9hZGVkIGNvcnJlY3RseSwgYnV0IGl0IGlzIG9wdGlvbmFsLlxuICAgICAgICAvLyBUT0RPIGluIGZ1dHVyZSwgY2FjaGUgdGhlIHJlc3BvbnNlP1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlID0gRVJST1JfTUFQUElOR1tzdGF0dXNdID8/IGBFcnJvciAoJHtzdGF0dXN9KSBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gbG9hZCBmaWxlYDtcbiAgICB0aHJvdyBFcnJvcihgJHttZXNzYWdlfTogXCIke3JlbW90ZVVSTH1cIi5gKTtcbn1cblxuY2xhc3MgRmlsZUNhY2hlIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIGBGaWxlQ2FjaGVgIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHJlcXVlc3QgaXMgaW4gdGhlIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0IFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbGVSZXNwb25zZSB8IHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgYXN5bmMgbWF0Y2gocmVxdWVzdCkge1xuXG4gICAgICAgIGxldCBmaWxlUGF0aCA9IHBhdGguam9pbih0aGlzLnBhdGgsIHJlcXVlc3QpO1xuICAgICAgICBsZXQgZmlsZSA9IG5ldyBGaWxlUmVzcG9uc2UoZmlsZVBhdGgpO1xuXG4gICAgICAgIGlmIChmaWxlLmV4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gcmVzcG9uc2UgdG8gdGhlIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0IFxuICAgICAqIEBwYXJhbSB7UmVzcG9uc2V8RmlsZVJlc3BvbnNlfSByZXNwb25zZSBcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBwdXQocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG5cbiAgICAgICAgbGV0IG91dHB1dFBhdGggPSBwYXRoLmpvaW4odGhpcy5wYXRoLCByZXF1ZXN0KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMubWtkaXIocGF0aC5kaXJuYW1lKG91dHB1dFBhdGgpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGF3YWl0IGZzLnByb21pc2VzLndyaXRlRmlsZShvdXRwdXRQYXRoLCBidWZmZXIpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSB3cml0aW5nIHRoZSBmaWxlIHRvIGNhY2hlOicsIGVycilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gYWRkIHRoZSByZXN0P1xuICAgIC8vIGFkZEFsbChyZXF1ZXN0czogUmVxdWVzdEluZm9bXSk6IFByb21pc2U8dm9pZD47XG4gICAgLy8gZGVsZXRlKHJlcXVlc3Q6IFJlcXVlc3RJbmZvIHwgVVJMLCBvcHRpb25zPzogQ2FjaGVRdWVyeU9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIC8vIGtleXMocmVxdWVzdD86IFJlcXVlc3RJbmZvIHwgVVJMLCBvcHRpb25zPzogQ2FjaGVRdWVyeU9wdGlvbnMpOiBQcm9taXNlPFJlYWRvbmx5QXJyYXk8UmVxdWVzdD4+O1xuICAgIC8vIG1hdGNoKHJlcXVlc3Q6IFJlcXVlc3RJbmZvIHwgVVJMLCBvcHRpb25zPzogQ2FjaGVRdWVyeU9wdGlvbnMpOiBQcm9taXNlPFJlc3BvbnNlIHwgdW5kZWZpbmVkPjtcbiAgICAvLyBtYXRjaEFsbChyZXF1ZXN0PzogUmVxdWVzdEluZm8gfCBVUkwsIG9wdGlvbnM/OiBDYWNoZVF1ZXJ5T3B0aW9ucyk6IFByb21pc2U8UmVhZG9ubHlBcnJheTxSZXNwb25zZT4+O1xufVxuXG4vKipcbiAqIFxuICogQHBhcmFtIHtGaWxlQ2FjaGV8Q2FjaGV9IGNhY2hlIFRoZSBjYWNoZSB0byBzZWFyY2hcbiAqIEBwYXJhbSB7c3RyaW5nW119IG5hbWVzIFRoZSBuYW1lcyBvZiB0aGUgaXRlbSB0byBzZWFyY2ggZm9yXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGaWxlUmVzcG9uc2V8UmVzcG9uc2V8dW5kZWZpbmVkPn0gVGhlIGl0ZW0gZnJvbSB0aGUgY2FjaGUsIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRyeUNhY2hlKGNhY2hlLCAuLi5uYW1lcykge1xuICAgIGZvciAobGV0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWNoZS5tYXRjaChuYW1lKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogXG4gKiBSZXRyaWV2ZXMgYSBmaWxlIGZyb20gZWl0aGVyIGEgcmVtb3RlIFVSTCB1c2luZyB0aGUgRmV0Y2ggQVBJIG9yIGZyb20gdGhlIGxvY2FsIGZpbGUgc3lzdGVtIHVzaW5nIHRoZSBGaWxlU3lzdGVtIEFQSS5cbiAqIElmIHRoZSBmaWxlc3lzdGVtIGlzIGF2YWlsYWJsZSBhbmQgYGVudi51c2VDYWNoZSA9IHRydWVgLCB0aGUgZmlsZSB3aWxsIGJlIGRvd25sb2FkZWQgYW5kIGNhY2hlZC5cbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhfb3JfcmVwb19pZCBUaGlzIGNhbiBiZSBlaXRoZXI6XG4gKiAtIGEgc3RyaW5nLCB0aGUgKm1vZGVsIGlkKiBvZiBhIG1vZGVsIHJlcG8gb24gaHVnZ2luZ2ZhY2UuY28uXG4gKiAtIGEgcGF0aCB0byBhICpkaXJlY3RvcnkqIHBvdGVudGlhbGx5IGNvbnRhaW5pbmcgdGhlIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gbG9jYXRlIGluIGBwYXRoX29yX3JlcG9gLlxuICogQHBhcmFtIHtib29sZWFufSBbZmF0YWw9dHJ1ZV0gV2hldGhlciB0byB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZmlsZSBpcyBub3QgZm91bmQuXG4gKiBAcGFyYW0ge1ByZXRyYWluZWRPcHRpb25zfSBbb3B0aW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9uYWwgcGFyYW1ldGVycy5cbiAqIFxuICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBmaWxlIGlzIG5vdCBmb3VuZCBhbmQgYGZhdGFsYCBpcyB0cnVlLlxuICogQHJldHVybnMge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGZpbGUgY29udGVudCBhcyBhIGJ1ZmZlci5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1vZGVsRmlsZShwYXRoX29yX3JlcG9faWQsIGZpbGVuYW1lLCBmYXRhbCA9IHRydWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKCFlbnYuYWxsb3dMb2NhbE1vZGVscykge1xuICAgICAgICAvLyBVc2VyIGhhcyBkaXNhYmxlZCBsb2NhbCBtb2RlbHMsIHNvIHdlIGp1c3QgbWFrZSBzdXJlIG90aGVyIHNldHRpbmdzIGFyZSBjb3JyZWN0LlxuXG4gICAgICAgIGlmIChvcHRpb25zLmxvY2FsX2ZpbGVzX29ubHkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIGRldGVjdGVkOiBsb2NhbCBtb2RlbHMgYXJlIGRpc2FibGVkIChgZW52LmFsbG93TG9jYWxNb2RlbHM9ZmFsc2VgKSBidXQgeW91IGhhdmUgcmVxdWVzdGVkIHRvIG9ubHkgdXNlIGxvY2FsIG1vZGVscyAoYGxvY2FsX2ZpbGVzX29ubHk9dHJ1ZWApLlwiKVxuICAgICAgICB9IGVsc2UgaWYgKCFlbnYuYWxsb3dSZW1vdGVNb2RlbHMpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIGRldGVjdGVkOiBib3RoIGxvY2FsIGFuZCByZW1vdGUgbW9kZWxzIGFyZSBkaXNhYmxlZC4gRml4IGJ5IHNldHRpbmcgYGVudi5hbGxvd0xvY2FsTW9kZWxzYCBvciBgZW52LmFsbG93UmVtb3RlTW9kZWxzYCB0byBgdHJ1ZWAuXCIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbml0aWF0ZSBmaWxlIHJldHJpZXZhbFxuICAgIGRpc3BhdGNoQ2FsbGJhY2sob3B0aW9ucy5wcm9ncmVzc19jYWxsYmFjaywge1xuICAgICAgICBzdGF0dXM6ICdpbml0aWF0ZScsXG4gICAgICAgIG5hbWU6IHBhdGhfb3JfcmVwb19pZCxcbiAgICAgICAgZmlsZTogZmlsZW5hbWVcbiAgICB9KVxuXG4gICAgLy8gRmlyc3QsIGNoZWNrIGlmIHRoZSBhIGNhY2hpbmcgYmFja2VuZCBpcyBhdmFpbGFibGVcbiAgICAvLyBJZiBubyBjYWNoaW5nIG1lY2hhbmlzbSBhdmFpbGFibGUsIHdpbGwgZG93bmxvYWQgdGhlIGZpbGUgZXZlcnkgdGltZVxuICAgIGxldCBjYWNoZTtcbiAgICBpZiAoIWNhY2hlICYmIGVudi51c2VCcm93c2VyQ2FjaGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWNoZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQnJvd3NlciBjYWNoZSBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQuJylcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcywgdGhlIGJyb3dzZXIgY2FjaGUgbWF5IGJlIHZpc2libGUsIGJ1dCBub3QgYWNjZXNzaWJsZSBkdWUgdG8gc2VjdXJpdHkgcmVzdHJpY3Rpb25zLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIHdoZW4gcnVubmluZyBhbiBhcHBsaWNhdGlvbiBpbiBhbiBpZnJhbWUsIGlmIGEgdXNlciBhdHRlbXB0cyB0byBsb2FkIHRoZSBwYWdlIGluXG4gICAgICAgICAgICAvLyBpbmNvZ25pdG8gbW9kZSwgdGhlIGZvbGxvd2luZyBlcnJvciBpcyB0aHJvd246IGBET01FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdvcGVuJyBvbiAnQ2FjaGVTdG9yYWdlJzpcbiAgICAgICAgICAgIC8vIEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gYnJlYWsgdGhyb3VnaCB0aGUgc2VjdXJpdHkgcG9saWN5IG9mIHRoZSB1c2VyIGFnZW50LmBcbiAgICAgICAgICAgIC8vIFNvLCBpbnN0ZWFkIG9mIGNyYXNoaW5nLCB3ZSBqdXN0IGlnbm9yZSB0aGUgZXJyb3IgYW5kIGNvbnRpbnVlIHdpdGhvdXQgdXNpbmcgdGhlIGNhY2hlLlxuICAgICAgICAgICAgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbigndHJhbnNmb3JtZXJzLWNhY2hlJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgb3BlbmluZyB0aGUgYnJvd3NlciBjYWNoZTonLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2FjaGUgJiYgZW52LnVzZUZTQ2FjaGUpIHtcbiAgICAgICAgLy8gVE9ETyB0aHJvdyBlcnJvciBpZiBub3QgYXZhaWxhYmxlXG5cbiAgICAgICAgLy8gSWYgYGNhY2hlX2RpcmAgaXMgbm90IHNwZWNpZmllZCwgdXNlIHRoZSBkZWZhdWx0IGNhY2hlIGRpcmVjdG9yeVxuICAgICAgICBjYWNoZSA9IG5ldyBGaWxlQ2FjaGUob3B0aW9ucy5jYWNoZV9kaXIgPz8gZW52LmNhY2hlRGlyKTtcbiAgICB9XG5cbiAgICBpZiAoIWNhY2hlICYmIGVudi51c2VDdXN0b21DYWNoZSkge1xuICAgICAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBzcGVjaWZ5IGEgY3VzdG9tIGNhY2hlIHN5c3RlbS5cbiAgICAgICAgaWYgKCFlbnYuY3VzdG9tQ2FjaGUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdgZW52LnVzZUN1c3RvbUNhY2hlPXRydWVgLCBidXQgYGVudi5jdXN0b21DYWNoZWAgaXMgbm90IGRlZmluZWQuJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHJlcXVpcmVkIG1ldGhvZHMgYXJlIGRlZmluZWQ6XG4gICAgICAgIGlmICghZW52LmN1c3RvbUNhY2hlLm1hdGNoIHx8ICFlbnYuY3VzdG9tQ2FjaGUucHV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJgZW52LmN1c3RvbUNhY2hlYCBtdXN0IGJlIGFuIG9iamVjdCB3aGljaCBpbXBsZW1lbnRzIHRoZSBgbWF0Y2hgIGFuZCBgcHV0YCBmdW5jdGlvbnMgb2YgdGhlIFdlYiBDYWNoZSBBUEkuIFwiICtcbiAgICAgICAgICAgICAgICBcIkZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhY2hlXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBjYWNoZSA9IGVudi5jdXN0b21DYWNoZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXZpc2lvbiA9IG9wdGlvbnMucmV2aXNpb24gPz8gJ21haW4nO1xuXG4gICAgbGV0IHJlcXVlc3RVUkwgPSBwYXRoSm9pbihwYXRoX29yX3JlcG9faWQsIGZpbGVuYW1lKTtcbiAgICBsZXQgbG9jYWxQYXRoID0gcGF0aEpvaW4oZW52LmxvY2FsTW9kZWxQYXRoLCByZXF1ZXN0VVJMKTtcblxuICAgIGxldCByZW1vdGVVUkwgPSBwYXRoSm9pbihcbiAgICAgICAgZW52LnJlbW90ZUhvc3QsXG4gICAgICAgIGVudi5yZW1vdGVQYXRoVGVtcGxhdGVcbiAgICAgICAgICAgIC5yZXBsYWNlQWxsKCd7bW9kZWx9JywgcGF0aF9vcl9yZXBvX2lkKVxuICAgICAgICAgICAgLnJlcGxhY2VBbGwoJ3tyZXZpc2lvbn0nLCByZXZpc2lvbiksXG4gICAgICAgIGZpbGVuYW1lXG4gICAgKTtcblxuICAgIC8vIENob29zZSBjYWNoZSBrZXkgZm9yIGZpbGVzeXN0ZW0gY2FjaGVcbiAgICAvLyBXaGVuIHVzaW5nIHRoZSBtYWluIHJldmlzaW9uIChkZWZhdWx0KSwgd2UgdXNlIHRoZSByZXF1ZXN0IFVSTCBhcyB0aGUgY2FjaGUga2V5LlxuICAgIC8vIElmIGEgc3BlY2lmaWMgcmV2aXNpb24gaXMgcmVxdWVzdGVkLCB3ZSBhY2NvdW50IGZvciB0aGlzIGluIHRoZSBjYWNoZSBrZXkuXG4gICAgbGV0IGZzQ2FjaGVLZXkgPSByZXZpc2lvbiA9PT0gJ21haW4nID8gcmVxdWVzdFVSTCA6IHBhdGhKb2luKHBhdGhfb3JfcmVwb19pZCwgcmV2aXNpb24sIGZpbGVuYW1lKTtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGxldCBjYWNoZUtleTtcbiAgICBsZXQgcHJvcG9zZWRDYWNoZUtleSA9IGNhY2hlIGluc3RhbmNlb2YgRmlsZUNhY2hlID8gZnNDYWNoZUtleSA6IHJlbW90ZVVSTDtcblxuICAgIC8qKiBAdHlwZSB7UmVzcG9uc2V8dW5kZWZpbmVkfSAqL1xuICAgIGxldCByZXNwb25zZVRvQ2FjaGU7XG5cbiAgICAvKiogQHR5cGUge1Jlc3BvbnNlfEZpbGVSZXNwb25zZXx1bmRlZmluZWR9ICovXG4gICAgbGV0IHJlc3BvbnNlO1xuXG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIC8vIEEgY2FjaGluZyBzeXN0ZW0gaXMgYXZhaWxhYmxlLCBzbyB3ZSB0cnkgdG8gZ2V0IHRoZSBmaWxlIGZyb20gaXQuXG4gICAgICAgIC8vICAxLiBXZSBmaXJzdCB0cnkgdG8gZ2V0IGZyb20gY2FjaGUgdXNpbmcgdGhlIGxvY2FsIHBhdGguIEluIHNvbWUgZW52aXJvbm1lbnRzIChsaWtlIGRlbm8pLFxuICAgICAgICAvLyAgICAgbm9uLVVSTCBjYWNoZSBrZXlzIGFyZSBub3QgYWxsb3dlZC4gSW4gdGhlc2UgY2FzZXMsIGByZXNwb25zZWAgd2lsbCBiZSB1bmRlZmluZWQuXG4gICAgICAgIC8vICAyLiBJZiBubyByZXNwb25zZSBpcyBmb3VuZCwgd2UgdHJ5IHRvIGdldCBmcm9tIGNhY2hlIHVzaW5nIHRoZSByZW1vdGUgVVJMIG9yIGZpbGUgc3lzdGVtIGNhY2hlLlxuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRyeUNhY2hlKGNhY2hlLCBsb2NhbFBhdGgsIHByb3Bvc2VkQ2FjaGVLZXkpO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIENhY2hpbmcgbm90IGF2YWlsYWJsZSwgb3IgZmlsZSBpcyBub3QgY2FjaGVkLCBzbyB3ZSBwZXJmb3JtIHRoZSByZXF1ZXN0XG5cbiAgICAgICAgaWYgKGVudi5hbGxvd0xvY2FsTW9kZWxzKSB7XG4gICAgICAgICAgICAvLyBBY2Nlc3NpbmcgbG9jYWwgbW9kZWxzIGlzIGVuYWJsZWQsIHNvIHdlIHRyeSB0byBnZXQgdGhlIGZpbGUgbG9jYWxseS5cbiAgICAgICAgICAgIC8vIElmIHJlcXVlc3QgaXMgYSB2YWxpZCBIVFRQIFVSTCwgd2Ugc2tpcCB0aGUgbG9jYWwgZmlsZSBjaGVjay4gT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gZ2V0IHRoZSBmaWxlIGxvY2FsbHkuXG4gICAgICAgICAgICBjb25zdCBpc1VSTCA9IGlzVmFsaWRIdHRwVXJsKHJlcXVlc3RVUkwpO1xuICAgICAgICAgICAgaWYgKCFpc1VSTCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZ2V0RmlsZShsb2NhbFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleSA9IGxvY2FsUGF0aDsgLy8gVXBkYXRlIHRoZSBjYWNoZSBrZXkgdG8gYmUgdGhlIGxvY2FsIHBhdGhcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIHRyeWluZyB0byBnZXQgdGhlIGZpbGUgbG9jYWxseS5cbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogZXJyb3IgaGFuZGxpbmcgaXMgZG9uZSBpbiB0aGUgbmV4dCBzdGVwIChzaW5jZSBgcmVzcG9uc2VgIHdpbGwgYmUgdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuYWJsZSB0byBsb2FkIGZyb20gbG9jYWwgcGF0aCBcIiR7bG9jYWxQYXRofVwiOiBcIiR7ZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5sb2NhbF9maWxlc19vbmx5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGBsb2NhbF9maWxlc19vbmx5PXRydWVcXGAsIGJ1dCBhdHRlbXB0ZWQgdG8gbG9hZCBhIHJlbW90ZSBmaWxlIGZyb206ICR7cmVxdWVzdFVSTH0uYCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFlbnYuYWxsb3dSZW1vdGVNb2RlbHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYGVudi5hbGxvd1JlbW90ZU1vZGVscz1mYWxzZVxcYCwgYnV0IGF0dGVtcHRlZCB0byBsb2FkIGEgcmVtb3RlIGZpbGUgZnJvbTogJHtyZXF1ZXN0VVJMfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAvLyBGaWxlIG5vdCBmb3VuZCBsb2NhbGx5LiBUaGlzIG1lYW5zIGVpdGhlcjpcbiAgICAgICAgICAgIC8vIC0gVGhlIHVzZXIgaGFzIGRpc2FibGVkIGxvY2FsIGZpbGUgYWNjZXNzIChgZW52LmFsbG93TG9jYWxNb2RlbHM9ZmFsc2VgKVxuICAgICAgICAgICAgLy8gLSB0aGUgcGF0aCBpcyBhIHZhbGlkIEhUVFAgdXJsIChgcmVzcG9uc2UgPT09IHVuZGVmaW5lZGApXG4gICAgICAgICAgICAvLyAtIHRoZSBwYXRoIGlzIG5vdCBhIHZhbGlkIEhUVFAgdXJsIGFuZCB0aGUgZmlsZSBpcyBub3QgcHJlc2VudCBvbiB0aGUgZmlsZSBzeXN0ZW0gb3IgbG9jYWwgc2VydmVyIChgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDRgKVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbF9maWxlc19vbmx5IHx8ICFlbnYuYWxsb3dSZW1vdGVNb2RlbHMpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIHJlcXVlc3RlZCBsb2NhbCBmaWxlcyBvbmx5LCBidXQgdGhlIGZpbGUgaXMgbm90IGZvdW5kIGxvY2FsbHkuXG4gICAgICAgICAgICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBcXGBsb2NhbF9maWxlc19vbmx5PXRydWVcXGAgb3IgXFxgZW52LmFsbG93UmVtb3RlTW9kZWxzPWZhbHNlXFxgIGFuZCBmaWxlIHdhcyBub3QgZm91bmQgbG9jYWxseSBhdCBcIiR7bG9jYWxQYXRofVwiLmApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbGUgbm90IGZvdW5kLCBidXQgdGhpcyBmaWxlIGlzIG9wdGlvbmFsLlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGluIGZ1dHVyZSwgY2FjaGUgdGhlIHJlc3BvbnNlP1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbGUgbm90IGZvdW5kIGxvY2FsbHksIHNvIHdlIHRyeSB0byBkb3dubG9hZCBpdCBmcm9tIHRoZSByZW1vdGUgc2VydmVyXG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGdldEZpbGUocmVtb3RlVVJMKTtcblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKHJlc3BvbnNlLnN0YXR1cywgcmVtb3RlVVJMLCBmYXRhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1Y2Nlc3MhIFdlIHVzZSB0aGUgcHJvcG9zZWQgY2FjaGUga2V5IGZyb20gZWFybGllclxuICAgICAgICAgICAgY2FjaGVLZXkgPSBwcm9wb3NlZENhY2hlS2V5O1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoY2FjaGUgJiYgcmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSAmJiByZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgLy8gb25seSBjbG9uZSBpZiBjYWNoZSBhdmFpbGFibGUsIGFuZCByZXNwb25zZSBpcyB2YWxpZFxuICAgICAgICAgICAgcmVzcG9uc2VUb0NhY2hlID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gU3RhcnQgZG93bmxvYWRpbmdcbiAgICBkaXNwYXRjaENhbGxiYWNrKG9wdGlvbnMucHJvZ3Jlc3NfY2FsbGJhY2ssIHtcbiAgICAgICAgc3RhdHVzOiAnZG93bmxvYWQnLFxuICAgICAgICBuYW1lOiBwYXRoX29yX3JlcG9faWQsXG4gICAgICAgIGZpbGU6IGZpbGVuYW1lXG4gICAgfSlcblxuICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlYWRSZXNwb25zZShyZXNwb25zZSwgZGF0YSA9PiB7XG4gICAgICAgIGRpc3BhdGNoQ2FsbGJhY2sob3B0aW9ucy5wcm9ncmVzc19jYWxsYmFjaywge1xuICAgICAgICAgICAgc3RhdHVzOiAncHJvZ3Jlc3MnLFxuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgIG5hbWU6IHBhdGhfb3JfcmVwb19pZCxcbiAgICAgICAgICAgIGZpbGU6IGZpbGVuYW1lXG4gICAgICAgIH0pXG4gICAgfSlcblxuXG4gICAgaWYgKFxuICAgICAgICAvLyBPbmx5IGNhY2hlIHdlYiByZXNwb25zZXNcbiAgICAgICAgLy8gaS5lLiwgZG8gbm90IGNhY2hlIEZpbGVSZXNwb25zZXMgKHByZXZlbnRzIGR1cGxpY2F0aW9uKVxuICAgICAgICByZXNwb25zZVRvQ2FjaGUgJiYgY2FjaGVLZXlcbiAgICAgICAgJiZcbiAgICAgICAgLy8gQ2hlY2sgYWdhaW4gd2hldGhlciByZXF1ZXN0IGlzIGluIGNhY2hlLiBJZiBub3QsIHdlIGFkZCB0aGUgcmVzcG9uc2UgdG8gdGhlIGNhY2hlXG4gICAgICAgIChhd2FpdCBjYWNoZS5tYXRjaChjYWNoZUtleSkgPT09IHVuZGVmaW5lZClcbiAgICApIHtcbiAgICAgICAgYXdhaXQgY2FjaGUucHV0KGNhY2hlS2V5LCByZXNwb25zZVRvQ2FjaGUpXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgY3Jhc2ggaWYgdW5hYmxlIHRvIGFkZCB0byBjYWNoZSAoZS5nLiwgUXVvdGFFeGNlZWRlZEVycm9yKS5cbiAgICAgICAgICAgICAgICAvLyBSYXRoZXIsIGxvZyBhIHdhcm5pbmcgYW5kIHByb2NlZWQgd2l0aCBleGVjdXRpb24uXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmFibGUgdG8gYWRkIHJlc3BvbnNlIHRvIGJyb3dzZXIgY2FjaGU6ICR7ZXJyfS5gKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgZGlzcGF0Y2hDYWxsYmFjayhvcHRpb25zLnByb2dyZXNzX2NhbGxiYWNrLCB7XG4gICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICBuYW1lOiBwYXRoX29yX3JlcG9faWQsXG4gICAgICAgIGZpbGU6IGZpbGVuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuXG4vKipcbiAqIEZldGNoZXMgYSBKU09OIGZpbGUgZnJvbSBhIGdpdmVuIHBhdGggYW5kIGZpbGUgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kZWxQYXRoIFRoZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkgY29udGFpbmluZyB0aGUgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlTmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBmZXRjaC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZhdGFsPXRydWVdIFdoZXRoZXIgdG8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGZpbGUgaXMgbm90IGZvdW5kLlxuICogQHBhcmFtIHtQcmV0cmFpbmVkT3B0aW9uc30gW29wdGlvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbmFsIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgSlNPTiBkYXRhIHBhcnNlZCBpbnRvIGEgSmF2YVNjcmlwdCBvYmplY3QuXG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGZpbGUgaXMgbm90IGZvdW5kIGFuZCBgZmF0YWxgIGlzIHRydWUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNb2RlbEpTT04obW9kZWxQYXRoLCBmaWxlTmFtZSwgZmF0YWwgPSB0cnVlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgYnVmZmVyID0gYXdhaXQgZ2V0TW9kZWxGaWxlKG1vZGVsUGF0aCwgZmlsZU5hbWUsIGZhdGFsLCBvcHRpb25zKTtcbiAgICBpZiAoYnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFJldHVybiBlbXB0eSBvYmplY3RcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgfVxuXG4gICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgbGV0IGpzb25EYXRhID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyKTtcblxuICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25EYXRhKTtcbn1cblxuLyoqXG4gKiBSZWFkIGFuZCB0cmFjayBwcm9ncmVzcyB3aGVuIHJlYWRpbmcgYSBSZXNwb25zZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmVzcG9uc2UgVGhlIFJlc3BvbnNlIG9iamVjdCB0byByZWFkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9ncmVzc19jYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIHByb2dyZXNzIHVwZGF0ZXNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFVpbnQ4QXJyYXk+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBVaW50OEFycmF5IGJ1ZmZlclxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkUmVzcG9uc2UocmVzcG9uc2UsIHByb2dyZXNzX2NhbGxiYWNrKSB7XG4gICAgLy8gUmVhZCBhbmQgdHJhY2sgcHJvZ3Jlc3Mgd2hlbiByZWFkaW5nIGEgUmVzcG9uc2Ugb2JqZWN0XG5cbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gZGV0ZXJtaW5lIGNvbnRlbnQtbGVuZ3RoIGZyb20gcmVzcG9uc2UgaGVhZGVycy4gV2lsbCBleHBhbmQgYnVmZmVyIHdoZW4gbmVlZGVkLicpXG4gICAgfVxuICAgIGxldCB0b3RhbCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGggPz8gJzAnKTtcbiAgICBsZXQgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodG90YWwpO1xuICAgIGxldCBsb2FkZWQgPSAwO1xuXG4gICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICBhc3luYyBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuXG4gICAgICAgIGxldCBuZXdMb2FkZWQgPSBsb2FkZWQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChuZXdMb2FkZWQgPiB0b3RhbCkge1xuICAgICAgICAgICAgdG90YWwgPSBuZXdMb2FkZWQ7XG5cbiAgICAgICAgICAgIC8vIEFkZGluZyB0aGUgbmV3IGRhdGEgd2lsbCBvdmVyZmxvdyBidWZmZXIuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGV4dGVuZCB0aGUgYnVmZmVyXG4gICAgICAgICAgICBsZXQgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodG90YWwpO1xuXG4gICAgICAgICAgICAvLyBjb3B5IGNvbnRlbnRzXG4gICAgICAgICAgICBuZXdCdWZmZXIuc2V0KGJ1ZmZlcik7XG5cbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ld0J1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIuc2V0KHZhbHVlLCBsb2FkZWQpXG4gICAgICAgIGxvYWRlZCA9IG5ld0xvYWRlZDtcblxuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IChsb2FkZWQgLyB0b3RhbCkgKiAxMDA7XG5cbiAgICAgICAgLy8gQ2FsbCB5b3VyIGZ1bmN0aW9uIGhlcmVcbiAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2soe1xuICAgICAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzLFxuICAgICAgICAgICAgbG9hZGVkOiBsb2FkZWQsXG4gICAgICAgICAgICB0b3RhbDogdG90YWwsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIHJlYWQoKTtcbiAgICB9XG5cbiAgICAvLyBBY3R1YWxseSByZWFkXG4gICAgYXdhaXQgcmVhZCgpO1xuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBKb2lucyBtdWx0aXBsZSBwYXJ0cyBvZiBhIHBhdGggaW50byBhIHNpbmdsZSBwYXRoLCB3aGlsZSBoYW5kbGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwYXJ0cyBNdWx0aXBsZSBwYXJ0cyBvZiBhIHBhdGguXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGpvaW5lZCBwYXRoLlxuICovXG5mdW5jdGlvbiBwYXRoSm9pbiguLi5wYXJ0cykge1xuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NTE0MjU2NVxuICAgIHBhcnRzID0gcGFydHMubWFwKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXi8nKSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPT0gcGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcGFydCA9IHBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCcvJCcpLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgfSlcbiAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xufVxuIiwiXG4vKipcbiAqIEBmaWxlIEhlbHBlciBtb2R1bGUgZm9yIGltYWdlIHByb2Nlc3NpbmcuIFxuICogXG4gKiBUaGVzZSBmdW5jdGlvbnMgYW5kIGNsYXNzZXMgYXJlIG9ubHkgdXNlZCBpbnRlcm5hbGx5LCBcbiAqIG1lYW5pbmcgYW4gZW5kLXVzZXIgc2hvdWxkbid0IG5lZWQgdG8gYWNjZXNzIGFueXRoaW5nIGhlcmUuXG4gKiBcbiAqIEBtb2R1bGUgdXRpbHMvaW1hZ2VcbiAqL1xuXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICcuL2NvcmUuanMnO1xuaW1wb3J0IHsgZ2V0RmlsZSB9IGZyb20gJy4vaHViLmpzJztcbmltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudi5qcyc7XG5cbi8vIFdpbGwgYmUgZW1wdHkgKG9yIG5vdCB1c2VkKSBpZiBydW5uaW5nIGluIGJyb3dzZXIgb3Igd2ViLXdvcmtlclxuaW1wb3J0IHNoYXJwIGZyb20gJ3NoYXJwJztcblxuY29uc3QgQlJPV1NFUl9FTlYgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCc7XG5cbmxldCBjcmVhdGVDYW52YXNGdW5jdGlvbjtcbmxldCBJbWFnZURhdGFDbGFzcztcbmxldCBsb2FkSW1hZ2VGdW5jdGlvbjtcbmlmIChCUk9XU0VSX0VOVikge1xuICAgIC8vIFJ1bm5pbmcgaW4gYnJvd3NlciBvciB3ZWItd29ya2VyXG4gICAgY3JlYXRlQ2FudmFzRnVuY3Rpb24gPSAoLyoqIEB0eXBlIHtudW1iZXJ9ICovIHdpZHRoLCAvKiogQHR5cGUge251bWJlcn0gKi8gaGVpZ2h0KSA9PiB7XG4gICAgICAgIGlmICghc2VsZi5PZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2Zmc2NyZWVuQ2FudmFzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgc2VsZi5PZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodClcbiAgICB9O1xuICAgIGxvYWRJbWFnZUZ1bmN0aW9uID0gc2VsZi5jcmVhdGVJbWFnZUJpdG1hcDtcbiAgICBJbWFnZURhdGFDbGFzcyA9IHNlbGYuSW1hZ2VEYXRhO1xuXG59IGVsc2UgaWYgKHNoYXJwKSB7XG4gICAgLy8gUnVubmluZyBpbiBOb2RlLmpzLCBlbGVjdHJvbiwgb3Igb3RoZXIgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcblxuICAgIGxvYWRJbWFnZUZ1bmN0aW9uID0gYXN5bmMgKC8qKkB0eXBlIHtzaGFycC5TaGFycH0qL2ltZykgPT4ge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGltZy5tZXRhZGF0YSgpO1xuICAgICAgICBjb25zdCByYXdDaGFubmVscyA9IG1ldGFkYXRhLmNoYW5uZWxzO1xuXG4gICAgICAgIGxldCB7IGRhdGEsIGluZm8gfSA9IGF3YWl0IGltZy5yYXcoKS50b0J1ZmZlcih7IHJlc29sdmVXaXRoT2JqZWN0OiB0cnVlIH0pO1xuXG4gICAgICAgIGNvbnN0IG5ld0ltYWdlID0gbmV3IFJhd0ltYWdlKG5ldyBVaW50OENsYW1wZWRBcnJheShkYXRhKSwgaW5mby53aWR0aCwgaW5mby5oZWlnaHQsIGluZm8uY2hhbm5lbHMpO1xuICAgICAgICBpZiAocmF3Q2hhbm5lbHMgIT09IHVuZGVmaW5lZCAmJiByYXdDaGFubmVscyAhPT0gaW5mby5jaGFubmVscykge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBuZXcgaW1hZ2UgaGFzIHRoZSBzYW1lIG51bWJlciBvZiBjaGFubmVscyBhcyB0aGUgaW5wdXQgaW1hZ2UuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgZ3JheXNjYWxlIGltYWdlcy5cbiAgICAgICAgICAgIG5ld0ltYWdlLmNvbnZlcnQocmF3Q2hhbm5lbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdJbWFnZTtcbiAgICB9XG5cbn0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gbG9hZCBpbWFnZSBwcm9jZXNzaW5nIGxpYnJhcnkuJyk7XG59XG5cblxuLy8gRGVmaW5lZCBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHl0aG9uLXBpbGxvdy9QaWxsb3cvYmxvYi9hNDA1ZTg0MDZiODNmOGJmYjg5MTZlOTM5NzFlZGM3NDA3YjhiMWZmL3NyYy9saWJJbWFnaW5nL0ltYWdpbmcuaCNMMjYyLUwyNjhcbmNvbnN0IFJFU0FNUExJTkdfTUFQUElORyA9IHtcbiAgICAwOiAnbmVhcmVzdCcsXG4gICAgMTogJ2xhbmN6b3MnLFxuICAgIDI6ICdiaWxpbmVhcicsXG4gICAgMzogJ2JpY3ViaWMnLFxuICAgIDQ6ICdib3gnLFxuICAgIDU6ICdoYW1taW5nJyxcbn1cblxuZXhwb3J0IGNsYXNzIFJhd0ltYWdlIHtcblxuICAgIC8qKlxuICAgICAqIE1hcHBpbmcgZnJvbSBmaWxlIGV4dGVuc2lvbnMgdG8gTUlNRSB0eXBlcy5cbiAgICAgKi9cbiAgICBfQ09OVEVOVF9UWVBFX01BUCA9IHtcbiAgICAgICAgJ3BuZyc6ICdpbWFnZS9wbmcnLFxuICAgICAgICAnanBnJzogJ2ltYWdlL2pwZWcnLFxuICAgICAgICAnanBlZyc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgJ2dpZic6ICdpbWFnZS9naWYnLFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBgUmF3SW1hZ2VgIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1VpbnQ4Q2xhbXBlZEFycmF5fSBkYXRhIFRoZSBwaXhlbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGltYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW1hZ2UuXG4gICAgICogQHBhcmFtIHsxfDJ8M3w0fSBjaGFubmVscyBUaGUgbnVtYmVyIG9mIGNoYW5uZWxzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIHdpZHRoLCBoZWlnaHQsIGNoYW5uZWxzKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCBmb3IgcmVhZGluZyBhbiBpbWFnZSBmcm9tIGEgdmFyaWV0eSBvZiBpbnB1dCB0eXBlcy5cbiAgICAgKiBAcGFyYW0ge1Jhd0ltYWdlfHN0cmluZ3xVUkx9IGlucHV0IFxuICAgICAqIEByZXR1cm5zIFRoZSBpbWFnZSBvYmplY3QuXG4gICAgICogXG4gICAgICogKipFeGFtcGxlOioqIFJlYWQgaW1hZ2UgZnJvbSBhIFVSTC5cbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogbGV0IGltYWdlID0gYXdhaXQgUmF3SW1hZ2UucmVhZCgnaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9kYXRhc2V0cy9YZW5vdmEvdHJhbnNmb3JtZXJzLmpzLWRvY3MvcmVzb2x2ZS9tYWluL2Zvb3RiYWxsLW1hdGNoLmpwZycpO1xuICAgICAqIC8vIHRlc3Qge1xuICAgICAqIC8vICAgXCJkYXRhXCI6IFVpbnQ4Q2xhbXBlZEFycmF5IFsgMjUsIDI1LCAyNSwgMTksIDE5LCAxOSwgLi4uIF0sXG4gICAgICogLy8gICBcIndpZHRoXCI6IDgwMCxcbiAgICAgKiAvLyAgIFwiaGVpZ2h0XCI6IDUzMyxcbiAgICAgKiAvLyAgIFwiY2hhbm5lbHNcIjogM1xuICAgICAqIC8vIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgcmVhZChpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSYXdJbWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGlucHV0KSB8fCBpbnB1dCBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZnJvbVVSTChpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGlucHV0IHR5cGU6ICR7dHlwZW9mIGlucHV0fWApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGFuIGltYWdlIGZyb20gYSBVUkwgb3IgZmlsZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gdXJsIFRoZSBVUkwgb3IgZmlsZSBwYXRoIHRvIHJlYWQgdGhlIGltYWdlIGZyb20uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmF3SW1hZ2U+fSBUaGUgaW1hZ2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tVVJMKHVybCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBnZXRGaWxlKHVybCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVhZCBpbWFnZSBmcm9tIFwiJHt1cmx9XCIgKCR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9KWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tQmxvYihibG9iKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBJbWFnZSBmcm9tIGEgYmxvYi5cbiAgICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2IgVGhlIGJsb2IgdG8gcmVhZCB0aGUgaW1hZ2UgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSYXdJbWFnZT59IFRoZSBpbWFnZSBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21CbG9iKGJsb2IpIHtcbiAgICAgICAgaWYgKEJST1dTRVJfRU5WKSB7XG4gICAgICAgICAgICAvLyBSdW5uaW5nIGluIGVudmlyb25tZW50IHdpdGggY2FudmFzXG4gICAgICAgICAgICBsZXQgaW1nID0gYXdhaXQgbG9hZEltYWdlRnVuY3Rpb24oYmxvYik7XG5cbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNyZWF0ZUNhbnZhc0Z1bmN0aW9uKGltZy53aWR0aCwgaW1nLmhlaWdodCkuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgLy8gRHJhdyBpbWFnZSB0byBjb250ZXh0XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcyhjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGltZy53aWR0aCwgaW1nLmhlaWdodCkuZGF0YSwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCA0KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVXNlIHNoYXJwLmpzIHRvIHJlYWQgKGFuZCBwb3NzaWJsZSByZXNpemUpIHRoZSBpbWFnZS5cbiAgICAgICAgICAgIGxldCBpbWcgPSBzaGFycChhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgbG9hZEltYWdlRnVuY3Rpb24oaW1nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGltYWdlIHRvIGdyYXlzY2FsZSBmb3JtYXQuXG4gICAgICogQHJldHVybnMge1Jhd0ltYWdlfSBgdGhpc2AgdG8gc3VwcG9ydCBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBncmF5c2NhbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWxzID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuZXdEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIDEpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGNhc2UgMzogLy8gcmdiIHRvIGdyYXlzY2FsZVxuICAgICAgICAgICAgY2FzZSA0OiAvLyByZ2JhIHRvIGdyYXlzY2FsZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSArPSB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZCA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3JlZW4gPSB0aGlzLmRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibHVlID0gdGhpcy5kYXRhW2kgKyAyXTtcblxuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IE1hdGgucm91bmQoMC4yOTg5ICogcmVkICsgMC41ODcwICogZ3JlZW4gKyAwLjExNDAgKiBibHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udmVyc2lvbiBmYWlsZWQgZHVlIHRvIHVuc3VwcG9ydGVkIG51bWJlciBvZiBjaGFubmVsczogJHt0aGlzLmNoYW5uZWxzfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUobmV3RGF0YSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGltYWdlIHRvIFJHQiBmb3JtYXQuXG4gICAgICogQHJldHVybnMge1Jhd0ltYWdlfSBgdGhpc2AgdG8gc3VwcG9ydCBjaGFpbmluZy5cbiAgICAgKi9cbiAgICByZ2IoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWxzID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuZXdEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIDMpO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBncmF5c2NhbGUgdG8gcmdiXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IC8vIHJnYmEgdG8gcmdiXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gdGhpcy5kYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSB0aGlzLmRhdGFbaSArIDJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJzaW9uIGZhaWxlZCBkdWUgdG8gdW5zdXBwb3J0ZWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke3RoaXMuY2hhbm5lbHN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZShuZXdEYXRhLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMyk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBpbWFnZSB0byBSR0JBIGZvcm1hdC5cbiAgICAgKiBAcmV0dXJucyB7UmF3SW1hZ2V9IGB0aGlzYCB0byBzdXBwb3J0IGNoYWluaW5nLlxuICAgICAqL1xuICAgIHJnYmEoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWxzID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuZXdEYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCAqIDQpO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5jaGFubmVscykge1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBncmF5c2NhbGUgdG8gcmdiYVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmZzZXQgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gdGhpcy5kYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gMjU1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzogLy8gcmdiIHRvIHJnYmFcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtvZmZzZXQrK10gPSB0aGlzLmRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW29mZnNldCsrXSA9IHRoaXMuZGF0YVtpICsgMl07XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGFbb2Zmc2V0KytdID0gMjU1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJzaW9uIGZhaWxlZCBkdWUgdG8gdW5zdXBwb3J0ZWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke3RoaXMuY2hhbm5lbHN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlKG5ld0RhdGEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdGhlIGltYWdlIHRvIHRoZSBnaXZlbiBkaW1lbnNpb25zLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjYW52YXMgQVBJIHRvIHBlcmZvcm0gdGhlIHJlc2l6aW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIG5ldyBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIG5ldyBpbWFnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHJlc2l6aW5nLlxuICAgICAqIEBwYXJhbSB7MHwxfDJ8M3w0fDV8c3RyaW5nfSBbb3B0aW9ucy5yZXNhbXBsZV0gVGhlIHJlc2FtcGxpbmcgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSYXdJbWFnZT59IGB0aGlzYCB0byBzdXBwb3J0IGNoYWluaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCB7XG4gICAgICAgIHJlc2FtcGxlID0gMixcbiAgICB9ID0ge30pIHtcblxuICAgICAgICAvLyBFbnN1cmUgcmVzYW1wbGUgbWV0aG9kIGlzIGEgc3RyaW5nXG4gICAgICAgIGxldCByZXNhbXBsZU1ldGhvZCA9IFJFU0FNUExJTkdfTUFQUElOR1tyZXNhbXBsZV0gPz8gcmVzYW1wbGU7XG5cbiAgICAgICAgaWYgKEJST1dTRVJfRU5WKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHVzZSBgcmVzYW1wbGVgIGluIGJyb3dzZXIgZW52aXJvbm1lbnRcblxuICAgICAgICAgICAgLy8gU3RvcmUgbnVtYmVyIG9mIGNoYW5uZWxzIGJlZm9yZSByZXNpemluZ1xuICAgICAgICAgICAgbGV0IG51bUNoYW5uZWxzID0gdGhpcy5jaGFubmVscztcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGNhbnZhcyBvYmplY3QgZm9yIHRoaXMgaW1hZ2VcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnRvQ2FudmFzKCk7XG5cbiAgICAgICAgICAgIC8vIEFjdHVhbGx5IHBlcmZvcm0gcmVzaXppbmcgdXNpbmcgdGhlIGNhbnZhcyBBUElcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNyZWF0ZUNhbnZhc0Z1bmN0aW9uKHdpZHRoLCBoZWlnaHQpLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgaW1hZ2UgdG8gY29udGV4dCwgcmVzaXppbmcgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGltYWdlIGZyb20gdGhlIHJlc2l6ZWQgZGF0YVxuICAgICAgICAgICAgbGV0IHJlc2l6ZWRJbWFnZSA9IG5ldyBSYXdJbWFnZShjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGEsIHdpZHRoLCBoZWlnaHQsIDQpO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGJhY2sgc28gdGhhdCBpbWFnZSBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYW5uZWxzIGFzIGJlZm9yZVxuICAgICAgICAgICAgcmV0dXJuIHJlc2l6ZWRJbWFnZS5jb252ZXJ0KG51bUNoYW5uZWxzKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHNoYXJwIGltYWdlIGZyb20gcmF3IGRhdGEsIGFuZCByZXNpemVcbiAgICAgICAgICAgIGxldCBpbWcgPSB0aGlzLnRvU2hhcnAoKTtcblxuICAgICAgICAgICAgc3dpdGNoIChyZXNhbXBsZU1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JveCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaGFtbWluZyc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNhbXBsZU1ldGhvZCA9PT0gJ2JveCcgfHwgcmVzYW1wbGVNZXRob2QgPT09ICdoYW1taW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBSZXNhbXBsaW5nIG1ldGhvZCAke3Jlc2FtcGxlTWV0aG9kfSBpcyBub3QgeWV0IHN1cHBvcnRlZC4gVXNpbmcgYmlsaW5lYXIgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2FtcGxlTWV0aG9kID0gJ2JpbGluZWFyJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FzZSAnbmVhcmVzdCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnYmlsaW5lYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2JpY3ViaWMnOlxuICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIHJlc2l6aW5nIHVzaW5nIGFmZmluZSB0cmFuc2Zvcm0uIFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1hdGNoZXMgaG93IHRoZSBweXRob24gUGlsbG93IGxpYnJhcnkgZG9lcyBpdC5cbiAgICAgICAgICAgICAgICAgICAgaW1nID0gaW1nLmFmZmluZShbd2lkdGggLyB0aGlzLndpZHRoLCAwLCAwLCBoZWlnaHQgLyB0aGlzLmhlaWdodF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRvcjogcmVzYW1wbGVNZXRob2RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbGFuY3pvcyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9weXRob24tcGlsbG93L1BpbGxvdy9kaXNjdXNzaW9ucy81NTE5XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sb3ZlbGwvc2hhcnAvYmxvYi9tYWluL2RvY3MvYXBpLXJlc2l6ZS5tZFxuICAgICAgICAgICAgICAgICAgICBpbWcgPSBpbWcucmVzaXplKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXQ6ICdmaWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlcm5lbDogJ2xhbmN6b3MzJywgLy8gUElMIExhbmN6b3MgdXNlcyBhIGtlcm5lbCBzaXplIG9mIDMgXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzYW1wbGluZyBtZXRob2QgJHtyZXNhbXBsZU1ldGhvZH0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGxvYWRJbWFnZUZ1bmN0aW9uKGltZyk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGFzeW5jIHBhZChbbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tXSkge1xuICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgMCk7XG4gICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIDApO1xuICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIDApO1xuICAgICAgICBib3R0b20gPSBNYXRoLm1heChib3R0b20sIDApO1xuXG4gICAgICAgIGlmIChsZWZ0ID09PSAwICYmIHJpZ2h0ID09PSAwICYmIHRvcCA9PT0gMCAmJiBib3R0b20gPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vIHBhZGRpbmcgbmVlZGVkXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChCUk9XU0VSX0VOVikge1xuICAgICAgICAgICAgLy8gU3RvcmUgbnVtYmVyIG9mIGNoYW5uZWxzIGJlZm9yZSBwYWRkaW5nXG4gICAgICAgICAgICBsZXQgbnVtQ2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgY2FudmFzIG9iamVjdCBmb3IgdGhpcyBpbWFnZVxuICAgICAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMudG9DYW52YXMoKTtcblxuICAgICAgICAgICAgbGV0IG5ld1dpZHRoID0gdGhpcy53aWR0aCArIGxlZnQgKyByaWdodDtcbiAgICAgICAgICAgIGxldCBuZXdIZWlnaHQgPSB0aGlzLmhlaWdodCArIHRvcCArIGJvdHRvbTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNhbnZhcyBvZiB0aGUgZGVzaXJlZCBzaXplLlxuICAgICAgICAgICAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzRnVuY3Rpb24obmV3V2lkdGgsIG5ld0hlaWdodCkuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgLy8gRHJhdyBpbWFnZSB0byBjb250ZXh0LCBwYWRkaW5nIGluIHRoZSBwcm9jZXNzXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGNhbnZhcyxcbiAgICAgICAgICAgICAgICAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICBsZWZ0LCB0b3AsIG5ld1dpZHRoLCBuZXdIZWlnaHRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBpbWFnZSBmcm9tIHRoZSBwYWRkZWQgZGF0YVxuICAgICAgICAgICAgbGV0IHBhZGRlZEltYWdlID0gbmV3IFJhd0ltYWdlKFxuICAgICAgICAgICAgICAgIGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCkuZGF0YSxcbiAgICAgICAgICAgICAgICBuZXdXaWR0aCwgbmV3SGVpZ2h0LCA0KTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBiYWNrIHNvIHRoYXQgaW1hZ2UgaGFzIHRoZSBzYW1lIG51bWJlciBvZiBjaGFubmVscyBhcyBiZWZvcmVcbiAgICAgICAgICAgIHJldHVybiBwYWRkZWRJbWFnZS5jb252ZXJ0KG51bUNoYW5uZWxzKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGltZyA9IHRoaXMudG9TaGFycCgpLmV4dGVuZCh7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9KTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBsb2FkSW1hZ2VGdW5jdGlvbihpbWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgY2VudGVyX2Nyb3AoY3JvcF93aWR0aCwgY3JvcF9oZWlnaHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGltYWdlIGlzIGFscmVhZHkgdGhlIGRlc2lyZWQgc2l6ZSwgcmV0dXJuIGl0XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSBjcm9wX3dpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBjcm9wX2hlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgYm91bmRzIG9mIHRoZSBpbWFnZSBpbiB0aGUgbmV3IGNhbnZhc1xuICAgICAgICBsZXQgd2lkdGhfb2Zmc2V0ID0gKHRoaXMud2lkdGggLSBjcm9wX3dpZHRoKSAvIDI7XG4gICAgICAgIGxldCBoZWlnaHRfb2Zmc2V0ID0gKHRoaXMuaGVpZ2h0IC0gY3JvcF9oZWlnaHQpIC8gMjtcblxuXG4gICAgICAgIGlmIChCUk9XU0VSX0VOVikge1xuICAgICAgICAgICAgLy8gU3RvcmUgbnVtYmVyIG9mIGNoYW5uZWxzIGJlZm9yZSByZXNpemluZ1xuICAgICAgICAgICAgbGV0IG51bUNoYW5uZWxzID0gdGhpcy5jaGFubmVscztcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGNhbnZhcyBvYmplY3QgZm9yIHRoaXMgaW1hZ2VcbiAgICAgICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnRvQ2FudmFzKCk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjYW52YXMgb2YgdGhlIGRlc2lyZWQgc2l6ZS4gVGhpcyBpcyBuZWVkZWQgc2luY2UgaWYgdGhlIFxuICAgICAgICAgICAgLy8gaW1hZ2UgaXMgdG9vIHNtYWxsLCB3ZSBuZWVkIHRvIHBhZCBpdCB3aXRoIGJsYWNrIHBpeGVscy5cbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNyZWF0ZUNhbnZhc0Z1bmN0aW9uKGNyb3Bfd2lkdGgsIGNyb3BfaGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICBsZXQgc291cmNlWCA9IDA7XG4gICAgICAgICAgICBsZXQgc291cmNlWSA9IDA7XG4gICAgICAgICAgICBsZXQgZGVzdFggPSAwO1xuICAgICAgICAgICAgbGV0IGRlc3RZID0gMDtcblxuICAgICAgICAgICAgaWYgKHdpZHRoX29mZnNldCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc291cmNlWCA9IHdpZHRoX29mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdFggPSAtd2lkdGhfb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGVpZ2h0X29mZnNldCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc291cmNlWSA9IGhlaWdodF9vZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc3RZID0gLWhlaWdodF9vZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERyYXcgaW1hZ2UgdG8gY29udGV4dCwgY3JvcHBpbmcgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoY2FudmFzLFxuICAgICAgICAgICAgICAgIHNvdXJjZVgsIHNvdXJjZVksIGNyb3Bfd2lkdGgsIGNyb3BfaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGRlc3RYLCBkZXN0WSwgY3JvcF93aWR0aCwgY3JvcF9oZWlnaHRcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBpbWFnZSBmcm9tIHRoZSByZXNpemVkIGRhdGFcbiAgICAgICAgICAgIGxldCByZXNpemVkSW1hZ2UgPSBuZXcgUmF3SW1hZ2UoY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjcm9wX3dpZHRoLCBjcm9wX2hlaWdodCkuZGF0YSwgY3JvcF93aWR0aCwgY3JvcF9oZWlnaHQsIDQpO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGJhY2sgc28gdGhhdCBpbWFnZSBoYXMgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYW5uZWxzIGFzIGJlZm9yZVxuICAgICAgICAgICAgcmV0dXJuIHJlc2l6ZWRJbWFnZS5jb252ZXJ0KG51bUNoYW5uZWxzKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHNoYXJwIGltYWdlIGZyb20gcmF3IGRhdGFcbiAgICAgICAgICAgIGxldCBpbWcgPSB0aGlzLnRvU2hhcnAoKTtcblxuICAgICAgICAgICAgaWYgKHdpZHRoX29mZnNldCA+PSAwICYmIGhlaWdodF9vZmZzZXQgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIENyb3BwZWQgaW1hZ2UgbGllcyBlbnRpcmVseSB3aXRoaW4gdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgICAgICAgICAgICAgaW1nID0gaW1nLmV4dHJhY3Qoe1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBNYXRoLmZsb29yKHdpZHRoX29mZnNldCksXG4gICAgICAgICAgICAgICAgICAgIHRvcDogTWF0aC5mbG9vcihoZWlnaHRfb2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNyb3Bfd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY3JvcF9oZWlnaHQsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGhfb2Zmc2V0IDw9IDAgJiYgaGVpZ2h0X29mZnNldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JvcHBlZCBpbWFnZSBsaWVzIGVudGlyZWx5IG91dHNpZGUgdGhlIG9yaWdpbmFsIGltYWdlLFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGFkZCBwYWRkaW5nXG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IE1hdGguZmxvb3IoLWhlaWdodF9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gTWF0aC5mbG9vcigtd2lkdGhfb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpbWcgPSBpbWcuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlcyB0aGUgcmVzdWx0aW5nIGltYWdlIGhhcyB0aGUgZGVzaXJlZCBkaW1lbnNpb25zXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjcm9wX3dpZHRoIC0gdGhpcy53aWR0aCAtIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogY3JvcF9oZWlnaHQgLSB0aGlzLmhlaWdodCAtIHRvcCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JvcHBlZCBpbWFnZSBsaWVzIHBhcnRpYWxseSBvdXRzaWRlIHRoZSBvcmlnaW5hbCBpbWFnZS5cbiAgICAgICAgICAgICAgICAvLyBXZSBmaXJzdCBwYWQsIHRoZW4gY3JvcC5cblxuICAgICAgICAgICAgICAgIGxldCB5X3BhZGRpbmcgPSBbMCwgMF07XG4gICAgICAgICAgICAgICAgbGV0IHlfZXh0cmFjdCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhlaWdodF9vZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHlfcGFkZGluZ1swXSA9IE1hdGguZmxvb3IoLWhlaWdodF9vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB5X3BhZGRpbmdbMV0gPSBjcm9wX2hlaWdodCAtIHRoaXMuaGVpZ2h0IC0geV9wYWRkaW5nWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHlfZXh0cmFjdCA9IE1hdGguZmxvb3IoaGVpZ2h0X29mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHhfcGFkZGluZyA9IFswLCAwXTtcbiAgICAgICAgICAgICAgICBsZXQgeF9leHRyYWN0ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGhfb2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB4X3BhZGRpbmdbMF0gPSBNYXRoLmZsb29yKC13aWR0aF9vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB4X3BhZGRpbmdbMV0gPSBjcm9wX3dpZHRoIC0gdGhpcy53aWR0aCAtIHhfcGFkZGluZ1swXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4X2V4dHJhY3QgPSBNYXRoLmZsb29yKHdpZHRoX29mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW1nID0gaW1nLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogeV9wYWRkaW5nWzBdLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHlfcGFkZGluZ1sxXSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogeF9wYWRkaW5nWzBdLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogeF9wYWRkaW5nWzFdLFxuICAgICAgICAgICAgICAgIH0pLmV4dHJhY3Qoe1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB4X2V4dHJhY3QsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogeV9leHRyYWN0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY3JvcF93aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjcm9wX2hlaWdodCxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgbG9hZEltYWdlRnVuY3Rpb24oaW1nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvQ2FudmFzKCkge1xuICAgICAgICBpZiAoIUJST1dTRVJfRU5WKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvQ2FudmFzKCkgaXMgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlciBlbnZpcm9ubWVudHMuJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsb25lLCBhbmQgY29udmVydCBkYXRhIHRvIFJHQkEgYmVmb3JlIGRyYXdpbmcgdG8gY2FudmFzLlxuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlIGNhbnZhcyBBUEkgb25seSBzdXBwb3J0cyBSR0JBXG4gICAgICAgIGxldCBjbG9uZWQgPSB0aGlzLmNsb25lKCkucmdiYSgpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBjYW52YXMgb2JqZWN0IGZvciB0aGUgY2xvbmVkIGltYWdlXG4gICAgICAgIGxldCBjbG9uZWRDYW52YXMgPSBjcmVhdGVDYW52YXNGdW5jdGlvbihjbG9uZWQud2lkdGgsIGNsb25lZC5oZWlnaHQpO1xuXG4gICAgICAgIC8vIERyYXcgaW1hZ2UgdG8gY29udGV4dFxuICAgICAgICBsZXQgZGF0YSA9IG5ldyBJbWFnZURhdGFDbGFzcyhjbG9uZWQuZGF0YSwgY2xvbmVkLndpZHRoLCBjbG9uZWQuaGVpZ2h0KTtcbiAgICAgICAgY2xvbmVkQ2FudmFzLmdldENvbnRleHQoJzJkJykucHV0SW1hZ2VEYXRhKGRhdGEsIDAsIDApO1xuXG4gICAgICAgIHJldHVybiBjbG9uZWRDYW52YXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byB1cGRhdGUgdGhlIGltYWdlIGRhdGEuXG4gICAgICogQHBhcmFtIHtVaW50OENsYW1wZWRBcnJheX0gZGF0YSBUaGUgbmV3IGltYWdlIGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSBuZXcgd2lkdGggb2YgdGhlIGltYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIGltYWdlLlxuICAgICAqIEBwYXJhbSB7MXwyfDN8NH0gY2hhbm5lbHMgVGhlIG5ldyBudW1iZXIgb2YgY2hhbm5lbHMgb2YgdGhlIGltYWdlLlxuICAgICAqL1xuICAgIF91cGRhdGUoZGF0YSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGlmIChjaGFubmVscyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscyA9IGNoYW5uZWxzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lIHRoZSBpbWFnZVxuICAgICAqIEByZXR1cm5zIHtSYXdJbWFnZX0gVGhlIGNsb25lZCBpbWFnZVxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhd0ltYWdlKHRoaXMuZGF0YS5zbGljZSgpLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5jaGFubmVscyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCBmb3IgY29udmVydGluZyBpbWFnZSB0byBoYXZlIGEgY2VydGFpbiBudW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtQ2hhbm5lbHMgVGhlIG51bWJlciBvZiBjaGFubmVscy4gTXVzdCBiZSAxLCAzLCBvciA0LlxuICAgICAqIEByZXR1cm5zIHtSYXdJbWFnZX0gYHRoaXNgIHRvIHN1cHBvcnQgY2hhaW5pbmcuXG4gICAgICovXG4gICAgY29udmVydChudW1DaGFubmVscykge1xuICAgICAgICBpZiAodGhpcy5jaGFubmVscyA9PT0gbnVtQ2hhbm5lbHMpIHJldHVybiB0aGlzOyAvLyBBbHJlYWR5IGNvcnJlY3QgbnVtYmVyIG9mIGNoYW5uZWxzXG5cbiAgICAgICAgc3dpdGNoIChudW1DaGFubmVscykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRoaXMuZ3JheXNjYWxlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGhpcy5yZ2IoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLnJnYmEoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJzaW9uIGZhaWxlZCBkdWUgdG8gdW5zdXBwb3J0ZWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke3RoaXMuY2hhbm5lbHN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZSB0aGUgaW1hZ2UgdG8gdGhlIGdpdmVuIHBhdGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gc2F2ZSB0aGUgaW1hZ2UgdG8uXG4gICAgICovXG4gICAgc2F2ZShwYXRoKSB7XG5cbiAgICAgICAgaWYgKEJST1dTRVJfRU5WKSB7XG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBwYXRoLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IG1pbWUgPSB0aGlzLl9DT05URU5UX1RZUEVfTUFQW2V4dGVuc2lvbl0gPz8gJ2ltYWdlL3BuZyc7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgaW1hZ2UgdG8gY2FudmFzXG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLnRvQ2FudmFzKCk7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGNhbnZhcyBjb250ZW50IHRvIGEgZGF0YSBVUkxcbiAgICAgICAgICAgIGNvbnN0IGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKG1pbWUpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gYW5jaG9yIGVsZW1lbnQgd2l0aCB0aGUgZGF0YSBVUkwgYXMgdGhlIGhyZWYgYXR0cmlidXRlXG4gICAgICAgICAgICBjb25zdCBkb3dubG9hZExpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICBkb3dubG9hZExpbmsuaHJlZiA9IGRhdGFVUkw7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgZG93bmxvYWQgYXR0cmlidXRlIHRvIHNwZWNpZnkgdGhlIGRlc2lyZWQgZmlsZW5hbWUgZm9yIHRoZSBkb3dubG9hZGVkIGltYWdlXG4gICAgICAgICAgICBkb3dubG9hZExpbmsuZG93bmxvYWQgPSBwYXRoO1xuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBkb3dubG9hZFxuICAgICAgICAgICAgZG93bmxvYWRMaW5rLmNsaWNrKCk7XG5cbiAgICAgICAgICAgIC8vIENsZWFuIHVwOiByZW1vdmUgdGhlIGFuY2hvciBlbGVtZW50IGZyb20gdGhlIERPTVxuICAgICAgICAgICAgZG93bmxvYWRMaW5rLnJlbW92ZSgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIWVudi51c2VGUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2F2ZSB0aGUgaW1hZ2UgYmVjYXVzZSBmaWxlc3lzdGVtIGlzIGRpc2FibGVkIGluIHRoaXMgZW52aXJvbm1lbnQuJylcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW1nID0gdGhpcy50b1NoYXJwKCk7XG4gICAgICAgICAgICBpbWcudG9GaWxlKHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TaGFycCgpIHtcbiAgICAgICAgaWYgKEJST1dTRVJfRU5WKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvU2hhcnAoKSBpcyBvbmx5IHN1cHBvcnRlZCBpbiBzZXJ2ZXItc2lkZSBlbnZpcm9ubWVudHMuJylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaGFycCh0aGlzLmRhdGEsIHtcbiAgICAgICAgICAgIHJhdzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgY2hhbm5lbHM6IHRoaXMuY2hhbm5lbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiXG4vKipcbiAqIEBmaWxlIEhlbHBlciBtb2R1bGUgZm9yIG1hdGhlbWF0aWNhbCBwcm9jZXNzaW5nLiBcbiAqIFxuICogVGhlc2UgZnVuY3Rpb25zIGFuZCBjbGFzc2VzIGFyZSBvbmx5IHVzZWQgaW50ZXJuYWxseSwgXG4gKiBtZWFuaW5nIGFuIGVuZC11c2VyIHNob3VsZG4ndCBuZWVkIHRvIGFjY2VzcyBhbnl0aGluZyBoZXJlLlxuICogXG4gKiBAbW9kdWxlIHV0aWxzL21hdGhzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7SW50OEFycmF5IHwgVWludDhBcnJheSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgSW50MTZBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MzJBcnJheSB8IFVpbnQzMkFycmF5IHwgRmxvYXQzMkFycmF5IHwgRmxvYXQ2NEFycmF5fSBUeXBlZEFycmF5XG4gKiBAdHlwZWRlZiB7QmlnSW50NjRBcnJheSB8IEJpZ1VpbnQ2NEFycmF5fSBCaWdUeXBlZEFycmF5XG4gKiBAdHlwZWRlZiB7VHlwZWRBcnJheSB8IEJpZ1R5cGVkQXJyYXl9IEFueVR5cGVkQXJyYXlcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7VHlwZWRBcnJheX0gaW5wdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVycG9sYXRlX2RhdGEoaW5wdXQsIFtpbl9jaGFubmVscywgaW5faGVpZ2h0LCBpbl93aWR0aF0sIFtvdXRfaGVpZ2h0LCBvdXRfd2lkdGhdLCBtb2RlID0gJ2JpbGluZWFyJywgYWxpZ25fY29ybmVycyA9IGZhbHNlKSB7XG4gICAgLy8gVE9ETyB1c2UgbW9kZSBhbmQgYWxpZ25fY29ybmVyc1xuXG4gICAgLy8gT3V0cHV0IGltYWdlIGRpbWVuc2lvbnNcbiAgICBjb25zdCB4X3NjYWxlID0gb3V0X3dpZHRoIC8gaW5fd2lkdGg7XG4gICAgY29uc3QgeV9zY2FsZSA9IG91dF9oZWlnaHQgLyBpbl9oZWlnaHQ7XG5cbiAgICAvLyBPdXRwdXQgaW1hZ2VcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgb3V0X2ltZyA9IG5ldyBpbnB1dC5jb25zdHJ1Y3RvcihvdXRfaGVpZ2h0ICogb3V0X3dpZHRoICogaW5fY2hhbm5lbHMpO1xuXG4gICAgLy8gUHJlLWNhbGN1bGF0ZSBzdHJpZGVzXG4gICAgY29uc3QgaW5TdHJpZGUgPSBpbl9oZWlnaHQgKiBpbl93aWR0aDtcbiAgICBjb25zdCBvdXRTdHJpZGUgPSBvdXRfaGVpZ2h0ICogb3V0X3dpZHRoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRfaGVpZ2h0OyArK2kpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvdXRfd2lkdGg7ICsraikge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG91dHB1dCBvZmZzZXRcbiAgICAgICAgICAgIGNvbnN0IG91dE9mZnNldCA9IGkgKiBvdXRfd2lkdGggKyBqO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgaW5wdXQgcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIGNvbnN0IHggPSAoaiArIDAuNSkgLyB4X3NjYWxlIC0gMC41O1xuICAgICAgICAgICAgY29uc3QgeSA9IChpICsgMC41KSAvIHlfc2NhbGUgLSAwLjU7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZm91ciBuZWFyZXN0IGlucHV0IHBpeGVsc1xuICAgICAgICAgICAgLy8gV2UgYWxzbyBjaGVjayBpZiB0aGUgaW5wdXQgcGl4ZWwgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGUgaW1hZ2UgYm91bmRzXG4gICAgICAgICAgICBsZXQgeDEgPSBNYXRoLmZsb29yKHgpO1xuICAgICAgICAgICAgbGV0IHkxID0gTWF0aC5mbG9vcih5KTtcbiAgICAgICAgICAgIGNvbnN0IHgyID0gTWF0aC5taW4oeDEgKyAxLCBpbl93aWR0aCAtIDEpO1xuICAgICAgICAgICAgY29uc3QgeTIgPSBNYXRoLm1pbih5MSArIDEsIGluX2hlaWdodCAtIDEpO1xuXG4gICAgICAgICAgICB4MSA9IE1hdGgubWF4KHgxLCAwKTtcbiAgICAgICAgICAgIHkxID0gTWF0aC5tYXgoeTEsIDApO1xuXG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZnJhY3Rpb25hbCBkaXN0YW5jZXMgYmV0d2VlbiB0aGUgaW5wdXQgcGl4ZWwgYW5kIHRoZSBmb3VyIG5lYXJlc3QgcGl4ZWxzXG4gICAgICAgICAgICBjb25zdCBzID0geCAtIHgxO1xuICAgICAgICAgICAgY29uc3QgdCA9IHkgLSB5MTtcblxuICAgICAgICAgICAgLy8gUGVyZm9ybSBiaWxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICBjb25zdCB3MSA9ICgxIC0gcykgKiAoMSAtIHQpO1xuICAgICAgICAgICAgY29uc3QgdzIgPSBzICogKDEgLSB0KTtcbiAgICAgICAgICAgIGNvbnN0IHczID0gKDEgLSBzKSAqIHQ7XG4gICAgICAgICAgICBjb25zdCB3NCA9IHMgKiB0O1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGZvdXIgbmVhcmVzdCBpbnB1dCBwaXhlbCBpbmRpY2VzXG4gICAgICAgICAgICBjb25zdCB5U3RyaWRlID0geTEgKiBpbl93aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHhTdHJpZGUgPSB5MiAqIGluX3dpZHRoO1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9IHlTdHJpZGUgKyB4MTtcbiAgICAgICAgICAgIGNvbnN0IGlkeDIgPSB5U3RyaWRlICsgeDI7XG4gICAgICAgICAgICBjb25zdCBpZHgzID0geFN0cmlkZSArIHgxO1xuICAgICAgICAgICAgY29uc3QgaWR4NCA9IHhTdHJpZGUgKyB4MjtcblxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbl9jaGFubmVsczsgKytrKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNoYW5uZWwgb2Zmc2V0XG4gICAgICAgICAgICAgICAgY29uc3QgY09mZnNldCA9IGsgKiBpblN0cmlkZTtcblxuICAgICAgICAgICAgICAgIG91dF9pbWdbayAqIG91dFN0cmlkZSArIG91dE9mZnNldF0gPVxuICAgICAgICAgICAgICAgICAgICB3MSAqIGlucHV0W2NPZmZzZXQgKyBpZHgxXSArXG4gICAgICAgICAgICAgICAgICAgIHcyICogaW5wdXRbY09mZnNldCArIGlkeDJdICtcbiAgICAgICAgICAgICAgICAgICAgdzMgKiBpbnB1dFtjT2Zmc2V0ICsgaWR4M10gK1xuICAgICAgICAgICAgICAgICAgICB3NCAqIGlucHV0W2NPZmZzZXQgKyBpZHg0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRfaW1nO1xufVxuXG5cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byB0cmFuc3Bvc2UgYSBgQW55VHlwZWRBcnJheWAgZGlyZWN0bHlcbiAqIEBwYXJhbSB7VH0gYXJyYXkgXG4gKiBAdGVtcGxhdGUge0FueVR5cGVkQXJyYXl9IFQgXG4gKiBAcGFyYW0ge251bWJlcltdfSBkaW1zIFxuICogQHBhcmFtIHtudW1iZXJbXX0gYXhlcyBcbiAqIEByZXR1cm5zIHtbVCwgbnVtYmVyW11dfSBUaGUgdHJhbnNwb3NlZCBhcnJheSBhbmQgdGhlIG5ldyBzaGFwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZV9kYXRhKGFycmF5LCBkaW1zLCBheGVzKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgc2hhcGUgb2YgdGhlIHRyYW5zcG9zZWQgYXJyYXlcbiAgICAvLyBhbmQgdGhlIHN0cmlkZSBvZiB0aGUgb3JpZ2luYWwgYXJyYXlcbiAgICBjb25zdCBzaGFwZSA9IG5ldyBBcnJheShheGVzLmxlbmd0aCk7XG4gICAgY29uc3Qgc3RyaWRlID0gbmV3IEFycmF5KGF4ZXMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSBheGVzLmxlbmd0aCAtIDEsIHMgPSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBzdHJpZGVbaV0gPSBzO1xuICAgICAgICBzaGFwZVtpXSA9IGRpbXNbYXhlc1tpXV07XG4gICAgICAgIHMgKj0gc2hhcGVbaV07XG4gICAgfVxuXG4gICAgLy8gUHJlY29tcHV0ZSBpbnZlcnNlIG1hcHBpbmcgb2Ygc3RyaWRlXG4gICAgY29uc3QgaW52U3RyaWRlID0gYXhlcy5tYXAoKF8sIGkpID0+IHN0cmlkZVtheGVzLmluZGV4T2YoaSldKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgdHJhbnNwb3NlZCBhcnJheSB3aXRoIHRoZSBuZXcgc2hhcGVcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgdHJhbnNwb3NlZERhdGEgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IoYXJyYXkubGVuZ3RoKTtcblxuICAgIC8vIFRyYW5zcG9zZSB0aGUgb3JpZ2luYWwgYXJyYXkgdG8gdGhlIG5ldyBhcnJheVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbGV0IG5ld0luZGV4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaiA9IGRpbXMubGVuZ3RoIC0gMSwgayA9IGk7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICBuZXdJbmRleCArPSAoayAlIGRpbXNbal0pICogaW52U3RyaWRlW2pdO1xuICAgICAgICAgICAgayA9IE1hdGguZmxvb3IoayAvIGRpbXNbal0pO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zcG9zZWREYXRhW25ld0luZGV4XSA9IGFycmF5W2ldO1xuICAgIH1cblxuICAgIHJldHVybiBbdHJhbnNwb3NlZERhdGEsIHNoYXBlXTtcbn1cblxuXG4vKipcbiAqIENvbXB1dGUgdGhlIHNvZnRtYXggb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnIgVGhlIGFycmF5IG9mIG51bWJlcnMgdG8gY29tcHV0ZSB0aGUgc29mdG1heCBvZi5cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gVGhlIHNvZnRtYXggYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb2Z0bWF4KGFycikge1xuICAgIC8vIENvbXB1dGUgdGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIGFycmF5XG4gICAgY29uc3QgbWF4VmFsID0gbWF4KGFycilbMF07XG5cbiAgICAvLyBDb21wdXRlIHRoZSBleHBvbmVudGlhbHMgb2YgdGhlIGFycmF5IHZhbHVlc1xuICAgIGNvbnN0IGV4cHMgPSBhcnIubWFwKHggPT4gTWF0aC5leHAoeCAtIG1heFZhbCkpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgc3VtIG9mIHRoZSBleHBvbmVudGlhbHNcbiAgICBjb25zdCBzdW1FeHBzID0gZXhwcy5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwsIDApO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgc29mdG1heCB2YWx1ZXNcbiAgICBjb25zdCBzb2Z0bWF4QXJyID0gZXhwcy5tYXAoeCA9PiB4IC8gc3VtRXhwcyk7XG5cbiAgICByZXR1cm4gc29mdG1heEFycjtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsb2dhcml0aG0gb2YgdGhlIHNvZnRtYXggZnVuY3Rpb24gZm9yIHRoZSBpbnB1dCBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGFyciBUaGUgaW5wdXQgYXJyYXkgdG8gY2FsY3VsYXRlIHRoZSBsb2dfc29mdG1heCBmdW5jdGlvbiBmb3IuXG4gKiBAcmV0dXJucyB7YW55fSBUaGUgcmVzdWx0aW5nIGxvZ19zb2Z0bWF4IGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9nX3NvZnRtYXgoYXJyKSB7XG4gICAgLy8gQ29tcHV0ZSB0aGUgc29mdG1heCB2YWx1ZXNcbiAgICBjb25zdCBzb2Z0bWF4QXJyID0gc29mdG1heChhcnIpO1xuXG4gICAgLy8gQXBwbHkgbG9nIGZvcm11bGEgdG8gZWFjaCBlbGVtZW50XG4gICAgY29uc3QgbG9nU29mdG1heEFyciA9IHNvZnRtYXhBcnIubWFwKHggPT4gTWF0aC5sb2coeCkpO1xuXG4gICAgcmV0dXJuIGxvZ1NvZnRtYXhBcnI7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIGFycmF5cy5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGFycjEgVGhlIGZpcnN0IGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyMiBUaGUgc2Vjb25kIGFycmF5LlxuICogQHJldHVybnMge251bWJlcn0gVGhlIGRvdCBwcm9kdWN0IG9mIGFycjEgYW5kIGFycjIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYXJyMSwgYXJyMikge1xuICAgIHJldHVybiBhcnIxLnJlZHVjZSgoYWNjLCB2YWwsIGkpID0+IGFjYyArIHZhbCAqIGFycjJbaV0sIDApO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSB0b3AgayBpdGVtcyBmcm9tIGFuIGl0ZXJhYmxlLCBzb3J0ZWQgYnkgZGVzY2VuZGluZyBvcmRlclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIFRoZSBpdGVtcyB0byBiZSBzb3J0ZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdG9wX2s9MF0gVGhlIG51bWJlciBvZiB0b3AgaXRlbXMgdG8gcmV0dXJuIChkZWZhdWx0OiAwID0gcmV0dXJuIGFsbClcbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHRvcCBrIGl0ZW1zLCBzb3J0ZWQgYnkgZGVzY2VuZGluZyBvcmRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wSXRlbXMoaXRlbXMsIHRvcF9rID0gMCkge1xuICAgIC8vIGlmIHRvcCA9PSAwLCByZXR1cm4gYWxsXG5cbiAgICBpdGVtcyA9IEFycmF5LmZyb20oaXRlbXMpXG4gICAgICAgIC5tYXAoKHgsIGkpID0+IFtpLCB4XSkgICAgICAgICAgICAvLyBHZXQgaW5kaWNlcyAoW2luZGV4LCBzY29yZV0pXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSkgICAgICAvLyBTb3J0IGJ5IGxvZyBwcm9iYWJpbGl0aWVzXG5cbiAgICBpZiAodG9wX2sgPiAwKSB7XG4gICAgICAgIGl0ZW1zID0gaXRlbXMuc2xpY2UoMCwgdG9wX2spOyAgICAvLyBHZXQgdG9wIGsgaXRlbXNcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXNcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY29zaW5lIHNpbWlsYXJpdHkgYmV0d2VlbiB0d28gYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IGFycjEgVGhlIGZpcnN0IGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyMiBUaGUgc2Vjb25kIGFycmF5LlxuICogQHJldHVybnMge251bWJlcn0gVGhlIGNvc2luZSBzaW1pbGFyaXR5IGJldHdlZW4gdGhlIHR3byBhcnJheXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3Nfc2ltKGFycjEsIGFycjIpIHtcbiAgICAvLyBDYWxjdWxhdGUgZG90IHByb2R1Y3Qgb2YgdGhlIHR3byBhcnJheXNcbiAgICBjb25zdCBkb3RQcm9kdWN0ID0gZG90KGFycjEsIGFycjIpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGZpcnN0IGFycmF5XG4gICAgY29uc3QgbWFnbml0dWRlQSA9IG1hZ25pdHVkZShhcnIxKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWFnbml0dWRlIG9mIHRoZSBzZWNvbmQgYXJyYXlcbiAgICBjb25zdCBtYWduaXR1ZGVCID0gbWFnbml0dWRlKGFycjIpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBjb3NpbmUgc2ltaWxhcml0eVxuICAgIGNvbnN0IGNvc2luZVNpbWlsYXJpdHkgPSBkb3RQcm9kdWN0IC8gKG1hZ25pdHVkZUEgKiBtYWduaXR1ZGVCKTtcblxuICAgIHJldHVybiBjb3NpbmVTaW1pbGFyaXR5O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG1hZ25pdHVkZSBvZiBhIGdpdmVuIGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyIFRoZSBhcnJheSB0byBjYWxjdWxhdGUgdGhlIG1hZ25pdHVkZSBvZi5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBtYWduaXR1ZGUgb2YgdGhlIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFnbml0dWRlKGFycikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoYXJyLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCAqIHZhbCwgMCkpO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgYW5kIGluZGV4IG9mIHRoZSBtaW5pbXVtIGVsZW1lbnQgaW4gYW4gYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcltdfSBhcnIgYXJyYXkgb2YgbnVtYmVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gdGhlIHZhbHVlIGFuZCBpbmRleCBvZiB0aGUgbWluaW11bSBlbGVtZW50LCBvZiB0aGUgZm9ybTogW3ZhbHVlT2ZNaW4sIGluZGV4T2ZNaW5dXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYXJyYXkgaXMgZW1wdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaW4oYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHRocm93IEVycm9yKCdBcnJheSBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgIGxldCBtaW4gPSBhcnJbMF07XG4gICAgbGV0IGluZGV4T2ZNaW4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPCBtaW4pIHtcbiAgICAgICAgICAgIG1pbiA9IGFycltpXTtcbiAgICAgICAgICAgIGluZGV4T2ZNaW4gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWluLCBpbmRleE9mTWluXTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIGFuZCBpbmRleCBvZiB0aGUgbWF4aW11bSBlbGVtZW50IGluIGFuIGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyIGFycmF5IG9mIG51bWJlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IHRoZSB2YWx1ZSBhbmQgaW5kZXggb2YgdGhlIG1heGltdW0gZWxlbWVudCwgb2YgdGhlIGZvcm06IFt2YWx1ZU9mTWF4LCBpbmRleE9mTWF4XVxuICogQHRocm93cyB7RXJyb3J9IElmIGFycmF5IGlzIGVtcHR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4KGFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB0aHJvdyBFcnJvcignQXJyYXkgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgICBsZXQgbWF4ID0gYXJyWzBdO1xuICAgIGxldCBpbmRleE9mTWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYXJyW2ldID4gbWF4KSB7XG4gICAgICAgICAgICBtYXggPSBhcnJbaV07XG4gICAgICAgICAgICBpbmRleE9mTWF4ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21heCwgaW5kZXhPZk1heF07XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBEaXNjcmV0ZSBGb3VyaWVyIFRyYW5zZm9ybSBzYW1wbGUgZnJlcXVlbmNpZXMuXG4gKiBcbiAqIENvZGUgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9udW1weS9udW1weS9ibG9iLzI1OTA4Y2FjZDE5OTE1YmYzZGRkNjU5YzI4YmUyOGE0MWJkOTdhNTQvbnVtcHkvZmZ0L2hlbHBlci5weSNMMTczLUwyMjFcbiAqIE9yaWdpbmFsIFB5dGhvbiBkb2M6IGh0dHBzOi8vbnVtcHkub3JnL2RvYy9zdGFibGUvcmVmZXJlbmNlL2dlbmVyYXRlZC9udW1weS5mZnQucmZmdGZyZXEuaHRtbFxuICogQGV4YW1wbGVcbiAqIHJmZnRmcmVxKDQwMCwgMSAvIDE2MDAwKSAvLyAoMjAxKcKgWzAsIDQwLCA4MCwgMTIwLCAxNjAsIDIwMCwgLi4uLCA4MDAwXVxuICogQHBhcmFtIHtudW1iZXJ9IG4gV2luZG93IGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IFtkID0gMS4wXSBTYW1wbGUgc3BhY2luZyAoaW52ZXJzZSBvZiB0aGUgc2FtcGxpbmcgcmF0ZSkuIERlZmF1bHRzIHRvIDEuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIG4gaXMgbm90IGFuIGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IEFycmF5IG9mIGxlbmd0aCBgTWF0aC5mbG9vcihuIC8gMikgKyAxO2AgY29udGFpbmluZyB0aGUgc2FtcGxlIGZyZXF1ZW5jaWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmZmdGZyZXEobiwgZCA9IDEuMCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBuIHNob3VsZCBiZSBhbiBpbnRlZ2VyLCBidXQgJHtufSBnaXZlbi5gKTtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gMS4wIC8gKG4gKiBkKTtcbiAgICBjb25zdCBsZW4gPSBNYXRoLmZsb29yKG4gLyAyKSArIDE7XG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcmVzdWx0c1tpXSA9IGkgKiB2YWw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG4vKipcbiAqIEZGVCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBwZXJmb3JtaW5nIEZhc3QgRm91cmllciBUcmFuc2Zvcm0gb24gYXJyYXlzXG4gKiBDb2RlIGFkYXB0ZWQgZnJvbSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9mZnQuanNcbiAqL1xuZXhwb3J0IGNsYXNzIEZGVCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgVGhlIHNpemUgb2YgdGhlIGlucHV0IGFycmF5LiBNdXN0IGJlIGEgcG93ZXIgb2YgdHdvIGFuZCBiaWdnZXIgdGhhbiAxLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBGRlQgc2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvIGFuZCBiaWdnZXIgdGhhbiAxLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZSB8IDA7IC8vIGNvbnZlcnQgdG8gYSAzMi1iaXQgc2lnbmVkIGludGVnZXJcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA8PSAxIHx8ICh0aGlzLnNpemUgJiAodGhpcy5zaXplIC0gMSkpICE9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGRlQgc2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvIGFuZCBiaWdnZXIgdGhhbiAxJyk7XG5cbiAgICAgICAgdGhpcy5fY3NpemUgPSBzaXplIDw8IDE7XG5cbiAgICAgICAgdGhpcy50YWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5zaXplICogMik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50YWJsZS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLlBJICogaSAvIHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMudGFibGVbaV0gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICB0aGlzLnRhYmxlW2kgKyAxXSA9IC1NYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHNpemUncyBwb3dlciBvZiB0d29cbiAgICAgICAgbGV0IHBvd2VyID0gMDtcbiAgICAgICAgZm9yIChsZXQgdCA9IDE7IHRoaXMuc2l6ZSA+IHQ7IHQgPDw9IDEpXG4gICAgICAgICAgICArK3Bvd2VyO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBpbml0aWFsIHN0ZXAncyB3aWR0aDpcbiAgICAgICAgLy8gICAqIElmIHdlIGFyZSBmdWxsIHJhZGl4LTQsIGl0IGlzIDJ4IHNtYWxsZXIgdG8gZ2l2ZSBpbml0YWwgbGVuPThcbiAgICAgICAgLy8gICAqIE90aGVyd2lzZSBpdCBpcyB0aGUgc2FtZSBhcyBgcG93ZXJgIHRvIGdpdmUgbGVuPTRcbiAgICAgICAgdGhpcy5fd2lkdGggPSBwb3dlciAlIDIgPT09IDAgPyBwb3dlciAtIDEgOiBwb3dlcjtcblxuICAgICAgICAvLyBQcmUtY29tcHV0ZSBiaXQtcmV2ZXJzYWwgcGF0dGVybnNcbiAgICAgICAgdGhpcy5fYml0cmV2ID0gbmV3IEludDMyQXJyYXkoMSA8PCB0aGlzLl93aWR0aCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fYml0cmV2Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB0aGlzLl9iaXRyZXZbal0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgc2hpZnQgPSAwOyBzaGlmdCA8IHRoaXMuX3dpZHRoOyBzaGlmdCArPSAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV2U2hpZnQgPSB0aGlzLl93aWR0aCAtIHNoaWZ0IC0gMjtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaXRyZXZbal0gfD0gKChqID4+PiBzaGlmdCkgJiAzKSA8PCByZXZTaGlmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbXBsZXggbnVtYmVyIGFycmF5IHdpdGggc2l6ZSBgMiAqIHNpemVgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fSBBIGNvbXBsZXggbnVtYmVyIGFycmF5IHdpdGggc2l6ZSBgMiAqIHNpemVgXG4gICAgICovXG4gICAgY3JlYXRlQ29tcGxleEFycmF5KCkge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9jc2l6ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBjb21wbGV4IG51bWJlciByZXByZXNlbnRhdGlvbiBzdG9yZWQgaW4gYSBGbG9hdDMyQXJyYXkgdG8gYW4gYXJyYXkgb2YgcmVhbCBudW1iZXJzLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBjb21wbGV4IFRoZSBjb21wbGV4IG51bWJlciByZXByZXNlbnRhdGlvbiB0byBiZSBjb252ZXJ0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gW3N0b3JhZ2VdIEFuIG9wdGlvbmFsIGFycmF5IHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBBbiBhcnJheSBvZiByZWFsIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBjb21wbGV4IG51bWJlciByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBmcm9tQ29tcGxleEFycmF5KGNvbXBsZXgsIHN0b3JhZ2UpIHtcbiAgICAgICAgY29uc3QgcmVzID0gc3RvcmFnZSB8fCBuZXcgQXJyYXkoY29tcGxleC5sZW5ndGggPj4+IDEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBsZXgubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICByZXNbaSA+Pj4gMV0gPSBjb21wbGV4W2ldO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSByZWFsLXZhbHVlZCBpbnB1dCBhcnJheSB0byBhIGNvbXBsZXgtdmFsdWVkIG91dHB1dCBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gaW5wdXQgVGhlIHJlYWwtdmFsdWVkIGlucHV0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBbc3RvcmFnZV0gT3B0aW9uYWwgYnVmZmVyIHRvIHN0b3JlIHRoZSBvdXRwdXQgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gVGhlIGNvbXBsZXgtdmFsdWVkIG91dHB1dCBhcnJheS5cbiAgICAgKi9cbiAgICB0b0NvbXBsZXhBcnJheShpbnB1dCwgc3RvcmFnZSkge1xuICAgICAgICBjb25zdCByZXMgPSBzdG9yYWdlIHx8IHRoaXMuY3JlYXRlQ29tcGxleEFycmF5KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBpbnB1dFtpID4+PiAxXTtcbiAgICAgICAgICAgIHJlc1tpICsgMV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGxldGVzIHRoZSBzcGVjdHJ1bSBieSBhZGRpbmcgaXRzIG1pcnJvcmVkIG5lZ2F0aXZlIGZyZXF1ZW5jeSBjb21wb25lbnRzLlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBzcGVjdHJ1bSBUaGUgaW5wdXQgc3BlY3RydW0uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgY29tcGxldGVTcGVjdHJ1bShzcGVjdHJ1bSkge1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5fY3NpemU7XG4gICAgICAgIGNvbnN0IGhhbGYgPSBzaXplID4+PiAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGhhbGY7IGkgKz0gMikge1xuICAgICAgICAgICAgc3BlY3RydW1bc2l6ZSAtIGldID0gc3BlY3RydW1baV07XG4gICAgICAgICAgICBzcGVjdHJ1bVtzaXplIC0gaSArIDFdID0gLXNwZWN0cnVtW2kgKyAxXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgRmFzdCBGb3VyaWVyIFRyYW5zZm9ybSAoRkZUKSBvbiB0aGUgZ2l2ZW4gaW5wdXQgZGF0YSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIG91dHB1dCBidWZmZXIuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG91dCBUaGUgb3V0cHV0IGJ1ZmZlciB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBkYXRhIFRoZSBpbnB1dCBkYXRhIHRvIHRyYW5zZm9ybS5cbiAgICAgKiBcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50LlxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHRyYW5zZm9ybShvdXQsIGRhdGEpIHtcbiAgICAgICAgaWYgKG91dCA9PT0gZGF0YSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Jyk7XG5cbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtNChvdXQsIGRhdGEsIDEgLyogRE9ORSAqLyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSByZWFsLXZhbHVlZCBmb3J3YXJkIEZGVCBvbiB0aGUgZ2l2ZW4gaW5wdXQgYnVmZmVyIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbiB0aGUgZ2l2ZW4gb3V0cHV0IGJ1ZmZlci5cbiAgICAgKiBUaGUgaW5wdXQgYnVmZmVyIG11c3QgY29udGFpbiByZWFsIHZhbHVlcyBvbmx5LCB3aGlsZSB0aGUgb3V0cHV0IGJ1ZmZlciB3aWxsIGNvbnRhaW4gY29tcGxleCB2YWx1ZXMuIFRoZSBpbnB1dCBhbmRcbiAgICAgKiBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvdXQgVGhlIG91dHB1dCBidWZmZXIuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGRhdGEgVGhlIGlucHV0IGJ1ZmZlciBjb250YWluaW5nIHJlYWwgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHRoZSBzYW1lLlxuICAgICAqL1xuICAgIHJlYWxUcmFuc2Zvcm0ob3V0LCBkYXRhKSB7XG4gICAgICAgIGlmIChvdXQgPT09IGRhdGEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBtdXN0IGJlIGRpZmZlcmVudCcpO1xuXG4gICAgICAgIHRoaXMuX3JlYWxUcmFuc2Zvcm00KG91dCwgZGF0YSwgMSAvKiBET05FICovKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhbiBpbnZlcnNlIEZGVCB0cmFuc2Zvcm1hdGlvbiBvbiB0aGUgZ2l2ZW4gYGRhdGFgIGFycmF5LCBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW4gYG91dGAuXG4gICAgICogVGhlIGBvdXRgIGFycmF5IG11c3QgYmUgYSBkaWZmZXJlbnQgYnVmZmVyIHRoYW4gdGhlIGBkYXRhYCBhcnJheS4gVGhlIGBvdXRgIGFycmF5IHdpbGwgY29udGFpbiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIHRyYW5zZm9ybWF0aW9uLiBUaGUgYGRhdGFgIGFycmF5IHdpbGwgbm90IGJlIG1vZGlmaWVkLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvdXQgVGhlIG91dHB1dCBidWZmZXIgZm9yIHRoZSB0cmFuc2Zvcm1lZCBkYXRhLlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBkYXRhIFRoZSBpbnB1dCBkYXRhIHRvIHRyYW5zZm9ybS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYG91dGAgYW5kIGBkYXRhYCByZWZlciB0byB0aGUgc2FtZSBidWZmZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgaW52ZXJzZVRyYW5zZm9ybShvdXQsIGRhdGEpIHtcbiAgICAgICAgaWYgKG91dCA9PT0gZGF0YSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIG11c3QgYmUgZGlmZmVyZW50Jyk7XG5cbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtNChvdXQsIGRhdGEsIC0xIC8qIERPTkUgKi8pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIG91dFtpXSAvPSB0aGlzLnNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSByYWRpeC00IGltcGxlbWVudGF0aW9uIG9mIGEgZGlzY3JldGUgRm91cmllciB0cmFuc2Zvcm0gb24gYSBnaXZlbiBzZXQgb2YgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvdXQgVGhlIG91dHB1dCBidWZmZXIgZm9yIHRoZSB0cmFuc2Zvcm1lZCBkYXRhLlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBkYXRhIFRoZSBpbnB1dCBidWZmZXIgb2YgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW52IEEgc2NhbGluZyBmYWN0b3IgdG8gYXBwbHkgdG8gdGhlIHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBfdHJhbnNmb3JtNChvdXQsIGRhdGEsIGludikge1xuICAgICAgICAvLyByYWRpeC00IGltcGxlbWVudGF0aW9uXG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2NzaXplO1xuXG4gICAgICAgIC8vIEluaXRpYWwgc3RlcCAocGVybXV0ZSBhbmQgdHJhbnNmb3JtKVxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICBsZXQgc3RlcCA9IDEgPDwgd2lkdGg7XG4gICAgICAgIGxldCBsZW4gPSAoc2l6ZSAvIHN0ZXApIDw8IDE7XG5cbiAgICAgICAgbGV0IG91dE9mZjtcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGxldCBiaXRyZXYgPSB0aGlzLl9iaXRyZXY7XG4gICAgICAgIGlmIChsZW4gPT09IDQpIHtcbiAgICAgICAgICAgIGZvciAob3V0T2ZmID0gMCwgdCA9IDA7IG91dE9mZiA8IHNpemU7IG91dE9mZiArPSBsZW4sICsrdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZiA9IGJpdHJldlt0XTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaW5nbGVUcmFuc2Zvcm0yKGRhdGEsIG91dCwgb3V0T2ZmLCBvZmYsIHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbGVuID09PSA4XG4gICAgICAgICAgICBmb3IgKG91dE9mZiA9IDAsIHQgPSAwOyBvdXRPZmYgPCBzaXplOyBvdXRPZmYgKz0gbGVuLCArK3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmYgPSBiaXRyZXZbdF07XG4gICAgICAgICAgICAgICAgdGhpcy5fc2luZ2xlVHJhbnNmb3JtNChkYXRhLCBvdXQsIG91dE9mZiwgb2ZmLCBzdGVwLCBpbnYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHN0ZXBzIGluIGRlY3JlYXNpbmcgb3JkZXJcbiAgICAgICAgZm9yIChzdGVwID4+PSAyOyBzdGVwID49IDI7IHN0ZXAgPj49IDIpIHtcbiAgICAgICAgICAgIGxlbiA9IChzaXplIC8gc3RlcCkgPDwgMTtcbiAgICAgICAgICAgIGxldCBxdWFydGVyTGVuID0gbGVuID4+PiAyO1xuXG4gICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggb2Zmc2V0cyBpbiB0aGUgZGF0YVxuICAgICAgICAgICAgZm9yIChvdXRPZmYgPSAwOyBvdXRPZmYgPCBzaXplOyBvdXRPZmYgKz0gbGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gRnVsbCBjYXNlXG4gICAgICAgICAgICAgICAgbGV0IGxpbWl0ID0gb3V0T2ZmICsgcXVhcnRlckxlbjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gb3V0T2ZmLCBrID0gMDsgaSA8IGxpbWl0OyBpICs9IDIsIGsgKz0gc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBBID0gaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQiA9IEEgKyBxdWFydGVyTGVuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBDID0gQiArIHF1YXJ0ZXJMZW47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEQgPSBDICsgcXVhcnRlckxlbjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQXIgPSBvdXRbQV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEFpID0gb3V0W0EgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQnIgPSBvdXRbQl07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEJpID0gb3V0W0IgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQ3IgPSBvdXRbQ107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IENpID0gb3V0W0MgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgRHIgPSBvdXRbRF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IERpID0gb3V0W0QgKyAxXTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZUJyID0gdGhpcy50YWJsZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVCaSA9IGludiAqIHRoaXMudGFibGVbayArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBNQnIgPSBCciAqIHRhYmxlQnIgLSBCaSAqIHRhYmxlQmk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IE1CaSA9IEJyICogdGFibGVCaSArIEJpICogdGFibGVCcjtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZUNyID0gdGhpcy50YWJsZVsyICoga107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlQ2kgPSBpbnYgKiB0aGlzLnRhYmxlWzIgKiBrICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IE1DciA9IENyICogdGFibGVDciAtIENpICogdGFibGVDaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTUNpID0gQ3IgKiB0YWJsZUNpICsgQ2kgKiB0YWJsZUNyO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlRHIgPSB0aGlzLnRhYmxlWzMgKiBrXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVEaSA9IGludiAqIHRoaXMudGFibGVbMyAqIGsgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTURyID0gRHIgKiB0YWJsZURyIC0gRGkgKiB0YWJsZURpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBNRGkgPSBEciAqIHRhYmxlRGkgKyBEaSAqIHRhYmxlRHI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJlLUZpbmFsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUMHIgPSBBciArIE1DcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDBpID0gQWkgKyBNQ2k7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQxciA9IEFyIC0gTUNyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUMWkgPSBBaSAtIE1DaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDJyID0gTUJyICsgTURyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUMmkgPSBNQmkgKyBNRGk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQzciA9IGludiAqIChNQnIgLSBNRHIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUM2kgPSBpbnYgKiAoTUJpIC0gTURpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgb3V0W0FdID0gVDByICsgVDJyO1xuICAgICAgICAgICAgICAgICAgICBvdXRbQSArIDFdID0gVDBpICsgVDJpO1xuICAgICAgICAgICAgICAgICAgICBvdXRbQl0gPSBUMXIgKyBUM2k7XG4gICAgICAgICAgICAgICAgICAgIG91dFtCICsgMV0gPSBUMWkgLSBUM3I7XG4gICAgICAgICAgICAgICAgICAgIG91dFtDXSA9IFQwciAtIFQycjtcbiAgICAgICAgICAgICAgICAgICAgb3V0W0MgKyAxXSA9IFQwaSAtIFQyaTtcbiAgICAgICAgICAgICAgICAgICAgb3V0W0RdID0gVDFyIC0gVDNpO1xuICAgICAgICAgICAgICAgICAgICBvdXRbRCArIDFdID0gVDFpICsgVDNyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcmFkaXgtMiBpbXBsZW1lbnRhdGlvbiBvZiBhIGRpc2NyZXRlIEZvdXJpZXIgdHJhbnNmb3JtIG9uIGEgZ2l2ZW4gc2V0IG9mIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZGF0YSBUaGUgaW5wdXQgYnVmZmVyIG9mIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWQuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG91dCBUaGUgb3V0cHV0IGJ1ZmZlciBmb3IgdGhlIHRyYW5zZm9ybWVkIGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG91dE9mZiBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHdyaXRlIHRoZSBvdXRwdXQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2ZmIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gYmVnaW4gcmVhZGluZyB0aGUgaW5wdXQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgc3RlcCBzaXplIGZvciBpbmRleGluZyB0aGUgaW5wdXQgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBfc2luZ2xlVHJhbnNmb3JtMihkYXRhLCBvdXQsIG91dE9mZiwgb2ZmLCBzdGVwKSB7XG4gICAgICAgIC8vIHJhZGl4LTIgaW1wbGVtZW50YXRpb25cbiAgICAgICAgLy8gTk9URTogT25seSBjYWxsZWQgZm9yIGxlbj00XG5cbiAgICAgICAgY29uc3QgZXZlblIgPSBkYXRhW29mZl07XG4gICAgICAgIGNvbnN0IGV2ZW5JID0gZGF0YVtvZmYgKyAxXTtcbiAgICAgICAgY29uc3Qgb2RkUiA9IGRhdGFbb2ZmICsgc3RlcF07XG4gICAgICAgIGNvbnN0IG9kZEkgPSBkYXRhW29mZiArIHN0ZXAgKyAxXTtcblxuICAgICAgICBvdXRbb3V0T2ZmXSA9IGV2ZW5SICsgb2RkUjtcbiAgICAgICAgb3V0W291dE9mZiArIDFdID0gZXZlbkkgKyBvZGRJO1xuICAgICAgICBvdXRbb3V0T2ZmICsgMl0gPSBldmVuUiAtIG9kZFI7XG4gICAgICAgIG91dFtvdXRPZmYgKyAzXSA9IGV2ZW5JIC0gb2RkSTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyByYWRpeC00IHRyYW5zZm9ybWF0aW9uIG9uIGlucHV0IGRhdGEgb2YgbGVuZ3RoIDhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBkYXRhIElucHV0IGRhdGEgYXJyYXkgb2YgbGVuZ3RoIDhcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3V0IE91dHB1dCBkYXRhIGFycmF5IG9mIGxlbmd0aCA4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG91dE9mZiBJbmRleCBvZiBvdXRwdXQgYXJyYXkgdG8gc3RhcnQgd3JpdGluZyBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZiBJbmRleCBvZiBpbnB1dCBhcnJheSB0byBzdGFydCByZWFkaW5nIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBTdGVwIHNpemUgYmV0d2VlbiBlbGVtZW50cyBpbiBpbnB1dCBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnYgU2NhbGluZyBmYWN0b3IgZm9yIGludmVyc2UgdHJhbnNmb3JtXG4gICAgICogXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgX3NpbmdsZVRyYW5zZm9ybTQoZGF0YSwgb3V0LCBvdXRPZmYsIG9mZiwgc3RlcCwgaW52KSB7XG4gICAgICAgIC8vIHJhZGl4LTRcbiAgICAgICAgLy8gTk9URTogT25seSBjYWxsZWQgZm9yIGxlbj04XG4gICAgICAgIGNvbnN0IHN0ZXAyID0gc3RlcCAqIDI7XG4gICAgICAgIGNvbnN0IHN0ZXAzID0gc3RlcCAqIDM7XG5cbiAgICAgICAgLy8gT3JpZ2luYWwgdmFsdWVzXG4gICAgICAgIGNvbnN0IEFyID0gZGF0YVtvZmZdO1xuICAgICAgICBjb25zdCBBaSA9IGRhdGFbb2ZmICsgMV07XG4gICAgICAgIGNvbnN0IEJyID0gZGF0YVtvZmYgKyBzdGVwXTtcbiAgICAgICAgY29uc3QgQmkgPSBkYXRhW29mZiArIHN0ZXAgKyAxXTtcbiAgICAgICAgY29uc3QgQ3IgPSBkYXRhW29mZiArIHN0ZXAyXTtcbiAgICAgICAgY29uc3QgQ2kgPSBkYXRhW29mZiArIHN0ZXAyICsgMV07XG4gICAgICAgIGNvbnN0IERyID0gZGF0YVtvZmYgKyBzdGVwM107XG4gICAgICAgIGNvbnN0IERpID0gZGF0YVtvZmYgKyBzdGVwMyArIDFdO1xuXG4gICAgICAgIC8vIFByZS1GaW5hbCB2YWx1ZXNcbiAgICAgICAgY29uc3QgVDByID0gQXIgKyBDcjtcbiAgICAgICAgY29uc3QgVDBpID0gQWkgKyBDaTtcbiAgICAgICAgY29uc3QgVDFyID0gQXIgLSBDcjtcbiAgICAgICAgY29uc3QgVDFpID0gQWkgLSBDaTtcbiAgICAgICAgY29uc3QgVDJyID0gQnIgKyBEcjtcbiAgICAgICAgY29uc3QgVDJpID0gQmkgKyBEaTtcbiAgICAgICAgY29uc3QgVDNyID0gaW52ICogKEJyIC0gRHIpO1xuICAgICAgICBjb25zdCBUM2kgPSBpbnYgKiAoQmkgLSBEaSk7XG5cbiAgICAgICAgLy8gRmluYWwgdmFsdWVzXG4gICAgICAgIG91dFtvdXRPZmZdID0gVDByICsgVDJyO1xuICAgICAgICBvdXRbb3V0T2ZmICsgMV0gPSBUMGkgKyBUMmk7XG4gICAgICAgIG91dFtvdXRPZmYgKyAyXSA9IFQxciArIFQzaTtcbiAgICAgICAgb3V0W291dE9mZiArIDNdID0gVDFpIC0gVDNyO1xuICAgICAgICBvdXRbb3V0T2ZmICsgNF0gPSBUMHIgLSBUMnI7XG4gICAgICAgIG91dFtvdXRPZmYgKyA1XSA9IFQwaSAtIFQyaTtcbiAgICAgICAgb3V0W291dE9mZiArIDZdID0gVDFyIC0gVDNpO1xuICAgICAgICBvdXRbb3V0T2ZmICsgN10gPSBUMWkgKyBUM3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhbCBpbnB1dCByYWRpeC00IGltcGxlbWVudGF0aW9uXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG91dCBPdXRwdXQgYXJyYXkgZm9yIHRoZSB0cmFuc2Zvcm1lZCBkYXRhXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGRhdGEgSW5wdXQgYXJyYXkgb2YgcmVhbCBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludiBUaGUgc2NhbGUgZmFjdG9yIHVzZWQgdG8gbm9ybWFsaXplIHRoZSBpbnZlcnNlIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIF9yZWFsVHJhbnNmb3JtNChvdXQsIGRhdGEsIGludikge1xuICAgICAgICAvLyBSZWFsIGlucHV0IHJhZGl4LTQgaW1wbGVtZW50YXRpb25cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2NzaXplO1xuXG4gICAgICAgIC8vIEluaXRpYWwgc3RlcCAocGVybXV0ZSBhbmQgdHJhbnNmb3JtKVxuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICBsZXQgc3RlcCA9IDEgPDwgd2lkdGg7XG4gICAgICAgIGxldCBsZW4gPSAoc2l6ZSAvIHN0ZXApIDw8IDE7XG5cbiAgICAgICAgdmFyIG91dE9mZjtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHZhciBiaXRyZXYgPSB0aGlzLl9iaXRyZXY7XG4gICAgICAgIGlmIChsZW4gPT09IDQpIHtcbiAgICAgICAgICAgIGZvciAob3V0T2ZmID0gMCwgdCA9IDA7IG91dE9mZiA8IHNpemU7IG91dE9mZiArPSBsZW4sICsrdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZiA9IGJpdHJldlt0XTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaW5nbGVSZWFsVHJhbnNmb3JtMihkYXRhLCBvdXQsIG91dE9mZiwgb2ZmID4+PiAxLCBzdGVwID4+PiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGxlbiA9PT0gOFxuICAgICAgICAgICAgZm9yIChvdXRPZmYgPSAwLCB0ID0gMDsgb3V0T2ZmIDwgc2l6ZTsgb3V0T2ZmICs9IGxlbiwgKyt0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2ZmID0gYml0cmV2W3RdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NpbmdsZVJlYWxUcmFuc2Zvcm00KGRhdGEsIG91dCwgb3V0T2ZmLCBvZmYgPj4+IDEsIHN0ZXAgPj4+IDEsIGludik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggc3RlcHMgaW4gZGVjcmVhc2luZyBvcmRlclxuICAgICAgICBmb3IgKHN0ZXAgPj49IDI7IHN0ZXAgPj0gMjsgc3RlcCA+Pj0gMikge1xuICAgICAgICAgICAgbGVuID0gKHNpemUgLyBzdGVwKSA8PCAxO1xuICAgICAgICAgICAgY29uc3QgaGFsZkxlbiA9IGxlbiA+Pj4gMTtcbiAgICAgICAgICAgIGNvbnN0IHF1YXJ0ZXJMZW4gPSBoYWxmTGVuID4+PiAxO1xuICAgICAgICAgICAgY29uc3QgaHF1YXJ0ZXJMZW4gPSBxdWFydGVyTGVuID4+PiAxO1xuXG4gICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggb2Zmc2V0cyBpbiB0aGUgZGF0YVxuICAgICAgICAgICAgZm9yIChvdXRPZmYgPSAwOyBvdXRPZmYgPCBzaXplOyBvdXRPZmYgKz0gbGVuKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGsgPSAwOyBpIDw9IGhxdWFydGVyTGVuOyBpICs9IDIsIGsgKz0gc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBBID0gb3V0T2ZmICsgaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQiA9IEEgKyBxdWFydGVyTGVuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBDID0gQiArIHF1YXJ0ZXJMZW47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEQgPSBDICsgcXVhcnRlckxlbjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQXIgPSBvdXRbQV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEFpID0gb3V0W0EgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQnIgPSBvdXRbQl07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEJpID0gb3V0W0IgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgQ3IgPSBvdXRbQ107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IENpID0gb3V0W0MgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgRHIgPSBvdXRbRF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IERpID0gb3V0W0QgKyAxXTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZUJyID0gdGhpcy50YWJsZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVCaSA9IGludiAqIHRoaXMudGFibGVbayArIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBNQnIgPSBCciAqIHRhYmxlQnIgLSBCaSAqIHRhYmxlQmk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IE1CaSA9IEJyICogdGFibGVCaSArIEJpICogdGFibGVCcjtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZUNyID0gdGhpcy50YWJsZVsyICoga107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlQ2kgPSBpbnYgKiB0aGlzLnRhYmxlWzIgKiBrICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IE1DciA9IENyICogdGFibGVDciAtIENpICogdGFibGVDaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTUNpID0gQ3IgKiB0YWJsZUNpICsgQ2kgKiB0YWJsZUNyO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlRHIgPSB0aGlzLnRhYmxlWzMgKiBrXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVEaSA9IGludiAqIHRoaXMudGFibGVbMyAqIGsgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTURyID0gRHIgKiB0YWJsZURyIC0gRGkgKiB0YWJsZURpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBNRGkgPSBEciAqIHRhYmxlRGkgKyBEaSAqIHRhYmxlRHI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJlLUZpbmFsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUMHIgPSBBciArIE1DcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDBpID0gQWkgKyBNQ2k7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQxciA9IEFyIC0gTUNyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUMWkgPSBBaSAtIE1DaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgVDJyID0gTUJyICsgTURyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUMmkgPSBNQmkgKyBNRGk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFQzciA9IGludiAqIChNQnIgLSBNRHIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBUM2kgPSBpbnYgKiAoTUJpIC0gTURpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5hbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgb3V0W0FdID0gVDByICsgVDJyO1xuICAgICAgICAgICAgICAgICAgICBvdXRbQSArIDFdID0gVDBpICsgVDJpO1xuICAgICAgICAgICAgICAgICAgICBvdXRbQl0gPSBUMXIgKyBUM2k7XG4gICAgICAgICAgICAgICAgICAgIG91dFtCICsgMV0gPSBUMWkgLSBUM3I7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3V0cHV0IGZpbmFsIG1pZGRsZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W0NdID0gVDByIC0gVDJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W0MgKyAxXSA9IFQwaSAtIFQyaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IG92ZXJ3cml0ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGhxdWFydGVyTGVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgU0EgPSBvdXRPZmYgKyBxdWFydGVyTGVuIC0gaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgU0IgPSBvdXRPZmYgKyBoYWxmTGVuIC0gaTtcblxuICAgICAgICAgICAgICAgICAgICBvdXRbU0FdID0gVDFyICsgLWludiAqIFQzaTtcbiAgICAgICAgICAgICAgICAgICAgb3V0W1NBICsgMV0gPSAtVDFpIC0gaW52ICogVDNyO1xuICAgICAgICAgICAgICAgICAgICBvdXRbU0JdID0gVDByICsgLWludiAqIFQycjtcbiAgICAgICAgICAgICAgICAgICAgb3V0W1NCICsgMV0gPSAtVDBpICsgaW52ICogVDJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgc2luZ2xlIHJlYWwgaW5wdXQgcmFkaXgtMiB0cmFuc2Zvcm1hdGlvbiBvbiB0aGUgcHJvdmlkZWQgZGF0YVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBkYXRhIFRoZSBpbnB1dCBkYXRhIGFycmF5XG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG91dCBUaGUgb3V0cHV0IGRhdGEgYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3V0T2ZmIFRoZSBvdXRwdXQgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZiBUaGUgaW5wdXQgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHN0ZXBcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBfc2luZ2xlUmVhbFRyYW5zZm9ybTIoZGF0YSwgb3V0LCBvdXRPZmYsIG9mZiwgc3RlcCkge1xuICAgICAgICAvLyByYWRpeC0yIGltcGxlbWVudGF0aW9uXG4gICAgICAgIC8vIE5PVEU6IE9ubHkgY2FsbGVkIGZvciBsZW49NFxuXG4gICAgICAgIGNvbnN0IGV2ZW5SID0gZGF0YVtvZmZdO1xuICAgICAgICBjb25zdCBvZGRSID0gZGF0YVtvZmYgKyBzdGVwXTtcblxuICAgICAgICBvdXRbb3V0T2ZmXSA9IGV2ZW5SICsgb2RkUjtcbiAgICAgICAgb3V0W291dE9mZiArIDFdID0gMDtcbiAgICAgICAgb3V0W291dE9mZiArIDJdID0gZXZlblIgLSBvZGRSO1xuICAgICAgICBvdXRbb3V0T2ZmICsgM10gPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGEgc2luZ2xlIHJlYWwtdmFsdWVkIHRyYW5zZm9ybSB1c2luZyByYWRpeC00IGFsZ29yaXRobS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBvbmx5IGNhbGxlZCBmb3IgbGVuPTguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZGF0YSBUaGUgaW5wdXQgZGF0YSBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3V0IFRoZSBvdXRwdXQgZGF0YSBhcnJheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3V0T2ZmIFRoZSBvZmZzZXQgaW50byB0aGUgb3V0cHV0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmYgVGhlIG9mZnNldCBpbnRvIHRoZSBpbnB1dCBhcnJheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgc3RlcCBzaXplIGZvciB0aGUgaW5wdXQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludiBUaGUgdmFsdWUgb2YgaW52ZXJzZS5cbiAgICAgKi9cbiAgICBfc2luZ2xlUmVhbFRyYW5zZm9ybTQoZGF0YSwgb3V0LCBvdXRPZmYsIG9mZiwgc3RlcCwgaW52KSB7XG4gICAgICAgIC8vIHJhZGl4LTRcbiAgICAgICAgLy8gTk9URTogT25seSBjYWxsZWQgZm9yIGxlbj04XG4gICAgICAgIGNvbnN0IHN0ZXAyID0gc3RlcCAqIDI7XG4gICAgICAgIGNvbnN0IHN0ZXAzID0gc3RlcCAqIDM7XG5cbiAgICAgICAgLy8gT3JpZ2luYWwgdmFsdWVzXG4gICAgICAgIGNvbnN0IEFyID0gZGF0YVtvZmZdO1xuICAgICAgICBjb25zdCBCciA9IGRhdGFbb2ZmICsgc3RlcF07XG4gICAgICAgIGNvbnN0IENyID0gZGF0YVtvZmYgKyBzdGVwMl07XG4gICAgICAgIGNvbnN0IERyID0gZGF0YVtvZmYgKyBzdGVwM107XG5cbiAgICAgICAgLy8gUHJlLUZpbmFsIHZhbHVlc1xuICAgICAgICBjb25zdCBUMHIgPSBBciArIENyO1xuICAgICAgICBjb25zdCBUMXIgPSBBciAtIENyO1xuICAgICAgICBjb25zdCBUMnIgPSBCciArIERyO1xuICAgICAgICBjb25zdCBUM3IgPSBpbnYgKiAoQnIgLSBEcik7XG5cbiAgICAgICAgLy8gRmluYWwgdmFsdWVzXG4gICAgICAgIG91dFtvdXRPZmZdID0gVDByICsgVDJyO1xuICAgICAgICBvdXRbb3V0T2ZmICsgMV0gPSAwO1xuICAgICAgICBvdXRbb3V0T2ZmICsgMl0gPSBUMXI7XG4gICAgICAgIG91dFtvdXRPZmYgKyAzXSA9IC1UM3I7XG4gICAgICAgIG91dFtvdXRPZmYgKyA0XSA9IFQwciAtIFQycjtcbiAgICAgICAgb3V0W291dE9mZiArIDVdID0gMDtcbiAgICAgICAgb3V0W291dE9mZiArIDZdID0gVDFyO1xuICAgICAgICBvdXRbb3V0T2ZmICsgN10gPSBUM3I7XG4gICAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIG1lZGlhbiBmaWx0ZXIgb24gdGhlIHByb3ZpZGVkIGRhdGEuIFBhZGRpbmcgaXMgZG9uZSBieSBtaXJyb3JpbmcgdGhlIGRhdGEuXG4gKiBAcGFyYW0ge0FueVR5cGVkQXJyYXl9IGRhdGEgVGhlIGlucHV0IGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gd2luZG93U2l6ZSBUaGUgd2luZG93IHNpemVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lZGlhbkZpbHRlcihkYXRhLCB3aW5kb3dTaXplKSB7XG5cbiAgICBpZiAod2luZG93U2l6ZSAlIDIgPT09IDAgfHwgd2luZG93U2l6ZSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2luZG93IHNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIG9kZCBudW1iZXInKTtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgb3V0cHV0QXJyYXkgPSBuZXcgZGF0YS5jb25zdHJ1Y3RvcihkYXRhLmxlbmd0aCk7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IGRhdGEuY29uc3RydWN0b3Iod2luZG93U2l6ZSk7IC8vIFJldXNhYmxlIGFycmF5IGZvciBzdG9yaW5nIHZhbHVlc1xuXG4gICAgY29uc3QgaGFsZldpbmRvd1NpemUgPSBNYXRoLmZsb29yKHdpbmRvd1NpemUgLyAyKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBsZXQgdmFsdWVzSW5kZXggPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAtaGFsZldpbmRvd1NpemU7IGogPD0gaGFsZldpbmRvd1NpemU7ICsraikge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gaSArIGo7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBNYXRoLmFicyhpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAyICogKGRhdGEubGVuZ3RoIC0gMSkgLSBpbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZmVyW3ZhbHVlc0luZGV4KytdID0gZGF0YVtpbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXIuc29ydCgpO1xuICAgICAgICBvdXRwdXRBcnJheVtpXSA9IGJ1ZmZlcltoYWxmV2luZG93U2l6ZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dEFycmF5O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byByb3VuZCBhIG51bWJlciB0byBhIGdpdmVuIG51bWJlciBvZiBkZWNpbWFsc1xuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIHJvdW5kXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbHMgVGhlIG51bWJlciBvZiBkZWNpbWFsc1xuICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdW5kZWQgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChudW0sIGRlY2ltYWxzKSB7XG4gICAgY29uc3QgcG93ID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xufVxuIiwiLyoqXG4gKiBAZmlsZSBIZWxwZXIgbW9kdWxlIGZvciBgVGVuc29yYCBwcm9jZXNzaW5nLlxuICogXG4gKiBUaGVzZSBmdW5jdGlvbnMgYW5kIGNsYXNzZXMgYXJlIG9ubHkgdXNlZCBpbnRlcm5hbGx5LCBcbiAqIG1lYW5pbmcgYW4gZW5kLXVzZXIgc2hvdWxkbid0IG5lZWQgdG8gYWNjZXNzIGFueXRoaW5nIGhlcmUuXG4gKiBcbiAqIEBtb2R1bGUgdXRpbHMvdGVuc29yXG4gKi9cblxuaW1wb3J0IHsgT05OWCB9IGZyb20gJy4uL2JhY2tlbmRzL29ubnguanMnO1xuXG5pbXBvcnQge1xuICAgIGludGVycG9sYXRlX2RhdGEsXG4gICAgdHJhbnNwb3NlX2RhdGFcbn0gZnJvbSAnLi9tYXRocy5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL21hdGhzLmpzJykuQW55VHlwZWRBcnJheX0gQW55VHlwZWRBcnJheVxuICovXG5cbi8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuY29uc3QgT05OWFRlbnNvciA9IE9OTlguVGVuc29yO1xuXG5leHBvcnQgY2xhc3MgVGVuc29yIGV4dGVuZHMgT05OWFRlbnNvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFRlbnNvciBvciBjb3B5IGFuIGV4aXN0aW5nIFRlbnNvci5cbiAgICAgKiBAcGFyYW0ge1tzdHJpbmcsIEFycmF5fEFueVR5cGVkQXJyYXksIG51bWJlcltdXXxbT05OWFRlbnNvcl19IGFyZ3NcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgT05OWC5UZW5zb3IpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzaGFsbG93IGNvcHlcbiAgICAgICAgICAgIHN1cGVyKGFyZ3NbMF0udHlwZSwgYXJnc1swXS5kYXRhLCBhcmdzWzBdLmRpbXMpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgbmV3XG4gICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgZ2V0OiAob2JqLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gTnVtYmVyKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2V5IGlzIGFuIGludGVnZXIgKGkuZS4sIGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5fZ2V0aXRlbShpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGFsbG93IHNldHRpbmcgb2YgZGF0YVxuXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG9iamVjdCBmb3IgaXRlcmF0aW5nIG92ZXIgdGhlIHRlbnNvciBkYXRhIGluIHJvdy1tYWpvciBvcmRlci5cbiAgICAgKiBJZiB0aGUgdGVuc29yIGhhcyBtb3JlIHRoYW4gb25lIGRpbWVuc2lvbiwgdGhlIGl0ZXJhdG9yIHdpbGwgeWllbGQgc3ViYXJyYXlzLlxuICAgICAqIEByZXR1cm5zIHtJdGVyYXRvcn0gQW4gaXRlcmF0b3Igb2JqZWN0IGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgdGVuc29yIGRhdGEgaW4gcm93LW1ham9yIG9yZGVyLlxuICAgICAqL1xuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgY29uc3QgW2l0ZXJMZW5ndGgsIC4uLml0ZXJEaW1zXSA9IHRoaXMuZGltcztcblxuICAgICAgICBpZiAoaXRlckRpbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaXRlclNpemUgPSBpdGVyRGltcy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlckxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fc3ViYXJyYXkoaSwgaXRlclNpemUsIGl0ZXJEaW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLmRhdGFcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5kZXggaW50byBhIFRlbnNvciBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBhY2Nlc3MuXG4gICAgICogQHJldHVybnMge1RlbnNvcn0gVGhlIGRhdGEgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKi9cbiAgICBfZ2V0aXRlbShpbmRleCkge1xuICAgICAgICBjb25zdCBbaXRlckxlbmd0aCwgLi4uaXRlckRpbXNdID0gdGhpcy5kaW1zO1xuXG4gICAgICAgIGluZGV4ID0gc2FmZUluZGV4KGluZGV4LCBpdGVyTGVuZ3RoKTtcblxuICAgICAgICBpZiAoaXRlckRpbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaXRlclNpemUgPSBpdGVyRGltcy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJhcnJheShpbmRleCwgaXRlclNpemUsIGl0ZXJEaW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVuc29yKHRoaXMudHlwZSwgW3RoaXMuZGF0YVtpbmRleF1dLCBpdGVyRGltcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnxiaWdpbnR9IGl0ZW0gVGhlIGl0ZW0gdG8gc2VhcmNoIGZvciBpbiB0aGUgdGVuc29yXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGl0ZW0gaW4gdGhlIHRlbnNvciBkYXRhLlxuICAgICAqL1xuICAgIGluZGV4T2YoaXRlbSkge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgLy8gTm90ZTogPT0gaW5zdGVhZCBvZiA9PT0gc28gd2UgY2FuIG1hdGNoIEludHMgd2l0aCBCaWdJbnRzXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2luZGV4XSA9PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGl0ZXJTaXplIFxuICAgICAqIEBwYXJhbSB7YW55fSBpdGVyRGltcyBcbiAgICAgKiBAcmV0dXJucyB7VGVuc29yfVxuICAgICAqL1xuICAgIF9zdWJhcnJheShpbmRleCwgaXRlclNpemUsIGl0ZXJEaW1zKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5kYXRhLnN1YmFycmF5KGluZGV4ICogaXRlclNpemUsIChpbmRleCArIDEpICogaXRlclNpemUpO1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcih0aGlzLnR5cGUsIGRhdGEsIGl0ZXJEaW1zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGlzIHRlbnNvciBhcyBhIHN0YW5kYXJkIEphdmFTY3JpcHQgTnVtYmVyLiBUaGlzIG9ubHkgd29ya3NcbiAgICAgKiBmb3IgdGVuc29ycyB3aXRoIG9uZSBlbGVtZW50LiBGb3Igb3RoZXIgY2FzZXMsIHNlZSBgVGVuc29yLnRvbGlzdCgpYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdmFsdWUgb2YgdGhpcyB0ZW5zb3IgYXMgYSBzdGFuZGFyZCBKYXZhU2NyaXB0IE51bWJlci5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHRlbnNvciBoYXMgbW9yZSB0aGFuIG9uZSBlbGVtZW50LlxuICAgICAqL1xuICAgIGl0ZW0oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGEgVGVuc29yIHdpdGggJHt0aGlzLmRhdGEubGVuZ3RofSBlbGVtZW50cyBjYW5ub3QgYmUgY29udmVydGVkIHRvIFNjYWxhcmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0ZW5zb3IgZGF0YSB0byBhIG4tZGltZW5zaW9uYWwgSlMgbGlzdFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICB0b2xpc3QoKSB7XG4gICAgICAgIHJldHVybiByZXNoYXBlKHRoaXMuZGF0YSwgdGhpcy5kaW1zKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBUZW5zb3Igd2l0aCB0aGUgc2lnbW9pZCBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7VGVuc29yfSBUaGUgdGVuc29yIHdpdGggdGhlIHNpZ21vaWQgZnVuY3Rpb24gYXBwbGllZC5cbiAgICAgKi9cbiAgICBzaWdtb2lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnNpZ21vaWRfKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgc2lnbW9pZCBmdW5jdGlvbiB0byB0aGUgdGVuc29yIGluIHBsYWNlLlxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IFJldHVybnMgYHRoaXNgLlxuICAgICAqL1xuICAgIHNpZ21vaWRfKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gMSAvICgxICsgTWF0aC5leHAoLXRoaXMuZGF0YVtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcih0aGlzLnR5cGUsIHRoaXMuZGF0YS5zbGljZSgpLCB0aGlzLmRpbXMuc2xpY2UoKSk7XG4gICAgfVxuXG4gICAgc2xpY2UoLi4uc2xpY2VzKSB7XG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciBzbGljaW5nIHdpdGggcmFuZ2VzIGFuZCBudW1iZXJzXG4gICAgICAgIGxldCBuZXdUZW5zb3JEaW1zID0gW107XG4gICAgICAgIGxldCBuZXdPZmZzZXRzID0gW107XG5cbiAgICAgICAgLy8gc2xpY2VzIGlzIGFuIGFycmF5IG9mIG51bWJlcnMgb3IgYXJyYXlzIG9mIG51bWJlcnNcbiAgICAgICAgLy8gZS5nLiwgc2xpY2VzID0gWzAsIFsxLCAzXSwgbnVsbCwgWzAsIDNdXVxuICAgICAgICBmb3IgKGxldCBzbGljZUluZGV4ID0gMDsgc2xpY2VJbmRleCA8IHRoaXMuZGltcy5sZW5ndGg7ICsrc2xpY2VJbmRleCkge1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gc2xpY2VzW3NsaWNlSW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAoc2xpY2UgPT09IG51bGwgfHwgc2xpY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIG51bGwgb3IgdW5kZWZpbmVkIG1lYW5zIHRha2UgdGhlIHdob2xlIGRpbWVuc2lvblxuICAgICAgICAgICAgICAgIG5ld09mZnNldHMucHVzaChbMCwgdGhpcy5kaW1zW3NsaWNlSW5kZXhdXSk7XG4gICAgICAgICAgICAgICAgbmV3VGVuc29yRGltcy5wdXNoKHRoaXMuZGltc1tzbGljZUluZGV4XSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNsaWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHNsaWNlID0gc2FmZUluZGV4KHNsaWNlLCB0aGlzLmRpbXNbc2xpY2VJbmRleF0sIHNsaWNlSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gQSBudW1iZXIgbWVhbnMgdGFrZSBhIHNpbmdsZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgbmV3T2Zmc2V0cy5wdXNoKFtzbGljZSwgc2xpY2UgKyAxXSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzbGljZSkgJiYgc2xpY2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gQW4gYXJyYXkgb2YgbGVuZ3RoIDIgbWVhbnMgdGFrZSBhIHJhbmdlIG9mIGVsZW1lbnRzXG5cbiAgICAgICAgICAgICAgICBpZiAoc2xpY2VbMF0gPiBzbGljZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2xpY2U6ICR7c2xpY2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldHMgPSBbXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHNsaWNlWzBdLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oc2xpY2VbMV0sIHRoaXMuZGltc1tzbGljZUluZGV4XSlcbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgbmV3T2Zmc2V0cy5wdXNoKG9mZnNldHMpO1xuICAgICAgICAgICAgICAgIG5ld1RlbnNvckRpbXMucHVzaChvZmZzZXRzWzFdIC0gb2Zmc2V0c1swXSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNsaWNlOiAke3NsaWNlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5ld0RpbXMgPSBuZXdPZmZzZXRzLm1hcCgoW3N0YXJ0LCBlbmRdKSA9PiBlbmQgLSBzdGFydCk7XG4gICAgICAgIGxldCBuZXdCdWZmZXJTaXplID0gbmV3RGltcy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcblxuICAgICAgICAvLyBBbGxvY2F0ZSBtZW1vcnlcbiAgICAgICAgbGV0IGRhdGEgPSBuZXcgdGhpcy5kYXRhLmNvbnN0cnVjdG9yKG5ld0J1ZmZlclNpemUpO1xuXG4gICAgICAgIC8vIFByZWNvbXB1dGUgc3RyaWRlc1xuICAgICAgICBjb25zdCBzdHJpZGUgPSB0aGlzLnN0cmlkZSgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3QnVmZmVyU2l6ZTsgKytpKSB7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gbmV3RGltcy5sZW5ndGggLSAxLCBudW0gPSBpOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBuZXdEaW1zW2pdO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggKz0gKChudW0gJSBzaXplKSArIG5ld09mZnNldHNbal1bMF0pICogc3RyaWRlW2pdO1xuICAgICAgICAgICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhW2ldID0gdGhpcy5kYXRhW29yaWdpbmFsSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKHRoaXMudHlwZSwgZGF0YSwgbmV3VGVuc29yRGltcyk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB0cmFuc3Bvc2VkIHZlcnNpb24gb2YgdGhpcyBUZW5zb3IsIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgZGltZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0gIHsuLi5udW1iZXJ9IGRpbXMgRGltZW5zaW9ucyB0byB0cmFuc3Bvc2UuXG4gICAgICogQHJldHVybnMge1RlbnNvcn0gVGhlIHRyYW5zcG9zZWQgdGVuc29yLlxuICAgICAqL1xuICAgIHRyYW5zcG9zZSguLi5kaW1zKSB7XG4gICAgICAgIHJldHVybiB0cmFuc3Bvc2UodGhpcywgZGltcyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVuYW1lIHRyYW5zcG9zZSB0byBwZXJtdXRlXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHRyYW5zcG9zZVxuXG4gICAgLy8gVE9ETyBhZGQgLm1heCgpIGFuZCAubWluKCkgbWV0aG9kc1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3VtIG9mIGVhY2ggcm93IG9mIHRoZSBpbnB1dCB0ZW5zb3IgaW4gdGhlIGdpdmVuIGRpbWVuc2lvbiBkaW0uXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaW09bnVsbF0gVGhlIGRpbWVuc2lvbiBvciBkaW1lbnNpb25zIHRvIHJlZHVjZS4gSWYgYG51bGxgLCBhbGwgZGltZW5zaW9ucyBhcmUgcmVkdWNlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBkaW0gV2hldGhlciB0aGUgb3V0cHV0IHRlbnNvciBoYXMgYGRpbWAgcmV0YWluZWQgb3Igbm90LlxuICAgICAqIEByZXR1cm5zIFRoZSBzdW1tZWQgdGVuc29yXG4gICAgICovXG4gICAgc3VtKGRpbSA9IG51bGwsIGtlZXBkaW0gPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtKDEsIGRpbSwga2VlcGRpbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF0cml4IG5vcm0gb3IgdmVjdG9yIG5vcm0gb2YgYSBnaXZlbiB0ZW5zb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbcD0nZnJvJ10gVGhlIG9yZGVyIG9mIG5vcm1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RpbT1udWxsXSBTcGVjaWZpZXMgd2hpY2ggZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IgdG8gY2FsY3VsYXRlIHRoZSBub3JtIGFjcm9zcy5cbiAgICAgKiBJZiBkaW0gaXMgTm9uZSwgdGhlIG5vcm0gd2lsbCBiZSBjYWxjdWxhdGVkIGFjcm9zcyBhbGwgZGltZW5zaW9ucyBvZiBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtrZWVwZGltPWZhbHNlXSBXaGV0aGVyIHRoZSBvdXRwdXQgdGVuc29ycyBoYXZlIGRpbSByZXRhaW5lZCBvciBub3QuXG4gICAgICogQHJldHVybnMge1RlbnNvcn0gVGhlIG5vcm0gb2YgdGhlIHRlbnNvci5cbiAgICAgKi9cbiAgICBub3JtKHAgPSAnZnJvJywgZGltID0gbnVsbCwga2VlcGRpbSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChwID09PSAnZnJvJykge1xuICAgICAgICAgICAgLy8gTk9URTogU2luY2Ugd2Ugb25seSBzdXBwb3J0IGludGVnZXIgZGltcywgRnJvYmVuaXVzIG5vcm0gcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0IGFzIHA9Mi5cbiAgICAgICAgICAgIHAgPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIG5vcm06ICR7cH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGxldCB2YWwgPSB0aGlzLmRhdGEucmVkdWNlKChhLCBiKSA9PiBhICsgKGIgKiogcCksIDApICoqICgxIC8gcCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbnNvcih0aGlzLnR5cGUsIFt2YWxdLCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOZWdhdGl2ZSBpbmRleGluZ1xuICAgICAgICBkaW0gPSBzYWZlSW5kZXgoZGltLCB0aGlzLmRpbXMubGVuZ3RoKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHNoYXBlIG9mIHRoZSByZXN1bHRpbmcgYXJyYXkgYWZ0ZXIgc3VtbWF0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdERpbXMgPSB0aGlzLmRpbXMuc2xpY2UoKTsgLy8gQ29weSB0aGUgb3JpZ2luYWwgZGltZW5zaW9uc1xuICAgICAgICByZXN1bHREaW1zW2RpbV0gPSAxOyAvLyBSZW1vdmUgdGhlIHNwZWNpZmllZCBheGlzXG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIHN0b3JlIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZXNcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IHRoaXMuZGF0YS5jb25zdHJ1Y3Rvcih0aGlzLmRhdGEubGVuZ3RoIC8gdGhpcy5kaW1zW2RpbV0pO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZGF0YSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGluZGV4IGluIHRoZSByZXN1bHRpbmcgYXJyYXlcbiAgICAgICAgICAgIGxldCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpbXMubGVuZ3RoIC0gMSwgbnVtID0gaSwgcmVzdWx0TXVsdGlwbGllciA9IDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZGltc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoaiAhPT0gZGltKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbnVtICUgc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SW5kZXggKz0gaW5kZXggKiByZXN1bHRNdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRNdWx0aXBsaWVyICo9IHJlc3VsdERpbXNbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gc2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHZhbHVlIGF0IHRoZSBjdXJyZW50IGluZGV4XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0SW5kZXhdICs9ICh0aGlzLmRhdGFbaV0pICoqIHA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocCAhPT0gMSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSByZXN1bHRbaV0gKiogKDEgLyBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2VlcGRpbSkge1xuICAgICAgICAgICAgcmVzdWx0RGltcy5zcGxpY2UoZGltLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKHRoaXMudHlwZSwgcmVzdWx0LCByZXN1bHREaW1zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBgTF9wYCBub3JtYWxpemF0aW9uIG9mIGlucHV0cyBvdmVyIHNwZWNpZmllZCBkaW1lbnNpb24uIE9wZXJhdGVzIGluIHBsYWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcD0yXSBUaGUgZXhwb25lbnQgdmFsdWUgaW4gdGhlIG5vcm0gZm9ybXVsYXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RpbT0xXSBUaGUgZGltZW5zaW9uIHRvIHJlZHVjZVxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IGB0aGlzYCBmb3Igb3BlcmF0aW9uIGNoYWluaW5nLlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZV8ocCA9IDIuMCwgZGltID0gMSkge1xuICAgICAgICBkaW0gPSBzYWZlSW5kZXgoZGltLCB0aGlzLmRpbXMubGVuZ3RoKTtcblxuICAgICAgICBjb25zdCBub3JtID0gdGhpcy5ub3JtKHAsIGRpbSwgdHJ1ZSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBpbmRleCBpbiB0aGUgcmVzdWx0aW5nIGFycmF5XG4gICAgICAgICAgICBsZXQgcmVzdWx0SW5kZXggPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gdGhpcy5kaW1zLmxlbmd0aCAtIDEsIG51bSA9IGksIHJlc3VsdE11bHRpcGxpZXIgPSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmRpbXNbal07XG4gICAgICAgICAgICAgICAgaWYgKGogIT09IGRpbSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG51bSAlIHNpemU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEluZGV4ICs9IGluZGV4ICogcmVzdWx0TXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0TXVsdGlwbGllciAqPSB0aGlzLmRpbXNbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gc2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpdmlkZSBieSBub3JtYWxpemVkIHZhbHVlXG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gLz0gbm9ybS5kYXRhW3Jlc3VsdEluZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGBMX3BgIG5vcm1hbGl6YXRpb24gb2YgaW5wdXRzIG92ZXIgc3BlY2lmaWVkIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3A9Ml0gVGhlIGV4cG9uZW50IHZhbHVlIGluIHRoZSBub3JtIGZvcm11bGF0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaW09MV0gVGhlIGRpbWVuc2lvbiB0byByZWR1Y2VcbiAgICAgKiBAcmV0dXJucyB7VGVuc29yfSBUaGUgbm9ybWFsaXplZCB0ZW5zb3IuXG4gICAgICovXG4gICAgbm9ybWFsaXplKHAgPSAyLjAsIGRpbSA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5ub3JtYWxpemVfKHAsIGRpbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBzdHJpZGUgb2YgdGhpcyB0ZW5zb3IuXG4gICAgICogU3RyaWRlIGlzIHRoZSBqdW1wIG5lY2Vzc2FyeSB0byBnbyBmcm9tIG9uZSBlbGVtZW50IHRvIHRoZSBuZXh0IG9uZSBpbiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvbiBkaW0uXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBUaGUgc3RyaWRlIG9mIHRoaXMgdGVuc29yLlxuICAgICAqL1xuICAgIHN0cmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIGRpbXNUb1N0cmlkZSh0aGlzLmRpbXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0ZW5zb3Igd2l0aCBhbGwgc3BlY2lmaWVkIGRpbWVuc2lvbnMgb2YgaW5wdXQgb2Ygc2l6ZSAxIHJlbW92ZWQuXG4gICAgICogXG4gICAgICogTk9URTogVGhlIHJldHVybmVkIHRlbnNvciBzaGFyZXMgdGhlIHN0b3JhZ2Ugd2l0aCB0aGUgaW5wdXQgdGVuc29yLCBzbyBjaGFuZ2luZyB0aGUgY29udGVudHMgb2Ygb25lIHdpbGwgY2hhbmdlIHRoZSBjb250ZW50cyBvZiB0aGUgb3RoZXIuXG4gICAgICogSWYgeW91IHdvdWxkIGxpa2UgYSBjb3B5LCB1c2UgYHRlbnNvci5jbG9uZSgpYCBiZWZvcmUgc3F1ZWV6aW5nLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGltPW51bGxdIElmIGdpdmVuLCB0aGUgaW5wdXQgd2lsbCBiZSBzcXVlZXplZCBvbmx5IGluIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9ucy5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3F1ZWV6ZWQgdGVuc29yXG4gICAgICovXG4gICAgc3F1ZWV6ZShkaW0gPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKFxuICAgICAgICAgICAgdGhpcy50eXBlLFxuICAgICAgICAgICAgdGhpcy5kYXRhLFxuICAgICAgICAgICAgY2FsY19zcXVlZXplX2RpbXModGhpcy5kaW1zLCBkaW0pXG4gICAgICAgIClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbi1wbGFjZSB2ZXJzaW9uIG9mIEBzZWUge0BsaW5rIFRlbnNvci5zcXVlZXplfVxuICAgICAqL1xuICAgIHNxdWVlemVfKGRpbSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY19zcXVlZXplX2RpbXModGhpcy5kaW1zLCBkaW0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHRlbnNvciB3aXRoIGEgZGltZW5zaW9uIG9mIHNpemUgb25lIGluc2VydGVkIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAgICogXG4gICAgICogTk9URTogVGhlIHJldHVybmVkIHRlbnNvciBzaGFyZXMgdGhlIHNhbWUgdW5kZXJseWluZyBkYXRhIHdpdGggdGhpcyB0ZW5zb3IuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpbSBUaGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBzaW5nbGV0b24gZGltZW5zaW9uXG4gICAgICogQHJldHVybnMgVGhlIHVuc3F1ZWV6ZWQgdGVuc29yXG4gICAgICovXG4gICAgdW5zcXVlZXplKGRpbSA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoXG4gICAgICAgICAgICB0aGlzLnR5cGUsXG4gICAgICAgICAgICB0aGlzLmRhdGEsXG4gICAgICAgICAgICBjYWxjX3Vuc3F1ZWV6ZV9kaW1zKHRoaXMuZGltcywgZGltKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluLXBsYWNlIHZlcnNpb24gb2YgQHNlZSB7QGxpbmsgVGVuc29yLnVuc3F1ZWV6ZX1cbiAgICAgKi9cbiAgICB1bnNxdWVlemVfKGRpbSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY191bnNxdWVlemVfZGltcyh0aGlzLmRpbXMsIGRpbSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluLXBsYWNlIHZlcnNpb24gb2YgQHNlZSB7QGxpbmsgVGVuc29yLmZsYXR0ZW59XG4gICAgICovXG4gICAgZmxhdHRlbl8oc3RhcnRfZGltID0gMCwgZW5kX2RpbSA9IC0xKSB7XG4gICAgICAgIC8vIFRPRE8gdmFsaWRhdGUgaW5wdXRzXG4gICAgICAgIGVuZF9kaW0gPSAoZW5kX2RpbSArIHRoaXMuZGltcy5sZW5ndGgpICUgdGhpcy5kaW1zLmxlbmd0aDtcblxuICAgICAgICBsZXQgZGltc1RvS2VlcEJlZm9yZSA9IHRoaXMuZGltcy5zbGljZSgwLCBzdGFydF9kaW0pO1xuICAgICAgICBsZXQgZGltc1RvRmxhdHRlbiA9IHRoaXMuZGltcy5zbGljZShzdGFydF9kaW0sIGVuZF9kaW0gKyAxKTtcbiAgICAgICAgbGV0IGRpbXNUb0tlZXBBZnRlciA9IHRoaXMuZGltcy5zbGljZShlbmRfZGltICsgMSk7XG5cbiAgICAgICAgdGhpcy5kaW1zID0gWy4uLmRpbXNUb0tlZXBCZWZvcmUsIGRpbXNUb0ZsYXR0ZW4ucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSksIC4uLmRpbXNUb0tlZXBBZnRlcl1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgaW5wdXQgYnkgcmVzaGFwaW5nIGl0IGludG8gYSBvbmUtZGltZW5zaW9uYWwgdGVuc29yLlxuICAgICAqIElmIGBzdGFydF9kaW1gIG9yIGBlbmRfZGltYCBhcmUgcGFzc2VkLCBvbmx5IGRpbWVuc2lvbnMgc3RhcnRpbmcgd2l0aCBgc3RhcnRfZGltYFxuICAgICAqIGFuZCBlbmRpbmcgd2l0aCBgZW5kX2RpbWAgYXJlIGZsYXR0ZW5lZC4gVGhlIG9yZGVyIG9mIGVsZW1lbnRzIGluIGlucHV0IGlzIHVuY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRfZGltIHRoZSBmaXJzdCBkaW0gdG8gZmxhdHRlblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRfZGltIHRoZSBsYXN0IGRpbSB0byBmbGF0dGVuXG4gICAgICogQHJldHVybnMgVGhlIGZsYXR0ZW5lZCB0ZW5zb3IuXG4gICAgICovXG4gICAgZmxhdHRlbihzdGFydF9kaW0gPSAwLCBlbmRfZGltID0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5mbGF0dGVuXyhzdGFydF9kaW0sIGVuZF9kaW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgdGVuc29yIHdpdGggdGhlIHNhbWUgZGF0YSBhcyB0aGUgYHNlbGZgIHRlbnNvciBidXQgb2YgYSBkaWZmZXJlbnQgYHNoYXBlYC5cbiAgICAgKiBAcGFyYW0gIHsuLi5udW1iZXJ9IGRpbXMgdGhlIGRlc2lyZWQgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSB0ZW5zb3Igd2l0aCB0aGUgc2FtZSBkYXRhIGJ1dCBkaWZmZXJlbnQgc2hhcGVcbiAgICAgKi9cbiAgICB2aWV3KC4uLmRpbXMpIHtcbiAgICAgICAgLy8gVE9ETzogdmFsaWRhdGUgZGltc1xuICAgICAgICBsZXQgaW5mZXJyZWRJbmRleCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChkaW1zW2ldID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmZlcnJlZEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBkaW1lbnNpb24gY2FuIGJlIGluZmVycmVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmZlcnJlZEluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmZlcnJlZEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gU29tZSBkaW1lbnNpb24gbXVzdCBiZSBpbmZlcnJlZFxuICAgICAgICAgICAgY29uc3QgcHJvZHVjdE90aGVyID0gZGltcy5yZWR1Y2UoKHByb2R1Y3QsIGN1cnIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ICE9PSBpbmZlcnJlZEluZGV4ID8gcHJvZHVjdCAqIGN1cnIgOiBwcm9kdWN0XG4gICAgICAgICAgICB9LCAxKTtcblxuICAgICAgICAgICAgZGltc1tpbmZlcnJlZEluZGV4XSA9IHRoaXMuZGF0YS5sZW5ndGggLyBwcm9kdWN0T3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IodGhpcy50eXBlLCB0aGlzLmRhdGEsIGRpbXMpOyAvLyBOT1RFOiB1c2VzIHNhbWUgdW5kZXJseWluZyBzdG9yYWdlXG4gICAgfVxuXG4gICAgbmVnXygpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IC10aGlzLmRhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5lZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5uZWdfKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIG5lc3RlZCBhcnJheSBvZiBhIGdpdmVuIHR5cGUgYW5kIGRlcHRoIChzZWUgZXhhbXBsZXMpLlxuICogXG4gKiBAZXhhbXBsZVxuICogICBOZXN0QXJyYXk8c3RyaW5nLCAxPjsgLy8gc3RyaW5nW11cbiAqIEBleGFtcGxlXG4gKiAgIE5lc3RBcnJheTxudW1iZXIsIDI+OyAvLyBudW1iZXJbXVtdXG4gKiBAZXhhbXBsZVxuICogICBOZXN0QXJyYXk8c3RyaW5nLCAzPjsgLy8gc3RyaW5nW11bXVtdIGV0Yy5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge251bWJlcn0gRGVwdGhcbiAqIEB0ZW1wbGF0ZSB7bmV2ZXJbXX0gW0FjYz1bXV1cbiAqIEB0eXBlZGVmIHtBY2NbJ2xlbmd0aCddIGV4dGVuZHMgRGVwdGggPyBUIDogTmVzdEFycmF5PFRbXSwgRGVwdGgsIFsuLi5BY2MsIG5ldmVyXT59IE5lc3RBcnJheVxuICovXG5cbi8qKlxuICogUmVzaGFwZXMgYSAxLWRpbWVuc2lvbmFsIGFycmF5IGludG8gYW4gbi1kaW1lbnNpb25hbCBhcnJheSwgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBkaW1lbnNpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHJlc2hhcGUoWzEwICAgICAgICAgICAgICAgICAgICBdLCBbMSAgICAgIF0pOyAvLyBUeXBlOiBudW1iZXJbXSAgICAgIFZhbHVlOiBbMTBdXG4gKiAgIHJlc2hhcGUoWzEsIDIsIDMsIDQgICAgICAgICAgICBdLCBbMiwgMiAgIF0pOyAvLyBUeXBlOiBudW1iZXJbXVtdICAgIFZhbHVlOiBbWzEsIDJdLCBbMywgNF1dXG4gKiAgIHJlc2hhcGUoWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdLCBbMiwgMiwgMl0pOyAvLyBUeXBlOiBudW1iZXJbXVtdW10gIFZhbHVlOiBbW1sxLCAyXSwgWzMsIDRdXSwgW1s1LCA2XSwgWzcsIDhdXV1cbiAqICAgcmVzaGFwZShbMSwgMiwgMywgNCwgNSwgNiwgNywgOF0sIFs0LCAyICAgXSk7IC8vIFR5cGU6IG51bWJlcltdW10gICAgVmFsdWU6IFtbMSwgMl0sIFszLCA0XSwgWzUsIDZdLCBbNywgOF1dXG4gKiBAcGFyYW0ge1RbXX0gZGF0YSBUaGUgaW5wdXQgYXJyYXkgdG8gcmVzaGFwZS5cbiAqIEBwYXJhbSB7RElNfSBkaW1lbnNpb25zIFRoZSB0YXJnZXQgc2hhcGUvZGltZW5zaW9ucy5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUge1tudW1iZXJdfFtudW1iZXIsIG51bWJlcl18W251bWJlciwgbnVtYmVyLCBudW1iZXJdfFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdfSBESU1cbiAqIEByZXR1cm5zIHtOZXN0QXJyYXk8VCwgRElNW1wibGVuZ3RoXCJdPn0gVGhlIHJlc2hhcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiByZXNoYXBlKGRhdGEsIGRpbWVuc2lvbnMpIHtcblxuICAgIGNvbnN0IHRvdGFsRWxlbWVudHMgPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBkaW1lbnNpb25TaXplID0gZGltZW5zaW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcblxuICAgIGlmICh0b3RhbEVsZW1lbnRzICE9PSBkaW1lbnNpb25TaXplKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBjYW5ub3QgcmVzaGFwZSBhcnJheSBvZiBzaXplICR7dG90YWxFbGVtZW50c30gaW50byBzaGFwZSAoJHtkaW1lbnNpb25zfSlgKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICBsZXQgcmVzaGFwZWRBcnJheSA9IGRhdGE7XG5cbiAgICBmb3IgKGxldCBpID0gZGltZW5zaW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNoYXBlZEFycmF5ID0gcmVzaGFwZWRBcnJheS5yZWR1Y2UoKGFjYywgdmFsKSA9PiB7XG4gICAgICAgICAgICBsZXQgbGFzdEFycmF5ID0gYWNjW2FjYy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgaWYgKGxhc3RBcnJheS5sZW5ndGggPCBkaW1lbnNpb25zW2ldKSB7XG4gICAgICAgICAgICAgICAgbGFzdEFycmF5LnB1c2godmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goW3ZhbF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbW11dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzaGFwZWRBcnJheVswXTtcbn1cblxuLyoqXG4gKiBUcmFuc3Bvc2VzIGEgdGVuc29yIGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgYXhlcy5cbiAqIEBwYXJhbSB7YW55fSB0ZW5zb3IgVGhlIGlucHV0IHRlbnNvciB0byB0cmFuc3Bvc2UuXG4gKiBAcGFyYW0ge0FycmF5fSBheGVzIFRoZSBheGVzIHRvIHRyYW5zcG9zZSB0aGUgdGVuc29yIGFsb25nLlxuICogQHJldHVybnMge1RlbnNvcn0gVGhlIHRyYW5zcG9zZWQgdGVuc29yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKHRlbnNvciwgYXhlcykge1xuICAgIGNvbnN0IFt0cmFuc3Bvc2VkRGF0YSwgc2hhcGVdID0gdHJhbnNwb3NlX2RhdGEodGVuc29yLmRhdGEsIHRlbnNvci5kaW1zLCBheGVzKTtcbiAgICByZXR1cm4gbmV3IFRlbnNvcih0ZW5zb3IudHlwZSwgdHJhbnNwb3NlZERhdGEsIHNoYXBlKTtcbn1cblxuXG4vKipcbiAqIEludGVycG9sYXRlcyBhbiBUZW5zb3IgdG8gdGhlIGdpdmVuIHNpemUuXG4gKiBAcGFyYW0ge1RlbnNvcn0gaW5wdXQgVGhlIGlucHV0IHRlbnNvciB0byBpbnRlcnBvbGF0ZS4gRGF0YSBtdXN0IGJlIGNoYW5uZWwtZmlyc3QgKGkuZS4sIFtjLCBoLCB3XSlcbiAqIEBwYXJhbSB7bnVtYmVyW119IHNpemUgVGhlIG91dHB1dCBzaXplIG9mIHRoZSBpbWFnZVxuICogQHBhcmFtIHtzdHJpbmd9IG1vZGUgVGhlIGludGVycG9sYXRpb24gbW9kZVxuICogQHBhcmFtIHtib29sZWFufSBhbGlnbl9jb3JuZXJzIFdoZXRoZXIgdG8gYWxpZ24gY29ybmVycy5cbiAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBpbnRlcnBvbGF0ZWQgdGVuc29yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGUoaW5wdXQsIFtvdXRfaGVpZ2h0LCBvdXRfd2lkdGhdLCBtb2RlID0gJ2JpbGluZWFyJywgYWxpZ25fY29ybmVycyA9IGZhbHNlKSB7XG5cbiAgICAvLyBJbnB1dCBpbWFnZSBkaW1lbnNpb25zXG4gICAgY29uc3QgaW5fY2hhbm5lbHMgPSBpbnB1dC5kaW1zLmF0KC0zKSA/PyAxO1xuICAgIGNvbnN0IGluX2hlaWdodCA9IGlucHV0LmRpbXMuYXQoLTIpO1xuICAgIGNvbnN0IGluX3dpZHRoID0gaW5wdXQuZGltcy5hdCgtMSk7XG5cbiAgICBsZXQgb3V0cHV0ID0gaW50ZXJwb2xhdGVfZGF0YShcbiAgICAgICAgaW5wdXQuZGF0YSxcbiAgICAgICAgW2luX2NoYW5uZWxzLCBpbl9oZWlnaHQsIGluX3dpZHRoXSxcbiAgICAgICAgW291dF9oZWlnaHQsIG91dF93aWR0aF0sXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGFsaWduX2Nvcm5lcnNcbiAgICApO1xuICAgIHJldHVybiBuZXcgVGVuc29yKGlucHV0LnR5cGUsIG91dHB1dCwgW2luX2NoYW5uZWxzLCBvdXRfaGVpZ2h0LCBvdXRfd2lkdGhdKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG1lYW4gcG9vbGluZyBvZiB0aGUgbGFzdCBoaWRkZW4gc3RhdGUgZm9sbG93ZWQgYnkgYSBub3JtYWxpemF0aW9uIHN0ZXAuXG4gKiBAcGFyYW0ge1RlbnNvcn0gbGFzdF9oaWRkZW5fc3RhdGUgVGVuc29yIG9mIHNoYXBlIFtiYXRjaFNpemUsIHNlcUxlbmd0aCwgZW1iZWREaW1dXG4gKiBAcGFyYW0ge1RlbnNvcn0gYXR0ZW50aW9uX21hc2sgVGVuc29yIG9mIHNoYXBlIFtiYXRjaFNpemUsIHNlcUxlbmd0aF1cbiAqIEByZXR1cm5zIHtUZW5zb3J9IFJldHVybnMgYSBuZXcgVGVuc29yIG9mIHNoYXBlIFtiYXRjaFNpemUsIGVtYmVkRGltXS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lYW5fcG9vbGluZyhsYXN0X2hpZGRlbl9zdGF0ZSwgYXR0ZW50aW9uX21hc2spIHtcbiAgICAvLyBsYXN0X2hpZGRlbl9zdGF0ZTogW2JhdGNoU2l6ZSwgc2VxTGVuZ3RoLCBlbWJlZERpbV1cbiAgICAvLyBhdHRlbnRpb25fbWFzazogICAgW2JhdGNoU2l6ZSwgc2VxTGVuZ3RoXVxuXG4gICAgbGV0IHNoYXBlID0gW2xhc3RfaGlkZGVuX3N0YXRlLmRpbXNbMF0sIGxhc3RfaGlkZGVuX3N0YXRlLmRpbXNbMl1dO1xuICAgIGxldCByZXR1cm5lZERhdGEgPSBuZXcgbGFzdF9oaWRkZW5fc3RhdGUuZGF0YS5jb25zdHJ1Y3RvcihzaGFwZVswXSAqIHNoYXBlWzFdKTtcbiAgICBsZXQgW2JhdGNoU2l6ZSwgc2VxTGVuZ3RoLCBlbWJlZERpbV0gPSBsYXN0X2hpZGRlbl9zdGF0ZS5kaW1zO1xuXG4gICAgbGV0IG91dEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoU2l6ZTsgKytpKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBpICogZW1iZWREaW0gKiBzZXFMZW5ndGg7XG5cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBlbWJlZERpbTsgKytrKSB7XG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICAgICAgICAgIGxldCBhdHRuTWFza09mZnNldCA9IGkgKiBzZXFMZW5ndGg7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0MiA9IG9mZnNldCArIGs7XG4gICAgICAgICAgICAvLyBQb29sIG92ZXIgYWxsIHdvcmRzIGluIHNlcXVlbmNlXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNlcUxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5kZXggaW50byBhdHRlbnRpb24gbWFza1xuICAgICAgICAgICAgICAgIGxldCBhdHRuID0gTnVtYmVyKGF0dGVudGlvbl9tYXNrLmRhdGFbYXR0bk1hc2tPZmZzZXQgKyBqXSk7XG5cbiAgICAgICAgICAgICAgICBjb3VudCArPSBhdHRuO1xuICAgICAgICAgICAgICAgIHN1bSArPSBsYXN0X2hpZGRlbl9zdGF0ZS5kYXRhW29mZnNldDIgKyBqICogZW1iZWREaW1dICogYXR0bjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGF2ZyA9IHN1bSAvIGNvdW50O1xuICAgICAgICAgICAgcmV0dXJuZWREYXRhW291dEluZGV4KytdID0gYXZnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUZW5zb3IoXG4gICAgICAgIGxhc3RfaGlkZGVuX3N0YXRlLnR5cGUsXG4gICAgICAgIHJldHVybmVkRGF0YSxcbiAgICAgICAgc2hhcGVcbiAgICApXG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBuZXcgZGltZW5zaW9ucyB3aGVuIHBlcmZvcm1pbmcgYSBzcXVlZXplIG9wZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyW119IGRpbXMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRlbnNvci5cbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfG51bGx9IGRpbSBUaGUgZGltZW5zaW9uKHMpIHRvIHNxdWVlemUuXG4gKiBAcmV0dXJucyBUaGUgbmV3IGRpbWVuc2lvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjYWxjX3NxdWVlemVfZGltcyhkaW1zLCBkaW0pIHtcbiAgICBkaW1zID0gZGltcy5zbGljZSgpO1xuICAgIGlmIChkaW0gPT09IG51bGwpIHtcbiAgICAgICAgZGltcyA9IGRpbXMuZmlsdGVyKChkKSA9PiBkICE9PSAxKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkaW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaW1zW2RpbV0gPT09IDEpIHtcbiAgICAgICAgICAgIGRpbXMuc3BsaWNlKGRpbSwgMSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGltKSkge1xuICAgICAgICBkaW1zID0gZGltcy5maWx0ZXIoKHgsIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB4ICE9PSAxIHx8ICFkaW0uaW5jbHVkZXMoaSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGltcztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIG5ldyBkaW1lbnNpb25zIHdoZW4gcGVyZm9ybWluZyBhbiB1bnNxdWVlemUgb3BlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJbXX0gZGltcyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpbSBUaGUgZGltZW5zaW9uIHRvIHVuc3F1ZWV6ZS5cbiAqIEByZXR1cm5zIFRoZSBuZXcgZGltZW5zaW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGNfdW5zcXVlZXplX2RpbXMoZGltcywgZGltKSB7XG4gICAgLy8gRGltZW5zaW9uIG91dCBvZiByYW5nZSAoZS5nLiwgXCJleHBlY3RlZCB0byBiZSBpbiByYW5nZSBvZiBbLTQsIDNdLCBidXQgZ290IDRcIilcbiAgICAvLyArIDEgc2luY2Ugd2UgYWxsb3cgaW5zZXJ0aW5nIGF0IHRoZSBlbmQgKGkuZS4gZGltID0gLTEpXG4gICAgZGltID0gc2FmZUluZGV4KGRpbSwgZGltcy5sZW5ndGggKyAxKTtcbiAgICBkaW1zID0gZGltcy5zbGljZSgpO1xuICAgIC8vIEluc2VydCAxIGludG8gc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgIGRpbXMuc3BsaWNlKGRpbSwgMCwgMSk7XG4gICAgcmV0dXJuIGRpbXM7XG59XG5cbi8qKlxuICogU2FmZWx5IGNhbGN1bGF0ZSB0aGUgaW5kZXggZm9yIGFuIGFycmF5IG9mIGEgZ2l2ZW4gc2l6ZSwgYWxsb3dpbmcgbmVnYXRpdmUgaW5kZXhpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRoYXQgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgVGhlIHNpemUgb2YgdGhlIGFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtkaW1lbnNpb249bnVsbF0gVGhlIGRpbWVuc2lvbiB0aGF0IHRoZSBpbmRleCBpcyBmb3IgKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCwgZ3VhcmFudGVlZCB0byBiZSBub24tbmVnYXRpdmUgYW5kIGxlc3MgdGhhbiBgYXJyYXlMZW5ndGhgLlxuICogXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhZmVJbmRleChpbmRleCwgc2l6ZSwgZGltZW5zaW9uID0gbnVsbCkge1xuICAgIGlmIChpbmRleCA8IC1zaXplIHx8IGluZGV4ID49IHNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmRleEVycm9yOiBpbmRleCAke2luZGV4fSBpcyBvdXQgb2YgYm91bmRzIGZvciBkaW1lbnNpb24ke2RpbWVuc2lvbiA9PT0gbnVsbCA/ICcnIDogJyAnICsgZGltZW5zaW9ufSB3aXRoIHNpemUgJHtzaXplfWApO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgLy8gTmVnYXRpdmUgaW5kZXhpbmcsIGVuc3VyaW5nIHBvc2l0aXZlIGluZGV4XG4gICAgICAgIGluZGV4ID0gKChpbmRleCAlIHNpemUpICsgc2l6ZSkgJSBzaXplO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG59XG5cbi8qKlxuICogQ29uY2F0ZW5hdGVzIGFuIGFycmF5IG9mIHRlbnNvcnMgYWxvbmcgYSBzcGVjaWZpZWQgZGltZW5zaW9uLlxuICogQHBhcmFtIHtUZW5zb3JbXX0gdGVuc29ycyBUaGUgYXJyYXkgb2YgdGVuc29ycyB0byBjb25jYXRlbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaW0gVGhlIGRpbWVuc2lvbiB0byBjb25jYXRlbmF0ZSBhbG9uZy5cbiAqIEByZXR1cm5zIHtUZW5zb3J9IFRoZSBjb25jYXRlbmF0ZWQgdGVuc29yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2F0KHRlbnNvcnMsIGRpbSA9IDApIHtcbiAgICBkaW0gPSBzYWZlSW5kZXgoZGltLCB0ZW5zb3JzWzBdLmRpbXMubGVuZ3RoKTtcblxuICAgIC8vIFRPRE8gZG8gdmFsaWRhdGlvbiBvZiBzaGFwZXNcblxuICAgIGNvbnN0IHJlc3VsdERpbXMgPSB0ZW5zb3JzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICByZXN1bHREaW1zW2RpbV0gPSB0ZW5zb3JzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIuZGltc1tkaW1dLCAwKTtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBzdG9yZSB0aGUgYWNjdW11bGF0ZWQgdmFsdWVzXG4gICAgY29uc3QgcmVzdWx0U2l6ZSA9IHJlc3VsdERpbXMucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IHRlbnNvcnNbMF0uZGF0YS5jb25zdHJ1Y3RvcihyZXN1bHRTaXplKTtcblxuICAgIC8vIENyZWF0ZSBvdXRwdXQgdGVuc29yIG9mIHNhbWUgdHlwZSBhcyBmaXJzdFxuICAgIGNvbnN0IHJlc3VsdFR5cGUgPSB0ZW5zb3JzWzBdLnR5cGU7XG5cbiAgICBpZiAoZGltID09PSAwKSB7XG4gICAgICAgIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2UgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcblxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgdCBvZiB0ZW5zb3JzKSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0KHQuZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0LmRhdGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGxldCBjdXJyZW50RGltID0gMDtcblxuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRlbnNvcnMubGVuZ3RoOyArK3QpIHtcbiAgICAgICAgICAgIGxldCB0ZW5zb3IgPSB0ZW5zb3JzW3RdO1xuXG4gICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGRhdGEgYXJyYXlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVuc29yLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGluZGV4IGluIHRoZSByZXN1bHRpbmcgYXJyYXlcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0SW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRlbnNvci5kaW1zLmxlbmd0aCAtIDEsIG51bSA9IGksIHJlc3VsdE11bHRpcGxpZXIgPSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gdGVuc29yLmRpbXNbal07XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IG51bSAlIHNpemU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09PSBkaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IGN1cnJlbnREaW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SW5kZXggKz0gaW5kZXggKiByZXN1bHRNdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRNdWx0aXBsaWVyICo9IHJlc3VsdERpbXNbal07XG4gICAgICAgICAgICAgICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gc2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHZhbHVlIGF0IHRoZSBjdXJyZW50IGluZGV4XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdEluZGV4XSA9IHRlbnNvci5kYXRhW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50RGltICs9IHRlbnNvci5kaW1zW2RpbV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZW5zb3IocmVzdWx0VHlwZSwgcmVzdWx0LCByZXN1bHREaW1zKTtcbn1cblxuLyoqXG4gKiBTdGFjayBhbiBhcnJheSBvZiB0ZW5zb3JzIGFsb25nIGEgc3BlY2lmaWVkIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSB7VGVuc29yW119IHRlbnNvcnMgVGhlIGFycmF5IG9mIHRlbnNvcnMgdG8gc3RhY2suXG4gKiBAcGFyYW0ge251bWJlcn0gZGltIFRoZSBkaW1lbnNpb24gdG8gc3RhY2sgYWxvbmcuXG4gKiBAcmV0dXJucyB7VGVuc29yfSBUaGUgc3RhY2tlZCB0ZW5zb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFjayh0ZW5zb3JzLCBkaW0gPSAwKSB7XG4gICAgLy8gVE9ETyBkbyB2YWxpZGF0aW9uIG9mIHNoYXBlc1xuICAgIC8vIE5PVEU6IHN0YWNrIGV4cGVjdHMgZWFjaCB0ZW5zb3IgdG8gYmUgZXF1YWwgc2l6ZVxuICAgIHJldHVybiBjYXQodGVuc29ycy5tYXAodCA9PiB0LnVuc3F1ZWV6ZShkaW0pKSwgZGltKTtcbn1cblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBhbmQgbWVhbiBvdmVyIHRoZSBkaW1lbnNpb25zIHNwZWNpZmllZCBieSBkaW0uIGRpbSBjYW4gYmUgYSBzaW5nbGUgZGltZW5zaW9uIG9yIGBudWxsYCB0byByZWR1Y2Ugb3ZlciBhbGwgZGltZW5zaW9ucy5cbiAqIEBwYXJhbSB7VGVuc29yfSBpbnB1dCB0aGUgaW5wdXQgdGVuc29cbiAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IGRpbSB0aGUgZGltZW5zaW9uIHRvIHJlZHVjZS4gSWYgTm9uZSwgYWxsIGRpbWVuc2lvbnMgYXJlIHJlZHVjZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY29ycmVjdGlvbiBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHNhbXBsZSBzaXplIGFuZCBzYW1wbGUgZGVncmVlcyBvZiBmcmVlZG9tLiBEZWZhdWx0cyB0byBCZXNzZWwncyBjb3JyZWN0aW9uLCBjb3JyZWN0aW9uPTEuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBkaW0gd2hldGhlciB0aGUgb3V0cHV0IHRlbnNvciBoYXMgZGltIHJldGFpbmVkIG9yIG5vdC5cbiAqIEByZXR1cm5zIHtUZW5zb3JbXX0gQSB0dXBsZSBvZiAoc3RkLCBtZWFuKSB0ZW5zb3JzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RkX21lYW4oaW5wdXQsIGRpbSA9IG51bGwsIGNvcnJlY3Rpb24gPSAxLCBrZWVwZGltID0gZmFsc2UpIHtcblxuICAgIGlmIChkaW0gPT09IG51bGwpIHtcbiAgICAgICAgLy8gTm9uZSB0byByZWR1Y2Ugb3ZlciBhbGwgZGltZW5zaW9ucy5cbiAgICAgICAgY29uc3Qgc3VtID0gaW5wdXQuZGF0YS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICAgICAgY29uc3QgbWVhbiA9IHN1bSAvIGlucHV0LmRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdGQgPSBNYXRoLnNxcnQoaW5wdXQuZGF0YS5yZWR1Y2UoKGEsIGIpID0+IGEgKyAoYiAtIG1lYW4pICoqIDIsIDApIC8gKGlucHV0LmRhdGEubGVuZ3RoIC0gY29ycmVjdGlvbikpO1xuXG4gICAgICAgIGNvbnN0IG1lYW5UZW5zb3IgPSBuZXcgVGVuc29yKGlucHV0LnR5cGUsIFttZWFuXSwgWy8qIHNjYWxhciAqL10pO1xuICAgICAgICBjb25zdCBzdGRUZW5zb3IgPSBuZXcgVGVuc29yKGlucHV0LnR5cGUsIFtzdGRdLCBbLyogc2NhbGFyICovXSk7XG5cbiAgICAgICAgcmV0dXJuIFtzdGRUZW5zb3IsIG1lYW5UZW5zb3JdO1xuICAgIH1cblxuICAgIC8vIE5lZ2F0aXZlIGluZGV4aW5nXG4gICAgZGltID0gc2FmZUluZGV4KGRpbSwgaW5wdXQuZGltcy5sZW5ndGgpO1xuXG4gICAgY29uc3QgbWVhblRlbnNvciA9IG1lYW4oaW5wdXQsIGRpbSwga2VlcGRpbSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHNoYXBlIG9mIHRoZSByZXN1bHRpbmcgYXJyYXkgYWZ0ZXIgc3VtbWF0aW9uXG4gICAgY29uc3QgcmVzdWx0RGltcyA9IGlucHV0LmRpbXMuc2xpY2UoKTsgLy8gQ29weSB0aGUgb3JpZ2luYWwgZGltZW5zaW9uc1xuICAgIHJlc3VsdERpbXNbZGltXSA9IDE7IC8vIFJlbW92ZSB0aGUgc3BlY2lmaWVkIGF4aXNcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byBzdG9yZSB0aGUgYWNjdW11bGF0ZWQgdmFsdWVzXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IGlucHV0LmRhdGEuY29uc3RydWN0b3IoaW5wdXQuZGF0YS5sZW5ndGggLyBpbnB1dC5kaW1zW2RpbV0pO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkYXRhIGFycmF5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5kYXRhLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBpbmRleCBpbiB0aGUgcmVzdWx0aW5nIGFycmF5XG4gICAgICAgIGxldCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IGlucHV0LmRpbXMubGVuZ3RoIC0gMSwgbnVtID0gaSwgcmVzdWx0TXVsdGlwbGllciA9IDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gaW5wdXQuZGltc1tqXTtcbiAgICAgICAgICAgIGlmIChqICE9PSBkaW0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG51bSAlIHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0SW5kZXggKz0gaW5kZXggKiByZXN1bHRNdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgIHJlc3VsdE11bHRpcGxpZXIgKj0gcmVzdWx0RGltc1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB2YWx1ZSBhdCB0aGUgY3VycmVudCBpbmRleFxuICAgICAgICByZXN1bHRbcmVzdWx0SW5kZXhdICs9IChpbnB1dC5kYXRhW2ldIC0gbWVhblRlbnNvci5kYXRhW3Jlc3VsdEluZGV4XSkgKiogMjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgICByZXN1bHRbaV0gPSBNYXRoLnNxcnQocmVzdWx0W2ldIC8gKGlucHV0LmRpbXNbZGltXSAtIGNvcnJlY3Rpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoIWtlZXBkaW0pIHtcbiAgICAgICAgcmVzdWx0RGltcy5zcGxpY2UoZGltLCAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGRUZW5zb3IgPSBuZXcgVGVuc29yKGlucHV0LnR5cGUsIHJlc3VsdCwgcmVzdWx0RGltcyk7XG5cbiAgICByZXR1cm4gW3N0ZFRlbnNvciwgbWVhblRlbnNvcl07XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtZWFuIHZhbHVlIG9mIGVhY2ggcm93IG9mIHRoZSBpbnB1dCB0ZW5zb3IgaW4gdGhlIGdpdmVuIGRpbWVuc2lvbiBkaW0uXG4gKiBAcGFyYW0ge1RlbnNvcn0gaW5wdXQgdGhlIGlucHV0IHRlbnNvci5cbiAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IGRpbSB0aGUgZGltZW5zaW9uIHRvIHJlZHVjZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcGRpbSB3aGV0aGVyIHRoZSBvdXRwdXQgdGVuc29yIGhhcyBkaW0gcmV0YWluZWQgb3Igbm90LlxuICogQHJldHVybnMgQSBuZXcgdGVuc29yIHdpdGggbWVhbnMgdGFrZW4gYWxvbmcgdGhlIHNwZWNpZmllZCBkaW1lbnNpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWFuKGlucHV0LCBkaW0gPSBudWxsLCBrZWVwZGltID0gZmFsc2UpIHtcblxuICAgIGlmIChkaW0gPT09IG51bGwpIHtcbiAgICAgICAgLy8gTm9uZSB0byByZWR1Y2Ugb3ZlciBhbGwgZGltZW5zaW9ucy5cbiAgICAgICAgbGV0IHZhbCA9IGlucHV0LmRhdGEucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKGlucHV0LnR5cGUsIFt2YWwgLyBpbnB1dC5kYXRhLmxlbmd0aF0sIFsvKiBzY2FsYXIgKi9dKTtcbiAgICB9XG5cbiAgICAvLyBOZWdhdGl2ZSBpbmRleGluZ1xuICAgIGRpbSA9IHNhZmVJbmRleChkaW0sIGlucHV0LmRpbXMubGVuZ3RoKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc2hhcGUgb2YgdGhlIHJlc3VsdGluZyBhcnJheSBhZnRlciBzdW1tYXRpb25cbiAgICBjb25zdCByZXN1bHREaW1zID0gaW5wdXQuZGltcy5zbGljZSgpOyAvLyBDb3B5IHRoZSBvcmlnaW5hbCBkaW1lbnNpb25zXG4gICAgcmVzdWx0RGltc1tkaW1dID0gMTsgLy8gUmVtb3ZlIHRoZSBzcGVjaWZpZWQgYXhpc1xuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIHN0b3JlIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZXNcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgaW5wdXQuZGF0YS5jb25zdHJ1Y3RvcihpbnB1dC5kYXRhLmxlbmd0aCAvIGlucHV0LmRpbXNbZGltXSk7XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGRhdGEgYXJyYXlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0LmRhdGEubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGluZGV4IGluIHRoZSByZXN1bHRpbmcgYXJyYXlcbiAgICAgICAgbGV0IHJlc3VsdEluZGV4ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBqID0gaW5wdXQuZGltcy5sZW5ndGggLSAxLCBudW0gPSBpLCByZXN1bHRNdWx0aXBsaWVyID0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBpbnB1dC5kaW1zW2pdO1xuICAgICAgICAgICAgaWYgKGogIT09IGRpbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbnVtICUgc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRJbmRleCArPSBpbmRleCAqIHJlc3VsdE11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgcmVzdWx0TXVsdGlwbGllciAqPSByZXN1bHREaW1zW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIHZhbHVlIGF0IHRoZSBjdXJyZW50IGluZGV4XG4gICAgICAgIHJlc3VsdFtyZXN1bHRJbmRleF0gKz0gaW5wdXQuZGF0YVtpXTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQuZGltc1tkaW1dICE9PSAxKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSByZXN1bHRbaV0gLyBpbnB1dC5kaW1zW2RpbV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWtlZXBkaW0pIHtcbiAgICAgICAgcmVzdWx0RGltcy5zcGxpY2UoZGltLCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRlbnNvcihpbnB1dC50eXBlLCByZXN1bHQsIHJlc3VsdERpbXMpO1xufVxuXG5cbi8qKlxuICpcbiAqIE1lYXN1cmVzIHNpbWlsYXJpdHkgYmV0d2VlbiB0d28gdGVtcG9yYWwgc2VxdWVuY2VzIChlLmcuLCBpbnB1dCBhdWRpbyBhbmQgb3V0cHV0IHRva2Vuc1xuICogdG8gZ2VuZXJhdGUgdG9rZW4tbGV2ZWwgdGltZXN0YW1wcykuXG4gKiBAcGFyYW0ge1RlbnNvcn0gbWF0cml4IFxuICogQHJldHVybnMge251bWJlcltdW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkeW5hbWljVGltZVdhcnBpbmcobWF0cml4KSB7XG4gICAgY29uc3QgW291dHB1dF9sZW5ndGgsIGlucHV0X2xlbmd0aF0gPSBtYXRyaXguZGltcztcblxuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gW291dHB1dF9sZW5ndGggKyAxLCBpbnB1dF9sZW5ndGggKyAxXTtcblxuICAgIGNvbnN0IGNvc3QgPSBuZXcgVGVuc29yKFxuICAgICAgICAnZmxvYXQzMicsXG4gICAgICAgIG5ldyBGbG9hdDMyQXJyYXkob3V0cHV0U2hhcGVbMF0gKiBvdXRwdXRTaGFwZVsxXSkuZmlsbChJbmZpbml0eSksXG4gICAgICAgIG91dHB1dFNoYXBlXG4gICAgKTtcblxuICAgIGNvbnN0IHRyYWNlID0gbmV3IFRlbnNvcihcbiAgICAgICAgJ2Zsb2F0MzInLFxuICAgICAgICBuZXcgRmxvYXQzMkFycmF5KG91dHB1dFNoYXBlWzBdICogb3V0cHV0U2hhcGVbMV0pLmZpbGwoLTEpLFxuICAgICAgICBvdXRwdXRTaGFwZVxuICAgIClcblxuICAgIC8vIHNhbWUgYXMgYGNvc3RbMF1bMF0gPSAwYDtcbiAgICBjb3N0WzBdLmRhdGFbMF0gPSAwO1xuXG4gICAgZm9yIChsZXQgaiA9IDE7IGogPCBpbnB1dF9sZW5ndGggKyAxOyArK2opIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBvdXRwdXRfbGVuZ3RoICsgMTsgKytpKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGMwID0gY29zdFtpIC0gMV1baiAtIDFdLml0ZW0oKTtcbiAgICAgICAgICAgIGNvbnN0IGMxID0gY29zdFtpIC0gMV1bal0uaXRlbSgpO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBjb3N0W2ldW2ogLSAxXS5pdGVtKCk7XG5cbiAgICAgICAgICAgIGxldCBjLCB0O1xuICAgICAgICAgICAgaWYgKGMwIDwgYzEgJiYgYzAgPCBjMikge1xuICAgICAgICAgICAgICAgIGMgPSBjMDtcbiAgICAgICAgICAgICAgICB0ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYzEgPCBjMCAmJiBjMSA8IGMyKSB7XG4gICAgICAgICAgICAgICAgYyA9IGMxO1xuICAgICAgICAgICAgICAgIHQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjID0gYzI7XG4gICAgICAgICAgICAgICAgdCA9IDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvc3RbaV0uZGF0YVtqXSA9IG1hdHJpeFtpIC0gMV1baiAtIDFdLml0ZW0oKSArIGM7XG4gICAgICAgICAgICB0cmFjZVtpXS5kYXRhW2pdID0gdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJhY2t0cmFjZVxuICAgIGxldCBpID0gb3V0cHV0X2xlbmd0aDtcbiAgICBsZXQgaiA9IGlucHV0X2xlbmd0aDtcblxuICAgIHRyYWNlLmRhdGEuZmlsbCgyLCAwLCBvdXRwdXRTaGFwZVsxXSkgLy8gdHJhY2VbMCwgOl0gPSAyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRTaGFwZVswXTsgKytpKSB7IC8vIHRyYWNlWzosIDBdID0gMVxuICAgICAgICB0cmFjZVtpXS5kYXRhWzBdID0gMTtcbiAgICB9XG5cbiAgICBsZXQgdGV4dF9pbmRpY2VzID0gW107XG4gICAgbGV0IHRpbWVfaW5kaWNlcyA9IFtdO1xuXG4gICAgd2hpbGUgKGkgPiAwIHx8IGogPiAwKSB7XG4gICAgICAgIHRleHRfaW5kaWNlcy5wdXNoKGkgLSAxKTtcbiAgICAgICAgdGltZV9pbmRpY2VzLnB1c2goaiAtIDEpO1xuXG4gICAgICAgIGNvbnN0IHQgPSB0cmFjZVtpXVtqXS5pdGVtKCk7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIC0taTsgLS1qO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYEludGVybmFsIGVycm9yIGluIGR5bmFtaWMgdGltZSB3YXJwaW5nLiBVbmV4cGVjdGVkIHRyYWNlWyR7aX0sICR7an1dLiBQbGVhc2UgZmlsZSBhIGJ1ZyByZXBvcnQuYFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRleHRfaW5kaWNlcy5yZXZlcnNlKCk7XG4gICAgdGltZV9pbmRpY2VzLnJldmVyc2UoKTtcblxuICAgIHJldHVybiBbdGV4dF9pbmRpY2VzLCB0aW1lX2luZGljZXNdO1xuXG59XG5cbmZ1bmN0aW9uIGRpbXNUb1N0cmlkZShkaW1zKSB7XG4gICAgY29uc3Qgc3RyaWRlID0gbmV3IEFycmF5KGRpbXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gZGltcy5sZW5ndGggLSAxLCBzMiA9IDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHN0cmlkZVtpXSA9IHMyO1xuICAgICAgICBzMiAqPSBkaW1zW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaWRlO1xufVxuIiwiLy8gYmFja2dyb3VuZC5qcyAtIEhhbmRsZXMgcmVxdWVzdHMgZnJvbSB0aGUgVUksIHJ1bnMgdGhlIG1vZGVsLCB0aGVuIHNlbmRzIGJhY2sgYSByZXNwb25zZVxuXG5pbXBvcnQge3ByZXR0eUxvZywgZ2V0U2l0ZUlEfSBmcm9tICcuLi91dGlscy91dGlscy5qcyc7XG5pbXBvcnQge3NpbWlsYXJpdHksIHN0b3JlRW1iZWRkaW5ncywgbG9hZEVtYmVkZGluZ3N9IGZyb20gXCIuL3NlbWFudGljLmpzXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gMS4gQ29udGV4dCBNZW51cyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuLy8gQWRkIGEgbGlzdGVuZXIgdG8gY3JlYXRlIHRoZSBpbml0aWFsIGNvbnRleHQgbWVudSBpdGVtcyxcbi8vIGNvbnRleHQgbWVudSBpdGVtcyBvbmx5IG5lZWQgdG8gYmUgY3JlYXRlZCBhdCBydW50aW1lLm9uSW5zdGFsbGVkXG4vLyBjaHJvbWUucnVudGltZS5vbkluc3RhbGxlZC5hZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XG4vLyBSZWdpc3RlciBhIGNvbnRleHQgbWVudSBpdGVtIHRoYXQgd2lsbCBvbmx5IHNob3cgdXAgZm9yIHNlbGVjdGlvbiB0ZXh0LlxuLy8gY2hyb21lLmNvbnRleHRNZW51cy5jcmVhdGUoe1xuLy8gICAgIGlkOiAnY2xhc3NpZnktc2VsZWN0aW9uJyxcbi8vICAgICB0aXRsZTogJ0NsYXNzaWZ5IFwiJXNcIicsXG4vLyAgICAgY29udGV4dHM6IFsnc2VsZWN0aW9uJ10sXG4vLyB9KTtcbi8vIH0pO1xuLy9cbi8vIFBlcmZvcm0gaW5mZXJlbmNlIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGEgY29udGV4dCBtZW51XG4vLyBjaHJvbWUuY29udGV4dE1lbnVzLm9uQ2xpY2tlZC5hZGRMaXN0ZW5lcihhc3luYyAoaW5mbywgdGFiKSA9PiB7XG4vLyBJZ25vcmUgY29udGV4dCBtZW51IGNsaWNrcyB0aGF0IGFyZSBub3QgZm9yIGNsYXNzaWZpY2F0aW9ucyAob3Igd2hlbiB0aGVyZSBpcyBubyBpbnB1dClcbi8vIGlmIChpbmZvLm1lbnVJdGVtSWQgIT09ICdjbGFzc2lmeS1zZWxlY3Rpb24nIHx8ICFpbmZvLnNlbGVjdGlvblRleHQpIHJldHVybjtcbi8vXG4vLyBQZXJmb3JtIGNsYXNzaWZpY2F0aW9uIG9uIHRoZSBzZWxlY3RlZCB0ZXh0XG4vLyBsZXQgcmVzdWx0ID0gYXdhaXQgY2xhc3NpZnkoaW5mby5zZWxlY3Rpb25UZXh0KTtcbi8vXG4vLyBEbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4vLyBjaHJvbWUuc2NyaXB0aW5nLmV4ZWN1dGVTY3JpcHQoXG4vL1xuLy8gICAgIHtcbi8vICAgICB0YXJnZXQ6IHsgdGFiSWQ6IHRhYi5pZCB9LCAgICAvLyBSdW4gaW4gdGhlIHRhYiB0aGF0IHRoZSB1c2VyIGNsaWNrZWQgaW5cbi8vICAgICBhcmdzOiBbcmVzdWx0XSwgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uXG4vLyAgICAgZnVuY3Rpb246IChyZXN1bHQpID0+IHsgICAgICAgLy8gVGhlIGZ1bmN0aW9uIHRvIHJ1blxuLy8gICAgICAgICAvLyBOT1RFOiBUaGlzIGZ1bmN0aW9uIGlzIHJ1biBpbiB0aGUgY29udGV4dCBvZiB0aGUgd2ViIHBhZ2UsIG1lYW5pbmcgdGhhdCBgZG9jdW1lbnRgIGlzIGF2YWlsYWJsZS5cbi8vICAgICAgICAgY29uc29sZS5sb2coJ3Jlc3VsdCcsIHJlc3VsdClcbi8vICAgICAgICAgY29uc29sZS5sb2coJ2RvY3VtZW50JywgZG9jdW1lbnQpXG4vLyAgICAgfSxcbi8vIH1cbi8vICk7XG4vLyB9KTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gMi4gTWVzc2FnZSBFdmVudHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuLy8gTGlzdGVuIGZvciBtZXNzYWdlcyBmcm9tIHRoZSBVSSwgcHJvY2VzcyBpdCwgYW5kIHNlbmQgdGhlIHJlc3VsdCBiYWNrLlxuXG4vLyBUT0RPOiBib2R5IHRleHQgaXMgbm90IHBlcnNpc3RlbnRcbmxldCBib2R5VGV4dCA9IFtdO1xubGV0IGlucHV0VGV4dCA9IFwiXCI7XG5cbmxldCBsaXZlUHJvY2VzcyA9IDA7XG5sZXQgY3VyclNpdGUgPSBcIlwiO1xuXG5jaHJvbWUucnVudGltZS5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoYXN5bmMgZnVuY3Rpb24gKHJlcXVlc3QsIHNlbmRlciwgc2VuZFJlc3BvbnNlKSB7XG4gICAgaWYgKHJlcXVlc3QudHlwZSA9PT0gXCJ0YWJVcGRhdGVkXCIpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QudGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBib2R5VGV4dCA9IHJlcXVlc3QudGV4dDtcbiAgICAgICAgICAgIGN1cnJTaXRlID0gZ2V0U2l0ZUlEKHJlcXVlc3QuY3VycmVudFVSTCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QudHlwZSA9PT0gXCJpbnB1dFRleHRcIikge1xuICAgICAgICBpbnB1dFRleHQgPSByZXF1ZXN0LnRleHQ7XG4gICAgfSBlbHNlIHtyZXR1cm47IH1cbiAgICBpZiAoIWJvZHlUZXh0IHx8ICFpbnB1dFRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxpdmVQcm9jZXNzKys7XG4gICAgY29uc3QgcHJvY2Vzc0lkID0gbGl2ZVByb2Nlc3M7XG5cbiAgICBhd2FpdCBwcm9jZXNzUXVlcnkoaW5wdXRUZXh0LCBib2R5VGV4dCwgcHJvY2Vzc0lkKTtcbn0pO1xuXG5cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NRdWVyeShxdWVyeSwgYm9keVRleHQsIHByb2Nlc3NJZCkge1xuICAgIGlmIChib2R5VGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcHJldHR5TG9nKFwiRXJyb3JcIiwgXCJubyBjb250ZW50IGZvdW5kLiBwbGVhc2UgcmVsb2FkIHRoaXMgcGFnZSBpZiB0aGlzIGlzIHVuZXhwZWN0ZWRcIiwgXCJyZWRcIik7XG4gICAgICAgIGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlKHt0eXBlOiBcImVycm9yXCIsIHJlYXNvbjogXCJObyBjb250ZW50IGRldGVjdGVkLiBSZWxvYWRpbmcgbWF5IGhlbHAuXCJ9KTtcbiAgICAgICAgcmV0dXJuOyAgLy8gRXhpdCBlYXJseSBpZiBubyBib2R5VGV4dFxuICAgIH1cblxuICAgIGF3YWl0IGxvYWRFbWJlZGRpbmdzKGN1cnJTaXRlKTtcbiAgICBwcmV0dHlMb2coXCJzdGFydGluZyBwcm9jZXNzIFwiICsgcHJvY2Vzc0lkLCBib2R5VGV4dC5sZW5ndGggKyBcIiBpdGVtc1wiLCBcIm9yYW5nZVwiKTtcblxuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgY29uc3QgayA9IDEwO1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHRleHQgb2YgYm9keVRleHQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3NJZCAhPT0gbGl2ZVByb2Nlc3MpIHsgcmV0dXJuO31cbiAgICAgICAgbGV0IHNpbSA9IGF3YWl0IHNpbWlsYXJpdHkocXVlcnksIHRleHQpO1xuXG4gICAgICAgIGlmIChzaW0gPiAwLjE1KSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe3NpbTogc2ltLCB0ZXh0OiB0ZXh0fSk7XG4gICAgICAgICAgICByZXN1bHRzLnNvcnQoKGEsIGIpID0+IGIuc2ltIC0gYS5zaW0pO1xuICAgICAgICAgICAgcmVzdWx0cy5sZW5ndGggPSBNYXRoLm1pbihyZXN1bHRzLmxlbmd0aCwgayk7XG5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzSWQgIT09IGxpdmVQcm9jZXNzKSB7IHJldHVybjt9XG4gICAgICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZXN1bHRzXCIsIHByb2dyZXNzOiAxMDAgKiAoaSAvIGJvZHlUZXh0Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgdGV4dDogcmVzdWx0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgIH1cbiAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7dHlwZTogXCJyZXN1bHRzXCIsIHByb2dyZXNzOiAxMDB9KTtcbiAgICBhd2FpdCBzdG9yZUVtYmVkZGluZ3MoKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuIiwiLy8gRGVmaW5lIGNhY2hpbmcgcGFyYW1ldGVyc1xuaW1wb3J0IHtDdXN0b21DYWNoZX0gZnJvbSBcIi4uL3V0aWxzL2NhY2hlLmpzXCI7XG5pbXBvcnQge3BpcGVsaW5lLCBlbnZ9IGZyb20gJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJztcbmltcG9ydCB7cHJldHR5TG9nfSBmcm9tIFwiLi4vdXRpbHMvdXRpbHMuanNcIjtcblxuZW52LnVzZUJyb3dzZXJDYWNoZSA9IGZhbHNlO1xuZW52LnVzZUN1c3RvbUNhY2hlID0gdHJ1ZTtcbmVudi5jdXN0b21DYWNoZSA9IG5ldyBDdXN0b21DYWNoZSgndHJhbnNmb3JtZXJzLWNhY2hlJyk7XG5lbnYuYWxsb3dMb2NhbE1vZGVscyA9IGZhbHNlO1xuXG5cbi8vIER1ZSB0byBhIGJ1ZyBpbiBvbm54cnVudGltZS13ZWIsIHdlIG11c3QgZGlzYWJsZSBtdWx0aXRocmVhZGluZyBmb3Igbm93LlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvaXNzdWVzLzE0NDQ1IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuZW52LmJhY2tlbmRzLm9ubngud2FzbS5udW1UaHJlYWRzID0gMTtcblxuLy8gdGhlc2Ugc2hvdWxkIGdvIGluIEVtYmVkUGlwZWxpbmUgcHJvYlxubGV0IGVtYmVkZGluZ3NEaWN0ID0ge307XG5sZXQgY3VycklEID0gXCJcIjtcblxuY2xhc3MgRW1iZWRQaXBlbGluZSB7XG4gICAgc3RhdGljIHRhc2sgPSAnZmVhdHVyZS1leHRyYWN0aW9uJztcbiAgICBzdGF0aWMgbW9kZWwgPSAnWGVub3ZhL2Rpc3RpbHVzZS1iYXNlLW11bHRpbGluZ3VhbC1jYXNlZC12Mic7XG4gICAgc3RhdGljIGluc3RhbmNlID0gbnVsbDtcblxuICAgIHN0YXRpYyBhc3luYyBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgPT09IG51bGwpIHsgLy8gbm8gYXdhaXQ/XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gYXdhaXQgcGlwZWxpbmUodGhpcy50YXNrLCB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NfY2FsbGJhY2s6IGFzeW5jIGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2Uoe3R5cGU6IFwiZG93bmxvYWRcIiwgZGF0YTogZGF0YX0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSh7dHlwZTogXCJkb3dubG9hZFwiLCBkYXRhOiB7c3RhdHVzOiBcImNvbXBsZXRlXCJ9fSlcblxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICB9XG59XG5cbi8vIEltcG9ydGFudDogUmV0dXJuIHRydWUgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcmVzcG9uc2UgaXMgYXN5bmNocm9ub3VzLlxuY2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKGFzeW5jIChyZXF1ZXN0LCBzZW5kZXIsIHNlbmRSZXNwb25zZSkgPT4ge1xuICAgIHN3aXRjaCAocmVxdWVzdC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJsb2FkXCI6XG4gICAgICAgICAgICBhd2FpdCBsb2FkKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNsZWFyTG9jYWxTdG9yYWdlXCI6XG4gICAgICAgICAgICBjaHJvbWUuc3RvcmFnZS5sb2NhbC5jbGVhcigoKSA9PiB7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicHJ1bmVFbWJlZGRpbmdzXCI6XG4gICAgICAgICAgICBhd2FpdCBwcnVuZVN0b3JlZEVtYmVkZGluZ3MoMTApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufSk7XG5cblxuYXN5bmMgZnVuY3Rpb24gbG9hZCgpIHtcbiAgICBhd2FpdCBFbWJlZFBpcGVsaW5lLmdldEluc3RhbmNlKCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVtYmVkKHRleHQsIHVzZV9kaWN0ID0gdHJ1ZSkge1xuICAgIGlmICh1c2VfZGljdCAmJiB0ZXh0IGluIGVtYmVkZGluZ3NEaWN0KSB7XG4gICAgICAgIHJldHVybiBlbWJlZGRpbmdzRGljdFt0ZXh0XTtcbiAgICB9XG5cbiAgICBsZXQgZW1iZWRkZXIgPSBhd2FpdCBFbWJlZFBpcGVsaW5lLmdldEluc3RhbmNlKCk7XG4gICAgbGV0IGUwID0gYXdhaXQgZW1iZWRkZXIodGV4dCwge3Bvb2xpbmc6ICdtZWFuJywgbm9ybWFsaXplOiB0cnVlfSk7XG4gICAgaWYgKHVzZV9kaWN0KSB7XG4gICAgICAgIGVtYmVkZGluZ3NEaWN0W3RleHRdID0gZTBbXCJkYXRhXCJdO1xuICAgIH1cbiAgICByZXR1cm4gZTBbXCJkYXRhXCJdO1xufVxuXG5cbi8vIGRvIG9uIGNsZWFuLXVwIC8gdW5tb3VudFxuYXN5bmMgZnVuY3Rpb24gcHJ1bmVTdG9yZWRFbWJlZGRpbmdzKGspIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KG51bGwsIGZ1bmN0aW9uIChhbGxEYXRhKSB7XG4gICAgICAgICAgICBsZXQgZW1iZWRkaW5nS2V5cyA9IE9iamVjdC5rZXlzKGFsbERhdGEpLmZpbHRlcihrZXkgPT4gYWxsRGF0YVtrZXldLmlzX2VtYmVkZGluZ3MgPT09IHRydWUpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFsbCBlbWJlZGRpbmcga2V5cyBmb3VuZDpcIiwgZW1iZWRkaW5nS2V5cyk7ICAvLyBUaGlzIGxvZ3MgYWxsIHRoZSBlbWJlZGRpbmcga2V5c1xuXG4gICAgICAgICAgICAvLyBTb3J0IHRoZXNlIGVtYmVkZGluZyBrZXlzIGJhc2VkIG9uIGZyZWNlbmN5IHNjb3Jlc1xuICAgICAgICAgICAgbGV0IHNvcnRlZEtleXMgPSBlbWJlZGRpbmdLZXlzLnNvcnQoKGEsIGIpID0+IGFsbERhdGFbYl0uZnJlY2VuY3lfc2NvcmUgLSBhbGxEYXRhW2FdLmZyZWNlbmN5X3Njb3JlKTtcblxuICAgICAgICAgICAgbGV0IHRvcEtLZXlzID0gc29ydGVkS2V5cy5zbGljZSgwLCBrKTtcbiAgICAgICAgICAgIGxldCBrZXlzVG9SZW1vdmUgPSBzb3J0ZWRLZXlzLmZpbHRlcihrZXkgPT4gIXRvcEtLZXlzLmluY2x1ZGVzKGtleSkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFJlbW92aW5nIHRoZSBmb2xsb3dpbmcga2V5czogJHtrZXlzVG9SZW1vdmV9YCk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbm9uLXRvcCBrIGVtYmVkZGluZ3MgZnJvbSBzdG9yYWdlLlxuICAgICAgICAgICAgaWYgKGtleXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2hyb21lLnN0b3JhZ2UubG9jYWwucmVtb3ZlKGtleXNUb1JlbW92ZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHJlbW92ZWQgJHtrZXlzVG9SZW1vdmUubGVuZ3RofSBrZXlzLmApO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RvcmVFbWJlZGRpbmdzKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShKU09OLnN0cmluZ2lmeShlbWJlZGRpbmdzRGljdCkpO1xuXG4gICAgY29uc3QgYm9keSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGUgPT4gcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IGUgPT4gcmVqZWN0KGUudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwobmV3IEJsb2IoW2J1ZmZlcl0sIHt0eXBlOiAnYXBwbGljYXRpb24vanNvbid9KSk7XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5zZXQoe1xuICAgICAgICAgICAgW2N1cnJJRF06IHtcbiAgICAgICAgICAgICAgICBfYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBmcmVjZW5jeV9zY29yZTogY29tcHV0ZUZyZWNlbmN5U2NvcmUoY3VycklEKSxcbiAgICAgICAgICAgICAgICBpc19lbWJlZGRpbmdzOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1vZGVsX25hbWU6IEVtYmVkUGlwZWxpbmUubW9kZWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHByZXR0eUxvZyhcInN0b3JlZCBcIiArIGN1cnJJRCwgT2JqZWN0LmtleXMoZW1iZWRkaW5nc0RpY3QpLmxlbmd0aCArIFwiIGl0ZW1zXCIpO1xuXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgd3JpdGluZyB0aGUgZW1iZWRkaW5ncyB0byBjYWNoZTonLCBlcnIpXG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlMb2FkKCkge1xuICAgIGZvciAobGV0IHRleHQgaW4gZW1iZWRkaW5nc0RpY3QpIHtcbiAgICAgICAgbGV0IGUwID0gYXdhaXQgZW1iZWQodGV4dCwgdHJ1ZSk7XG4gICAgICAgIGxldCBlMSA9IGF3YWl0IGVtYmVkKHRleHQsIGZhbHNlKTtcbiAgICAgICAgbGV0IHNpbSA9IGNvc2luZVNpbWlsYXJpdHkoZTAsIGUxKTtcbiAgICAgICAgaWYgKHNpbSA8ICAwLjk5KSB7XG4gICAgICAgICAgICBwcmV0dHlMb2coXCJsb2FkIGRpZmZlcnNcIiwgc2ltLCBcInJlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRFbWJlZGRpbmdzKElEKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKGVtYmVkZGluZ3NEaWN0KS5sZW5ndGggIT09IDAgJiYgSUQgPT09IGN1cnJJRCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJJRCA9IElEO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjaHJvbWUuc3RvcmFnZS5sb2NhbC5nZXQoW2N1cnJJRF0pO1xuICAgIGlmIChkYXRhW0lEXSAmJiBkYXRhW0lEXS5pc19lbWJlZGRpbmdzKSB7XG4gICAgICAgIHByZXR0eUxvZyhcImF0dGVtcHRpbmcgbG9hZFwiLCBJRCk7XG4gICAgICAgIGlmICghZGF0YVtJRF0ubW9kZWxfbmFtZSB8fCBkYXRhW0lEXS5tb2RlbF9uYW1lICE9PSBFbWJlZFBpcGVsaW5lLm1vZGVsKSB7IHJldHVybjsgfVxuICAgICAgICBjb25zdCBib2R5ID0gZGF0YVtJRF0uX2JvZHk7XG5cbiAgICAgICAgY29uc3QganNvblN0cmluZyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVDaGFyYWN0ZXJzID0gYXRvYihib2R5LnNwbGl0KCcsJylbMV0pO1xuICAgICAgICAgICAgY29uc3QgYnl0ZU51bWJlcnMgPSBBcnJheS5mcm9tKGJ5dGVDaGFyYWN0ZXJzKS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZU51bWJlcnMpO1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtieXRlQXJyYXldLCB7dHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nfSk7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChldmVudCkgPT4gcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gKGVycm9yKSA9PiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG9iamVjdC13aXRoLWludGVnZXIta2V5cyByZXByZXNlbnRhdGlvbiBpbnRvIEZsb2F0MzJBcnJheVxuICAgICAgICBmb3IgKGxldCB0ZXh0S2V5IGluIHBhcnNlZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZWREYXRhLmhhc093blByb3BlcnR5KHRleHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFycmF5RGF0YSA9IE9iamVjdC52YWx1ZXMocGFyc2VkRGF0YVt0ZXh0S2V5XSk7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nc0RpY3RbdGV4dEtleV0gPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcmV0dHlMb2coXCJsb2FkZWQgXCIgKyBJRCwgT2JqZWN0LmtleXMoZW1iZWRkaW5nc0RpY3QpLmxlbmd0aCArIFwiIGl0ZW1zXCIpO1xuICAgICAgICAvLyBhd2FpdCB2ZXJpZnlMb2FkKCk7XG4gICAgfVxufVxuXG5cbi8vIHRvZG86IGltcGxlbWVudCAmIG1vdmUgdG8gdXRpbHNcbmZ1bmN0aW9uIGNvbXB1dGVGcmVjZW5jeVNjb3JlKElEKSB7XG4gICAgcmV0dXJuIDQ7IC8vIGxvbCFcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2ltaWxhcml0eSh0ZXh0MSwgdGV4dDIpIHtcbiAgICBsZXQgZTAgPSBhd2FpdCBlbWJlZCh0ZXh0MSk7XG4gICAgbGV0IGUxID0gYXdhaXQgZW1iZWQodGV4dDIpO1xuXG4gICAgcmV0dXJuIGNvc2luZVNpbWlsYXJpdHkoZTAsIGUxKTtcbn1cblxuZnVuY3Rpb24gY29zaW5lU2ltaWxhcml0eSh2MSwgdjIpIHtcbiAgICBpZiAodjEubGVuZ3RoICE9PSB2Mi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBsZXQgZG90UHJvZHVjdCA9IDA7XG4gICAgbGV0IHYxX21hZyA9IDA7XG4gICAgbGV0IHYyX21hZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkb3RQcm9kdWN0ICs9IHYxW2ldICogdjJbaV07XG4gICAgICAgIHYxX21hZyArPSB2MVtpXSAqKiAyO1xuICAgICAgICB2Ml9tYWcgKz0gdjJbaV0gKiogMjtcbiAgICB9XG4gICAgcmV0dXJuIGRvdFByb2R1Y3QgLyAoTWF0aC5zcXJ0KHYxX21hZykgKiBNYXRoLnNxcnQodjJfbWFnKSk7XG59XG4iLCIvLyBBdXRob3I6IFhlbm92YVxuLy8gRGVzaWduIGEgY2FjaGluZyBBUEkgdG8gYmUgdXNlZCBieSB0aGUgZXh0ZW5zaW9uIHdoaWNoIGltcGxlbWVudHMgdGhlIHNhbWUgaW50ZXJmYWNlIGFzXG4vLyB0aGUgYnJvd3NlcidzIG5hdGl2ZSBDYWNoZSBBUEkgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYWNoZSlcbi8vIGJ1dCB1c2VzIHRoZSBicm93c2VyJ3MgbG9jYWwgc3RvcmFnZSBBUEkgKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZG9jcy9leHRlbnNpb25zL3JlZmVyZW5jZS9zdG9yYWdlLykuXG4vL1xuLy8gU2luY2UgdGhlIGxvY2FsIHN0b3JhZ2UgQVBJIHJlcXVpcmVzIGFsbCBkYXRhIHRvIGJlIHN0b3JlZCBhcyBKU09OICh3aGljaCBkb2Vzbid0IGFsbG93IHNvbWUgQVNDSUkgY2hhcnMpLFxuLy8gb25lIG9mIHRoZSBiZXR0ZXIgYXBwcm9hY2hlcyBpcyB0byBzdG9yZSB0aGUgcmVzcG9uc2UgYm9keSBhcyBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBub3QgaWRlYWwsXG4vLyBhcyBpdCBpbmNyZWFzZXMgdGhlIHNpemUgb2YgdGhlIHJlc3BvbnNlIGJvZHkgYnkgfjMzJSwgYnV0IGl0J3MgdGhlIGJlc3Qgd2UgY2FuIGRvIHdpdGggdGhlIGxvY2FsIHN0b3JhZ2UgQVBJLlxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDQzMjQwLzEzOTg5MDQzIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoaXMuXG4vL1xuLy8gRm9yIHNlcmlhbGl6YXRpb24gKGFycmF5YnVmZmVyIC0+IHN0cmluZykgYW5kIHVuc2VyaWFsaXphdGlvbiAoc3RyaW5nIC0+IGFycmF5YnVmZmVyKSxcbi8vIHVzZSB0aGUgYEZpbGVSZWFkZXJgIGFuZCBgQmxvYmAgQVBJcy4gQWx0aG91Z2ggb3RoZXIgb3B0aW9ucyBhcmUgYWxzbyBwb3NzaWJsZSwgdGhpcyBhcHByb2FjaFxuLy8gaXMgY29uc2lkZXJlZCB0byBiZSBiZXR0ZXIgZm9yIGxhcmdlciBmaWxlcyAobGlrZSBtb2RlbHMpLlxuLy9cbi8vIE90aGVyIHJlZmVyZW5jZXM6XG4vLyAgLSBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RvY3MvZXh0ZW5zaW9ucy9yZWZlcmVuY2Uvc3RvcmFnZS8jcHJvcGVydHktbG9jYWxcbi8vICAtIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY5NjUxMDcvY29udmVydGluZy1iZXR3ZWVuLXN0cmluZ3MtYW5kLWFycmF5YnVmZmVyc1xuXG5leHBvcnQgY2xhc3MgQ3VzdG9tQ2FjaGUge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgYEN1c3RvbUNhY2hlYCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjYWNoZU5hbWUpIHtcbiAgICAgICAgdGhpcy5jYWNoZU5hbWUgPSBjYWNoZU5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHJlcXVlc3QgaXMgaW4gdGhlIGNhY2hlLlxuICAgICAqIEBwYXJhbSB7UmVxdWVzdHxzdHJpbmd9IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXNwb25zZSB8IHVuZGVmaW5lZD59XG4gICAgICovXG4gICAgYXN5bmMgbWF0Y2gocmVxdWVzdCkge1xuICAgICAgICBjb25zdCB1cmwgPSByZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCA/IHJlcXVlc3QudXJsIDogcmVxdWVzdDtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gYXdhaXQgY2hyb21lLnN0b3JhZ2UubG9jYWwuZ2V0KFt1cmxdKTtcblxuICAgICAgICBpZiAoY2FjaGVkW3VybF0pIHtcbiAgICAgICAgICAgIGxldCBtb2RlbCA9ICBhd2FpdCBmZXRjaChjYWNoZWRbdXJsXS5fYm9keSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm1vZGVsOiBcIiwgbW9kZWwpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHJlc3BvbnNlIHRvIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge1JlcXVlc3R8c3RyaW5nfSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBwdXQocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgdXJsID0gcmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QgPyByZXF1ZXN0LnVybCA6IHJlcXVlc3Q7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG5cbiAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gZSA9PiByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGUgPT4gcmVqZWN0KGUudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKG5ldyBCbG9iKFtidWZmZXJdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIH0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNocm9tZS5zdG9yYWdlLmxvY2FsLnNldCh7XG4gICAgICAgICAgICAgICAgW3VybF06IHtcbiAgICAgICAgICAgICAgICAgICAgX2JvZHk6IGJvZHksXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBvcmlnaW5hbCByZXNwb25zZSBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMocmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RlZDogcmVzcG9uc2UucmVkaXJlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogcmVzcG9uc2UudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgb2s6IHJlc3BvbnNlLm9rLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSB3cml0aW5nIHRoZSBmaWxlIHRvIGNhY2hlOicsIGVycilcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBwcmV0dHlMb2cobGFiZWwsIG1lc3NhZ2UsIGxhYmVsQ29sb3IgPSAnYmx1ZScsIG1lc3NhZ2VDb2xvciA9ICdibGFjaycpIHtcbiAgICBjb25zb2xlLmxvZyhcIiVjXCIgKyBsYWJlbCArIFwiOiAlY1wiICsgbWVzc2FnZSxcbiAgICAgICAgXCJmb250LXdlaWdodDogYm9sZDsgY29sb3I6IFwiICsgbGFiZWxDb2xvciArIFwiO1wiLFxuICAgICAgICBcImZvbnQtd2VpZ2h0OiBub3JtYWw7IGNvbG9yOiBcIiArIG1lc3NhZ2VDb2xvciArIFwiO1wiKTtcbn1cblxuXG4vKiAgTG9va3MgZm9yIGEgc2VudGVuY2UgZW5kaW5nIGFmdGVyIG51bUNoYXJzLiAgKi9cbmZ1bmN0aW9uIHNwbGl0QnlDaGFycyh0ZXh0LCBudW1DaGFycykge1xuICAgIGxldCBjaHVua3MgPSBbXTtcbiAgICBsZXQgY3VyckNodW5rID0gJyc7XG4gICAgY29uc3Qgc2VudGVuY2VFbmRpbmdzID0gWycuJywgJz8nLCAnIScsICc7JywgJzonLCAnXFxuJywgJ+KAkyddO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJDaHVuayArPSB0ZXh0W2ldO1xuXG4gICAgICAgIGxldCBpc0VuZGluZ1B1bmN0dWF0aW9uID0gc2VudGVuY2VFbmRpbmdzLmluY2x1ZGVzKHRleHRbaV0pO1xuXG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTogaWYgdGhlIHB1bmN0dWF0aW9uIGlzIGEgcGVyaW9kIGFuZCB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgYSBxdW90ZVxuICAgICAgICBpZiAodGV4dFtpXSA9PT0gJy4nICYmIHRleHRbaSArIDFdID09PSAnXCInKSB7XG4gICAgICAgICAgICBjdXJyQ2h1bmsgKz0gdGV4dFsrK2ldO1xuICAgICAgICAgICAgaXNFbmRpbmdQdW5jdHVhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VyckNodW5rLnRyaW0oKS5sZW5ndGggPj0gbnVtQ2hhcnMgJiYgaXNFbmRpbmdQdW5jdHVhdGlvbikge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY3VyckNodW5rLnRyaW0oKSk7XG4gICAgICAgICAgICBjdXJyQ2h1bmsgPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyQ2h1bmsudHJpbSgpKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKGN1cnJDaHVuay50cmltKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBjaHVua3M7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpdGVJRCh1cmwpIHtcbiAgICBsZXQgdXJsT2JqID0gbmV3IFVSTCh1cmwpO1xuICAgIHJldHVybiB1cmxPYmouaG9zdG5hbWUgKyB1cmxPYmoucGF0aG5hbWU7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0UmVhZGFibGVDb250ZW50KHJlYWRhYmxlQ29udGVudCkge1xuICAgIHJldHVybiBzcGxpdEJ5Q2hhcnMocmVhZGFibGVDb250ZW50LCA1MCk7XG59XG5cblxuZnVuY3Rpb24gY29sbGVjdFRleHROb2RlcyhlbGVtZW50LCB0ZXh0cyA9IFtdKSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAncCcpIHtcbiAgICAgICAgbGV0IHNlbnRlbmNlcyA9IHRva2VuaXplci50b2tlbml6ZShlbGVtZW50LnRleHRDb250ZW50KTsgLy8gVG9rZW5pemUgdGhlIHRleHQgY29udGVudCBpbnRvIHNlbnRlbmNlc1xuICAgICAgICBmb3IgKGxldCBzZW50ZW5jZSBvZiBzZW50ZW5jZXMpIHtcbiAgICAgICAgICAgIHNlbnRlbmNlID0gc2VudGVuY2UudHJpbSgpOyAgLy8gUmVtb3ZlIGxlYWRpbmcvdHJhaWxpbmcgd2hpdGUgc3BhY2VzXG4gICAgICAgICAgICBpZiAoc2VudGVuY2UgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB0ZXh0cy5wdXNoKHNlbnRlbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGVsZW1lbnQuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgY29sbGVjdFRleHROb2RlcyhjaGlsZCwgdGV4dHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0cztcbn1cblxuXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwidmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mID8gKG9iaikgPT4gKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKSA6IChvYmopID0+IChvYmouX19wcm90b19fKTtcbnZhciBsZWFmUHJvdG90eXBlcztcbi8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLy8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLy8gbW9kZSAmIDE2OiByZXR1cm4gdmFsdWUgd2hlbiBpdCdzIFByb21pc2UtbGlrZVxuLy8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcblx0aWYobW9kZSAmIDEpIHZhbHVlID0gdGhpcyh2YWx1ZSk7XG5cdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG5cdGlmKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUpIHtcblx0XHRpZigobW9kZSAmIDQpICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcblx0XHRpZigobW9kZSAmIDE2KSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG5cdHZhciBkZWYgPSB7fTtcblx0bGVhZlByb3RvdHlwZXMgPSBsZWFmUHJvdG90eXBlcyB8fCBbbnVsbCwgZ2V0UHJvdG8oe30pLCBnZXRQcm90byhbXSksIGdldFByb3RvKGdldFByb3RvKV07XG5cdGZvcih2YXIgY3VycmVudCA9IG1vZGUgJiAyICYmIHZhbHVlOyB0eXBlb2YgY3VycmVudCA9PSAnb2JqZWN0JyAmJiAhfmxlYWZQcm90b3R5cGVzLmluZGV4T2YoY3VycmVudCk7IGN1cnJlbnQgPSBnZXRQcm90byhjdXJyZW50KSkge1xuXHRcdE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGN1cnJlbnQpLmZvckVhY2goKGtleSkgPT4gKGRlZltrZXldID0gKCkgPT4gKHZhbHVlW2tleV0pKSk7XG5cdH1cblx0ZGVmWydkZWZhdWx0J10gPSAoKSA9PiAodmFsdWUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGRlZik7XG5cdHJldHVybiBucztcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvc2VydmljZXdvcmtlcnMvYmFja2dyb3VuZC5qc1wiKTtcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9zZXJ2aWNld29ya2Vycy9zZW1hbnRpYy5qc1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==